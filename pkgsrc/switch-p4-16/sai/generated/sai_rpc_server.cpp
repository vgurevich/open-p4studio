/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "sai_rpc.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::sai;

#ifdef __cplusplus
extern "C" {
#endif
#include <sai.h>
#ifdef __cplusplus
}
#endif

extern sai_object_id_t switch_id;
sai_object_id_t switch_id;

void sai_thrift_parse_buffer(const std::string &thrift_buffer, void *buffer) {
  /* not supported yet */
}

// acl API helper functions

void sai_thrift_parse_acl_counter_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ACL_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_counter_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ACL_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ACL_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ACL_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_range_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ACL_RANGE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_range_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ACL_RANGE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ACL_TABLE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ACL_TABLE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ACL_TABLE_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ACL_TABLE_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_acl_table_group_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ACL_TABLE_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_acl_table_group_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ACL_TABLE_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// bfd API helper functions

void sai_thrift_parse_bfd_session_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_BFD_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bfd_session_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_BFD_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_bfd_session_state_notification(
    const sai_thrift_bfd_session_state_notification_t
        &thrift_bfd_session_state_notification,
    sai_bfd_session_state_notification_t *bfd_session_state_notification) {
  bfd_session_state_notification->bfd_session_id =
      thrift_bfd_session_state_notification.bfd_session_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  bfd_session_state_notification->session_state =
      thrift_bfd_session_state_notification.session_state;
#endif
}

// bridge API helper functions

void sai_thrift_parse_bridge_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_BRIDGE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bridge_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_BRIDGE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_bridge_port_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_BRIDGE_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_bridge_port_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_BRIDGE_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// buffer API helper functions

void sai_thrift_parse_buffer_pool_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_BUFFER_POOL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_buffer_pool_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_BUFFER_POOL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_buffer_profile_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_BUFFER_PROFILE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_buffer_profile_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_BUFFER_PROFILE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ingress_priority_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_INGRESS_PRIORITY_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ingress_priority_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_INGRESS_PRIORITY_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// counter API helper functions

void sai_thrift_parse_counter_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_counter_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// debug_counter API helper functions

void sai_thrift_parse_debug_counter_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_DEBUG_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_debug_counter_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_DEBUG_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// dtel API helper functions

void sai_thrift_parse_dtel_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_DTEL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_DTEL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_event_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_DTEL_EVENT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_event_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_DTEL_EVENT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_int_session_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_DTEL_INT_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_int_session_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_DTEL_INT_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_queue_report_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_DTEL_QUEUE_REPORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_queue_report_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_DTEL_QUEUE_REPORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_dtel_report_session_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_DTEL_REPORT_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_dtel_report_session_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_DTEL_REPORT_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// fdb API helper functions

void sai_thrift_parse_fdb_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_FDB_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fdb_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_FDB_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_fdb_flush_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_FDB_FLUSH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fdb_flush_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_FDB_FLUSH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_fdb_entry(const sai_thrift_fdb_entry_t &thrift_fdb_entry,
                                sai_fdb_entry_t *fdb_entry) {
  fdb_entry->switch_id = thrift_fdb_entry.switch_id;
  // using manual converter
  sai_thrift_mac_t_parse(thrift_fdb_entry.mac_address, &fdb_entry->mac_address);
  fdb_entry->bv_id = thrift_fdb_entry.bv_id;
}

void sai_thrift_parse_fdb_event_notification_data(
    const sai_thrift_fdb_event_notification_data_t
        &thrift_fdb_event_notification_data,
    sai_fdb_event_notification_data_t *fdb_event_notification_data) {
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->event_type =
      thrift_fdb_event_notification_data.event_type;
#endif
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->fdb_entry =
      thrift_fdb_event_notification_data.fdb_entry;
#endif
  fdb_event_notification_data->attr_count =
      thrift_fdb_event_notification_data.attr_count;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  fdb_event_notification_data->attr = thrift_fdb_event_notification_data.attr;
#endif
}

// generic_programmable API helper functions

void sai_thrift_parse_generic_programmable_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_GENERIC_PROGRAMMABLE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_generic_programmable_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_GENERIC_PROGRAMMABLE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// hash API helper functions

void sai_thrift_parse_fine_grained_hash_field_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_FINE_GRAINED_HASH_FIELD, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_fine_grained_hash_field_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_FINE_GRAINED_HASH_FIELD, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hash_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_HASH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hash_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HASH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// hostif API helper functions

void sai_thrift_parse_hostif_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_HOSTIF, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_HOSTIF, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_packet_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_HOSTIF_PACKET, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_packet_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_HOSTIF_PACKET, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_table_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_HOSTIF_TABLE_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_table_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_HOSTIF_TABLE_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_trap_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_HOSTIF_TRAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_trap_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_HOSTIF_TRAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_trap_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_HOSTIF_TRAP_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_trap_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_HOSTIF_TRAP_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_hostif_user_defined_trap_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_HOSTIF_USER_DEFINED_TRAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_hostif_user_defined_trap_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_HOSTIF_USER_DEFINED_TRAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// ipmc API helper functions

void sai_thrift_parse_ipmc_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_IPMC_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_IPMC_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipmc_entry(
    const sai_thrift_ipmc_entry_t &thrift_ipmc_entry,
    sai_ipmc_entry_t *ipmc_entry) {
  ipmc_entry->switch_id = thrift_ipmc_entry.switch_id;
  ipmc_entry->vr_id = thrift_ipmc_entry.vr_id;
  // using manual converter
  sai_thrift_ipmc_entry_type_t_parse(thrift_ipmc_entry.type, &ipmc_entry->type);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_ipmc_entry.destination,
                                &ipmc_entry->destination);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_ipmc_entry.source, &ipmc_entry->source);
}

// ipmc_group API helper functions

void sai_thrift_parse_ipmc_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_IPMC_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_IPMC_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipmc_group_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_IPMC_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipmc_group_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_IPMC_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// ipsec API helper functions

void sai_thrift_parse_ipsec_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_IPSEC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipsec_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_IPSEC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipsec_port_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_IPSEC_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipsec_port_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_IPSEC_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipsec_sa_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_IPSEC_SA, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_ipsec_sa_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_IPSEC_SA, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_ipsec_sa_status_notification(
    const sai_thrift_ipsec_sa_status_notification_t
        &thrift_ipsec_sa_status_notification,
    sai_ipsec_sa_status_notification_t *ipsec_sa_status_notification) {
  ipsec_sa_status_notification->ipsec_sa_id =
      thrift_ipsec_sa_status_notification.ipsec_sa_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  ipsec_sa_status_notification->ipsec_sa_octet_count_status =
      thrift_ipsec_sa_status_notification.ipsec_sa_octet_count_status;
#endif
  ipsec_sa_status_notification->ipsec_egress_sn_at_max_limit =
      thrift_ipsec_sa_status_notification.ipsec_egress_sn_at_max_limit;
}

// isolation_group API helper functions

void sai_thrift_parse_isolation_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ISOLATION_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_isolation_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ISOLATION_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_isolation_group_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ISOLATION_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_isolation_group_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ISOLATION_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// l2mc API helper functions

void sai_thrift_parse_l2mc_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_L2MC_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_L2MC_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_l2mc_entry(
    const sai_thrift_l2mc_entry_t &thrift_l2mc_entry,
    sai_l2mc_entry_t *l2mc_entry) {
  l2mc_entry->switch_id = thrift_l2mc_entry.switch_id;
  l2mc_entry->bv_id = thrift_l2mc_entry.bv_id;
  // using manual converter
  sai_thrift_l2mc_entry_type_t_parse(thrift_l2mc_entry.type, &l2mc_entry->type);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_l2mc_entry.destination,
                                &l2mc_entry->destination);
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_l2mc_entry.source, &l2mc_entry->source);
}

// l2mc_group API helper functions

void sai_thrift_parse_l2mc_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_L2MC_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_L2MC_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_l2mc_group_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_L2MC_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_l2mc_group_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_L2MC_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// lag API helper functions

void sai_thrift_parse_lag_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_LAG, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_lag_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_LAG, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_lag_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_LAG_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_lag_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_LAG_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// macsec API helper functions

void sai_thrift_parse_macsec_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MACSEC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MACSEC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_flow_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MACSEC_FLOW, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_flow_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_MACSEC_FLOW, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_port_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MACSEC_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_port_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_MACSEC_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_sa_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MACSEC_SA, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_sa_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_MACSEC_SA, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_macsec_sc_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MACSEC_SC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_macsec_sc_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_MACSEC_SC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// mcast_fdb API helper functions

void sai_thrift_parse_mcast_fdb_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MCAST_FDB_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_mcast_fdb_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_MCAST_FDB_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_mcast_fdb_entry(
    const sai_thrift_mcast_fdb_entry_t &thrift_mcast_fdb_entry,
    sai_mcast_fdb_entry_t *mcast_fdb_entry) {
  mcast_fdb_entry->switch_id = thrift_mcast_fdb_entry.switch_id;
  // using manual converter
  sai_thrift_mac_t_parse(thrift_mcast_fdb_entry.mac_address,
                         &mcast_fdb_entry->mac_address);
  mcast_fdb_entry->bv_id = thrift_mcast_fdb_entry.bv_id;
}

// mirror API helper functions

void sai_thrift_parse_mirror_session_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MIRROR_SESSION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_mirror_session_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_MIRROR_SESSION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// mpls API helper functions

void sai_thrift_parse_inseg_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_INSEG_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_inseg_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_INSEG_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_inseg_entry(
    const sai_thrift_inseg_entry_t &thrift_inseg_entry,
    sai_inseg_entry_t *inseg_entry) {
  inseg_entry->switch_id = thrift_inseg_entry.switch_id;
  inseg_entry->label = thrift_inseg_entry.label;
}

// my_mac API helper functions

void sai_thrift_parse_my_mac_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MY_MAC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_my_mac_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_MY_MAC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// nat API helper functions

void sai_thrift_parse_nat_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_NAT_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_nat_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_NAT_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_nat_zone_counter_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_NAT_ZONE_COUNTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_nat_zone_counter_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_NAT_ZONE_COUNTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_nat_entry_key(
    const sai_thrift_nat_entry_key_t &thrift_nat_entry_key,
    sai_nat_entry_key_t *nat_entry_key) {
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_key.src_ip, &nat_entry_key->src_ip);
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_key.dst_ip, &nat_entry_key->dst_ip);
  nat_entry_key->proto = thrift_nat_entry_key.proto;
  nat_entry_key->l4_src_port = thrift_nat_entry_key.l4_src_port;
  nat_entry_key->l4_dst_port = thrift_nat_entry_key.l4_dst_port;
}

void sai_thrift_parse_nat_entry_mask(
    const sai_thrift_nat_entry_mask_t &thrift_nat_entry_mask,
    sai_nat_entry_mask_t *nat_entry_mask) {
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_mask.src_ip, &nat_entry_mask->src_ip);
  // using manual converter
  sai_thrift_ip4_t_parse(thrift_nat_entry_mask.dst_ip, &nat_entry_mask->dst_ip);
  nat_entry_mask->proto = thrift_nat_entry_mask.proto;
  nat_entry_mask->l4_src_port = thrift_nat_entry_mask.l4_src_port;
  nat_entry_mask->l4_dst_port = thrift_nat_entry_mask.l4_dst_port;
}

void sai_thrift_parse_nat_entry_data(
    const sai_thrift_nat_entry_data_t &thrift_nat_entry_data,
    sai_nat_entry_data_t *nat_entry_data) {
  // using existing converter
  sai_thrift_parse_nat_entry_key(thrift_nat_entry_data.key,
                                 &nat_entry_data->key);
  // using existing converter
  sai_thrift_parse_nat_entry_mask(thrift_nat_entry_data.mask,
                                  &nat_entry_data->mask);
}

void sai_thrift_parse_nat_entry(const sai_thrift_nat_entry_t &thrift_nat_entry,
                                sai_nat_entry_t *nat_entry) {
  nat_entry->switch_id = thrift_nat_entry.switch_id;
  nat_entry->vr_id = thrift_nat_entry.vr_id;
  // using manual converter
  sai_thrift_nat_type_t_parse(thrift_nat_entry.nat_type, &nat_entry->nat_type);
  // using existing converter
  sai_thrift_parse_nat_entry_data(thrift_nat_entry.data, &nat_entry->data);
}

void sai_thrift_parse_nat_event_notification_data(
    const sai_thrift_nat_event_notification_data_t
        &thrift_nat_event_notification_data,
    sai_nat_event_notification_data_t *nat_event_notification_data) {
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  nat_event_notification_data->event_type =
      thrift_nat_event_notification_data.event_type;
#endif
  // using existing converter
  sai_thrift_parse_nat_entry(thrift_nat_event_notification_data.nat_entry,
                             &nat_event_notification_data->nat_entry);
}

// neighbor API helper functions

void sai_thrift_parse_neighbor_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_NEIGHBOR_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_neighbor_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_NEIGHBOR_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_neighbor_entry(
    const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
    sai_neighbor_entry_t *neighbor_entry) {
  neighbor_entry->switch_id = thrift_neighbor_entry.switch_id;
  neighbor_entry->rif_id = thrift_neighbor_entry.rif_id;
  // using manual converter
  sai_thrift_ip_address_t_parse(thrift_neighbor_entry.ip_address,
                                &neighbor_entry->ip_address);
}

// next_hop API helper functions

void sai_thrift_parse_next_hop_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_NEXT_HOP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_NEXT_HOP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// next_hop_group API helper functions

void sai_thrift_parse_next_hop_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_NEXT_HOP_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_NEXT_HOP_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_next_hop_group_map_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_map_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_next_hop_group_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_next_hop_group_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_NEXT_HOP_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// policer API helper functions

void sai_thrift_parse_policer_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_POLICER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_policer_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_POLICER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// port API helper functions

void sai_thrift_parse_port_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_connector_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_PORT_CONNECTOR, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_connector_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_PORT_CONNECTOR, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_pool_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_PORT_POOL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_pool_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_PORT_POOL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_serdes_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_PORT_SERDES, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_port_serdes_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_PORT_SERDES, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_port_oper_status_notification(
    const sai_thrift_port_oper_status_notification_t
        &thrift_port_oper_status_notification,
    sai_port_oper_status_notification_t *port_oper_status_notification) {
  port_oper_status_notification->port_id =
      thrift_port_oper_status_notification.port_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  port_oper_status_notification->port_state =
      thrift_port_oper_status_notification.port_state;
#endif
}

// qos_map API helper functions

void sai_thrift_parse_qos_map_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_QOS_MAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_qos_map_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_QOS_MAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// queue API helper functions

void sai_thrift_parse_queue_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_QUEUE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_queue_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_QUEUE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_queue_deadlock_notification_data(
    const sai_thrift_queue_deadlock_notification_data_t
        &thrift_queue_deadlock_notification_data,
    sai_queue_deadlock_notification_data_t *queue_deadlock_notification_data) {
  queue_deadlock_notification_data->queue_id =
      thrift_queue_deadlock_notification_data.queue_id;
#ifdef UNSUPPORTED /* complex struct members are not supported yet */
  queue_deadlock_notification_data->event =
      thrift_queue_deadlock_notification_data.event;
#endif
  queue_deadlock_notification_data->app_managed_recovery =
      thrift_queue_deadlock_notification_data.app_managed_recovery;
}

// route API helper functions

void sai_thrift_parse_route_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ROUTE_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_route_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ROUTE_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_route_entry(
    const sai_thrift_route_entry_t &thrift_route_entry,
    sai_route_entry_t *route_entry) {
  route_entry->switch_id = thrift_route_entry.switch_id;
  route_entry->vr_id = thrift_route_entry.vr_id;
  // using manual converter
  sai_thrift_ip_prefix_t_parse(thrift_route_entry.destination,
                               &route_entry->destination);
}

// router_interface API helper functions

void sai_thrift_parse_router_interface_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_ROUTER_INTERFACE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_router_interface_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_ROUTER_INTERFACE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// rpf_group API helper functions

void sai_thrift_parse_rpf_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_RPF_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_rpf_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_RPF_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_rpf_group_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_RPF_GROUP_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_rpf_group_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_RPF_GROUP_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// samplepacket API helper functions

void sai_thrift_parse_samplepacket_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_SAMPLEPACKET, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_samplepacket_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_SAMPLEPACKET, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// scheduler API helper functions

void sai_thrift_parse_scheduler_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_SCHEDULER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_scheduler_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_SCHEDULER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// scheduler_group API helper functions

void sai_thrift_parse_scheduler_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_SCHEDULER_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_scheduler_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_SCHEDULER_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// srv6 API helper functions

void sai_thrift_parse_my_sid_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_MY_SID_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_my_sid_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_MY_SID_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_srv6_sidlist_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_SRV6_SIDLIST, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_srv6_sidlist_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_SRV6_SIDLIST, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_my_sid_entry(
    const sai_thrift_my_sid_entry_t &thrift_my_sid_entry,
    sai_my_sid_entry_t *my_sid_entry) {
  my_sid_entry->switch_id = thrift_my_sid_entry.switch_id;
  my_sid_entry->vr_id = thrift_my_sid_entry.vr_id;
  my_sid_entry->locator_block_len = thrift_my_sid_entry.locator_block_len;
  my_sid_entry->locator_node_len = thrift_my_sid_entry.locator_node_len;
  my_sid_entry->function_len = thrift_my_sid_entry.function_len;
  my_sid_entry->args_len = thrift_my_sid_entry.args_len;
  // using manual converter
  sai_thrift_ip6_t_parse(thrift_my_sid_entry.sid, my_sid_entry->sid);
}

// stp API helper functions

void sai_thrift_parse_stp_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_STP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_stp_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_STP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_stp_port_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_STP_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_stp_port_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_STP_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// switch API helper functions

void sai_thrift_parse_switch_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_SWITCH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_switch_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_SWITCH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_switch_tunnel_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_SWITCH_TUNNEL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_switch_tunnel_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_SWITCH_TUNNEL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// system_port API helper functions

void sai_thrift_parse_system_port_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_SYSTEM_PORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_system_port_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_SYSTEM_PORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// tam API helper functions

void sai_thrift_parse_tam_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_TAM, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TAM, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_collector_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_COLLECTOR, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_collector_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_COLLECTOR, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_EVENT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_EVENT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_action_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_EVENT_ACTION, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_action_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_EVENT_ACTION, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_event_threshold_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_EVENT_THRESHOLD, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_event_threshold_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_EVENT_THRESHOLD, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_int_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_INT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_int_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_INT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_math_func_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_MATH_FUNC, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_math_func_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_MATH_FUNC, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_report_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_REPORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_report_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_REPORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_tel_type_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_TEL_TYPE, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_tel_type_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_TEL_TYPE, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_telemetry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_TELEMETRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_telemetry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_TELEMETRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tam_transport_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TAM_TRANSPORT, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tam_transport_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TAM_TRANSPORT, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// tunnel API helper functions

void sai_thrift_parse_tunnel_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TUNNEL, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_TUNNEL, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_map_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TUNNEL_MAP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_map_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TUNNEL_MAP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_map_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TUNNEL_MAP_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_map_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TUNNEL_MAP_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_tunnel_term_table_entry_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_tunnel_term_table_entry_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_TUNNEL_TERM_TABLE_ENTRY, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// udf API helper functions

void sai_thrift_parse_udf_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_UDF, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_UDF, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_udf_group_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_UDF_GROUP, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_group_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_UDF_GROUP, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_udf_match_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_UDF_MATCH, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_udf_match_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_UDF_MATCH, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// virtual_router API helper functions

void sai_thrift_parse_virtual_router_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_VIRTUAL_ROUTER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_virtual_router_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_VIRTUAL_ROUTER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// vlan API helper functions

void sai_thrift_parse_vlan_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_VLAN, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_vlan_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_VLAN, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

void sai_thrift_parse_vlan_member_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(
        SAI_OBJECT_TYPE_VLAN_MEMBER, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_vlan_member_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(
        SAI_OBJECT_TYPE_VLAN_MEMBER, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

// wred API helper functions

void sai_thrift_parse_wred_attributes(
    const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
    sai_attribute_t *attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();
  sai_thrift_attribute_t attribute;

  if (attr_list == 0) {
    return;
  }

  for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
    attribute = (sai_thrift_attribute_t)*it;
    attr_list[i].id = attribute.id;
    convert_attr_thrift_to_sai(SAI_OBJECT_TYPE_WRED, attribute, &attr_list[i]);
  }
}

void sai_thrift_deparse_wred_attributes(
    sai_attribute_t *attr_list,
    uint32_t attr_count,
    std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
  std::vector<sai_thrift_attribute_t>::const_iterator it =
      thrift_attr_list.begin();

  for (uint32_t i = 0; i < attr_count; i++, it++) {
    sai_thrift_attribute_t attribute;
    convert_attr_sai_to_thrift(SAI_OBJECT_TYPE_WRED, attr_list[i], attribute);
    thrift_attr_list.push_back(attribute);
  }
}

class sai_rpcHandler : virtual public sai_rpcIf {
 public:
  sai_rpcHandler() {}

  sai_thrift_object_id_t sai_thrift_create_acl_table(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_table(
        &acl_table_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return acl_table_oid_out;
  }

  void sai_thrift_remove_acl_table(const sai_thrift_object_id_t acl_table_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_table((sai_object_id_t)acl_table_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_attribute(
      const sai_thrift_object_id_t acl_table_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_acl_table_attributes(attr_vec, sai_attr);

    status = acl_api->set_acl_table_attribute((sai_object_id_t)acl_table_oid,
                                              sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_acl_table_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t acl_table_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_acl_table_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_table_attribute(
        (sai_object_id_t)acl_table_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_entry(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_entry_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_entry(
        &acl_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return acl_entry_oid_out;
  }

  void sai_thrift_remove_acl_entry(const sai_thrift_object_id_t acl_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_entry((sai_object_id_t)acl_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_entry_attribute(
      const sai_thrift_object_id_t acl_entry_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_acl_entry_attributes(attr_vec, sai_attr);

    status = acl_api->set_acl_entry_attribute((sai_object_id_t)acl_entry_oid,
                                              sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_acl_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t acl_entry_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_acl_entry_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_entry_attribute(
        (sai_object_id_t)acl_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_counter(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_counter_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_counter(
        &acl_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return acl_counter_oid_out;
  }

  void sai_thrift_remove_acl_counter(
      const sai_thrift_object_id_t acl_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_counter((sai_object_id_t)acl_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_counter_attribute(
      const sai_thrift_object_id_t acl_counter_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_acl_counter_attributes(attr_vec, sai_attr);

    status = acl_api->set_acl_counter_attribute(
        (sai_object_id_t)acl_counter_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_acl_counter_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t acl_counter_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_acl_counter_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_counter_attribute(
        (sai_object_id_t)acl_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_counter_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_range(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_range_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_range_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_range(
        &acl_range_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return acl_range_oid_out;
  }

  void sai_thrift_remove_acl_range(const sai_thrift_object_id_t acl_range_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_range((sai_object_id_t)acl_range_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_range_attribute(
      const sai_thrift_object_id_t acl_range_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_acl_range_attributes(attr_vec, sai_attr);

    status = acl_api->set_acl_range_attribute((sai_object_id_t)acl_range_oid,
                                              sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_acl_range_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t acl_range_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_acl_range_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_range_attribute(
        (sai_object_id_t)acl_range_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_range_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_group_attributes(attr_list, sai_attr_list);

    status = acl_api->create_acl_table_group(
        &acl_table_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return acl_table_group_oid_out;
  }

  void sai_thrift_remove_acl_table_group(
      const sai_thrift_object_id_t acl_table_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        acl_api->remove_acl_table_group((sai_object_id_t)acl_table_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_group_attribute(
      const sai_thrift_object_id_t acl_table_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_acl_table_group_attributes(attr_vec, sai_attr);

    status = acl_api->set_acl_table_group_attribute(
        (sai_object_id_t)acl_table_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_acl_table_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t acl_table_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_acl_table_group_attributes(attr_list_vec, sai_attr_list);

    status = acl_api->get_acl_table_group_attribute(
        (sai_object_id_t)acl_table_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t acl_table_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_acl_table_group_member_attributes(attr_list,
                                                       sai_attr_list);

    status = acl_api->create_acl_table_group_member(
        &acl_table_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return acl_table_group_member_oid_out;
  }

  void sai_thrift_remove_acl_table_group_member(
      const sai_thrift_object_id_t acl_table_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = acl_api->remove_acl_table_group_member(
        (sai_object_id_t)acl_table_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_acl_table_group_member_attribute(
      const sai_thrift_object_id_t acl_table_group_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_acl_table_group_member_attributes(attr_vec, sai_attr);

    status = acl_api->set_acl_table_group_member_attribute(
        (sai_object_id_t)acl_table_group_member_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_acl_table_group_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t acl_table_group_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_acl_table_group_member_attributes(attr_list_vec,
                                                       sai_attr_list);

    status = acl_api->get_acl_table_group_member_attribute(
        (sai_object_id_t)acl_table_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_acl_table_group_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bfd_session(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bfd_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bfd_session_attributes(attr_list, sai_attr_list);

    status = bfd_api->create_bfd_session(
        &bfd_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return bfd_session_oid_out;
  }

  void sai_thrift_remove_bfd_session(
      const sai_thrift_object_id_t bfd_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = bfd_api->remove_bfd_session((sai_object_id_t)bfd_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bfd_session_attribute(
      const sai_thrift_object_id_t bfd_session_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_bfd_session_attributes(attr_vec, sai_attr);

    status = bfd_api->set_bfd_session_attribute(
        (sai_object_id_t)bfd_session_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_bfd_session_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t bfd_session_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_bfd_session_attributes(attr_list_vec, sai_attr_list);

    status = bfd_api->get_bfd_session_attribute(
        (sai_object_id_t)bfd_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bfd_session_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bfd_session_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t bfd_session_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bfd_api->get_bfd_session_stats((sai_object_id_t)bfd_session_oid,
                                            number_of_counters,
                                            sai_counter_ids,
                                            sai_counters);

    // sai_adapter always takes all bfd stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bfd_session_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t bfd_session_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status =
        bfd_api->get_bfd_session_stats_ext((sai_object_id_t)bfd_session_oid,
                                           number_of_counters,
                                           sai_counter_ids,
                                           (sai_stats_mode_t)mode,
                                           sai_counters);

    // sai_adapter always takes all bfd stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bfd_session_stats(
      const sai_thrift_object_id_t bfd_session_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bfd_api_t *bfd_api;

    status = sai_api_query(SAI_API_BFD, (void **)&bfd_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bfd_api->clear_bfd_session_stats(
        (sai_object_id_t)bfd_session_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge_port(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bridge_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bridge_port_attributes(attr_list, sai_attr_list);

    status = bridge_api->create_bridge_port(
        &bridge_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return bridge_port_oid_out;
  }

  void sai_thrift_remove_bridge_port(
      const sai_thrift_object_id_t bridge_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = bridge_api->remove_bridge_port((sai_object_id_t)bridge_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bridge_port_attribute(
      const sai_thrift_object_id_t bridge_port_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_bridge_port_attributes(attr_vec, sai_attr);

    status = bridge_api->set_bridge_port_attribute(
        (sai_object_id_t)bridge_port_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_bridge_port_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t bridge_port_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_bridge_port_attributes(attr_list_vec, sai_attr_list);

    status = bridge_api->get_bridge_port_attribute(
        (sai_object_id_t)bridge_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bridge_port_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bridge_port_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t bridge_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bridge_api->get_bridge_port_stats((sai_object_id_t)bridge_port_oid,
                                               number_of_counters,
                                               sai_counter_ids,
                                               sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bridge_port_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t bridge_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status =
        bridge_api->get_bridge_port_stats_ext((sai_object_id_t)bridge_port_oid,
                                              number_of_counters,
                                              sai_counter_ids,
                                              (sai_stats_mode_t)mode,
                                              sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bridge_port_stats(
      const sai_thrift_object_id_t bridge_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bridge_api->clear_bridge_port_stats(
        (sai_object_id_t)bridge_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t bridge_oid_out = SAI_NULL_OBJECT_ID;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_bridge_attributes(attr_list, sai_attr_list);

    status = bridge_api->create_bridge(
        &bridge_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return bridge_oid_out;
  }

  void sai_thrift_remove_bridge(const sai_thrift_object_id_t bridge_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = bridge_api->remove_bridge((sai_object_id_t)bridge_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_bridge_attribute(const sai_thrift_object_id_t bridge_oid,
                                       const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_bridge_attributes(attr_vec, sai_attr);

    status =
        bridge_api->set_bridge_attribute((sai_object_id_t)bridge_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_bridge_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t bridge_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_bridge_attributes(attr_list_vec, sai_attr_list);

    status = bridge_api->get_bridge_attribute(
        (sai_object_id_t)bridge_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_bridge_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_bridge_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t bridge_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bridge_api->get_bridge_stats((sai_object_id_t)bridge_oid,
                                          number_of_counters,
                                          sai_counter_ids,
                                          sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_bridge_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t bridge_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = bridge_api->get_bridge_stats_ext((sai_object_id_t)bridge_oid,
                                              number_of_counters,
                                              sai_counter_ids,
                                              (sai_stats_mode_t)mode,
                                              sai_counters);

    // sai_adapter always takes all bridge stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_bridge_stats(
      const sai_thrift_object_id_t bridge_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bridge_api->clear_bridge_stats(
        (sai_object_id_t)bridge_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ingress_priority_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ingress_priority_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ingress_priority_group_attributes(attr_list,
                                                       sai_attr_list);

    status = buffer_api->create_ingress_priority_group(
        &ingress_priority_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return ingress_priority_group_oid_out;
  }

  void sai_thrift_remove_ingress_priority_group(
      const sai_thrift_object_id_t ingress_priority_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = buffer_api->remove_ingress_priority_group(
        (sai_object_id_t)ingress_priority_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ingress_priority_group_attribute(
      const sai_thrift_object_id_t ingress_priority_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_ingress_priority_group_attributes(attr_vec, sai_attr);

    status = buffer_api->set_ingress_priority_group_attribute(
        (sai_object_id_t)ingress_priority_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_ingress_priority_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t ingress_priority_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_ingress_priority_group_attributes(attr_list_vec,
                                                       sai_attr_list);

    status = buffer_api->get_ingress_priority_group_attribute(
        (sai_object_id_t)ingress_priority_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ingress_priority_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_ingress_priority_group_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t ingress_priority_group_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = buffer_api->get_ingress_priority_group_stats(
        (sai_object_id_t)ingress_priority_group_oid,
        number_of_counters,
        sai_counter_ids,
        sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_ingress_priority_group_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t ingress_priority_group_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = buffer_api->get_ingress_priority_group_stats_ext(
        (sai_object_id_t)ingress_priority_group_oid,
        number_of_counters,
        sai_counter_ids,
        (sai_stats_mode_t)mode,
        sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_ingress_priority_group_stats(
      const sai_thrift_object_id_t ingress_priority_group_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = buffer_api->clear_ingress_priority_group_stats(
        (sai_object_id_t)ingress_priority_group_oid,
        number_of_counters,
        sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_pool(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t buffer_pool_oid_out = SAI_NULL_OBJECT_ID;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_buffer_pool_attributes(attr_list, sai_attr_list);

    status = buffer_api->create_buffer_pool(
        &buffer_pool_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return buffer_pool_oid_out;
  }

  void sai_thrift_remove_buffer_pool(
      const sai_thrift_object_id_t buffer_pool_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = buffer_api->remove_buffer_pool((sai_object_id_t)buffer_pool_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_buffer_pool_attribute(
      const sai_thrift_object_id_t buffer_pool_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_buffer_pool_attributes(attr_vec, sai_attr);

    status = buffer_api->set_buffer_pool_attribute(
        (sai_object_id_t)buffer_pool_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_buffer_pool_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t buffer_pool_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_buffer_pool_attributes(attr_list_vec, sai_attr_list);

    status = buffer_api->get_buffer_pool_attribute(
        (sai_object_id_t)buffer_pool_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_buffer_pool_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_buffer_pool_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t buffer_pool_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = buffer_api->get_buffer_pool_stats((sai_object_id_t)buffer_pool_oid,
                                               number_of_counters,
                                               sai_counter_ids,
                                               sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_buffer_pool_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t buffer_pool_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status =
        buffer_api->get_buffer_pool_stats_ext((sai_object_id_t)buffer_pool_oid,
                                              number_of_counters,
                                              sai_counter_ids,
                                              (sai_stats_mode_t)mode,
                                              sai_counters);

    // sai_adapter always takes all buffer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_buffer_pool_stats(
      const sai_thrift_object_id_t buffer_pool_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = buffer_api->clear_buffer_pool_stats(
        (sai_object_id_t)buffer_pool_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_profile(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t buffer_profile_oid_out = SAI_NULL_OBJECT_ID;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_buffer_profile_attributes(attr_list, sai_attr_list);

    status = buffer_api->create_buffer_profile(
        &buffer_profile_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return buffer_profile_oid_out;
  }

  void sai_thrift_remove_buffer_profile(
      const sai_thrift_object_id_t buffer_profile_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        buffer_api->remove_buffer_profile((sai_object_id_t)buffer_profile_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_buffer_profile_attribute(
      const sai_thrift_object_id_t buffer_profile_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_buffer_profile_attributes(attr_vec, sai_attr);

    status = buffer_api->set_buffer_profile_attribute(
        (sai_object_id_t)buffer_profile_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_buffer_profile_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t buffer_profile_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;

    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_buffer_profile_attributes(attr_list_vec, sai_attr_list);

    status = buffer_api->get_buffer_profile_attribute(
        (sai_object_id_t)buffer_profile_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_buffer_profile_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_counter(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_counter_attributes(attr_list, sai_attr_list);

    status = counter_api->create_counter(
        &counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return counter_oid_out;
  }

  void sai_thrift_remove_counter(const sai_thrift_object_id_t counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = counter_api->remove_counter((sai_object_id_t)counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_counter_attribute(
      const sai_thrift_object_id_t counter_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_counter_attributes(attr_vec, sai_attr);

    status = counter_api->set_counter_attribute((sai_object_id_t)counter_oid,
                                                sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_counter_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t counter_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_counter_attributes(attr_list_vec, sai_attr_list);

    status = counter_api->get_counter_attribute(
        (sai_object_id_t)counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_counter_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_counter_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t counter_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = counter_api->get_counter_stats((sai_object_id_t)counter_oid,
                                            number_of_counters,
                                            sai_counter_ids,
                                            sai_counters);

    // sai_adapter always takes all counter stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_counter_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t counter_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = counter_api->get_counter_stats_ext((sai_object_id_t)counter_oid,
                                                number_of_counters,
                                                sai_counter_ids,
                                                (sai_stats_mode_t)mode,
                                                sai_counters);

    // sai_adapter always takes all counter stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_counter_stats(
      const sai_thrift_object_id_t counter_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_counter_api_t *counter_api;

    status = sai_api_query(SAI_API_COUNTER, (void **)&counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = counter_api->clear_counter_stats(
        (sai_object_id_t)counter_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_debug_counter(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t debug_counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_debug_counter_attributes(attr_list, sai_attr_list);

    status = debug_counter_api->create_debug_counter(
        &debug_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return debug_counter_oid_out;
  }

  void sai_thrift_remove_debug_counter(
      const sai_thrift_object_id_t debug_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = debug_counter_api->remove_debug_counter(
        (sai_object_id_t)debug_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_debug_counter_attribute(
      const sai_thrift_object_id_t debug_counter_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_debug_counter_attributes(attr_vec, sai_attr);

    status = debug_counter_api->set_debug_counter_attribute(
        (sai_object_id_t)debug_counter_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_debug_counter_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t debug_counter_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_debug_counter_api_t *debug_counter_api;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_debug_counter_attributes(attr_list_vec, sai_attr_list);

    status = debug_counter_api->get_debug_counter_attribute(
        (sai_object_id_t)debug_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_debug_counter_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel(
        &dtel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return dtel_oid_out;
  }

  void sai_thrift_remove_dtel(const sai_thrift_object_id_t dtel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel((sai_object_id_t)dtel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_attribute(const sai_thrift_object_id_t dtel_oid,
                                     const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_dtel_attributes(attr_vec, sai_attr);

    status = dtel_api->set_dtel_attribute((sai_object_id_t)dtel_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_dtel_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t dtel_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_dtel_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_attribute(
        (sai_object_id_t)dtel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_queue_report(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_queue_report_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_queue_report_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_queue_report(
        &dtel_queue_report_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return dtel_queue_report_oid_out;
  }

  void sai_thrift_remove_dtel_queue_report(
      const sai_thrift_object_id_t dtel_queue_report_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_queue_report(
        (sai_object_id_t)dtel_queue_report_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_queue_report_attribute(
      const sai_thrift_object_id_t dtel_queue_report_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_dtel_queue_report_attributes(attr_vec, sai_attr);

    status = dtel_api->set_dtel_queue_report_attribute(
        (sai_object_id_t)dtel_queue_report_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_dtel_queue_report_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t dtel_queue_report_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_dtel_queue_report_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_queue_report_attribute(
        (sai_object_id_t)dtel_queue_report_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_queue_report_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_int_session(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_int_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_int_session_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_int_session(
        &dtel_int_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return dtel_int_session_oid_out;
  }

  void sai_thrift_remove_dtel_int_session(
      const sai_thrift_object_id_t dtel_int_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_int_session(
        (sai_object_id_t)dtel_int_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_int_session_attribute(
      const sai_thrift_object_id_t dtel_int_session_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_dtel_int_session_attributes(attr_vec, sai_attr);

    status = dtel_api->set_dtel_int_session_attribute(
        (sai_object_id_t)dtel_int_session_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_dtel_int_session_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t dtel_int_session_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_dtel_int_session_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_int_session_attribute(
        (sai_object_id_t)dtel_int_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_int_session_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_report_session(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_report_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_report_session_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_report_session(
        &dtel_report_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return dtel_report_session_oid_out;
  }

  void sai_thrift_remove_dtel_report_session(
      const sai_thrift_object_id_t dtel_report_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_report_session(
        (sai_object_id_t)dtel_report_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_report_session_attribute(
      const sai_thrift_object_id_t dtel_report_session_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_dtel_report_session_attributes(attr_vec, sai_attr);

    status = dtel_api->set_dtel_report_session_attribute(
        (sai_object_id_t)dtel_report_session_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_dtel_report_session_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t dtel_report_session_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_dtel_report_session_attributes(attr_list_vec,
                                                    sai_attr_list);

    status = dtel_api->get_dtel_report_session_attribute(
        (sai_object_id_t)dtel_report_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_report_session_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_event(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t dtel_event_oid_out = SAI_NULL_OBJECT_ID;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_dtel_event_attributes(attr_list, sai_attr_list);

    status = dtel_api->create_dtel_event(
        &dtel_event_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return dtel_event_oid_out;
  }

  void sai_thrift_remove_dtel_event(
      const sai_thrift_object_id_t dtel_event_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = dtel_api->remove_dtel_event((sai_object_id_t)dtel_event_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_dtel_event_attribute(
      const sai_thrift_object_id_t dtel_event_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_dtel_event_attributes(attr_vec, sai_attr);

    status = dtel_api->set_dtel_event_attribute((sai_object_id_t)dtel_event_oid,
                                                sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_dtel_event_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t dtel_event_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_dtel_event_attributes(attr_list_vec, sai_attr_list);

    status = dtel_api->get_dtel_event_attribute(
        (sai_object_id_t)dtel_event_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_dtel_event_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_fdb_entry(
      const sai_thrift_fdb_entry_t &fdb_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_fdb_entry_attributes(attr_list, sai_attr_list);

    status =
        fdb_api->create_fdb_entry(&sai_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_fdb_entry(const sai_thrift_fdb_entry_t &fdb_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    status = fdb_api->remove_fdb_entry(&sai_fdb_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_fdb_entry_attribute(
      const sai_thrift_fdb_entry_t &fdb_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_attribute_t *sai_attr;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_fdb_entry_attributes(attr_vec, sai_attr);

    status = fdb_api->set_fdb_entry_attribute(&sai_fdb_entry, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_fdb_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_fdb_entry_t &fdb_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_entry_t sai_fdb_entry;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_fdb_entry(fdb_entry, &sai_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_fdb_entry_attributes(attr_list_vec, sai_attr_list);

    status = fdb_api->get_fdb_entry_attribute(
        &sai_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_fdb_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_flush_fdb_entries(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    sai_thrift_parse_fdb_flush_attributes(attr_list, sai_attr_list);

    status = fdb_api->flush_fdb_entries(switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_fdb_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_fdb_entry_t> &fdb_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_fdb_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_fdb_entry_t> &fdb_entry,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_fdb_entry_attribute(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_fdb_entry_t> &fdb_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_fdb_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const std::vector<sai_thrift_fdb_entry_t> &fdb_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const sai_thrift_attribute_list_t &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode,
      const std::vector<sai_thrift_status_t> &object_statuses) {
    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_generic_programmable(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t generic_programmable_oid_out = SAI_NULL_OBJECT_ID;
    sai_generic_programmable_api_t *generic_programmable_api;

    status = sai_api_query(SAI_API_GENERIC_PROGRAMMABLE,
                           (void **)&generic_programmable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_generic_programmable_attributes(attr_list, sai_attr_list);

    status = generic_programmable_api->create_generic_programmable(
        &generic_programmable_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return generic_programmable_oid_out;
  }

  void sai_thrift_remove_generic_programmable(
      const sai_thrift_object_id_t generic_programmable_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_generic_programmable_api_t *generic_programmable_api;

    status = sai_api_query(SAI_API_GENERIC_PROGRAMMABLE,
                           (void **)&generic_programmable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = generic_programmable_api->remove_generic_programmable(
        (sai_object_id_t)generic_programmable_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_generic_programmable_attribute(
      const sai_thrift_object_id_t generic_programmable_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_generic_programmable_api_t *generic_programmable_api;

    status = sai_api_query(SAI_API_GENERIC_PROGRAMMABLE,
                           (void **)&generic_programmable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_generic_programmable_attributes(attr_vec, sai_attr);

    status = generic_programmable_api->set_generic_programmable_attribute(
        (sai_object_id_t)generic_programmable_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_generic_programmable_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t generic_programmable_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_generic_programmable_api_t *generic_programmable_api;

    status = sai_api_query(SAI_API_GENERIC_PROGRAMMABLE,
                           (void **)&generic_programmable_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_generic_programmable_attributes(attr_list_vec,
                                                     sai_attr_list);

    status = generic_programmable_api->get_generic_programmable_attribute(
        (sai_object_id_t)generic_programmable_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_generic_programmable_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_fine_grained_hash_field(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t fine_grained_hash_field_oid_out = SAI_NULL_OBJECT_ID;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_fine_grained_hash_field_attributes(attr_list,
                                                        sai_attr_list);

    status = hash_api->create_fine_grained_hash_field(
        &fine_grained_hash_field_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return fine_grained_hash_field_oid_out;
  }

  void sai_thrift_remove_fine_grained_hash_field(
      const sai_thrift_object_id_t fine_grained_hash_field_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hash_api->remove_fine_grained_hash_field(
        (sai_object_id_t)fine_grained_hash_field_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_fine_grained_hash_field_attribute(
      const sai_thrift_object_id_t fine_grained_hash_field_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_fine_grained_hash_field_attributes(attr_vec, sai_attr);

    status = hash_api->set_fine_grained_hash_field_attribute(
        (sai_object_id_t)fine_grained_hash_field_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_fine_grained_hash_field_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t fine_grained_hash_field_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_fine_grained_hash_field_attributes(attr_list_vec,
                                                        sai_attr_list);

    status = hash_api->get_fine_grained_hash_field_attribute(
        (sai_object_id_t)fine_grained_hash_field_oid,
        attr_count,
        sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_fine_grained_hash_field_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hash(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hash_oid_out = SAI_NULL_OBJECT_ID;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hash_attributes(attr_list, sai_attr_list);

    status = hash_api->create_hash(
        &hash_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return hash_oid_out;
  }

  void sai_thrift_remove_hash(const sai_thrift_object_id_t hash_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hash_api->remove_hash((sai_object_id_t)hash_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hash_attribute(const sai_thrift_object_id_t hash_oid,
                                     const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_hash_attributes(attr_vec, sai_attr);

    status = hash_api->set_hash_attribute((sai_object_id_t)hash_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_hash_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t hash_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_hash_attributes(attr_list_vec, sai_attr_list);

    status = hash_api->get_hash_attribute(
        (sai_object_id_t)hash_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hash_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_trap_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_trap_group_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif_trap_group(
        &hostif_trap_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return hostif_trap_group_oid_out;
  }

  void sai_thrift_remove_hostif_trap_group(
      const sai_thrift_object_id_t hostif_trap_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_trap_group(
        (sai_object_id_t)hostif_trap_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_trap_group_attribute(
      const sai_thrift_object_id_t hostif_trap_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_hostif_trap_group_attributes(attr_vec, sai_attr);

    status = hostif_api->set_hostif_trap_group_attribute(
        (sai_object_id_t)hostif_trap_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_hostif_trap_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t hostif_trap_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_hostif_trap_group_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_trap_group_attribute(
        (sai_object_id_t)hostif_trap_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_trap_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_trap_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_trap_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif_trap(
        &hostif_trap_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return hostif_trap_oid_out;
  }

  void sai_thrift_remove_hostif_trap(
      const sai_thrift_object_id_t hostif_trap_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_trap((sai_object_id_t)hostif_trap_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_trap_attribute(
      const sai_thrift_object_id_t hostif_trap_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_hostif_trap_attributes(attr_vec, sai_attr);

    status = hostif_api->set_hostif_trap_attribute(
        (sai_object_id_t)hostif_trap_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_hostif_trap_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t hostif_trap_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_hostif_trap_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_trap_attribute(
        (sai_object_id_t)hostif_trap_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_trap_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_user_defined_trap(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_user_defined_trap_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_list,
                                                         sai_attr_list);

    status = hostif_api->create_hostif_user_defined_trap(
        &hostif_user_defined_trap_oid_out,
        switch_id,
        attr_count,
        sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return hostif_user_defined_trap_oid_out;
  }

  void sai_thrift_remove_hostif_user_defined_trap(
      const sai_thrift_object_id_t hostif_user_defined_trap_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_user_defined_trap(
        (sai_object_id_t)hostif_user_defined_trap_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_user_defined_trap_attribute(
      const sai_thrift_object_id_t hostif_user_defined_trap_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_vec, sai_attr);

    status = hostif_api->set_hostif_user_defined_trap_attribute(
        (sai_object_id_t)hostif_user_defined_trap_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_hostif_user_defined_trap_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t hostif_user_defined_trap_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_hostif_user_defined_trap_attributes(attr_list_vec,
                                                         sai_attr_list);

    status = hostif_api->get_hostif_user_defined_trap_attribute(
        (sai_object_id_t)hostif_user_defined_trap_oid,
        attr_count,
        sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_user_defined_trap_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif(
        &hostif_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return hostif_oid_out;
  }

  void sai_thrift_remove_hostif(const sai_thrift_object_id_t hostif_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif((sai_object_id_t)hostif_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_attribute(const sai_thrift_object_id_t hostif_oid,
                                       const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_hostif_attributes(attr_vec, sai_attr);

    status =
        hostif_api->set_hostif_attribute((sai_object_id_t)hostif_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_hostif_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t hostif_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_hostif_attributes(attr_list_vec, sai_attr_list);

    status = hostif_api->get_hostif_attribute(
        (sai_object_id_t)hostif_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_table_entry(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t hostif_table_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_hostif_table_entry_attributes(attr_list, sai_attr_list);

    status = hostif_api->create_hostif_table_entry(
        &hostif_table_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return hostif_table_entry_oid_out;
  }

  void sai_thrift_remove_hostif_table_entry(
      const sai_thrift_object_id_t hostif_table_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = hostif_api->remove_hostif_table_entry(
        (sai_object_id_t)hostif_table_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_hostif_table_entry_attribute(
      const sai_thrift_object_id_t hostif_table_entry_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_hostif_table_entry_attributes(attr_vec, sai_attr);

    status = hostif_api->set_hostif_table_entry_attribute(
        (sai_object_id_t)hostif_table_entry_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_hostif_table_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t hostif_table_entry_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hostif_api_t *hostif_api;

    status = sai_api_query(SAI_API_HOSTIF, (void **)&hostif_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_hostif_table_entry_attributes(attr_list_vec,
                                                   sai_attr_list);

    status = hostif_api->get_hostif_table_entry_attribute(
        (sai_object_id_t)hostif_table_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_hostif_table_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_size_t sai_thrift_recv_hostif_packet(
      const sai_thrift_object_id_t hostif_oid,
      const sai_thrift_size_t buffer_size,
      const std::string &buffer,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    // This function is UNSUPPORTED
    return 0ULL;
  }

  void sai_thrift_send_hostif_packet(
      const sai_thrift_object_id_t hostif_oid,
      const sai_thrift_size_t buffer_size,
      const std::string &buffer,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_allocate_hostif_packet(
      std::string &buffer_out,
      const sai_thrift_object_id_t hostif_oid,
      const sai_thrift_size_t buffer_size,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_free_hostif_packet(std::string &buffer_out,
                                     const sai_thrift_object_id_t hostif_oid,
                                     const std::string &buffer) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_create_ipmc_entry(
      const sai_thrift_ipmc_entry_t &ipmc_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_entry_attributes(attr_list, sai_attr_list);

    status =
        ipmc_api->create_ipmc_entry(&sai_ipmc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_ipmc_entry(const sai_thrift_ipmc_entry_t &ipmc_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    status = ipmc_api->remove_ipmc_entry(&sai_ipmc_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_entry_attribute(
      const sai_thrift_ipmc_entry_t &ipmc_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_attribute_t *sai_attr;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_ipmc_entry_attributes(attr_vec, sai_attr);

    status = ipmc_api->set_ipmc_entry_attribute(&sai_ipmc_entry, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_ipmc_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_ipmc_entry_t &ipmc_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_entry_t sai_ipmc_entry;
    sai_ipmc_api_t *ipmc_api;

    status = sai_api_query(SAI_API_IPMC, (void **)&ipmc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_ipmc_entry(ipmc_entry, &sai_ipmc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_ipmc_entry_attributes(attr_list_vec, sai_attr_list);

    status = ipmc_api->get_ipmc_entry_attribute(
        &sai_ipmc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipmc_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipmc_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_group_attributes(attr_list, sai_attr_list);

    status = ipmc_group_api->create_ipmc_group(
        &ipmc_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return ipmc_group_oid_out;
  }

  void sai_thrift_remove_ipmc_group(
      const sai_thrift_object_id_t ipmc_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = ipmc_group_api->remove_ipmc_group((sai_object_id_t)ipmc_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_group_attribute(
      const sai_thrift_object_id_t ipmc_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_ipmc_group_attributes(attr_vec, sai_attr);

    status = ipmc_group_api->set_ipmc_group_attribute(
        (sai_object_id_t)ipmc_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_ipmc_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t ipmc_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_ipmc_group_attributes(attr_list_vec, sai_attr_list);

    status = ipmc_group_api->get_ipmc_group_attribute(
        (sai_object_id_t)ipmc_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipmc_group_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipmc_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipmc_group_member_attributes(attr_list, sai_attr_list);

    status = ipmc_group_api->create_ipmc_group_member(
        &ipmc_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return ipmc_group_member_oid_out;
  }

  void sai_thrift_remove_ipmc_group_member(
      const sai_thrift_object_id_t ipmc_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = ipmc_group_api->remove_ipmc_group_member(
        (sai_object_id_t)ipmc_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipmc_group_member_attribute(
      const sai_thrift_object_id_t ipmc_group_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_ipmc_group_member_attributes(attr_vec, sai_attr);

    status = ipmc_group_api->set_ipmc_group_member_attribute(
        (sai_object_id_t)ipmc_group_member_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_ipmc_group_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t ipmc_group_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipmc_group_api_t *ipmc_group_api;

    status = sai_api_query(SAI_API_IPMC_GROUP, (void **)&ipmc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_ipmc_group_member_attributes(attr_list_vec, sai_attr_list);

    status = ipmc_group_api->get_ipmc_group_member_attribute(
        (sai_object_id_t)ipmc_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipmc_group_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipsec(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipsec_oid_out = SAI_NULL_OBJECT_ID;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipsec_attributes(attr_list, sai_attr_list);

    status = ipsec_api->create_ipsec(
        &ipsec_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return ipsec_oid_out;
  }

  void sai_thrift_remove_ipsec(const sai_thrift_object_id_t ipsec_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = ipsec_api->remove_ipsec((sai_object_id_t)ipsec_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipsec_attribute(const sai_thrift_object_id_t ipsec_oid,
                                      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_ipsec_attributes(attr_vec, sai_attr);

    status =
        ipsec_api->set_ipsec_attribute((sai_object_id_t)ipsec_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_ipsec_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t ipsec_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_ipsec_attributes(attr_list_vec, sai_attr_list);

    status = ipsec_api->get_ipsec_attribute(
        (sai_object_id_t)ipsec_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipsec_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipsec_port(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipsec_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipsec_port_attributes(attr_list, sai_attr_list);

    status = ipsec_api->create_ipsec_port(
        &ipsec_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return ipsec_port_oid_out;
  }

  void sai_thrift_remove_ipsec_port(
      const sai_thrift_object_id_t ipsec_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = ipsec_api->remove_ipsec_port((sai_object_id_t)ipsec_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipsec_port_attribute(
      const sai_thrift_object_id_t ipsec_port_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_ipsec_port_attributes(attr_vec, sai_attr);

    status = ipsec_api->set_ipsec_port_attribute(
        (sai_object_id_t)ipsec_port_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_ipsec_port_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t ipsec_port_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_ipsec_port_attributes(attr_list_vec, sai_attr_list);

    status = ipsec_api->get_ipsec_port_attribute(
        (sai_object_id_t)ipsec_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipsec_port_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_ipsec_port_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t ipsec_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = ipsec_api->get_ipsec_port_stats((sai_object_id_t)ipsec_port_oid,
                                             number_of_counters,
                                             sai_counter_ids,
                                             sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_ipsec_port_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t ipsec_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status =
        ipsec_api->get_ipsec_port_stats_ext((sai_object_id_t)ipsec_port_oid,
                                            number_of_counters,
                                            sai_counter_ids,
                                            (sai_stats_mode_t)mode,
                                            sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_ipsec_port_stats(
      const sai_thrift_object_id_t ipsec_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = ipsec_api->clear_ipsec_port_stats(
        (sai_object_id_t)ipsec_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_ipsec_sa(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t ipsec_sa_oid_out = SAI_NULL_OBJECT_ID;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_ipsec_sa_attributes(attr_list, sai_attr_list);

    status = ipsec_api->create_ipsec_sa(
        &ipsec_sa_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return ipsec_sa_oid_out;
  }

  void sai_thrift_remove_ipsec_sa(const sai_thrift_object_id_t ipsec_sa_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = ipsec_api->remove_ipsec_sa((sai_object_id_t)ipsec_sa_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_ipsec_sa_attribute(
      const sai_thrift_object_id_t ipsec_sa_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_ipsec_sa_attributes(attr_vec, sai_attr);

    status = ipsec_api->set_ipsec_sa_attribute((sai_object_id_t)ipsec_sa_oid,
                                               sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_ipsec_sa_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t ipsec_sa_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_ipsec_sa_attributes(attr_list_vec, sai_attr_list);

    status = ipsec_api->get_ipsec_sa_attribute(
        (sai_object_id_t)ipsec_sa_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_ipsec_sa_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_ipsec_sa_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t ipsec_sa_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = ipsec_api->get_ipsec_sa_stats((sai_object_id_t)ipsec_sa_oid,
                                           number_of_counters,
                                           sai_counter_ids,
                                           sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_ipsec_sa_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t ipsec_sa_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = ipsec_api->get_ipsec_sa_stats_ext((sai_object_id_t)ipsec_sa_oid,
                                               number_of_counters,
                                               sai_counter_ids,
                                               (sai_stats_mode_t)mode,
                                               sai_counters);

    // sai_adapter always takes all ipsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_ipsec_sa_stats(
      const sai_thrift_object_id_t ipsec_sa_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_ipsec_api_t *ipsec_api;

    status = sai_api_query(SAI_API_IPSEC, (void **)&ipsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = ipsec_api->clear_ipsec_sa_stats(
        (sai_object_id_t)ipsec_sa_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_isolation_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t isolation_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_isolation_group_attributes(attr_list, sai_attr_list);

    status = isolation_group_api->create_isolation_group(
        &isolation_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return isolation_group_oid_out;
  }

  void sai_thrift_remove_isolation_group(
      const sai_thrift_object_id_t isolation_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = isolation_group_api->remove_isolation_group(
        (sai_object_id_t)isolation_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_isolation_group_attribute(
      const sai_thrift_object_id_t isolation_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_isolation_group_attributes(attr_vec, sai_attr);

    status = isolation_group_api->set_isolation_group_attribute(
        (sai_object_id_t)isolation_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_isolation_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t isolation_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_isolation_group_attributes(attr_list_vec, sai_attr_list);

    status = isolation_group_api->get_isolation_group_attribute(
        (sai_object_id_t)isolation_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_isolation_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_isolation_group_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t isolation_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_isolation_group_member_attributes(attr_list,
                                                       sai_attr_list);

    status = isolation_group_api->create_isolation_group_member(
        &isolation_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return isolation_group_member_oid_out;
  }

  void sai_thrift_remove_isolation_group_member(
      const sai_thrift_object_id_t isolation_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = isolation_group_api->remove_isolation_group_member(
        (sai_object_id_t)isolation_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_isolation_group_member_attribute(
      const sai_thrift_object_id_t isolation_group_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_isolation_group_member_attributes(attr_vec, sai_attr);

    status = isolation_group_api->set_isolation_group_member_attribute(
        (sai_object_id_t)isolation_group_member_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_isolation_group_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t isolation_group_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_isolation_group_api_t *isolation_group_api;

    status =
        sai_api_query(SAI_API_ISOLATION_GROUP, (void **)&isolation_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_isolation_group_member_attributes(attr_list_vec,
                                                       sai_attr_list);

    status = isolation_group_api->get_isolation_group_member_attribute(
        (sai_object_id_t)isolation_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_isolation_group_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_l2mc_entry(
      const sai_thrift_l2mc_entry_t &l2mc_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_entry_attributes(attr_list, sai_attr_list);

    status =
        l2mc_api->create_l2mc_entry(&sai_l2mc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_l2mc_entry(const sai_thrift_l2mc_entry_t &l2mc_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    status = l2mc_api->remove_l2mc_entry(&sai_l2mc_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_entry_attribute(
      const sai_thrift_l2mc_entry_t &l2mc_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_attribute_t *sai_attr;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_l2mc_entry_attributes(attr_vec, sai_attr);

    status = l2mc_api->set_l2mc_entry_attribute(&sai_l2mc_entry, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_l2mc_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_l2mc_entry_t &l2mc_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_entry_t sai_l2mc_entry;
    sai_l2mc_api_t *l2mc_api;

    status = sai_api_query(SAI_API_L2MC, (void **)&l2mc_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_l2mc_entry(l2mc_entry, &sai_l2mc_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_l2mc_entry_attributes(attr_list_vec, sai_attr_list);

    status = l2mc_api->get_l2mc_entry_attribute(
        &sai_l2mc_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_l2mc_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t l2mc_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_group_attributes(attr_list, sai_attr_list);

    status = l2mc_group_api->create_l2mc_group(
        &l2mc_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return l2mc_group_oid_out;
  }

  void sai_thrift_remove_l2mc_group(
      const sai_thrift_object_id_t l2mc_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = l2mc_group_api->remove_l2mc_group((sai_object_id_t)l2mc_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_group_attribute(
      const sai_thrift_object_id_t l2mc_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_l2mc_group_attributes(attr_vec, sai_attr);

    status = l2mc_group_api->set_l2mc_group_attribute(
        (sai_object_id_t)l2mc_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_l2mc_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t l2mc_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_l2mc_group_attributes(attr_list_vec, sai_attr_list);

    status = l2mc_group_api->get_l2mc_group_attribute(
        (sai_object_id_t)l2mc_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_l2mc_group_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t l2mc_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_l2mc_group_member_attributes(attr_list, sai_attr_list);

    status = l2mc_group_api->create_l2mc_group_member(
        &l2mc_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return l2mc_group_member_oid_out;
  }

  void sai_thrift_remove_l2mc_group_member(
      const sai_thrift_object_id_t l2mc_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = l2mc_group_api->remove_l2mc_group_member(
        (sai_object_id_t)l2mc_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_l2mc_group_member_attribute(
      const sai_thrift_object_id_t l2mc_group_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_l2mc_group_member_attributes(attr_vec, sai_attr);

    status = l2mc_group_api->set_l2mc_group_member_attribute(
        (sai_object_id_t)l2mc_group_member_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_l2mc_group_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t l2mc_group_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_l2mc_group_api_t *l2mc_group_api;

    status = sai_api_query(SAI_API_L2MC_GROUP, (void **)&l2mc_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_l2mc_group_member_attributes(attr_list_vec, sai_attr_list);

    status = l2mc_group_api->get_l2mc_group_member_attribute(
        (sai_object_id_t)l2mc_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_l2mc_group_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_lag(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t lag_oid_out = SAI_NULL_OBJECT_ID;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_lag_attributes(attr_list, sai_attr_list);

    status =
        lag_api->create_lag(&lag_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return lag_oid_out;
  }

  void sai_thrift_remove_lag(const sai_thrift_object_id_t lag_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = lag_api->remove_lag((sai_object_id_t)lag_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_lag_attribute(const sai_thrift_object_id_t lag_oid,
                                    const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_lag_attributes(attr_vec, sai_attr);

    status = lag_api->set_lag_attribute((sai_object_id_t)lag_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_lag_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t lag_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_lag_attributes(attr_list_vec, sai_attr_list);

    status = lag_api->get_lag_attribute(
        (sai_object_id_t)lag_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_lag_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_lag_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t lag_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_lag_member_attributes(attr_list, sai_attr_list);

    status = lag_api->create_lag_member(
        &lag_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return lag_member_oid_out;
  }

  void sai_thrift_remove_lag_member(
      const sai_thrift_object_id_t lag_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = lag_api->remove_lag_member((sai_object_id_t)lag_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_lag_member_attribute(
      const sai_thrift_object_id_t lag_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_lag_member_attributes(attr_vec, sai_attr);

    status = lag_api->set_lag_member_attribute((sai_object_id_t)lag_member_oid,
                                               sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_lag_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t lag_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_lag_member_attributes(attr_list_vec, sai_attr_list);

    status = lag_api->get_lag_member_attribute(
        (sai_object_id_t)lag_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_lag_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec(
        &macsec_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return macsec_oid_out;
  }

  void sai_thrift_remove_macsec(const sai_thrift_object_id_t macsec_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec((sai_object_id_t)macsec_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_attribute(const sai_thrift_object_id_t macsec_oid,
                                       const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_macsec_attributes(attr_vec, sai_attr);

    status =
        macsec_api->set_macsec_attribute((sai_object_id_t)macsec_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_macsec_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t macsec_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_macsec_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_attribute(
        (sai_object_id_t)macsec_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_port(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_port_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_port(
        &macsec_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return macsec_port_oid_out;
  }

  void sai_thrift_remove_macsec_port(
      const sai_thrift_object_id_t macsec_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_port((sai_object_id_t)macsec_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_port_attribute(
      const sai_thrift_object_id_t macsec_port_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_macsec_port_attributes(attr_vec, sai_attr);

    status = macsec_api->set_macsec_port_attribute(
        (sai_object_id_t)macsec_port_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_macsec_port_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t macsec_port_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_macsec_port_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_port_attribute(
        (sai_object_id_t)macsec_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_port_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_port_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_port_stats((sai_object_id_t)macsec_port_oid,
                                               number_of_counters,
                                               sai_counter_ids,
                                               sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_port_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status =
        macsec_api->get_macsec_port_stats_ext((sai_object_id_t)macsec_port_oid,
                                              number_of_counters,
                                              sai_counter_ids,
                                              (sai_stats_mode_t)mode,
                                              sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_port_stats(
      const sai_thrift_object_id_t macsec_port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_port_stats(
        (sai_object_id_t)macsec_port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_flow(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_flow_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_flow_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_flow(
        &macsec_flow_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return macsec_flow_oid_out;
  }

  void sai_thrift_remove_macsec_flow(
      const sai_thrift_object_id_t macsec_flow_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_flow((sai_object_id_t)macsec_flow_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_flow_attribute(
      const sai_thrift_object_id_t macsec_flow_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_macsec_flow_attributes(attr_vec, sai_attr);

    status = macsec_api->set_macsec_flow_attribute(
        (sai_object_id_t)macsec_flow_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_macsec_flow_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t macsec_flow_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_macsec_flow_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_flow_attribute(
        (sai_object_id_t)macsec_flow_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_flow_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_flow_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_flow_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_flow_stats((sai_object_id_t)macsec_flow_oid,
                                               number_of_counters,
                                               sai_counter_ids,
                                               sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_flow_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_flow_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status =
        macsec_api->get_macsec_flow_stats_ext((sai_object_id_t)macsec_flow_oid,
                                              number_of_counters,
                                              sai_counter_ids,
                                              (sai_stats_mode_t)mode,
                                              sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_flow_stats(
      const sai_thrift_object_id_t macsec_flow_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_flow_stats(
        (sai_object_id_t)macsec_flow_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_sc(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_sc_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_sc_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_sc(
        &macsec_sc_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return macsec_sc_oid_out;
  }

  void sai_thrift_remove_macsec_sc(const sai_thrift_object_id_t macsec_sc_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_sc((sai_object_id_t)macsec_sc_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_sc_attribute(
      const sai_thrift_object_id_t macsec_sc_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_macsec_sc_attributes(attr_vec, sai_attr);

    status = macsec_api->set_macsec_sc_attribute((sai_object_id_t)macsec_sc_oid,
                                                 sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_macsec_sc_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t macsec_sc_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_macsec_sc_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_sc_attribute(
        (sai_object_id_t)macsec_sc_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_sc_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_sc_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_sc_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sc_stats((sai_object_id_t)macsec_sc_oid,
                                             number_of_counters,
                                             sai_counter_ids,
                                             sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_sc_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_sc_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sc_stats_ext((sai_object_id_t)macsec_sc_oid,
                                                 number_of_counters,
                                                 sai_counter_ids,
                                                 (sai_stats_mode_t)mode,
                                                 sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_sc_stats(
      const sai_thrift_object_id_t macsec_sc_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_sc_stats(
        (sai_object_id_t)macsec_sc_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_macsec_sa(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t macsec_sa_oid_out = SAI_NULL_OBJECT_ID;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_macsec_sa_attributes(attr_list, sai_attr_list);

    status = macsec_api->create_macsec_sa(
        &macsec_sa_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return macsec_sa_oid_out;
  }

  void sai_thrift_remove_macsec_sa(const sai_thrift_object_id_t macsec_sa_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = macsec_api->remove_macsec_sa((sai_object_id_t)macsec_sa_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_macsec_sa_attribute(
      const sai_thrift_object_id_t macsec_sa_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_macsec_sa_attributes(attr_vec, sai_attr);

    status = macsec_api->set_macsec_sa_attribute((sai_object_id_t)macsec_sa_oid,
                                                 sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_macsec_sa_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t macsec_sa_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_macsec_sa_attributes(attr_list_vec, sai_attr_list);

    status = macsec_api->get_macsec_sa_attribute(
        (sai_object_id_t)macsec_sa_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_macsec_sa_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_macsec_sa_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_sa_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sa_stats((sai_object_id_t)macsec_sa_oid,
                                             number_of_counters,
                                             sai_counter_ids,
                                             sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_macsec_sa_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t macsec_sa_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = macsec_api->get_macsec_sa_stats_ext((sai_object_id_t)macsec_sa_oid,
                                                 number_of_counters,
                                                 sai_counter_ids,
                                                 (sai_stats_mode_t)mode,
                                                 sai_counters);

    // sai_adapter always takes all macsec stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_macsec_sa_stats(
      const sai_thrift_object_id_t macsec_sa_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_macsec_api_t *macsec_api;

    status = sai_api_query(SAI_API_MACSEC, (void **)&macsec_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = macsec_api->clear_macsec_sa_stats(
        (sai_object_id_t)macsec_sa_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_create_mcast_fdb_entry(
      const sai_thrift_mcast_fdb_entry_t &mcast_fdb_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_mcast_fdb_entry_attributes(attr_list, sai_attr_list);

    status = mcast_fdb_api->create_mcast_fdb_entry(
        &sai_mcast_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_mcast_fdb_entry(
      const sai_thrift_mcast_fdb_entry_t &mcast_fdb_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    status = mcast_fdb_api->remove_mcast_fdb_entry(&sai_mcast_fdb_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_mcast_fdb_entry_attribute(
      const sai_thrift_mcast_fdb_entry_t &mcast_fdb_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_attribute_t *sai_attr;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_mcast_fdb_entry_attributes(attr_vec, sai_attr);

    status = mcast_fdb_api->set_mcast_fdb_entry_attribute(&sai_mcast_fdb_entry,
                                                          sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_mcast_fdb_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_mcast_fdb_entry_t &mcast_fdb_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mcast_fdb_entry_t sai_mcast_fdb_entry;
    sai_mcast_fdb_api_t *mcast_fdb_api;

    status = sai_api_query(SAI_API_MCAST_FDB, (void **)&mcast_fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_mcast_fdb_entry(mcast_fdb_entry, &sai_mcast_fdb_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_mcast_fdb_entry_attributes(attr_list_vec, sai_attr_list);

    status = mcast_fdb_api->get_mcast_fdb_entry_attribute(
        &sai_mcast_fdb_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_mcast_fdb_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_mirror_session(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t mirror_session_oid_out = SAI_NULL_OBJECT_ID;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_mirror_session_attributes(attr_list, sai_attr_list);

    status = mirror_api->create_mirror_session(
        &mirror_session_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return mirror_session_oid_out;
  }

  void sai_thrift_remove_mirror_session(
      const sai_thrift_object_id_t mirror_session_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        mirror_api->remove_mirror_session((sai_object_id_t)mirror_session_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_mirror_session_attribute(
      const sai_thrift_object_id_t mirror_session_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_mirror_session_attributes(attr_vec, sai_attr);

    status = mirror_api->set_mirror_session_attribute(
        (sai_object_id_t)mirror_session_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_mirror_session_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t mirror_session_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_mirror_session_attributes(attr_list_vec, sai_attr_list);

    status = mirror_api->get_mirror_session_attribute(
        (sai_object_id_t)mirror_session_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_mirror_session_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_inseg_entry(
      const sai_thrift_inseg_entry_t &inseg_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_inseg_entry_attributes(attr_list, sai_attr_list);

    status = mpls_api->create_inseg_entry(
        &sai_inseg_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_inseg_entry(
      const sai_thrift_inseg_entry_t &inseg_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    status = mpls_api->remove_inseg_entry(&sai_inseg_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_inseg_entry_attribute(
      const sai_thrift_inseg_entry_t &inseg_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_attribute_t *sai_attr;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_inseg_entry_attributes(attr_vec, sai_attr);

    status = mpls_api->set_inseg_entry_attribute(&sai_inseg_entry, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_inseg_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_inseg_entry_t &inseg_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_inseg_entry_t sai_inseg_entry;
    sai_mpls_api_t *mpls_api;

    status = sai_api_query(SAI_API_MPLS, (void **)&mpls_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_inseg_entry(inseg_entry, &sai_inseg_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_inseg_entry_attributes(attr_list_vec, sai_attr_list);

    status = mpls_api->get_inseg_entry_attribute(
        &sai_inseg_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_inseg_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_inseg_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_inseg_entry_t> &inseg_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_inseg_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_inseg_entry_t> &inseg_entry,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_inseg_entry_attribute(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_inseg_entry_t> &inseg_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_inseg_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const std::vector<sai_thrift_inseg_entry_t> &inseg_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const sai_thrift_attribute_list_t &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode,
      const std::vector<sai_thrift_status_t> &object_statuses) {
    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_my_mac(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t my_mac_oid_out = SAI_NULL_OBJECT_ID;
    sai_my_mac_api_t *my_mac_api;

    status = sai_api_query(SAI_API_MY_MAC, (void **)&my_mac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_my_mac_attributes(attr_list, sai_attr_list);

    status = my_mac_api->create_my_mac(
        &my_mac_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return my_mac_oid_out;
  }

  void sai_thrift_remove_my_mac(const sai_thrift_object_id_t my_mac_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_mac_api_t *my_mac_api;

    status = sai_api_query(SAI_API_MY_MAC, (void **)&my_mac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = my_mac_api->remove_my_mac((sai_object_id_t)my_mac_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_my_mac_attribute(const sai_thrift_object_id_t my_mac_oid,
                                       const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_my_mac_api_t *my_mac_api;

    status = sai_api_query(SAI_API_MY_MAC, (void **)&my_mac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_my_mac_attributes(attr_vec, sai_attr);

    status =
        my_mac_api->set_my_mac_attribute((sai_object_id_t)my_mac_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_my_mac_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t my_mac_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_mac_api_t *my_mac_api;

    status = sai_api_query(SAI_API_MY_MAC, (void **)&my_mac_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_my_mac_attributes(attr_list_vec, sai_attr_list);

    status = my_mac_api->get_my_mac_attribute(
        (sai_object_id_t)my_mac_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_my_mac_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_nat_entry(
      const sai_thrift_nat_entry_t &nat_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_nat_entry_attributes(attr_list, sai_attr_list);

    status =
        nat_api->create_nat_entry(&sai_nat_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_nat_entry(const sai_thrift_nat_entry_t &nat_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    status = nat_api->remove_nat_entry(&sai_nat_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_nat_entry_attribute(
      const sai_thrift_nat_entry_t &nat_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_attribute_t *sai_attr;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_nat_entry_attributes(attr_vec, sai_attr);

    status = nat_api->set_nat_entry_attribute(&sai_nat_entry, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_nat_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_nat_entry_t &nat_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t sai_nat_entry;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_nat_entry(nat_entry, &sai_nat_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_nat_entry_attributes(attr_list_vec, sai_attr_list);

    status = nat_api->get_nat_entry_attribute(
        &sai_nat_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_nat_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_nat_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_nat_entry_t> &nat_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_nat_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_nat_entry_t> &nat_entry,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_nat_entry_attribute(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_nat_entry_t> &nat_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_nat_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const std::vector<sai_thrift_nat_entry_t> &nat_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const sai_thrift_attribute_list_t &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode,
      const std::vector<sai_thrift_status_t> &object_statuses) {
    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_nat_zone_counter(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t nat_zone_counter_oid_out = SAI_NULL_OBJECT_ID;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_nat_zone_counter_attributes(attr_list, sai_attr_list);

    status = nat_api->create_nat_zone_counter(
        &nat_zone_counter_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return nat_zone_counter_oid_out;
  }

  void sai_thrift_remove_nat_zone_counter(
      const sai_thrift_object_id_t nat_zone_counter_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        nat_api->remove_nat_zone_counter((sai_object_id_t)nat_zone_counter_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_nat_zone_counter_attribute(
      const sai_thrift_object_id_t nat_zone_counter_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_nat_zone_counter_attributes(attr_vec, sai_attr);

    status = nat_api->set_nat_zone_counter_attribute(
        (sai_object_id_t)nat_zone_counter_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_nat_zone_counter_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t nat_zone_counter_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_api_t *nat_api;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_nat_zone_counter_attributes(attr_list_vec, sai_attr_list);

    status = nat_api->get_nat_zone_counter_attribute(
        (sai_object_id_t)nat_zone_counter_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_nat_zone_counter_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_neighbor_entry(
      const sai_thrift_neighbor_entry_t &neighbor_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_neighbor_entry_attributes(attr_list, sai_attr_list);

    status = neighbor_api->create_neighbor_entry(
        &sai_neighbor_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_neighbor_entry(
      const sai_thrift_neighbor_entry_t &neighbor_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    status = neighbor_api->remove_neighbor_entry(&sai_neighbor_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_neighbor_entry_attribute(
      const sai_thrift_neighbor_entry_t &neighbor_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_attribute_t *sai_attr;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_neighbor_entry_attributes(attr_vec, sai_attr);

    status = neighbor_api->set_neighbor_entry_attribute(&sai_neighbor_entry,
                                                        sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_neighbor_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_neighbor_entry_t &neighbor_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_entry_t sai_neighbor_entry;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_neighbor_entry(neighbor_entry, &sai_neighbor_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_neighbor_entry_attributes(attr_list_vec, sai_attr_list);

    status = neighbor_api->get_neighbor_entry_attribute(
        &sai_neighbor_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_neighbor_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_all_neighbor_entries() {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;

    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = neighbor_api->remove_all_neighbor_entries(switch_id);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_bulk_create_neighbor_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_neighbor_entry_t> &neighbor_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_neighbor_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_neighbor_entry_t> &neighbor_entry,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_neighbor_entry_attribute(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_neighbor_entry_t> &neighbor_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_neighbor_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const std::vector<sai_thrift_neighbor_entry_t> &neighbor_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const sai_thrift_attribute_list_t &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode,
      const std::vector<sai_thrift_status_t> &object_statuses) {
    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_oid_out = SAI_NULL_OBJECT_ID;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_attributes(attr_list, sai_attr_list);

    status = next_hop_api->create_next_hop(
        &next_hop_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return next_hop_oid_out;
  }

  void sai_thrift_remove_next_hop(const sai_thrift_object_id_t next_hop_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = next_hop_api->remove_next_hop((sai_object_id_t)next_hop_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_attribute(
      const sai_thrift_object_id_t next_hop_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_next_hop_attributes(attr_vec, sai_attr);

    status = next_hop_api->set_next_hop_attribute((sai_object_id_t)next_hop_oid,
                                                  sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_next_hop_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t next_hop_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *next_hop_api;

    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&next_hop_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_next_hop_attributes(attr_list_vec, sai_attr_list);

    status = next_hop_api->get_next_hop_attribute(
        (sai_object_id_t)next_hop_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_attributes(attr_list, sai_attr_list);

    status = next_hop_group_api->create_next_hop_group(
        &next_hop_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return next_hop_group_oid_out;
  }

  void sai_thrift_remove_next_hop_group(
      const sai_thrift_object_id_t next_hop_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = next_hop_group_api->remove_next_hop_group(
        (sai_object_id_t)next_hop_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_attribute(
      const sai_thrift_object_id_t next_hop_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_next_hop_group_attributes(attr_vec, sai_attr);

    status = next_hop_group_api->set_next_hop_group_attribute(
        (sai_object_id_t)next_hop_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_next_hop_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t next_hop_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_next_hop_group_attributes(attr_list_vec, sai_attr_list);

    status = next_hop_group_api->get_next_hop_group_attribute(
        (sai_object_id_t)next_hop_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_member_attributes(attr_list, sai_attr_list);

    status = next_hop_group_api->create_next_hop_group_member(
        &next_hop_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return next_hop_group_member_oid_out;
  }

  void sai_thrift_remove_next_hop_group_member(
      const sai_thrift_object_id_t next_hop_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = next_hop_group_api->remove_next_hop_group_member(
        (sai_object_id_t)next_hop_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_member_attribute(
      const sai_thrift_object_id_t next_hop_group_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_next_hop_group_member_attributes(attr_vec, sai_attr);

    status = next_hop_group_api->set_next_hop_group_member_attribute(
        (sai_object_id_t)next_hop_group_member_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_next_hop_group_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t next_hop_group_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_next_hop_group_member_attributes(attr_list_vec,
                                                      sai_attr_list);

    status = next_hop_group_api->get_next_hop_group_member_attribute(
        (sai_object_id_t)next_hop_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_map(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t next_hop_group_map_oid_out = SAI_NULL_OBJECT_ID;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_next_hop_group_map_attributes(attr_list, sai_attr_list);

    status = next_hop_group_api->create_next_hop_group_map(
        &next_hop_group_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return next_hop_group_map_oid_out;
  }

  void sai_thrift_remove_next_hop_group_map(
      const sai_thrift_object_id_t next_hop_group_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = next_hop_group_api->remove_next_hop_group_map(
        (sai_object_id_t)next_hop_group_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_next_hop_group_map_attribute(
      const sai_thrift_object_id_t next_hop_group_map_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_next_hop_group_map_attributes(attr_vec, sai_attr);

    status = next_hop_group_api->set_next_hop_group_map_attribute(
        (sai_object_id_t)next_hop_group_map_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_next_hop_group_map_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t next_hop_group_map_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_group_api_t *next_hop_group_api;

    status =
        sai_api_query(SAI_API_NEXT_HOP_GROUP, (void **)&next_hop_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_next_hop_group_map_attributes(attr_list_vec,
                                                   sai_attr_list);

    status = next_hop_group_api->get_next_hop_group_map_attribute(
        (sai_object_id_t)next_hop_group_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_next_hop_group_map_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_policer(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t policer_oid_out = SAI_NULL_OBJECT_ID;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_policer_attributes(attr_list, sai_attr_list);

    status = policer_api->create_policer(
        &policer_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return policer_oid_out;
  }

  void sai_thrift_remove_policer(const sai_thrift_object_id_t policer_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = policer_api->remove_policer((sai_object_id_t)policer_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_policer_attribute(
      const sai_thrift_object_id_t policer_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_policer_attributes(attr_vec, sai_attr);

    status = policer_api->set_policer_attribute((sai_object_id_t)policer_oid,
                                                sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_policer_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t policer_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_policer_attributes(attr_list_vec, sai_attr_list);

    status = policer_api->get_policer_attribute(
        (sai_object_id_t)policer_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_policer_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_policer_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t policer_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = policer_api->get_policer_stats((sai_object_id_t)policer_oid,
                                            number_of_counters,
                                            sai_counter_ids,
                                            sai_counters);

    // sai_adapter always takes all policer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_policer_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t policer_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = policer_api->get_policer_stats_ext((sai_object_id_t)policer_oid,
                                                number_of_counters,
                                                sai_counter_ids,
                                                (sai_stats_mode_t)mode,
                                                sai_counters);

    // sai_adapter always takes all policer stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_policer_stats(
      const sai_thrift_object_id_t policer_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_policer_api_t *policer_api;

    status = sai_api_query(SAI_API_POLICER, (void **)&policer_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = policer_api->clear_policer_stats(
        (sai_object_id_t)policer_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_attributes(attr_list, sai_attr_list);

    status = port_api->create_port(
        &port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return port_oid_out;
  }

  void sai_thrift_remove_port(const sai_thrift_object_id_t port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->remove_port((sai_object_id_t)port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_attribute(const sai_thrift_object_id_t port_oid,
                                     const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_port_attributes(attr_vec, sai_attr);

    status = port_api->set_port_attribute((sai_object_id_t)port_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_port_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t port_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_port_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_attribute(
        (sai_object_id_t)port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_port_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_stats((sai_object_id_t)port_oid,
                                      number_of_counters,
                                      sai_counter_ids,
                                      sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_port_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_stats_ext((sai_object_id_t)port_oid,
                                          number_of_counters,
                                          sai_counter_ids,
                                          (sai_stats_mode_t)mode,
                                          sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_port_stats(
      const sai_thrift_object_id_t port_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = port_api->clear_port_stats(
        (sai_object_id_t)port_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_clear_port_all_stats(const sai_thrift_object_id_t port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->clear_port_all_stats((sai_object_id_t)port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_pool(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_pool_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_pool_attributes(attr_list, sai_attr_list);

    status = port_api->create_port_pool(
        &port_pool_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return port_pool_oid_out;
  }

  void sai_thrift_remove_port_pool(const sai_thrift_object_id_t port_pool_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->remove_port_pool((sai_object_id_t)port_pool_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_pool_attribute(
      const sai_thrift_object_id_t port_pool_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_port_pool_attributes(attr_vec, sai_attr);

    status = port_api->set_port_pool_attribute((sai_object_id_t)port_pool_oid,
                                               sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_port_pool_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t port_pool_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_port_pool_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_pool_attribute(
        (sai_object_id_t)port_pool_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_pool_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_port_pool_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t port_pool_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_pool_stats((sai_object_id_t)port_pool_oid,
                                           number_of_counters,
                                           sai_counter_ids,
                                           sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_port_pool_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t port_pool_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = port_api->get_port_pool_stats_ext((sai_object_id_t)port_pool_oid,
                                               number_of_counters,
                                               sai_counter_ids,
                                               (sai_stats_mode_t)mode,
                                               sai_counters);

    // sai_adapter always takes all port stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_port_pool_stats(
      const sai_thrift_object_id_t port_pool_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = port_api->clear_port_pool_stats(
        (sai_object_id_t)port_pool_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_serdes(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_serdes_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_serdes_attributes(attr_list, sai_attr_list);

    status = port_api->create_port_serdes(
        &port_serdes_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return port_serdes_oid_out;
  }

  void sai_thrift_remove_port_serdes(
      const sai_thrift_object_id_t port_serdes_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = port_api->remove_port_serdes((sai_object_id_t)port_serdes_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_serdes_attribute(
      const sai_thrift_object_id_t port_serdes_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_port_serdes_attributes(attr_vec, sai_attr);

    status = port_api->set_port_serdes_attribute(
        (sai_object_id_t)port_serdes_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_port_serdes_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t port_serdes_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_port_serdes_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_serdes_attribute(
        (sai_object_id_t)port_serdes_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_serdes_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_port_connector(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t port_connector_oid_out = SAI_NULL_OBJECT_ID;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_port_connector_attributes(attr_list, sai_attr_list);

    status = port_api->create_port_connector(
        &port_connector_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return port_connector_oid_out;
  }

  void sai_thrift_remove_port_connector(
      const sai_thrift_object_id_t port_connector_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        port_api->remove_port_connector((sai_object_id_t)port_connector_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_port_connector_attribute(
      const sai_thrift_object_id_t port_connector_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_port_connector_attributes(attr_vec, sai_attr);

    status = port_api->set_port_connector_attribute(
        (sai_object_id_t)port_connector_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_port_connector_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t port_connector_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_port_connector_attributes(attr_list_vec, sai_attr_list);

    status = port_api->get_port_connector_attribute(
        (sai_object_id_t)port_connector_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_port_connector_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_qos_map(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t qos_map_oid_out = SAI_NULL_OBJECT_ID;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_qos_map_attributes(attr_list, sai_attr_list);

    status = qos_map_api->create_qos_map(
        &qos_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return qos_map_oid_out;
  }

  void sai_thrift_remove_qos_map(const sai_thrift_object_id_t qos_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = qos_map_api->remove_qos_map((sai_object_id_t)qos_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_qos_map_attribute(
      const sai_thrift_object_id_t qos_map_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_qos_map_attributes(attr_vec, sai_attr);

    status = qos_map_api->set_qos_map_attribute((sai_object_id_t)qos_map_oid,
                                                sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_qos_map_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t qos_map_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_map_api;

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_qos_map_attributes(attr_list_vec, sai_attr_list);

    status = qos_map_api->get_qos_map_attribute(
        (sai_object_id_t)qos_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_qos_map_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_queue(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t queue_oid_out = SAI_NULL_OBJECT_ID;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_queue_attributes(attr_list, sai_attr_list);

    status = queue_api->create_queue(
        &queue_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return queue_oid_out;
  }

  void sai_thrift_remove_queue(const sai_thrift_object_id_t queue_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = queue_api->remove_queue((sai_object_id_t)queue_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_queue_attribute(const sai_thrift_object_id_t queue_oid,
                                      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_queue_attributes(attr_vec, sai_attr);

    status =
        queue_api->set_queue_attribute((sai_object_id_t)queue_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_queue_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t queue_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_queue_attributes(attr_list_vec, sai_attr_list);

    status = queue_api->get_queue_attribute(
        (sai_object_id_t)queue_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_queue_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_queue_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t queue_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = queue_api->get_queue_stats((sai_object_id_t)queue_oid,
                                        number_of_counters,
                                        sai_counter_ids,
                                        sai_counters);

    // sai_adapter always takes all queue stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_queue_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t queue_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = queue_api->get_queue_stats_ext((sai_object_id_t)queue_oid,
                                            number_of_counters,
                                            sai_counter_ids,
                                            (sai_stats_mode_t)mode,
                                            sai_counters);

    // sai_adapter always takes all queue stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_queue_stats(
      const sai_thrift_object_id_t queue_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;

    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = queue_api->clear_queue_stats(
        (sai_object_id_t)queue_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  void sai_thrift_create_route_entry(
      const sai_thrift_route_entry_t &route_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_route_entry_attributes(attr_list, sai_attr_list);

    status = route_api->create_route_entry(
        &sai_route_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_route_entry(
      const sai_thrift_route_entry_t &route_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    status = route_api->remove_route_entry(&sai_route_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_route_entry_attribute(
      const sai_thrift_route_entry_t &route_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_attribute_t *sai_attr;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_route_entry_attributes(attr_vec, sai_attr);

    status = route_api->set_route_entry_attribute(&sai_route_entry, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_route_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_route_entry_t &route_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_entry_t sai_route_entry;
    sai_route_api_t *route_api;

    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_route_entry(route_entry, &sai_route_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_route_entry_attributes(attr_list_vec, sai_attr_list);

    status = route_api->get_route_entry_attribute(
        &sai_route_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_route_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_route_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_route_entry_t> &route_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_route_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_route_entry_t> &route_entry,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_route_entry_attribute(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_route_entry_t> &route_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_route_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const std::vector<sai_thrift_route_entry_t> &route_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const sai_thrift_attribute_list_t &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode,
      const std::vector<sai_thrift_status_t> &object_statuses) {
    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_router_interface(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t router_interface_oid_out = SAI_NULL_OBJECT_ID;
    sai_router_interface_api_t *router_interface_api;

    status =
        sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_router_interface_attributes(attr_list, sai_attr_list);

    status = router_interface_api->create_router_interface(
        &router_interface_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return router_interface_oid_out;
  }

  void sai_thrift_remove_router_interface(
      const sai_thrift_object_id_t router_interface_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status =
        sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = router_interface_api->remove_router_interface(
        (sai_object_id_t)router_interface_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_router_interface_attribute(
      const sai_thrift_object_id_t router_interface_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_router_interface_api_t *router_interface_api;

    status =
        sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_router_interface_attributes(attr_vec, sai_attr);

    status = router_interface_api->set_router_interface_attribute(
        (sai_object_id_t)router_interface_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_router_interface_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t router_interface_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status =
        sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_router_interface_attributes(attr_list_vec, sai_attr_list);

    status = router_interface_api->get_router_interface_attribute(
        (sai_object_id_t)router_interface_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_router_interface_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_router_interface_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t router_interface_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status =
        sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = router_interface_api->get_router_interface_stats(
        (sai_object_id_t)router_interface_oid,
        number_of_counters,
        sai_counter_ids,
        sai_counters);

    // sai_adapter always takes all router_interface stats. Since some of them
    // may be not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_router_interface_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t router_interface_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status =
        sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = router_interface_api->get_router_interface_stats_ext(
        (sai_object_id_t)router_interface_oid,
        number_of_counters,
        sai_counter_ids,
        (sai_stats_mode_t)mode,
        sai_counters);

    // sai_adapter always takes all router_interface stats. Since some of them
    // may be not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_router_interface_stats(
      const sai_thrift_object_id_t router_interface_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *router_interface_api;

    status =
        sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&router_interface_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = router_interface_api->clear_router_interface_stats(
        (sai_object_id_t)router_interface_oid,
        number_of_counters,
        sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_rpf_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t rpf_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_rpf_group_attributes(attr_list, sai_attr_list);

    status = rpf_group_api->create_rpf_group(
        &rpf_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return rpf_group_oid_out;
  }

  void sai_thrift_remove_rpf_group(const sai_thrift_object_id_t rpf_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = rpf_group_api->remove_rpf_group((sai_object_id_t)rpf_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_rpf_group_attribute(
      const sai_thrift_object_id_t rpf_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_rpf_group_attributes(attr_vec, sai_attr);

    status = rpf_group_api->set_rpf_group_attribute(
        (sai_object_id_t)rpf_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_rpf_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t rpf_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_rpf_group_attributes(attr_list_vec, sai_attr_list);

    status = rpf_group_api->get_rpf_group_attribute(
        (sai_object_id_t)rpf_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_rpf_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_rpf_group_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t rpf_group_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_rpf_group_member_attributes(attr_list, sai_attr_list);

    status = rpf_group_api->create_rpf_group_member(
        &rpf_group_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return rpf_group_member_oid_out;
  }

  void sai_thrift_remove_rpf_group_member(
      const sai_thrift_object_id_t rpf_group_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = rpf_group_api->remove_rpf_group_member(
        (sai_object_id_t)rpf_group_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_rpf_group_member_attribute(
      const sai_thrift_object_id_t rpf_group_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_rpf_group_member_attributes(attr_vec, sai_attr);

    status = rpf_group_api->set_rpf_group_member_attribute(
        (sai_object_id_t)rpf_group_member_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_rpf_group_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t rpf_group_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_rpf_group_api_t *rpf_group_api;

    status = sai_api_query(SAI_API_RPF_GROUP, (void **)&rpf_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_rpf_group_member_attributes(attr_list_vec, sai_attr_list);

    status = rpf_group_api->get_rpf_group_member_attribute(
        (sai_object_id_t)rpf_group_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_rpf_group_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_samplepacket(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t samplepacket_oid_out = SAI_NULL_OBJECT_ID;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_samplepacket_attributes(attr_list, sai_attr_list);

    status = samplepacket_api->create_samplepacket(
        &samplepacket_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return samplepacket_oid_out;
  }

  void sai_thrift_remove_samplepacket(
      const sai_thrift_object_id_t samplepacket_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = samplepacket_api->remove_samplepacket(
        (sai_object_id_t)samplepacket_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_samplepacket_attribute(
      const sai_thrift_object_id_t samplepacket_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_samplepacket_attributes(attr_vec, sai_attr);

    status = samplepacket_api->set_samplepacket_attribute(
        (sai_object_id_t)samplepacket_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_samplepacket_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t samplepacket_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_samplepacket_api_t *samplepacket_api;

    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_samplepacket_attributes(attr_list_vec, sai_attr_list);

    status = samplepacket_api->get_samplepacket_attribute(
        (sai_object_id_t)samplepacket_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_samplepacket_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t scheduler_oid_out = SAI_NULL_OBJECT_ID;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_scheduler_attributes(attr_list, sai_attr_list);

    status = scheduler_api->create_scheduler(
        &scheduler_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return scheduler_oid_out;
  }

  void sai_thrift_remove_scheduler(const sai_thrift_object_id_t scheduler_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = scheduler_api->remove_scheduler((sai_object_id_t)scheduler_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_scheduler_attribute(
      const sai_thrift_object_id_t scheduler_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_scheduler_attributes(attr_vec, sai_attr);

    status = scheduler_api->set_scheduler_attribute(
        (sai_object_id_t)scheduler_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_scheduler_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t scheduler_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;

    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_scheduler_attributes(attr_list_vec, sai_attr_list);

    status = scheduler_api->get_scheduler_attribute(
        (sai_object_id_t)scheduler_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_scheduler_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t scheduler_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_scheduler_group_api_t *scheduler_group_api;

    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_scheduler_group_attributes(attr_list, sai_attr_list);

    status = scheduler_group_api->create_scheduler_group(
        &scheduler_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return scheduler_group_oid_out;
  }

  void sai_thrift_remove_scheduler_group(
      const sai_thrift_object_id_t scheduler_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;

    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = scheduler_group_api->remove_scheduler_group(
        (sai_object_id_t)scheduler_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_scheduler_group_attribute(
      const sai_thrift_object_id_t scheduler_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_scheduler_group_api_t *scheduler_group_api;

    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_scheduler_group_attributes(attr_vec, sai_attr);

    status = scheduler_group_api->set_scheduler_group_attribute(
        (sai_object_id_t)scheduler_group_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_scheduler_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t scheduler_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;

    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_scheduler_group_attributes(attr_list_vec, sai_attr_list);

    status = scheduler_group_api->get_scheduler_group_attribute(
        (sai_object_id_t)scheduler_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_scheduler_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_srv6_sidlist(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t srv6_sidlist_oid_out = SAI_NULL_OBJECT_ID;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_srv6_sidlist_attributes(attr_list, sai_attr_list);

    status = srv6_api->create_srv6_sidlist(
        &srv6_sidlist_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return srv6_sidlist_oid_out;
  }

  void sai_thrift_remove_srv6_sidlist(
      const sai_thrift_object_id_t srv6_sidlist_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = srv6_api->remove_srv6_sidlist((sai_object_id_t)srv6_sidlist_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_srv6_sidlist_attribute(
      const sai_thrift_object_id_t srv6_sidlist_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_srv6_sidlist_attributes(attr_vec, sai_attr);

    status = srv6_api->set_srv6_sidlist_attribute(
        (sai_object_id_t)srv6_sidlist_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_srv6_sidlist_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t srv6_sidlist_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_srv6_sidlist_attributes(attr_list_vec, sai_attr_list);

    status = srv6_api->get_srv6_sidlist_attribute(
        (sai_object_id_t)srv6_sidlist_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_srv6_sidlist_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_create_my_sid_entry(
      const sai_thrift_my_sid_entry_t &my_sid_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_my_sid_entry_attributes(attr_list, sai_attr_list);

    status = srv6_api->create_my_sid_entry(
        &sai_my_sid_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return;
  }

  void sai_thrift_remove_my_sid_entry(
      const sai_thrift_my_sid_entry_t &my_sid_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    status = srv6_api->remove_my_sid_entry(&sai_my_sid_entry);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_my_sid_entry_attribute(
      const sai_thrift_my_sid_entry_t &my_sid_entry,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;
    sai_attribute_t *sai_attr;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_my_sid_entry_attributes(attr_vec, sai_attr);

    status = srv6_api->set_my_sid_entry_attribute(&sai_my_sid_entry, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_my_sid_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_my_sid_entry_t &my_sid_entry,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_my_sid_entry_t sai_my_sid_entry;
    sai_srv6_api_t *srv6_api;

    status = sai_api_query(SAI_API_SRV6, (void **)&srv6_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_parse_my_sid_entry(my_sid_entry, &sai_my_sid_entry);

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_my_sid_entry_attributes(attr_list_vec, sai_attr_list);

    status = srv6_api->get_my_sid_entry_attribute(
        &sai_my_sid_entry, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_my_sid_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_bulk_create_my_sid_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_my_sid_entry_t> &my_sid_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_remove_my_sid_entry(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_my_sid_entry_t> &my_sid_entry,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_set_my_sid_entry_attribute(
      std::vector<sai_thrift_status_t> &object_statuses_out,
      const std::vector<sai_thrift_my_sid_entry_t> &my_sid_entry,
      const std::vector<sai_thrift_attribute_t> &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_bulk_get_my_sid_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const std::vector<sai_thrift_my_sid_entry_t> &my_sid_entry,
      const std::vector<sai_thrift_uint32_t> &attr_count,
      const sai_thrift_attribute_list_t &attr_list,
      const sai_thrift_bulk_op_error_mode_t mode,
      const std::vector<sai_thrift_status_t> &object_statuses) {
    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_stp(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t stp_oid_out = SAI_NULL_OBJECT_ID;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_stp_attributes(attr_list, sai_attr_list);

    status =
        stp_api->create_stp(&stp_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return stp_oid_out;
  }

  void sai_thrift_remove_stp(const sai_thrift_object_id_t stp_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = stp_api->remove_stp((sai_object_id_t)stp_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_stp_attribute(const sai_thrift_object_id_t stp_oid,
                                    const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_stp_attributes(attr_vec, sai_attr);

    status = stp_api->set_stp_attribute((sai_object_id_t)stp_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_stp_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t stp_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_stp_attributes(attr_list_vec, sai_attr_list);

    status = stp_api->get_stp_attribute(
        (sai_object_id_t)stp_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_stp_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_stp_port(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t stp_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_stp_port_attributes(attr_list, sai_attr_list);

    status = stp_api->create_stp_port(
        &stp_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return stp_port_oid_out;
  }

  void sai_thrift_remove_stp_port(const sai_thrift_object_id_t stp_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = stp_api->remove_stp_port((sai_object_id_t)stp_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_stp_port_attribute(
      const sai_thrift_object_id_t stp_port_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_stp_port_attributes(attr_vec, sai_attr);

    status = stp_api->set_stp_port_attribute((sai_object_id_t)stp_port_oid,
                                             sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_stp_port_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t stp_port_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;

    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_stp_port_attributes(attr_list_vec, sai_attr_list);

    status = stp_api->get_stp_port_attribute(
        (sai_object_id_t)stp_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_stp_port_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_switch_register_read(
      std::vector<sai_thrift_uint32_t> &reg_val_out,
      const sai_thrift_uint64_t platform_context,
      const sai_thrift_uint32_t device_addr,
      const sai_thrift_uint32_t start_reg_addr) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_register_write(
      const sai_thrift_uint64_t platform_context,
      const sai_thrift_uint32_t device_addr,
      const sai_thrift_uint32_t start_reg_addr,
      const std::vector<sai_thrift_uint32_t> &reg_val) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_read(
      std::vector<sai_thrift_uint32_t> &reg_val_out,
      const sai_thrift_uint32_t device_addr,
      const sai_thrift_uint32_t start_reg_addr) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_write(
      const sai_thrift_uint32_t device_addr,
      const sai_thrift_uint32_t start_reg_addr,
      const std::vector<sai_thrift_uint32_t> &reg_val) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_cl22_read(
      std::vector<sai_thrift_uint32_t> &reg_val_out,
      const sai_thrift_uint32_t device_addr,
      const sai_thrift_uint32_t start_reg_addr) {
    // This function is UNSUPPORTED
    return;
  }

  void sai_thrift_switch_mdio_cl22_write(
      const sai_thrift_uint32_t device_addr,
      const sai_thrift_uint32_t start_reg_addr,
      const std::vector<sai_thrift_uint32_t> &reg_val) {
    // This function is UNSUPPORTED
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_switch(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t switch_id_out = SAI_NULL_OBJECT_ID;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_switch_attributes(attr_list, sai_attr_list);

    status =
        switch_api->create_switch(&switch_id_out, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    // switch_id is stored in the global variable
    switch_id = switch_id_out;
    return switch_id_out;
  }

  void sai_thrift_remove_switch() {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = switch_api->remove_switch(switch_id);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_switch_attribute(const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_switch_attributes(attr_vec, sai_attr);

    status = switch_api->set_switch_attribute(switch_id, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_switch_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_switch_attributes(attr_list_vec, sai_attr_list);

    status =
        switch_api->get_switch_attribute(switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_switch_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_switch_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = switch_api->get_switch_stats(
        switch_id, number_of_counters, sai_counter_ids, sai_counters);

    // sai_adapter always takes all switch stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_switch_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = switch_api->get_switch_stats_ext(switch_id,
                                              number_of_counters,
                                              sai_counter_ids,
                                              (sai_stats_mode_t)mode,
                                              sai_counters);

    // sai_adapter always takes all switch stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_switch_stats(
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = switch_api->clear_switch_stats(
        switch_id, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_switch_tunnel(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t switch_tunnel_oid_out = SAI_NULL_OBJECT_ID;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_switch_tunnel_attributes(attr_list, sai_attr_list);

    status = switch_api->create_switch_tunnel(
        &switch_tunnel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return switch_tunnel_oid_out;
  }

  void sai_thrift_remove_switch_tunnel(
      const sai_thrift_object_id_t switch_tunnel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        switch_api->remove_switch_tunnel((sai_object_id_t)switch_tunnel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_switch_tunnel_attribute(
      const sai_thrift_object_id_t switch_tunnel_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_switch_tunnel_attributes(attr_vec, sai_attr);

    status = switch_api->set_switch_tunnel_attribute(
        (sai_object_id_t)switch_tunnel_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_switch_tunnel_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t switch_tunnel_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_switch_tunnel_attributes(attr_list_vec, sai_attr_list);

    status = switch_api->get_switch_tunnel_attribute(
        (sai_object_id_t)switch_tunnel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_switch_tunnel_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_system_port(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t system_port_oid_out = SAI_NULL_OBJECT_ID;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_system_port_attributes(attr_list, sai_attr_list);

    status = system_port_api->create_system_port(
        &system_port_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return system_port_oid_out;
  }

  void sai_thrift_remove_system_port(
      const sai_thrift_object_id_t system_port_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        system_port_api->remove_system_port((sai_object_id_t)system_port_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_system_port_attribute(
      const sai_thrift_object_id_t system_port_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_system_port_attributes(attr_vec, sai_attr);

    status = system_port_api->set_system_port_attribute(
        (sai_object_id_t)system_port_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_system_port_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t system_port_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_system_port_api_t *system_port_api;

    status = sai_api_query(SAI_API_SYSTEM_PORT, (void **)&system_port_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_system_port_attributes(attr_list_vec, sai_attr_list);

    status = system_port_api->get_system_port_attribute(
        (sai_object_id_t)system_port_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_system_port_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_attributes(attr_list, sai_attr_list);

    status =
        tam_api->create_tam(&tam_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_oid_out;
  }

  void sai_thrift_remove_tam(const sai_thrift_object_id_t tam_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam((sai_object_id_t)tam_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tam_attribute(const sai_thrift_object_id_t tam_oid,
                                    const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_attribute((sai_object_id_t)tam_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_tam_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_attribute(
        (sai_object_id_t)tam_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_math_func(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_math_func_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_math_func_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_math_func(
        &tam_math_func_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_math_func_oid_out;
  }

  void sai_thrift_remove_tam_math_func(
      const sai_thrift_object_id_t tam_math_func_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_math_func((sai_object_id_t)tam_math_func_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_math_func_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_math_func_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_math_func_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_math_func_attribute(
        (sai_object_id_t)tam_math_func_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_math_func_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_math_func_attribute(
      const sai_thrift_object_id_t tam_math_func_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_math_func_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_math_func_attribute(
        (sai_object_id_t)tam_math_func_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event_threshold(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_threshold_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_threshold_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_event_threshold(
        &tam_event_threshold_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_event_threshold_oid_out;
  }

  void sai_thrift_remove_tam_event_threshold(
      const sai_thrift_object_id_t tam_event_threshold_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_event_threshold(
        (sai_object_id_t)tam_event_threshold_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_threshold_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_event_threshold_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_event_threshold_attributes(attr_list_vec,
                                                    sai_attr_list);

    status = tam_api->get_tam_event_threshold_attribute(
        (sai_object_id_t)tam_event_threshold_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_threshold_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_threshold_attribute(
      const sai_thrift_object_id_t tam_event_threshold_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_event_threshold_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_event_threshold_attribute(
        (sai_object_id_t)tam_event_threshold_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_int(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_int_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_int_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_int(
        &tam_int_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_int_oid_out;
  }

  void sai_thrift_remove_tam_int(const sai_thrift_object_id_t tam_int_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_int((sai_object_id_t)tam_int_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_int_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_int_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_int_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_int_attribute(
        (sai_object_id_t)tam_int_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_int_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_int_attribute(
      const sai_thrift_object_id_t tam_int_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_int_attributes(attr_vec, sai_attr);

    status =
        tam_api->set_tam_int_attribute((sai_object_id_t)tam_int_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_tel_type(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_tel_type_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_tel_type_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_tel_type(
        &tam_tel_type_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_tel_type_oid_out;
  }

  void sai_thrift_remove_tam_tel_type(
      const sai_thrift_object_id_t tam_tel_type_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_tel_type((sai_object_id_t)tam_tel_type_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_tel_type_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_tel_type_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_tel_type_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_tel_type_attribute(
        (sai_object_id_t)tam_tel_type_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_tel_type_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_tel_type_attribute(
      const sai_thrift_object_id_t tam_tel_type_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_tel_type_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_tel_type_attribute(
        (sai_object_id_t)tam_tel_type_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_report(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_report_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_report_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_report(
        &tam_report_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_report_oid_out;
  }

  void sai_thrift_remove_tam_report(
      const sai_thrift_object_id_t tam_report_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_report((sai_object_id_t)tam_report_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_report_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_report_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_report_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_report_attribute(
        (sai_object_id_t)tam_report_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_report_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_report_attribute(
      const sai_thrift_object_id_t tam_report_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_report_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_report_attribute((sai_object_id_t)tam_report_oid,
                                               sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_telemetry(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_telemetry_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_telemetry_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_telemetry(
        &tam_telemetry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_telemetry_oid_out;
  }

  void sai_thrift_remove_tam_telemetry(
      const sai_thrift_object_id_t tam_telemetry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_telemetry((sai_object_id_t)tam_telemetry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_telemetry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_telemetry_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_telemetry_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_telemetry_attribute(
        (sai_object_id_t)tam_telemetry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_telemetry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_telemetry_attribute(
      const sai_thrift_object_id_t tam_telemetry_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_telemetry_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_telemetry_attribute(
        (sai_object_id_t)tam_telemetry_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_transport(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_transport_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_transport_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_transport(
        &tam_transport_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_transport_oid_out;
  }

  void sai_thrift_remove_tam_transport(
      const sai_thrift_object_id_t tam_transport_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_transport((sai_object_id_t)tam_transport_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_transport_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_transport_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_transport_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_transport_attribute(
        (sai_object_id_t)tam_transport_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_transport_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_transport_attribute(
      const sai_thrift_object_id_t tam_transport_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_transport_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_transport_attribute(
        (sai_object_id_t)tam_transport_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_collector(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_collector_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_collector_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_collector(
        &tam_collector_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_collector_oid_out;
  }

  void sai_thrift_remove_tam_collector(
      const sai_thrift_object_id_t tam_collector_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_collector((sai_object_id_t)tam_collector_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_collector_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_collector_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_collector_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_collector_attribute(
        (sai_object_id_t)tam_collector_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_collector_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_collector_attribute(
      const sai_thrift_object_id_t tam_collector_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_collector_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_collector_attribute(
        (sai_object_id_t)tam_collector_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event_action(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_action_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_action_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_event_action(
        &tam_event_action_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_event_action_oid_out;
  }

  void sai_thrift_remove_tam_event_action(
      const sai_thrift_object_id_t tam_event_action_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status =
        tam_api->remove_tam_event_action((sai_object_id_t)tam_event_action_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_action_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_event_action_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_event_action_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_event_action_attribute(
        (sai_object_id_t)tam_event_action_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_action_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_action_attribute(
      const sai_thrift_object_id_t tam_event_action_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_event_action_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_event_action_attribute(
        (sai_object_id_t)tam_event_action_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tam_event(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tam_event_oid_out = SAI_NULL_OBJECT_ID;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tam_event_attributes(attr_list, sai_attr_list);

    status = tam_api->create_tam_event(
        &tam_event_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tam_event_oid_out;
  }

  void sai_thrift_remove_tam_event(const sai_thrift_object_id_t tam_event_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tam_api->remove_tam_event((sai_object_id_t)tam_event_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_get_tam_event_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tam_event_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tam_event_attributes(attr_list_vec, sai_attr_list);

    status = tam_api->get_tam_event_attribute(
        (sai_object_id_t)tam_event_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tam_event_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_set_tam_event_attribute(
      const sai_thrift_object_id_t tam_event_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tam_api_t *tam_api;

    status = sai_api_query(SAI_API_TAM, (void **)&tam_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tam_event_attributes(attr_vec, sai_attr);

    status = tam_api->set_tam_event_attribute((sai_object_id_t)tam_event_oid,
                                              sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_map_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_map_attributes(attr_list, sai_attr_list);

    status = tunnel_api->create_tunnel_map(
        &tunnel_map_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tunnel_map_oid_out;
  }

  void sai_thrift_remove_tunnel_map(
      const sai_thrift_object_id_t tunnel_map_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel_map((sai_object_id_t)tunnel_map_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_map_attribute(
      const sai_thrift_object_id_t tunnel_map_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tunnel_map_attributes(attr_vec, sai_attr);

    status = tunnel_api->set_tunnel_map_attribute(
        (sai_object_id_t)tunnel_map_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_tunnel_map_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tunnel_map_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tunnel_map_attributes(attr_list_vec, sai_attr_list);

    status = tunnel_api->get_tunnel_map_attribute(
        (sai_object_id_t)tunnel_map_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_map_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_attributes(attr_list, sai_attr_list);

    status = tunnel_api->create_tunnel(
        &tunnel_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tunnel_oid_out;
  }

  void sai_thrift_remove_tunnel(const sai_thrift_object_id_t tunnel_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel((sai_object_id_t)tunnel_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_attribute(const sai_thrift_object_id_t tunnel_oid,
                                       const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tunnel_attributes(attr_vec, sai_attr);

    status =
        tunnel_api->set_tunnel_attribute((sai_object_id_t)tunnel_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_tunnel_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tunnel_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tunnel_attributes(attr_list_vec, sai_attr_list);

    status = tunnel_api->get_tunnel_attribute(
        (sai_object_id_t)tunnel_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_tunnel_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t tunnel_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = tunnel_api->get_tunnel_stats((sai_object_id_t)tunnel_oid,
                                          number_of_counters,
                                          sai_counter_ids,
                                          sai_counters);

    // sai_adapter always takes all tunnel stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_tunnel_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t tunnel_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = tunnel_api->get_tunnel_stats_ext((sai_object_id_t)tunnel_oid,
                                              number_of_counters,
                                              sai_counter_ids,
                                              (sai_stats_mode_t)mode,
                                              sai_counters);

    // sai_adapter always takes all tunnel stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_tunnel_stats(
      const sai_thrift_object_id_t tunnel_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = tunnel_api->clear_tunnel_stats(
        (sai_object_id_t)tunnel_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_term_table_entry(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_term_table_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_list,
                                                        sai_attr_list);

    status = tunnel_api->create_tunnel_term_table_entry(
        &tunnel_term_table_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tunnel_term_table_entry_oid_out;
  }

  void sai_thrift_remove_tunnel_term_table_entry(
      const sai_thrift_object_id_t tunnel_term_table_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel_term_table_entry(
        (sai_object_id_t)tunnel_term_table_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_term_table_entry_attribute(
      const sai_thrift_object_id_t tunnel_term_table_entry_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_vec, sai_attr);

    status = tunnel_api->set_tunnel_term_table_entry_attribute(
        (sai_object_id_t)tunnel_term_table_entry_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_tunnel_term_table_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tunnel_term_table_entry_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tunnel_term_table_entry_attributes(attr_list_vec,
                                                        sai_attr_list);

    status = tunnel_api->get_tunnel_term_table_entry_attribute(
        (sai_object_id_t)tunnel_term_table_entry_oid,
        attr_count,
        sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_term_table_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map_entry(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t tunnel_map_entry_oid_out = SAI_NULL_OBJECT_ID;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_tunnel_map_entry_attributes(attr_list, sai_attr_list);

    status = tunnel_api->create_tunnel_map_entry(
        &tunnel_map_entry_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return tunnel_map_entry_oid_out;
  }

  void sai_thrift_remove_tunnel_map_entry(
      const sai_thrift_object_id_t tunnel_map_entry_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = tunnel_api->remove_tunnel_map_entry(
        (sai_object_id_t)tunnel_map_entry_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_tunnel_map_entry_attribute(
      const sai_thrift_object_id_t tunnel_map_entry_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_tunnel_map_entry_attributes(attr_vec, sai_attr);

    status = tunnel_api->set_tunnel_map_entry_attribute(
        (sai_object_id_t)tunnel_map_entry_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_tunnel_map_entry_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t tunnel_map_entry_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api;

    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_tunnel_map_entry_attributes(attr_list_vec, sai_attr_list);

    status = tunnel_api->get_tunnel_map_entry_attribute(
        (sai_object_id_t)tunnel_map_entry_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_tunnel_map_entry_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_oid_out = SAI_NULL_OBJECT_ID;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_attributes(attr_list, sai_attr_list);

    status =
        udf_api->create_udf(&udf_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return udf_oid_out;
  }

  void sai_thrift_remove_udf(const sai_thrift_object_id_t udf_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = udf_api->remove_udf((sai_object_id_t)udf_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_attribute(const sai_thrift_object_id_t udf_oid,
                                    const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_udf_attributes(attr_vec, sai_attr);

    status = udf_api->set_udf_attribute((sai_object_id_t)udf_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_udf_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t udf_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_udf_attributes(attr_list_vec, sai_attr_list);

    status = udf_api->get_udf_attribute(
        (sai_object_id_t)udf_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf_match(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_match_oid_out = SAI_NULL_OBJECT_ID;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_match_attributes(attr_list, sai_attr_list);

    status = udf_api->create_udf_match(
        &udf_match_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return udf_match_oid_out;
  }

  void sai_thrift_remove_udf_match(const sai_thrift_object_id_t udf_match_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = udf_api->remove_udf_match((sai_object_id_t)udf_match_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_match_attribute(
      const sai_thrift_object_id_t udf_match_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_udf_match_attributes(attr_vec, sai_attr);

    status = udf_api->set_udf_match_attribute((sai_object_id_t)udf_match_oid,
                                              sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_udf_match_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t udf_match_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_udf_match_attributes(attr_list_vec, sai_attr_list);

    status = udf_api->get_udf_match_attribute(
        (sai_object_id_t)udf_match_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_match_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_udf_group(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t udf_group_oid_out = SAI_NULL_OBJECT_ID;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_udf_group_attributes(attr_list, sai_attr_list);

    status = udf_api->create_udf_group(
        &udf_group_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return udf_group_oid_out;
  }

  void sai_thrift_remove_udf_group(const sai_thrift_object_id_t udf_group_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = udf_api->remove_udf_group((sai_object_id_t)udf_group_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_udf_group_attribute(
      const sai_thrift_object_id_t udf_group_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_udf_group_attributes(attr_vec, sai_attr);

    status = udf_api->set_udf_group_attribute((sai_object_id_t)udf_group_oid,
                                              sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_udf_group_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t udf_group_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_udf_api_t *udf_api;

    status = sai_api_query(SAI_API_UDF, (void **)&udf_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_udf_group_attributes(attr_list_vec, sai_attr_list);

    status = udf_api->get_udf_group_attribute(
        (sai_object_id_t)udf_group_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_udf_group_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_virtual_router(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t virtual_router_oid_out = SAI_NULL_OBJECT_ID;
    sai_virtual_router_api_t *virtual_router_api;

    status =
        sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_virtual_router_attributes(attr_list, sai_attr_list);

    status = virtual_router_api->create_virtual_router(
        &virtual_router_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return virtual_router_oid_out;
  }

  void sai_thrift_remove_virtual_router(
      const sai_thrift_object_id_t virtual_router_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *virtual_router_api;

    status =
        sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = virtual_router_api->remove_virtual_router(
        (sai_object_id_t)virtual_router_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_virtual_router_attribute(
      const sai_thrift_object_id_t virtual_router_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_virtual_router_api_t *virtual_router_api;

    status =
        sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_virtual_router_attributes(attr_vec, sai_attr);

    status = virtual_router_api->set_virtual_router_attribute(
        (sai_object_id_t)virtual_router_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_virtual_router_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t virtual_router_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *virtual_router_api;

    status =
        sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&virtual_router_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_virtual_router_attributes(attr_list_vec, sai_attr_list);

    status = virtual_router_api->get_virtual_router_attribute(
        (sai_object_id_t)virtual_router_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_virtual_router_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t vlan_oid_out = SAI_NULL_OBJECT_ID;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_vlan_attributes(attr_list, sai_attr_list);

    status = vlan_api->create_vlan(
        &vlan_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return vlan_oid_out;
  }

  void sai_thrift_remove_vlan(const sai_thrift_object_id_t vlan_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = vlan_api->remove_vlan((sai_object_id_t)vlan_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vlan_attribute(const sai_thrift_object_id_t vlan_oid,
                                     const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_vlan_attributes(attr_vec, sai_attr);

    status = vlan_api->set_vlan_attribute((sai_object_id_t)vlan_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_vlan_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t vlan_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_vlan_attributes(attr_list_vec, sai_attr_list);

    status = vlan_api->get_vlan_attribute(
        (sai_object_id_t)vlan_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_vlan_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_vlan_member(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t vlan_member_oid_out = SAI_NULL_OBJECT_ID;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_vlan_member_attributes(attr_list, sai_attr_list);

    status = vlan_api->create_vlan_member(
        &vlan_member_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return vlan_member_oid_out;
  }

  void sai_thrift_remove_vlan_member(
      const sai_thrift_object_id_t vlan_member_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = vlan_api->remove_vlan_member((sai_object_id_t)vlan_member_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_vlan_member_attribute(
      const sai_thrift_object_id_t vlan_member_oid,
      const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_vlan_member_attributes(attr_vec, sai_attr);

    status = vlan_api->set_vlan_member_attribute(
        (sai_object_id_t)vlan_member_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_vlan_member_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t vlan_member_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_vlan_member_attributes(attr_list_vec, sai_attr_list);

    status = vlan_api->get_vlan_member_attribute(
        (sai_object_id_t)vlan_member_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_vlan_member_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_get_vlan_stats(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t vlan_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = vlan_api->get_vlan_stats((sai_object_id_t)vlan_oid,
                                      number_of_counters,
                                      sai_counter_ids,
                                      sai_counters);

    // sai_adapter always takes all vlan stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_get_vlan_stats_ext(
      std::vector<sai_thrift_uint64_t> &counters_out,
      const sai_thrift_object_id_t vlan_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids,
      const sai_thrift_stats_mode_t mode) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *sai_counters = NULL;
    if (number_of_counters != 0) {
      sai_counters = (uint64_t *)malloc(sizeof(uint64_t) * number_of_counters);
    }

    status = vlan_api->get_vlan_stats_ext((sai_object_id_t)vlan_oid,
                                          number_of_counters,
                                          sai_counter_ids,
                                          (sai_stats_mode_t)mode,
                                          sai_counters);

    // sai_adapter always takes all vlan stats. Since some of them may be
    // not supported, SAI_STATUS_INVALID_PARAMETER should not be raised.
    if (status != SAI_STATUS_SUCCESS &&
        status != SAI_STATUS_INVALID_PARAMETER) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    for (uint32_t i = 0; i < (uint32_t)number_of_counters; i++) {
      counters_out.push_back((sai_thrift_uint64_t)sai_counters[i]);
    }
    free(sai_counters);
    return;
  }

  void sai_thrift_clear_vlan_stats(
      const sai_thrift_object_id_t vlan_oid,
      const std::vector<sai_thrift_stat_id_t> &counter_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_stat_id_t *sai_counter_ids = NULL;
    uint32_t number_of_counters = counter_ids.size();

    if (number_of_counters != 0) {
      sai_counter_ids =
          (sai_stat_id_t *)malloc(sizeof(sai_stat_id_t) * number_of_counters);
    } else {
      return;
    }

    std::vector<sai_thrift_stat_id_t>::const_iterator it = counter_ids.begin();
    for (uint32_t i = 0; i < counter_ids.size(); i++, it++) {
      sai_counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = vlan_api->clear_vlan_stats(
        (sai_object_id_t)vlan_oid, number_of_counters, sai_counter_ids);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_counter_ids);
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_wred(
      const std::vector<sai_thrift_attribute_t> &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t wred_oid_out = SAI_NULL_OBJECT_ID;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    }
    sai_thrift_parse_wred_attributes(attr_list, sai_attr_list);

    status = wred_api->create_wred(
        &wred_oid_out, switch_id, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr_list);
    return wred_oid_out;
  }

  void sai_thrift_remove_wred(const sai_thrift_object_id_t wred_oid) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    status = wred_api->remove_wred((sai_object_id_t)wred_oid);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    return;
  }

  void sai_thrift_set_wred_attribute(const sai_thrift_object_id_t wred_oid,
                                     const sai_thrift_attribute_t &attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t *sai_attr;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    std::vector<sai_thrift_attribute_t> attr_vec;
    attr_vec.push_back(attr);
    sai_attr = (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * 1);

    sai_thrift_parse_wred_attributes(attr_vec, sai_attr);

    status = wred_api->set_wred_attribute((sai_object_id_t)wred_oid, sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    free(sai_attr);

    return;
  }

  void sai_thrift_get_wred_attribute(
      sai_thrift_attribute_list_t &attr_list_out,
      const sai_thrift_object_id_t wred_oid,
      const sai_thrift_attribute_list_t &attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_wred_api_t *wred_api;

    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_attribute_t *sai_attr_list = NULL;
    uint32_t attr_count = attr_list.attr_list.size();

    if (attr_count != 0) {
      sai_attr_list =
          (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    } else {
      return;
    }

    const std::vector<sai_thrift_attribute_t> &attr_list_vec =
        attr_list.attr_list;

    sai_thrift_parse_wred_attributes(attr_list_vec, sai_attr_list);

    status = wred_api->get_wred_attribute(
        (sai_object_id_t)wred_oid, attr_count, sai_attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      sai_thrift_exception e;
      e.status = status;
      throw e;
    }

    sai_thrift_deparse_wred_attributes(
        sai_attr_list, attr_count, attr_list_out.attr_list);
    free(sai_attr_list);
    return;
  }

  void sai_thrift_query_attribute_enum_values_capability(
      std::vector<int32_t> &_out,
      const sai_thrift_object_type_t object_type,
      const sai_thrift_attr_id_t attr_id,
      const int32_t caps_count) {
    // This function should be manually implemented elsewhere
    return;
  }

  int64_t sai_thrift_object_type_get_availability(
      const sai_thrift_object_type_t object_type,
      const sai_thrift_attr_id_t attr_id,
      const int32_t attr_type) {
    // This function should be manually implemented elsewhere
    return 0ULL;
  }
};
