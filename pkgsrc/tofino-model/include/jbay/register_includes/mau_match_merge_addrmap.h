/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_MAU_MATCH_MERGE_ADDRMAP_H__
#define __REGISTER_INCLUDES_MAU_MATCH_MERGE_ADDRMAP_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>









#include "action_adr_vpn_mod_enable.h"
#include "actiondata_error_ctl.h"
#include "emm_ecc_error_ctl.h"
#include "err_idata_ovr_ctl.h"
#include "err_idata_ovr_fifo_ctl.h"
#include "exact_match_delay_thread.h"
#include "exact_match_logical_result_delay.h"
#include "exact_match_logical_result_en.h"
#include "exact_match_phys_result_delay.h"
#include "exact_match_phys_result_en.h"
#include "exact_match_phys_result_thread.h"
#include "exit_gateway_ctl.h"
#include "gateway_en.h"
#include "gateway_inhibit_lut.h"
#include "gateway_next_table_lut.h"
#include "gateway_payload_data.h"
#include "gateway_payload_exact_disable.h"
#include "gateway_payload_exact_pbus.h"
#include "gateway_payload_exact_shift_ovr.h"
#include "gateway_payload_match_adr.h"
#include "gateway_payload_tind_disable.h"
#include "gateway_payload_tind_pbus.h"
#include "gateway_to_logicaltable_xbar_ctl.h"
#include "gateway_to_pbus_xbar_ctl.h"
#include "gfm_parity_error_ctl.h"
#include "imem_parity_error_ctl.h"
#include "logical_table_thread.h"
#include "match_to_logical_table_ixbar_outputmap.h"
#include "mau_action_instruction_adr_default.h"
#include "mau_action_instruction_adr_exact_shiftcount.h"
#include "mau_action_instruction_adr_map_data.h"
#include "mau_action_instruction_adr_map_en.h"
#include "mau_action_instruction_adr_mask.h"
#include "mau_action_instruction_adr_miss_value.h"
#include "mau_action_instruction_adr_mode.h"
#include "mau_action_instruction_adr_per_entry_en_mux_ctl.h"
#include "mau_action_instruction_adr_tcam_actionbit_map_en.h"
#include "mau_action_instruction_adr_tcam_shiftcount.h"
#include "mau_actiondata_adr_default.h"
#include "mau_actiondata_adr_exact_shiftcount.h"
#include "mau_actiondata_adr_mask.h"
#include "mau_actiondata_adr_miss_value.h"
#include "mau_actiondata_adr_per_entry_en_mux_ctl.h"
#include "mau_actiondata_adr_tcam_actionbit_map_data.h"
#include "mau_actiondata_adr_tcam_actionbit_map_en.h"
#include "mau_actiondata_adr_tcam_shiftcount.h"
#include "mau_actiondata_adr_vpn_shiftcount.h"
#include "mau_hash_group_config.h"
#include "mau_hash_group_expand.h"
#include "mau_hash_group_mask.h"
#include "mau_hash_group_shiftcount.h"
#include "mau_hash_group_xbar_ctl.h"
#include "mau_idletime_adr_default.h"
#include "mau_idletime_adr_exact_shiftcount.h"
#include "mau_idletime_adr_mask.h"
#include "mau_idletime_adr_miss_value.h"
#include "mau_idletime_adr_per_entry_en_mux_ctl.h"
#include "mau_idletime_adr_tcam_actionbit_map_data.h"
#include "mau_idletime_adr_tcam_actionbit_map_en.h"
#include "mau_idletime_adr_tcam_shiftcount.h"
#include "mau_immediate_data_default.h"
#include "mau_immediate_data_exact_shiftcount.h"
#include "mau_immediate_data_mask.h"
#include "mau_immediate_data_miss_value.h"
#include "mau_immediate_data_tcam_actionbit_map_data.h"
#include "mau_immediate_data_tcam_actionbit_map_en.h"
#include "mau_immediate_data_tcam_shiftcount.h"
#include "mau_logical_to_meter_alu_map.h"
#include "mau_mapram_color_map_to_logical_ctl.h"
#include "mau_match_central_mapram_read_color_oflo_ctl.h"
#include "mau_match_merge_col_addrmap.h"
#include "mau_meter_adr_default.h"
#include "mau_meter_adr_exact_shiftcount.h"
#include "mau_meter_adr_mask.h"
#include "mau_meter_adr_miss_value.h"
#include "mau_meter_adr_per_entry_en_mux_ctl.h"
#include "mau_meter_adr_tcam_actionbit_map_data.h"
#include "mau_meter_adr_tcam_actionbit_map_en.h"
#include "mau_meter_adr_tcam_shiftcount.h"
#include "mau_meter_adr_type_position.h"
#include "mau_meter_alu_to_logical_map.h"
#include "mau_meter_precolor_hash_map_to_logical_ctl.h"
#include "mau_meter_precolor_hash_sel.h"
#include "mau_payload_shifter_enable.h"
#include "mau_physical_to_meter_alu_icxbar_map.h"
#include "mau_selector_action_entry_size.h"
#include "mau_selector_hash_sps_enable.h"
#include "mau_selectorlength_default.h"
#include "mau_selectorlength_mask.h"
#include "mau_selectorlength_shiftcount.h"
#include "mau_snapshot_capture_datapath_error.h"
#include "mau_snapshot_gateway_table_inhibit_logical.h"
#include "mau_snapshot_global_exec_out.h"
#include "mau_snapshot_logical_table_hit.h"
#include "mau_snapshot_long_branch_out.h"
#include "mau_snapshot_mpr_global_exec_out.h"
#include "mau_snapshot_mpr_long_branch_out.h"
#include "mau_snapshot_mpr_next_table_out.h"
#include "mau_snapshot_next_table_out.h"
#include "mau_snapshot_physical_exact_match_hit_address.h"
#include "mau_snapshot_physical_tcam_hit_address.h"
#include "mau_snapshot_table_active.h"
#include "mau_stateful_log_counter.h"
#include "mau_stateful_log_counter_clear.h"
#include "mau_stateful_log_counter_ctl.h"
#include "mau_stateful_log_counter_ctl2.h"
#include "mau_stateful_log_counter_ctl3.h"
#include "mau_stateful_log_ctl_ixbar_map.h"
#include "mau_stateful_log_cur_watermark.h"
#include "mau_stateful_log_fifo_level.h"
#include "mau_stateful_log_watermark_threshold.h"
#include "mau_stats_adr_default.h"
#include "mau_stats_adr_exact_shiftcount.h"
#include "mau_stats_adr_hole_swizzle_mode.h"
#include "mau_stats_adr_mask.h"
#include "mau_stats_adr_miss_value.h"
#include "mau_stats_adr_per_entry_en_mux_ctl.h"
#include "mau_stats_adr_tcam_actionbit_map_data.h"
#include "mau_stats_adr_tcam_actionbit_map_en.h"
#include "mau_stats_adr_tcam_shiftcount.h"
#include "mau_table_counter.h"
#include "mau_table_counter_clear.h"
#include "mau_table_counter_ctl.h"
#include "meter_alu_thread.h"
#include "meter_group_table_vpn_max.h"
#include "meter_group_table_vpn_mod_enable.h"
#include "mpr_always_run.h"
#include "mpr_bus_dep.h"
#include "mpr_glob_exec_lut.h"
#include "mpr_glob_exec_thread.h"
#include "mpr_long_brch_lut.h"
#include "mpr_long_brch_thread.h"
#include "mpr_next_table_lut.h"
#include "mpr_stage_id.h"
#include "mpr_thread_delay.h"
#include "next_table_format_data.h"
#include "next_table_map_en.h"
#include "next_table_map_en_gateway.h"
#include "next_table_tcam_actionbit_map_en.h"
#include "o_error_fifo_ctl.h"
#include "pred_always_run.h"
#include "pred_ghost_thread.h"
#include "pred_glob_exec_thread.h"
#include "pred_is_a_brch.h"
#include "pred_long_brch_lt_src.h"
#include "pred_long_brch_terminate.h"
#include "pred_long_brch_thread.h"
#include "pred_map_glob.h"
#include "pred_map_loca.h"
#include "pred_miss_exec.h"
#include "pred_miss_long_brch.h"
#include "pred_stage_id.h"
#include "predication_ctl.h"
#include "prev_error_ctl.h"
#include "s2p_meter_error_ctl.h"
#include "s2p_stats_error_ctl.h"
#include "selector_action_adr_shift.h"
#include "stash_hitmap_output_map.h"
#include "stash_next_table_lut.h"
#include "stash_row_nxtable_bus_drive.h"
#include "tcam_hit_to_logical_table_ixbar_outputmap.h"
#include "tcam_match_adr_to_physical_oxbar_outputmap.h"
#include "tcam_match_error_ctl.h"
#include "tcam_table_prop.h"
#include "tind_bus_prop.h"
#include "tind_ecc_error_ctl.h"
#include "tind_ram_data_size.h"

namespace jbay {
  namespace register_classes {

class MauMatchMergeAddrmap : public model_core::RegisterBlock<RegisterCallback> {
public:
  MauMatchMergeAddrmap(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 16384, false, write_callback, read_callback, std::string("MauMatchMergeAddrmap")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauMatchMergeAddrmap(
      
  )
    : RegisterBlock(0, 0, 0, false, 0, 0, "MauMatchMergeAddrmap")
    {
    }
public:





















  MauHashGroupXbarCtl &mau_hash_group_xbar_ctl(int j1,int j0) { return mau_hash_group_xbar_ctl_[j1][j0]; }













  MprGlobExecLut &mpr_glob_exec_lut(int j0) { return mpr_glob_exec_lut_[j0]; }






















  StashHitmapOutputMap &stash_hitmap_output_map(int j1,int j0) { return stash_hitmap_output_map_[j1][j0]; }













  StashNextTableLut &stash_next_table_lut(int j1,int j0) { return stash_next_table_lut_[j1][j0]; }













  StashRowNxtableBusDrive &stash_row_nxtable_bus_drive(int j1,int j0) { return stash_row_nxtable_bus_drive_[j1][j0]; }

















  GatewayToLogicaltableXbarCtl &gateway_to_logicaltable_xbar_ctl(int j0) { return gateway_to_logicaltable_xbar_ctl_[j0]; }













  GatewayInhibitLut &gateway_inhibit_lut(int j0) { return gateway_inhibit_lut_[j0]; }














  GatewayToPbusXbarCtl &gateway_to_pbus_xbar_ctl(int j0) { return gateway_to_pbus_xbar_ctl_[j0]; }













  ExitGatewayCtl &exit_gateway_ctl(int j0) { return exit_gateway_ctl_[j0]; }








  TindBusProp &tind_bus_prop(int j0) { return tind_bus_prop_[j0]; }







  MauSnapshotPhysicalTcamHitAddress &mau_snapshot_physical_tcam_hit_address(int j0) { return mau_snapshot_physical_tcam_hit_address_[j0]; }







  MauSnapshotPhysicalExactMatchHitAddress &mau_snapshot_physical_exact_match_hit_address(int j0) { return mau_snapshot_physical_exact_match_hit_address_[j0]; }








  MauTableCounter &mau_table_counter(int j1,int j0) { return mau_table_counter_[j1][j0]; }







  MauTableCounterClear &mau_table_counter_clear() { return mau_table_counter_clear_; }








  MauStatefulLogCounterClear &mau_stateful_log_counter_clear() { return mau_stateful_log_counter_clear_; }






  ActiondataErrorCtl &actiondata_error_ctl() { return actiondata_error_ctl_; }






  ImemParityErrorCtl &imem_parity_error_ctl() { return imem_parity_error_ctl_; }












  TcamHitToLogicalTableIxbarOutputmap &tcam_hit_to_logical_table_ixbar_outputmap(int j0) { return tcam_hit_to_logical_table_ixbar_outputmap_[j0]; }









  MauHashGroupMask &mau_hash_group_mask(int j0) { return mau_hash_group_mask_[j0]; }












  MprLongBrchLut &mpr_long_brch_lut(int j0) { return mpr_long_brch_lut_[j0]; }





















  GatewayPayloadTindPbus &gateway_payload_tind_pbus(int j0) { return gateway_payload_tind_pbus_[j0]; }





















  GatewayPayloadExactPbus &gateway_payload_exact_pbus(int j0) { return gateway_payload_exact_pbus_[j0]; }












  GatewayPayloadExactDisable &gateway_payload_exact_disable(int j0) { return gateway_payload_exact_disable_[j0]; }











  GatewayPayloadTindDisable &gateway_payload_tind_disable(int j0) { return gateway_payload_tind_disable_[j0]; }








  TcamTableProp &tcam_table_prop(int j0) { return tcam_table_prop_[j0]; }











  MauStatefulLogCounter &mau_stateful_log_counter(int j1,int j0) { return mau_stateful_log_counter_[j1][j0]; }














  MauStatefulLogCtlIxbarMap &mau_stateful_log_ctl_ixbar_map(int j2,int j1,int j0) { return mau_stateful_log_ctl_ixbar_map_[j2][j1][j0]; }










  ExactMatchDelayThread &exact_match_delay_thread(int j0) { return exact_match_delay_thread_[j0]; }










  LogicalTableThread &logical_table_thread(int j0) { return logical_table_thread_[j0]; }









  PredGlobExecThread &pred_glob_exec_thread(int j0) { return pred_glob_exec_thread_[j0]; }









  PredLongBrchThread &pred_long_brch_thread(int j0) { return pred_long_brch_thread_[j0]; }










  PredAlwaysRun &pred_always_run(int j0) { return pred_always_run_[j0]; }


















  MauMapramColorMapToLogicalCtl &mau_mapram_color_map_to_logical_ctl(int j0) { return mau_mapram_color_map_to_logical_ctl_[j0]; }














  MauPhysicalToMeterAluIcxbarMap &mau_physical_to_meter_alu_icxbar_map(int j1,int j0) { return mau_physical_to_meter_alu_icxbar_map_[j1][j0]; }










  MauMeterPrecolorHashMapToLogicalCtl &mau_meter_precolor_hash_map_to_logical_ctl(int j0) { return mau_meter_precolor_hash_map_to_logical_ctl_[j0]; }






















  MauSelectorActionEntrySize &mau_selector_action_entry_size(int j0) { return mau_selector_action_entry_size_[j0]; }













  SelectorActionAdrShift &selector_action_adr_shift(int j0) { return selector_action_adr_shift_[j0]; }


















  MprStageId &mpr_stage_id(int j0) { return mpr_stage_id_[j0]; }








  MauSnapshotNextTableOut &mau_snapshot_next_table_out(int j0) { return mau_snapshot_next_table_out_[j0]; }








  MauSnapshotMprNextTableOut &mau_snapshot_mpr_next_table_out(int j0) { return mau_snapshot_mpr_next_table_out_[j0]; }

























  MauStatefulLogCounterCtl &mau_stateful_log_counter_ctl(int j1,int j0) { return mau_stateful_log_counter_ctl_[j1][j0]; }








  MauStatefulLogCounterCtl2 &mau_stateful_log_counter_ctl2(int j0) { return mau_stateful_log_counter_ctl2_[j0]; }








  MauStatefulLogCounterCtl3 &mau_stateful_log_counter_ctl3(int j0) { return mau_stateful_log_counter_ctl3_[j0]; }









  MauStatefulLogFifoLevel &mau_stateful_log_fifo_level(int j0) { return mau_stateful_log_fifo_level_[j0]; }








  MauStatefulLogWatermarkThreshold &mau_stateful_log_watermark_threshold(int j0) { return mau_stateful_log_watermark_threshold_[j0]; }










  MauStatefulLogCurWatermark &mau_stateful_log_cur_watermark(int j0) { return mau_stateful_log_cur_watermark_[j0]; }








  MeterAluThread &meter_alu_thread(int j0) { return meter_alu_thread_[j0]; }









  ExactMatchPhysResultDelay &exact_match_phys_result_delay(int j0) { return exact_match_phys_result_delay_[j0]; }









  ExactMatchPhysResultEn &exact_match_phys_result_en(int j0) { return exact_match_phys_result_en_[j0]; }









  ExactMatchPhysResultThread &exact_match_phys_result_thread(int j0) { return exact_match_phys_result_thread_[j0]; }














  MauActionInstructionAdrMapEn &mau_action_instruction_adr_map_en(int j0) { return mau_action_instruction_adr_map_en_[j0]; }










  MauActionInstructionAdrMode &mau_action_instruction_adr_mode(int j0) { return mau_action_instruction_adr_mode_[j0]; }









  MauHashGroupExpand &mau_hash_group_expand(int j0) { return mau_hash_group_expand_[j0]; }









  MeterGroupTableVpnModEnable &meter_group_table_vpn_mod_enable(int j0) { return meter_group_table_vpn_mod_enable_[j0]; }











  MauMeterAluToLogicalMap &mau_meter_alu_to_logical_map(int j0) { return mau_meter_alu_to_logical_map_[j0]; }














  MauLogicalToMeterAluMap &mau_logical_to_meter_alu_map(int j0) { return mau_logical_to_meter_alu_map_[j0]; }









  ActionAdrVpnModEnable &action_adr_vpn_mod_enable(int j0) { return action_adr_vpn_mod_enable_[j0]; }














  PredicationCtl &predication_ctl(int j0) { return predication_ctl_[j0]; }












  MprThreadDelay &mpr_thread_delay(int j0) { return mpr_thread_delay_[j0]; }















  GatewayPayloadExactShiftOvr &gateway_payload_exact_shift_ovr(int j0) { return gateway_payload_exact_shift_ovr_[j0]; }









  MauSnapshotTableActive &mau_snapshot_table_active(int j0) { return mau_snapshot_table_active_[j0]; }








  MauSnapshotCaptureDatapathError &mau_snapshot_capture_datapath_error(int j0) { return mau_snapshot_capture_datapath_error_[j0]; }









  MauSnapshotGlobalExecOut &mau_snapshot_global_exec_out(int j0) { return mau_snapshot_global_exec_out_[j0]; }









  MauSnapshotLongBranchOut &mau_snapshot_long_branch_out(int j0) { return mau_snapshot_long_branch_out_[j0]; }









  MauSnapshotMprGlobalExecOut &mau_snapshot_mpr_global_exec_out(int j0) { return mau_snapshot_mpr_global_exec_out_[j0]; }









  MauSnapshotMprLongBranchOut &mau_snapshot_mpr_long_branch_out(int j0) { return mau_snapshot_mpr_long_branch_out_[j0]; }


















  MauTableCounterCtl &mau_table_counter_ctl(int j0) { return mau_table_counter_ctl_[j0]; }








  TcamMatchErrorCtl &tcam_match_error_ctl(int j0) { return tcam_match_error_ctl_[j0]; }








  TindEccErrorCtl &tind_ecc_error_ctl(int j0) { return tind_ecc_error_ctl_[j0]; }








  GfmParityErrorCtl &gfm_parity_error_ctl(int j0) { return gfm_parity_error_ctl_[j0]; }








  EmmEccErrorCtl &emm_ecc_error_ctl(int j0) { return emm_ecc_error_ctl_[j0]; }








  PrevErrorCtl &prev_error_ctl(int j0) { return prev_error_ctl_[j0]; }








  ErrIdataOvrFifoCtl &err_idata_ovr_fifo_ctl(int j0) { return err_idata_ovr_fifo_ctl_[j0]; }








  ErrIdataOvrCtl &err_idata_ovr_ctl(int j0) { return err_idata_ovr_ctl_[j0]; }








  OErrorFifoCtl &o_error_fifo_ctl(int j0) { return o_error_fifo_ctl_[j0]; }








  S2pStatsErrorCtl &s2p_stats_error_ctl(int j0) { return s2p_stats_error_ctl_[j0]; }








  S2pMeterErrorCtl &s2p_meter_error_ctl(int j0) { return s2p_meter_error_ctl_[j0]; }








  ExactMatchLogicalResultDelay &exact_match_logical_result_delay() { return exact_match_logical_result_delay_; }






  ExactMatchLogicalResultEn &exact_match_logical_result_en() { return exact_match_logical_result_en_; }









  NextTableMapEn &next_table_map_en() { return next_table_map_en_; }












  NextTableMapEnGateway &next_table_map_en_gateway() { return next_table_map_en_gateway_; }












  NextTableTcamActionbitMapEn &next_table_tcam_actionbit_map_en() { return next_table_tcam_actionbit_map_en_; }







  PredLongBrchTerminate &pred_long_brch_terminate() { return pred_long_brch_terminate_; }









  PredIsABrch &pred_is_a_brch() { return pred_is_a_brch_; }







  PredGhostThread &pred_ghost_thread() { return pred_ghost_thread_; }





  PredStageId &pred_stage_id() { return pred_stage_id_; }









  MauImmediateDataTcamActionbitMapEn &mau_immediate_data_tcam_actionbit_map_en() { return mau_immediate_data_tcam_actionbit_map_en_; }












  MauActionInstructionAdrTcamActionbitMapEn &mau_action_instruction_adr_tcam_actionbit_map_en() { return mau_action_instruction_adr_tcam_actionbit_map_en_; }









  MauActiondataAdrTcamActionbitMapEn &mau_actiondata_adr_tcam_actionbit_map_en() { return mau_actiondata_adr_tcam_actionbit_map_en_; }












  PredMapLoca &pred_map_loca(int j1,int j0) { return pred_map_loca_[j1][j0]; }












  PredMapGlob &pred_map_glob(int j1,int j0) { return pred_map_glob_[j1][j0]; }











  MauImmediateDataExactShiftcount &mau_immediate_data_exact_shiftcount(int j1,int j0) { return mau_immediate_data_exact_shiftcount_[j1][j0]; }











  MauActionInstructionAdrExactShiftcount &mau_action_instruction_adr_exact_shiftcount(int j1,int j0) { return mau_action_instruction_adr_exact_shiftcount_[j1][j0]; }












  MauActiondataAdrExactShiftcount &mau_actiondata_adr_exact_shiftcount(int j1,int j0) { return mau_actiondata_adr_exact_shiftcount_[j1][j0]; }















  MauStatsAdrExactShiftcount &mau_stats_adr_exact_shiftcount(int j1,int j0) { return mau_stats_adr_exact_shiftcount_[j1][j0]; }
















  MauMeterAdrExactShiftcount &mau_meter_adr_exact_shiftcount(int j1,int j0) { return mau_meter_adr_exact_shiftcount_[j1][j0]; }















  MauIdletimeAdrExactShiftcount &mau_idletime_adr_exact_shiftcount(int j1,int j0) { return mau_idletime_adr_exact_shiftcount_[j1][j0]; }













  GatewayNextTableLut &gateway_next_table_lut(int j1,int j0) { return gateway_next_table_lut_[j1][j0]; }



























  MatchToLogicalTableIxbarOutputmap &match_to_logical_table_ixbar_outputmap(int j1,int j0) { return match_to_logical_table_ixbar_outputmap_[j1][j0]; }



















  MauActionInstructionAdrMapData &mau_action_instruction_adr_map_data(int j2,int j1,int j0) { return mau_action_instruction_adr_map_data_[j2][j1][j0]; }












  MprNextTableLut &mpr_next_table_lut(int j1,int j0) { return mpr_next_table_lut_[j1][j0]; }













  GatewayPayloadData &gateway_payload_data(int j3,int j2,int j1,int j0) { return gateway_payload_data_[j3][j2][j1][j0]; }









  MauStatsAdrTcamActionbitMapEn &mau_stats_adr_tcam_actionbit_map_en() { return mau_stats_adr_tcam_actionbit_map_en_; }









  MauMeterAdrTcamActionbitMapEn &mau_meter_adr_tcam_actionbit_map_en() { return mau_meter_adr_tcam_actionbit_map_en_; }





  MauMatchCentralMapramReadColorOfloCtl &mau_match_central_mapram_read_color_oflo_ctl() { return mau_match_central_mapram_read_color_oflo_ctl_; }









  MauIdletimeAdrTcamActionbitMapEn &mau_idletime_adr_tcam_actionbit_map_en() { return mau_idletime_adr_tcam_actionbit_map_en_; }






  MauSelectorHashSpsEnable &mau_selector_hash_sps_enable() { return mau_selector_hash_sps_enable_; }






  MauHashGroupConfig &mau_hash_group_config() { return mau_hash_group_config_; }










  MauHashGroupShiftcount &mau_hash_group_shiftcount() { return mau_hash_group_shiftcount_; }







  MeterGroupTableVpnMax &meter_group_table_vpn_max() { return meter_group_table_vpn_max_; }












  MauMeterPrecolorHashSel &mau_meter_precolor_hash_sel() { return mau_meter_precolor_hash_sel_; }







  MprBusDep &mpr_bus_dep() { return mpr_bus_dep_; }






  MprGlobExecThread &mpr_glob_exec_thread() { return mpr_glob_exec_thread_; }






  MprLongBrchThread &mpr_long_brch_thread() { return mpr_long_brch_thread_; }







  MprAlwaysRun &mpr_always_run() { return mpr_always_run_; }






  GatewayEn &gateway_en() { return gateway_en_; }





  MauSnapshotLogicalTableHit &mau_snapshot_logical_table_hit() { return mau_snapshot_logical_table_hit_; }





  MauSnapshotGatewayTableInhibitLogical &mau_snapshot_gateway_table_inhibit_logical() { return mau_snapshot_gateway_table_inhibit_logical_; }




























  MauPayloadShifterEnable &mau_payload_shifter_enable(int j1,int j0) { return mau_payload_shifter_enable_[j1][j0]; }











  MauImmediateDataMask &mau_immediate_data_mask(int j1,int j0) { return mau_immediate_data_mask_[j1][j0]; }











  MauImmediateDataDefault &mau_immediate_data_default(int j1,int j0) { return mau_immediate_data_default_[j1][j0]; }









  MauImmediateDataTcamActionbitMapData &mau_immediate_data_tcam_actionbit_map_data(int j1,int j0) { return mau_immediate_data_tcam_actionbit_map_data_[j1][j0]; }












  MauActionInstructionAdrMask &mau_action_instruction_adr_mask(int j1,int j0) { return mau_action_instruction_adr_mask_[j1][j0]; }












  MauActionInstructionAdrDefault &mau_action_instruction_adr_default(int j1,int j0) { return mau_action_instruction_adr_default_[j1][j0]; }























  MauActionInstructionAdrPerEntryEnMuxCtl &mau_action_instruction_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_action_instruction_adr_per_entry_en_mux_ctl_[j1][j0]; }












  MauActiondataAdrVpnShiftcount &mau_actiondata_adr_vpn_shiftcount(int j1,int j0) { return mau_actiondata_adr_vpn_shiftcount_[j1][j0]; }











  MauActiondataAdrMask &mau_actiondata_adr_mask(int j1,int j0) { return mau_actiondata_adr_mask_[j1][j0]; }











  MauActiondataAdrDefault &mau_actiondata_adr_default(int j1,int j0) { return mau_actiondata_adr_default_[j1][j0]; }





















  MauActiondataAdrPerEntryEnMuxCtl &mau_actiondata_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_actiondata_adr_per_entry_en_mux_ctl_[j1][j0]; }









  MauActiondataAdrTcamActionbitMapData &mau_actiondata_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_actiondata_adr_tcam_actionbit_map_data_[j1][j0]; }











  MauStatsAdrMask &mau_stats_adr_mask(int j1,int j0) { return mau_stats_adr_mask_[j1][j0]; }











  MauStatsAdrDefault &mau_stats_adr_default(int j1,int j0) { return mau_stats_adr_default_[j1][j0]; }





















  MauStatsAdrPerEntryEnMuxCtl &mau_stats_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_stats_adr_per_entry_en_mux_ctl_[j1][j0]; }





























  MauStatsAdrHoleSwizzleMode &mau_stats_adr_hole_swizzle_mode(int j1,int j0) { return mau_stats_adr_hole_swizzle_mode_[j1][j0]; }









  MauStatsAdrTcamActionbitMapData &mau_stats_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_stats_adr_tcam_actionbit_map_data_[j1][j0]; }











  MauMeterAdrMask &mau_meter_adr_mask(int j1,int j0) { return mau_meter_adr_mask_[j1][j0]; }











  MauMeterAdrDefault &mau_meter_adr_default(int j1,int j0) { return mau_meter_adr_default_[j1][j0]; }





















  MauMeterAdrPerEntryEnMuxCtl &mau_meter_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_meter_adr_per_entry_en_mux_ctl_[j1][j0]; }









  MauMeterAdrTcamActionbitMapData &mau_meter_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_meter_adr_tcam_actionbit_map_data_[j1][j0]; }











  MauIdletimeAdrMask &mau_idletime_adr_mask(int j1,int j0) { return mau_idletime_adr_mask_[j1][j0]; }











  MauIdletimeAdrDefault &mau_idletime_adr_default(int j1,int j0) { return mau_idletime_adr_default_[j1][j0]; }









  MauIdletimeAdrTcamActionbitMapData &mau_idletime_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_idletime_adr_tcam_actionbit_map_data_[j1][j0]; }





















  MauIdletimeAdrPerEntryEnMuxCtl &mau_idletime_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_idletime_adr_per_entry_en_mux_ctl_[j1][j0]; }


















  MauSelectorlengthShiftcount &mau_selectorlength_shiftcount(int j1,int j0) { return mau_selectorlength_shiftcount_[j1][j0]; }











  MauSelectorlengthMask &mau_selectorlength_mask(int j1,int j0) { return mau_selectorlength_mask_[j1][j0]; }











  MauSelectorlengthDefault &mau_selectorlength_default(int j1,int j0) { return mau_selectorlength_default_[j1][j0]; }






















  MauMeterAdrTypePosition &mau_meter_adr_type_position(int j1,int j0) { return mau_meter_adr_type_position_[j1][j0]; }












  GatewayPayloadMatchAdr &gateway_payload_match_adr(int j2,int j1,int j0) { return gateway_payload_match_adr_[j2][j1][j0]; }













  TcamMatchAdrToPhysicalOxbarOutputmap &tcam_match_adr_to_physical_oxbar_outputmap(int j0) { return tcam_match_adr_to_physical_oxbar_outputmap_[j0]; }



















  TindRamDataSize &tind_ram_data_size(int j0) { return tind_ram_data_size_[j0]; }











  NextTableFormatData &next_table_format_data(int j0) { return next_table_format_data_[j0]; }









  PredMissExec &pred_miss_exec(int j0) { return pred_miss_exec_[j0]; }









  PredMissLongBrch &pred_miss_long_brch(int j0) { return pred_miss_long_brch_[j0]; }











  PredLongBrchLtSrc &pred_long_brch_lt_src(int j0) { return pred_long_brch_lt_src_[j0]; }










  MauImmediateDataTcamShiftcount &mau_immediate_data_tcam_shiftcount(int j0) { return mau_immediate_data_tcam_shiftcount_[j0]; }








  MauImmediateDataMissValue &mau_immediate_data_miss_value(int j0) { return mau_immediate_data_miss_value_[j0]; }










  MauActionInstructionAdrTcamShiftcount &mau_action_instruction_adr_tcam_shiftcount(int j0) { return mau_action_instruction_adr_tcam_shiftcount_[j0]; }









  MauActionInstructionAdrMissValue &mau_action_instruction_adr_miss_value(int j0) { return mau_action_instruction_adr_miss_value_[j0]; }











  MauActiondataAdrTcamShiftcount &mau_actiondata_adr_tcam_shiftcount(int j0) { return mau_actiondata_adr_tcam_shiftcount_[j0]; }








  MauActiondataAdrMissValue &mau_actiondata_adr_miss_value(int j0) { return mau_actiondata_adr_miss_value_[j0]; }














  MauStatsAdrTcamShiftcount &mau_stats_adr_tcam_shiftcount(int j0) { return mau_stats_adr_tcam_shiftcount_[j0]; }








  MauStatsAdrMissValue &mau_stats_adr_miss_value(int j0) { return mau_stats_adr_miss_value_[j0]; }















  MauMeterAdrTcamShiftcount &mau_meter_adr_tcam_shiftcount(int j0) { return mau_meter_adr_tcam_shiftcount_[j0]; }








  MauMeterAdrMissValue &mau_meter_adr_miss_value(int j0) { return mau_meter_adr_miss_value_[j0]; }














  MauIdletimeAdrTcamShiftcount &mau_idletime_adr_tcam_shiftcount(int j0) { return mau_idletime_adr_tcam_shiftcount_[j0]; }








  MauIdletimeAdrMissValue &mau_idletime_adr_miss_value(int j0) { return mau_idletime_adr_miss_value_[j0]; }







  MauMatchMergeColAddrmap &col(int j0) { return col_[j0]; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset < 0x30) {
      offset -= 0x0;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_hash_group_xbar_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x40 && offset < 0x80) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mpr_glob_exec_lut_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x80 && offset < 0xc0) {
      offset -= 0x80;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      stash_hitmap_output_map_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0xc0 && offset < 0x100) {
      offset -= 0xc0;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      stash_next_table_lut_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x100 && offset < 0x140) {
      offset -= 0x100;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      stash_row_nxtable_bus_drive_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x140 && offset < 0x180) {
      offset -= 0x140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_to_logicaltable_xbar_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x180 && offset < 0x1c0) {
      offset -= 0x180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_inhibit_lut_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1c0 && offset < 0x200) {
      offset -= 0x1c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_to_pbus_xbar_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x200 && offset < 0x240) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exit_gateway_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x240 && offset < 0x280) {
      offset -= 0x240;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tind_bus_prop_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x280 && offset < 0x2c0) {
      offset -= 0x280;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_physical_tcam_hit_address_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2c0 && offset < 0x300) {
      offset -= 0x2c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_physical_exact_match_hit_address_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x300 && offset < 0x340) {
      offset -= 0x300;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_table_counter_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x340 && offset < 0x344) {
      offset -= 0x340;
      if (read_callback_) read_callback_();
      mau_table_counter_clear_.read( offset, data );
    }
    else if (offset >= 0x344 && offset < 0x348) {
      offset -= 0x344;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_clear_.read( offset, data );
    }
    else if (offset >= 0x348 && offset < 0x34c) {
      offset -= 0x348;
      if (read_callback_) read_callback_();
      actiondata_error_ctl_.read( offset, data );
    }
    else if (offset >= 0x34c && offset < 0x350) {
      offset -= 0x34c;
      if (read_callback_) read_callback_();
      imem_parity_error_ctl_.read( offset, data );
    }
    else if (offset >= 0x360 && offset < 0x380) {
      offset -= 0x360;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_hit_to_logical_table_ixbar_outputmap_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x380 && offset < 0x398) {
      offset -= 0x380;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_hash_group_mask_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3a0 && offset < 0x3c0) {
      offset -= 0x3a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mpr_long_brch_lut_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3c0 && offset < 0x3e0) {
      offset -= 0x3c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_tind_pbus_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3e0 && offset < 0x400) {
      offset -= 0x3e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_exact_pbus_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1000 && offset < 0x1020) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_exact_disable_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1020 && offset < 0x1040) {
      offset -= 0x1020;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_tind_disable_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1040 && offset < 0x1060) {
      offset -= 0x1040;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_table_prop_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1060 && offset < 0x1080) {
      offset -= 0x1060;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1080 && offset < 0x10a0) {
      offset -= 0x1080;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_ctl_ixbar_map_[ i2 ][ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10a0 && offset < 0x10ac) {
      offset -= 0x10a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_delay_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x10b0 && offset < 0x10bc) {
      offset -= 0x10b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      logical_table_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x10c0 && offset < 0x10cc) {
      offset -= 0x10c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_glob_exec_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x10d0 && offset < 0x10dc) {
      offset -= 0x10d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_long_brch_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x10e0 && offset < 0x10ec) {
      offset -= 0x10e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_always_run_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x10f0 && offset < 0x1100) {
      offset -= 0x10f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_mapram_color_map_to_logical_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1100 && offset < 0x1110) {
      offset -= 0x1100;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_physical_to_meter_alu_icxbar_map_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1110 && offset < 0x1120) {
      offset -= 0x1110;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_precolor_hash_map_to_logical_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1120 && offset < 0x1130) {
      offset -= 0x1120;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selector_action_entry_size_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1130 && offset < 0x1140) {
      offset -= 0x1130;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      selector_action_adr_shift_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1140 && offset < 0x114c) {
      offset -= 0x1140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mpr_stage_id_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1150 && offset < 0x115c) {
      offset -= 0x1150;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_next_table_out_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1160 && offset < 0x116c) {
      offset -= 0x1160;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_mpr_next_table_out_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1170 && offset < 0x1180) {
      offset -= 0x1170;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1180 && offset < 0x1190) {
      offset -= 0x1180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_ctl2_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1190 && offset < 0x11a0) {
      offset -= 0x1190;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_ctl3_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11a0 && offset < 0x11b0) {
      offset -= 0x11a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_fifo_level_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11b0 && offset < 0x11c0) {
      offset -= 0x11b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_watermark_threshold_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11c0 && offset < 0x11d0) {
      offset -= 0x11c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_cur_watermark_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11d8 && offset < 0x11e0) {
      offset -= 0x11d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      meter_alu_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11e0 && offset < 0x11e8) {
      offset -= 0x11e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_phys_result_delay_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11e8 && offset < 0x11f0) {
      offset -= 0x11e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_phys_result_en_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11f0 && offset < 0x11f8) {
      offset -= 0x11f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_phys_result_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11f8 && offset < 0x1200) {
      offset -= 0x11f8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_map_en_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1400 && offset < 0x1408) {
      offset -= 0x1400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_mode_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1408 && offset < 0x1410) {
      offset -= 0x1408;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_hash_group_expand_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1410 && offset < 0x1418) {
      offset -= 0x1410;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      meter_group_table_vpn_mod_enable_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1418 && offset < 0x1420) {
      offset -= 0x1418;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_alu_to_logical_map_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1420 && offset < 0x1428) {
      offset -= 0x1420;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_logical_to_meter_alu_map_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1428 && offset < 0x1430) {
      offset -= 0x1428;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      action_adr_vpn_mod_enable_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1430 && offset < 0x1438) {
      offset -= 0x1430;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      predication_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1438 && offset < 0x1440) {
      offset -= 0x1438;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mpr_thread_delay_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1440 && offset < 0x1448) {
      offset -= 0x1440;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_exact_shift_ovr_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1448 && offset < 0x1450) {
      offset -= 0x1448;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_table_active_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1450 && offset < 0x1458) {
      offset -= 0x1450;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_capture_datapath_error_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1458 && offset < 0x1460) {
      offset -= 0x1458;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_global_exec_out_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1460 && offset < 0x1468) {
      offset -= 0x1460;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_long_branch_out_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1468 && offset < 0x1470) {
      offset -= 0x1468;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_mpr_global_exec_out_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1470 && offset < 0x1478) {
      offset -= 0x1470;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_mpr_long_branch_out_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1478 && offset < 0x1480) {
      offset -= 0x1478;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_table_counter_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1480 && offset < 0x1488) {
      offset -= 0x1480;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_match_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1488 && offset < 0x1490) {
      offset -= 0x1488;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tind_ecc_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1490 && offset < 0x1498) {
      offset -= 0x1490;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gfm_parity_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1498 && offset < 0x14a0) {
      offset -= 0x1498;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      emm_ecc_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x14a0 && offset < 0x14a8) {
      offset -= 0x14a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      prev_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x14a8 && offset < 0x14b0) {
      offset -= 0x14a8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      err_idata_ovr_fifo_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x14b0 && offset < 0x14b8) {
      offset -= 0x14b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      err_idata_ovr_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x14b8 && offset < 0x14c0) {
      offset -= 0x14b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      o_error_fifo_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x14c0 && offset < 0x14c8) {
      offset -= 0x14c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      s2p_stats_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x14c8 && offset < 0x14d0) {
      offset -= 0x14c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      s2p_meter_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x14d0 && offset < 0x14d4) {
      offset -= 0x14d0;
      if (read_callback_) read_callback_();
      exact_match_logical_result_delay_.read( offset, data );
    }
    else if (offset >= 0x14d4 && offset < 0x14d8) {
      offset -= 0x14d4;
      if (read_callback_) read_callback_();
      exact_match_logical_result_en_.read( offset, data );
    }
    else if (offset >= 0x14d8 && offset < 0x14dc) {
      offset -= 0x14d8;
      if (read_callback_) read_callback_();
      next_table_map_en_.read( offset, data );
    }
    else if (offset >= 0x14dc && offset < 0x14e0) {
      offset -= 0x14dc;
      if (read_callback_) read_callback_();
      next_table_map_en_gateway_.read( offset, data );
    }
    else if (offset >= 0x14e0 && offset < 0x14e4) {
      offset -= 0x14e0;
      if (read_callback_) read_callback_();
      next_table_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x14e4 && offset < 0x14e8) {
      offset -= 0x14e4;
      if (read_callback_) read_callback_();
      pred_long_brch_terminate_.read( offset, data );
    }
    else if (offset >= 0x14e8 && offset < 0x14ec) {
      offset -= 0x14e8;
      if (read_callback_) read_callback_();
      pred_is_a_brch_.read( offset, data );
    }
    else if (offset >= 0x14ec && offset < 0x14f0) {
      offset -= 0x14ec;
      if (read_callback_) read_callback_();
      pred_ghost_thread_.read( offset, data );
    }
    else if (offset >= 0x14f0 && offset < 0x14f4) {
      offset -= 0x14f0;
      if (read_callback_) read_callback_();
      pred_stage_id_.read( offset, data );
    }
    else if (offset >= 0x14f4 && offset < 0x14f8) {
      offset -= 0x14f4;
      if (read_callback_) read_callback_();
      mau_immediate_data_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x14f8 && offset < 0x14fc) {
      offset -= 0x14f8;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x14fc && offset < 0x1500) {
      offset -= 0x14fc;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x1600 && offset < 0x1800) {
      offset -= 0x1600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_map_loca_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1800 && offset < 0x1a00) {
      offset -= 0x1800;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_map_glob_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1a00 && offset < 0x1c00) {
      offset -= 0x1a00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1c00 && offset < 0x1e00) {
      offset -= 0x1c00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1e00 && offset < 0x2000) {
      offset -= 0x1e00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2000 && offset < 0x2200) {
      offset -= 0x2000;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2200 && offset < 0x2400) {
      offset -= 0x2200;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2400 && offset < 0x2600) {
      offset -= 0x2400;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2600 && offset < 0x2800) {
      offset -= 0x2600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_next_table_lut_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2800 && offset < 0x2900) {
      offset -= 0x2800;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      match_to_logical_table_ixbar_outputmap_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2900 && offset < 0x2a00) {
      offset -= 0x2900;
      int i2 = offset / 0x80;
      offset  -= i2 * 0x80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_map_data_[ i2 ][ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2a00 && offset < 0x2ac0) {
      offset -= 0x2a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mpr_next_table_lut_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2b00 && offset < 0x2c00) {
      offset -= 0x2b00;
      int i3 = offset / 0x20;
      offset  -= i3 * 0x20;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_data_[ i3 ][ i2 ][ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2c00 && offset < 0x2c04) {
      offset -= 0x2c00;
      if (read_callback_) read_callback_();
      mau_stats_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x2c04 && offset < 0x2c08) {
      offset -= 0x2c04;
      if (read_callback_) read_callback_();
      mau_meter_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x2c08 && offset < 0x2c0c) {
      offset -= 0x2c08;
      if (read_callback_) read_callback_();
      mau_match_central_mapram_read_color_oflo_ctl_.read( offset, data );
    }
    else if (offset >= 0x2c0c && offset < 0x2c10) {
      offset -= 0x2c0c;
      if (read_callback_) read_callback_();
      mau_idletime_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x2c10 && offset < 0x2c14) {
      offset -= 0x2c10;
      if (read_callback_) read_callback_();
      mau_selector_hash_sps_enable_.read( offset, data );
    }
    else if (offset >= 0x2c14 && offset < 0x2c18) {
      offset -= 0x2c14;
      if (read_callback_) read_callback_();
      mau_hash_group_config_.read( offset, data );
    }
    else if (offset >= 0x2c18 && offset < 0x2c1c) {
      offset -= 0x2c18;
      if (read_callback_) read_callback_();
      mau_hash_group_shiftcount_.read( offset, data );
    }
    else if (offset >= 0x2c1c && offset < 0x2c20) {
      offset -= 0x2c1c;
      if (read_callback_) read_callback_();
      meter_group_table_vpn_max_.read( offset, data );
    }
    else if (offset >= 0x2c20 && offset < 0x2c24) {
      offset -= 0x2c20;
      if (read_callback_) read_callback_();
      mau_meter_precolor_hash_sel_.read( offset, data );
    }
    else if (offset >= 0x2c24 && offset < 0x2c28) {
      offset -= 0x2c24;
      if (read_callback_) read_callback_();
      mpr_bus_dep_.read( offset, data );
    }
    else if (offset >= 0x2c28 && offset < 0x2c2c) {
      offset -= 0x2c28;
      if (read_callback_) read_callback_();
      mpr_glob_exec_thread_.read( offset, data );
    }
    else if (offset >= 0x2c2c && offset < 0x2c30) {
      offset -= 0x2c2c;
      if (read_callback_) read_callback_();
      mpr_long_brch_thread_.read( offset, data );
    }
    else if (offset >= 0x2c30 && offset < 0x2c34) {
      offset -= 0x2c30;
      if (read_callback_) read_callback_();
      mpr_always_run_.read( offset, data );
    }
    else if (offset >= 0x2c34 && offset < 0x2c38) {
      offset -= 0x2c34;
      if (read_callback_) read_callback_();
      gateway_en_.read( offset, data );
    }
    else if (offset >= 0x2c38 && offset < 0x2c3c) {
      offset -= 0x2c38;
      if (read_callback_) read_callback_();
      mau_snapshot_logical_table_hit_.read( offset, data );
    }
    else if (offset >= 0x2c3c && offset < 0x2c40) {
      offset -= 0x2c3c;
      if (read_callback_) read_callback_();
      mau_snapshot_gateway_table_inhibit_logical_.read( offset, data );
    }
    else if (offset >= 0x2c80 && offset < 0x2d00) {
      offset -= 0x2c80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_payload_shifter_enable_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2d00 && offset < 0x2d80) {
      offset -= 0x2d00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2d80 && offset < 0x2e00) {
      offset -= 0x2d80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2e00 && offset < 0x2e80) {
      offset -= 0x2e00;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2e80 && offset < 0x2f00) {
      offset -= 0x2e80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2f00 && offset < 0x2f80) {
      offset -= 0x2f00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2f80 && offset < 0x3000) {
      offset -= 0x2f80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3000 && offset < 0x3080) {
      offset -= 0x3000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_vpn_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3080 && offset < 0x3100) {
      offset -= 0x3080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3100 && offset < 0x3180) {
      offset -= 0x3100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3180 && offset < 0x3200) {
      offset -= 0x3180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3200 && offset < 0x3280) {
      offset -= 0x3200;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3280 && offset < 0x3300) {
      offset -= 0x3280;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3300 && offset < 0x3380) {
      offset -= 0x3300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3380 && offset < 0x3400) {
      offset -= 0x3380;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3400 && offset < 0x3480) {
      offset -= 0x3400;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_hole_swizzle_mode_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3480 && offset < 0x3500) {
      offset -= 0x3480;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3500 && offset < 0x3580) {
      offset -= 0x3500;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3580 && offset < 0x3600) {
      offset -= 0x3580;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3600 && offset < 0x3680) {
      offset -= 0x3600;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3680 && offset < 0x3700) {
      offset -= 0x3680;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3700 && offset < 0x3780) {
      offset -= 0x3700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3780 && offset < 0x3800) {
      offset -= 0x3780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3800 && offset < 0x3880) {
      offset -= 0x3800;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3880 && offset < 0x3900) {
      offset -= 0x3880;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3900 && offset < 0x3980) {
      offset -= 0x3900;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selectorlength_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3980 && offset < 0x3a00) {
      offset -= 0x3980;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selectorlength_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3a00 && offset < 0x3a80) {
      offset -= 0x3a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selectorlength_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3a80 && offset < 0x3b00) {
      offset -= 0x3a80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_type_position_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3b00 && offset < 0x3b80) {
      offset -= 0x3b00;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_match_adr_[ i2 ][ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3b80 && offset < 0x3bc0) {
      offset -= 0x3b80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_match_adr_to_physical_oxbar_outputmap_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3bc0 && offset < 0x3c00) {
      offset -= 0x3bc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tind_ram_data_size_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3c00 && offset < 0x3c40) {
      offset -= 0x3c00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      next_table_format_data_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3c40 && offset < 0x3c80) {
      offset -= 0x3c40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_miss_exec_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3c80 && offset < 0x3cc0) {
      offset -= 0x3c80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_miss_long_brch_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3cc0 && offset < 0x3d00) {
      offset -= 0x3cc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pred_long_brch_lt_src_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3d00 && offset < 0x3d40) {
      offset -= 0x3d00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3d40 && offset < 0x3d80) {
      offset -= 0x3d40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3d80 && offset < 0x3dc0) {
      offset -= 0x3d80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3dc0 && offset < 0x3e00) {
      offset -= 0x3dc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3e00 && offset < 0x3e40) {
      offset -= 0x3e00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3e40 && offset < 0x3e80) {
      offset -= 0x3e40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3e80 && offset < 0x3ec0) {
      offset -= 0x3e80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3ec0 && offset < 0x3f00) {
      offset -= 0x3ec0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3f00 && offset < 0x3f40) {
      offset -= 0x3f00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3f40 && offset < 0x3f80) {
      offset -= 0x3f40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3f80 && offset < 0x3fc0) {
      offset -= 0x3f80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3fc0 && offset < 0x4000) {
      offset -= 0x3fc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x800 && offset < 0xe00) {
      offset -= 0x800;
      int i0 = offset / 0x80;
      offset  -= i0 * 0x80;
      if (read_callback_) read_callback_();
      col_[ i0 ].read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset < 0x30) {
      offset -= 0x0;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_hash_group_xbar_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40 && offset < 0x80) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mpr_glob_exec_lut_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0xc0) {
      offset -= 0x80;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      stash_hitmap_output_map_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc0 && offset < 0x100) {
      offset -= 0xc0;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      stash_next_table_lut_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100 && offset < 0x140) {
      offset -= 0x100;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      stash_row_nxtable_bus_drive_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x140 && offset < 0x180) {
      offset -= 0x140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_to_logicaltable_xbar_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x180 && offset < 0x1c0) {
      offset -= 0x180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_inhibit_lut_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c0 && offset < 0x200) {
      offset -= 0x1c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_to_pbus_xbar_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x240) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exit_gateway_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x240 && offset < 0x280) {
      offset -= 0x240;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tind_bus_prop_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x280 && offset < 0x2c0) {
      offset -= 0x280;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_physical_tcam_hit_address_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c0 && offset < 0x300) {
      offset -= 0x2c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_physical_exact_match_hit_address_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x300 && offset < 0x340) {
      offset -= 0x300;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_table_counter_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x340 && offset < 0x344) {
      offset -= 0x340;
      mau_table_counter_clear_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x344 && offset < 0x348) {
      offset -= 0x344;
      mau_stateful_log_counter_clear_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x348 && offset < 0x34c) {
      offset -= 0x348;
      actiondata_error_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x34c && offset < 0x350) {
      offset -= 0x34c;
      imem_parity_error_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x360 && offset < 0x380) {
      offset -= 0x360;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_hit_to_logical_table_ixbar_outputmap_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x380 && offset < 0x398) {
      offset -= 0x380;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_hash_group_mask_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3a0 && offset < 0x3c0) {
      offset -= 0x3a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mpr_long_brch_lut_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c0 && offset < 0x3e0) {
      offset -= 0x3c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_tind_pbus_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3e0 && offset < 0x400) {
      offset -= 0x3e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_exact_pbus_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1020) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_exact_disable_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1020 && offset < 0x1040) {
      offset -= 0x1020;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_tind_disable_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1040 && offset < 0x1060) {
      offset -= 0x1040;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_table_prop_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1060 && offset < 0x1080) {
      offset -= 0x1060;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_counter_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1080 && offset < 0x10a0) {
      offset -= 0x1080;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_ctl_ixbar_map_[ i2 ][ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10a0 && offset < 0x10ac) {
      offset -= 0x10a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_delay_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10b0 && offset < 0x10bc) {
      offset -= 0x10b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      logical_table_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10c0 && offset < 0x10cc) {
      offset -= 0x10c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_glob_exec_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10d0 && offset < 0x10dc) {
      offset -= 0x10d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_long_brch_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10e0 && offset < 0x10ec) {
      offset -= 0x10e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_always_run_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10f0 && offset < 0x1100) {
      offset -= 0x10f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_mapram_color_map_to_logical_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1100 && offset < 0x1110) {
      offset -= 0x1100;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_physical_to_meter_alu_icxbar_map_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1110 && offset < 0x1120) {
      offset -= 0x1110;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_precolor_hash_map_to_logical_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1120 && offset < 0x1130) {
      offset -= 0x1120;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selector_action_entry_size_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1130 && offset < 0x1140) {
      offset -= 0x1130;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      selector_action_adr_shift_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1140 && offset < 0x114c) {
      offset -= 0x1140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mpr_stage_id_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1150 && offset < 0x115c) {
      offset -= 0x1150;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_next_table_out_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1160 && offset < 0x116c) {
      offset -= 0x1160;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_mpr_next_table_out_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1170 && offset < 0x1180) {
      offset -= 0x1170;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_counter_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1180 && offset < 0x1190) {
      offset -= 0x1180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_counter_ctl2_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1190 && offset < 0x11a0) {
      offset -= 0x1190;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_counter_ctl3_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11a0 && offset < 0x11b0) {
      offset -= 0x11a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_fifo_level_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11b0 && offset < 0x11c0) {
      offset -= 0x11b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_watermark_threshold_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11c0 && offset < 0x11d0) {
      offset -= 0x11c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_cur_watermark_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11d8 && offset < 0x11e0) {
      offset -= 0x11d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      meter_alu_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11e0 && offset < 0x11e8) {
      offset -= 0x11e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_phys_result_delay_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11e8 && offset < 0x11f0) {
      offset -= 0x11e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_phys_result_en_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11f0 && offset < 0x11f8) {
      offset -= 0x11f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_phys_result_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11f8 && offset < 0x1200) {
      offset -= 0x11f8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_map_en_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1400 && offset < 0x1408) {
      offset -= 0x1400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_mode_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1408 && offset < 0x1410) {
      offset -= 0x1408;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_hash_group_expand_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1410 && offset < 0x1418) {
      offset -= 0x1410;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      meter_group_table_vpn_mod_enable_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1418 && offset < 0x1420) {
      offset -= 0x1418;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_alu_to_logical_map_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1420 && offset < 0x1428) {
      offset -= 0x1420;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_logical_to_meter_alu_map_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1428 && offset < 0x1430) {
      offset -= 0x1428;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      action_adr_vpn_mod_enable_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1430 && offset < 0x1438) {
      offset -= 0x1430;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      predication_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1438 && offset < 0x1440) {
      offset -= 0x1438;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mpr_thread_delay_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1440 && offset < 0x1448) {
      offset -= 0x1440;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_exact_shift_ovr_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1448 && offset < 0x1450) {
      offset -= 0x1448;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_table_active_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1450 && offset < 0x1458) {
      offset -= 0x1450;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_capture_datapath_error_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1458 && offset < 0x1460) {
      offset -= 0x1458;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_global_exec_out_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1460 && offset < 0x1468) {
      offset -= 0x1460;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_long_branch_out_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1468 && offset < 0x1470) {
      offset -= 0x1468;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_mpr_global_exec_out_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1470 && offset < 0x1478) {
      offset -= 0x1470;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_mpr_long_branch_out_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1478 && offset < 0x1480) {
      offset -= 0x1478;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_table_counter_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1480 && offset < 0x1488) {
      offset -= 0x1480;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_match_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1488 && offset < 0x1490) {
      offset -= 0x1488;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tind_ecc_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1490 && offset < 0x1498) {
      offset -= 0x1490;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gfm_parity_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1498 && offset < 0x14a0) {
      offset -= 0x1498;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      emm_ecc_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14a0 && offset < 0x14a8) {
      offset -= 0x14a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      prev_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14a8 && offset < 0x14b0) {
      offset -= 0x14a8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      err_idata_ovr_fifo_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14b0 && offset < 0x14b8) {
      offset -= 0x14b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      err_idata_ovr_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14b8 && offset < 0x14c0) {
      offset -= 0x14b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      o_error_fifo_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14c0 && offset < 0x14c8) {
      offset -= 0x14c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      s2p_stats_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14c8 && offset < 0x14d0) {
      offset -= 0x14c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      s2p_meter_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14d0 && offset < 0x14d4) {
      offset -= 0x14d0;
      exact_match_logical_result_delay_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14d4 && offset < 0x14d8) {
      offset -= 0x14d4;
      exact_match_logical_result_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14d8 && offset < 0x14dc) {
      offset -= 0x14d8;
      next_table_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14dc && offset < 0x14e0) {
      offset -= 0x14dc;
      next_table_map_en_gateway_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14e0 && offset < 0x14e4) {
      offset -= 0x14e0;
      next_table_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14e4 && offset < 0x14e8) {
      offset -= 0x14e4;
      pred_long_brch_terminate_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14e8 && offset < 0x14ec) {
      offset -= 0x14e8;
      pred_is_a_brch_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14ec && offset < 0x14f0) {
      offset -= 0x14ec;
      pred_ghost_thread_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14f0 && offset < 0x14f4) {
      offset -= 0x14f0;
      pred_stage_id_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14f4 && offset < 0x14f8) {
      offset -= 0x14f4;
      mau_immediate_data_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14f8 && offset < 0x14fc) {
      offset -= 0x14f8;
      mau_action_instruction_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14fc && offset < 0x1500) {
      offset -= 0x14fc;
      mau_actiondata_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1600 && offset < 0x1800) {
      offset -= 0x1600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_map_loca_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1a00) {
      offset -= 0x1800;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_map_glob_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1a00 && offset < 0x1c00) {
      offset -= 0x1a00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c00 && offset < 0x1e00) {
      offset -= 0x1c00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1e00 && offset < 0x2000) {
      offset -= 0x1e00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2200) {
      offset -= 0x2000;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2200 && offset < 0x2400) {
      offset -= 0x2200;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2400 && offset < 0x2600) {
      offset -= 0x2400;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2600 && offset < 0x2800) {
      offset -= 0x2600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_next_table_lut_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2900) {
      offset -= 0x2800;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      match_to_logical_table_ixbar_outputmap_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2900 && offset < 0x2a00) {
      offset -= 0x2900;
      int i2 = offset / 0x80;
      offset  -= i2 * 0x80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_map_data_[ i2 ][ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2a00 && offset < 0x2ac0) {
      offset -= 0x2a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mpr_next_table_lut_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2b00 && offset < 0x2c00) {
      offset -= 0x2b00;
      int i3 = offset / 0x20;
      offset  -= i3 * 0x20;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_data_[ i3 ][ i2 ][ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c00 && offset < 0x2c04) {
      offset -= 0x2c00;
      mau_stats_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c04 && offset < 0x2c08) {
      offset -= 0x2c04;
      mau_meter_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c08 && offset < 0x2c0c) {
      offset -= 0x2c08;
      mau_match_central_mapram_read_color_oflo_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c0c && offset < 0x2c10) {
      offset -= 0x2c0c;
      mau_idletime_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c10 && offset < 0x2c14) {
      offset -= 0x2c10;
      mau_selector_hash_sps_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c14 && offset < 0x2c18) {
      offset -= 0x2c14;
      mau_hash_group_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c18 && offset < 0x2c1c) {
      offset -= 0x2c18;
      mau_hash_group_shiftcount_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c1c && offset < 0x2c20) {
      offset -= 0x2c1c;
      meter_group_table_vpn_max_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c20 && offset < 0x2c24) {
      offset -= 0x2c20;
      mau_meter_precolor_hash_sel_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c24 && offset < 0x2c28) {
      offset -= 0x2c24;
      mpr_bus_dep_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c28 && offset < 0x2c2c) {
      offset -= 0x2c28;
      mpr_glob_exec_thread_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c2c && offset < 0x2c30) {
      offset -= 0x2c2c;
      mpr_long_brch_thread_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c30 && offset < 0x2c34) {
      offset -= 0x2c30;
      mpr_always_run_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c34 && offset < 0x2c38) {
      offset -= 0x2c34;
      gateway_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c38 && offset < 0x2c3c) {
      offset -= 0x2c38;
      mau_snapshot_logical_table_hit_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c3c && offset < 0x2c40) {
      offset -= 0x2c3c;
      mau_snapshot_gateway_table_inhibit_logical_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c80 && offset < 0x2d00) {
      offset -= 0x2c80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_payload_shifter_enable_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d00 && offset < 0x2d80) {
      offset -= 0x2d00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d80 && offset < 0x2e00) {
      offset -= 0x2d80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2e00 && offset < 0x2e80) {
      offset -= 0x2e00;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2e80 && offset < 0x2f00) {
      offset -= 0x2e80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2f00 && offset < 0x2f80) {
      offset -= 0x2f00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2f80 && offset < 0x3000) {
      offset -= 0x2f80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3080) {
      offset -= 0x3000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_vpn_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3080 && offset < 0x3100) {
      offset -= 0x3080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3100 && offset < 0x3180) {
      offset -= 0x3100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3180 && offset < 0x3200) {
      offset -= 0x3180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3200 && offset < 0x3280) {
      offset -= 0x3200;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3280 && offset < 0x3300) {
      offset -= 0x3280;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3300 && offset < 0x3380) {
      offset -= 0x3300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3380 && offset < 0x3400) {
      offset -= 0x3380;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3400 && offset < 0x3480) {
      offset -= 0x3400;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_hole_swizzle_mode_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3480 && offset < 0x3500) {
      offset -= 0x3480;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3500 && offset < 0x3580) {
      offset -= 0x3500;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3580 && offset < 0x3600) {
      offset -= 0x3580;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3600 && offset < 0x3680) {
      offset -= 0x3600;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3680 && offset < 0x3700) {
      offset -= 0x3680;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3700 && offset < 0x3780) {
      offset -= 0x3700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3780 && offset < 0x3800) {
      offset -= 0x3780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3800 && offset < 0x3880) {
      offset -= 0x3800;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3880 && offset < 0x3900) {
      offset -= 0x3880;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3900 && offset < 0x3980) {
      offset -= 0x3900;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selectorlength_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3980 && offset < 0x3a00) {
      offset -= 0x3980;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selectorlength_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3a00 && offset < 0x3a80) {
      offset -= 0x3a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selectorlength_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3a80 && offset < 0x3b00) {
      offset -= 0x3a80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_type_position_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3b00 && offset < 0x3b80) {
      offset -= 0x3b00;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_match_adr_[ i2 ][ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3b80 && offset < 0x3bc0) {
      offset -= 0x3b80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_match_adr_to_physical_oxbar_outputmap_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3bc0 && offset < 0x3c00) {
      offset -= 0x3bc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tind_ram_data_size_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c00 && offset < 0x3c40) {
      offset -= 0x3c00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      next_table_format_data_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c40 && offset < 0x3c80) {
      offset -= 0x3c40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_miss_exec_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c80 && offset < 0x3cc0) {
      offset -= 0x3c80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_miss_long_brch_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3cc0 && offset < 0x3d00) {
      offset -= 0x3cc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pred_long_brch_lt_src_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3d00 && offset < 0x3d40) {
      offset -= 0x3d00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3d40 && offset < 0x3d80) {
      offset -= 0x3d40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3d80 && offset < 0x3dc0) {
      offset -= 0x3d80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3dc0 && offset < 0x3e00) {
      offset -= 0x3dc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3e00 && offset < 0x3e40) {
      offset -= 0x3e00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3e40 && offset < 0x3e80) {
      offset -= 0x3e40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3e80 && offset < 0x3ec0) {
      offset -= 0x3e80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3ec0 && offset < 0x3f00) {
      offset -= 0x3ec0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3f00 && offset < 0x3f40) {
      offset -= 0x3f00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3f40 && offset < 0x3f80) {
      offset -= 0x3f40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3f80 && offset < 0x3fc0) {
      offset -= 0x3f80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3fc0 && offset < 0x4000) {
      offset -= 0x3fc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0xe00) {
      offset -= 0x800;
      int i0 = offset / 0x80;
      offset  -= i0 * 0x80;
      col_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mau_hash_group_xbar_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mpr_glob_exec_lut_) {
      f0.reset();
    }
    for (auto &f0 : stash_hitmap_output_map_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : stash_next_table_lut_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : stash_row_nxtable_bus_drive_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : gateway_to_logicaltable_xbar_ctl_) {
      f0.reset();
    }
    for (auto &f0 : gateway_inhibit_lut_) {
      f0.reset();
    }
    for (auto &f0 : gateway_to_pbus_xbar_ctl_) {
      f0.reset();
    }
    for (auto &f0 : exit_gateway_ctl_) {
      f0.reset();
    }
    for (auto &f0 : tind_bus_prop_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_physical_tcam_hit_address_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_physical_exact_match_hit_address_) {
      f0.reset();
    }
    for (auto &f0 : mau_table_counter_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    mau_table_counter_clear_.reset();
    mau_stateful_log_counter_clear_.reset();
    actiondata_error_ctl_.reset();
    imem_parity_error_ctl_.reset();
    for (auto &f0 : tcam_hit_to_logical_table_ixbar_outputmap_) {
      f0.reset();
    }
    for (auto &f0 : mau_hash_group_mask_) {
      f0.reset();
    }
    for (auto &f0 : mpr_long_brch_lut_) {
      f0.reset();
    }
    for (auto &f0 : gateway_payload_tind_pbus_) {
      f0.reset();
    }
    for (auto &f0 : gateway_payload_exact_pbus_) {
      f0.reset();
    }
    for (auto &f0 : gateway_payload_exact_disable_) {
      f0.reset();
    }
    for (auto &f0 : gateway_payload_tind_disable_) {
      f0.reset();
    }
    for (auto &f0 : tcam_table_prop_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_counter_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stateful_log_ctl_ixbar_map_) {
      for (auto &f1 : f0) {
        for (auto &f2 : f1) {
          f2.reset();
        }
      }
    }
    for (auto &f0 : exact_match_delay_thread_) {
      f0.reset();
    }
    for (auto &f0 : logical_table_thread_) {
      f0.reset();
    }
    for (auto &f0 : pred_glob_exec_thread_) {
      f0.reset();
    }
    for (auto &f0 : pred_long_brch_thread_) {
      f0.reset();
    }
    for (auto &f0 : pred_always_run_) {
      f0.reset();
    }
    for (auto &f0 : mau_mapram_color_map_to_logical_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mau_physical_to_meter_alu_icxbar_map_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_precolor_hash_map_to_logical_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mau_selector_action_entry_size_) {
      f0.reset();
    }
    for (auto &f0 : selector_action_adr_shift_) {
      f0.reset();
    }
    for (auto &f0 : mpr_stage_id_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_next_table_out_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_mpr_next_table_out_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_counter_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stateful_log_counter_ctl2_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_counter_ctl3_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_fifo_level_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_watermark_threshold_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_cur_watermark_) {
      f0.reset();
    }
    for (auto &f0 : meter_alu_thread_) {
      f0.reset();
    }
    for (auto &f0 : exact_match_phys_result_delay_) {
      f0.reset();
    }
    for (auto &f0 : exact_match_phys_result_en_) {
      f0.reset();
    }
    for (auto &f0 : exact_match_phys_result_thread_) {
      f0.reset();
    }
    for (auto &f0 : mau_action_instruction_adr_map_en_) {
      f0.reset();
    }
    for (auto &f0 : mau_action_instruction_adr_mode_) {
      f0.reset();
    }
    for (auto &f0 : mau_hash_group_expand_) {
      f0.reset();
    }
    for (auto &f0 : meter_group_table_vpn_mod_enable_) {
      f0.reset();
    }
    for (auto &f0 : mau_meter_alu_to_logical_map_) {
      f0.reset();
    }
    for (auto &f0 : mau_logical_to_meter_alu_map_) {
      f0.reset();
    }
    for (auto &f0 : action_adr_vpn_mod_enable_) {
      f0.reset();
    }
    for (auto &f0 : predication_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mpr_thread_delay_) {
      f0.reset();
    }
    for (auto &f0 : gateway_payload_exact_shift_ovr_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_table_active_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_capture_datapath_error_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_global_exec_out_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_long_branch_out_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_mpr_global_exec_out_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_mpr_long_branch_out_) {
      f0.reset();
    }
    for (auto &f0 : mau_table_counter_ctl_) {
      f0.reset();
    }
    for (auto &f0 : tcam_match_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : tind_ecc_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : gfm_parity_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : emm_ecc_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : prev_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : err_idata_ovr_fifo_ctl_) {
      f0.reset();
    }
    for (auto &f0 : err_idata_ovr_ctl_) {
      f0.reset();
    }
    for (auto &f0 : o_error_fifo_ctl_) {
      f0.reset();
    }
    for (auto &f0 : s2p_stats_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : s2p_meter_error_ctl_) {
      f0.reset();
    }
    exact_match_logical_result_delay_.reset();
    exact_match_logical_result_en_.reset();
    next_table_map_en_.reset();
    next_table_map_en_gateway_.reset();
    next_table_tcam_actionbit_map_en_.reset();
    pred_long_brch_terminate_.reset();
    pred_is_a_brch_.reset();
    pred_ghost_thread_.reset();
    pred_stage_id_.reset();
    mau_immediate_data_tcam_actionbit_map_en_.reset();
    mau_action_instruction_adr_tcam_actionbit_map_en_.reset();
    mau_actiondata_adr_tcam_actionbit_map_en_.reset();
    for (auto &f0 : pred_map_loca_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : pred_map_glob_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_immediate_data_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : gateway_next_table_lut_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : match_to_logical_table_ixbar_outputmap_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_map_data_) {
      for (auto &f1 : f0) {
        for (auto &f2 : f1) {
          f2.reset();
        }
      }
    }
    for (auto &f0 : mpr_next_table_lut_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : gateway_payload_data_) {
      for (auto &f1 : f0) {
        for (auto &f2 : f1) {
          for (auto &f3 : f2) {
            f3.reset();
          }
        }
      }
    }
    mau_stats_adr_tcam_actionbit_map_en_.reset();
    mau_meter_adr_tcam_actionbit_map_en_.reset();
    mau_match_central_mapram_read_color_oflo_ctl_.reset();
    mau_idletime_adr_tcam_actionbit_map_en_.reset();
    mau_selector_hash_sps_enable_.reset();
    mau_hash_group_config_.reset();
    mau_hash_group_shiftcount_.reset();
    meter_group_table_vpn_max_.reset();
    mau_meter_precolor_hash_sel_.reset();
    mpr_bus_dep_.reset();
    mpr_glob_exec_thread_.reset();
    mpr_long_brch_thread_.reset();
    mpr_always_run_.reset();
    gateway_en_.reset();
    mau_snapshot_logical_table_hit_.reset();
    mau_snapshot_gateway_table_inhibit_logical_.reset();
    for (auto &f0 : mau_payload_shifter_enable_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_immediate_data_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_immediate_data_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_immediate_data_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_vpn_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_hole_swizzle_mode_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_selectorlength_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_selectorlength_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_selectorlength_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_type_position_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : gateway_payload_match_adr_) {
      for (auto &f1 : f0) {
        for (auto &f2 : f1) {
          f2.reset();
        }
      }
    }
    for (auto &f0 : tcam_match_adr_to_physical_oxbar_outputmap_) {
      f0.reset();
    }
    for (auto &f0 : tind_ram_data_size_) {
      f0.reset();
    }
    for (auto &f0 : next_table_format_data_) {
      f0.reset();
    }
    for (auto &f0 : pred_miss_exec_) {
      f0.reset();
    }
    for (auto &f0 : pred_miss_long_brch_) {
      f0.reset();
    }
    for (auto &f0 : pred_long_brch_lt_src_) {
      f0.reset();
    }
    for (auto &f0 : mau_immediate_data_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_immediate_data_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_action_instruction_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_action_instruction_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_actiondata_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_actiondata_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_stats_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_stats_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_meter_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_meter_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_idletime_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_idletime_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : col_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x30) {
      offset -= 0x0;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_hash_group_xbar_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40 && offset < 0x80) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mpr_glob_exec_lut_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0xc0) {
      offset -= 0x80;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += stash_hitmap_output_map_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc0 && offset < 0x100) {
      offset -= 0xc0;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += stash_next_table_lut_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100 && offset < 0x140) {
      offset -= 0x100;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += stash_row_nxtable_bus_drive_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x140 && offset < 0x180) {
      offset -= 0x140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_to_logicaltable_xbar_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x180 && offset < 0x1c0) {
      offset -= 0x180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_inhibit_lut_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c0 && offset < 0x200) {
      offset -= 0x1c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_to_pbus_xbar_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x240) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exit_gateway_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x240 && offset < 0x280) {
      offset -= 0x240;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tind_bus_prop_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x280 && offset < 0x2c0) {
      offset -= 0x280;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_physical_tcam_hit_address_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c0 && offset < 0x300) {
      offset -= 0x2c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_physical_exact_match_hit_address_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x300 && offset < 0x340) {
      offset -= 0x300;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_table_counter_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x340 && offset < 0x344) {
      offset -= 0x340;
      r += mau_table_counter_clear_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x344 && offset < 0x348) {
      offset -= 0x344;
      r += mau_stateful_log_counter_clear_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x348 && offset < 0x34c) {
      offset -= 0x348;
      r += actiondata_error_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x34c && offset < 0x350) {
      offset -= 0x34c;
      r += imem_parity_error_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x360 && offset < 0x380) {
      offset -= 0x360;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_hit_to_logical_table_ixbar_outputmap_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x380 && offset < 0x398) {
      offset -= 0x380;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_hash_group_mask_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3a0 && offset < 0x3c0) {
      offset -= 0x3a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mpr_long_brch_lut_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c0 && offset < 0x3e0) {
      offset -= 0x3c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_tind_pbus_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3e0 && offset < 0x400) {
      offset -= 0x3e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_exact_pbus_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1020) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_exact_disable_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1020 && offset < 0x1040) {
      offset -= 0x1020;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_tind_disable_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1040 && offset < 0x1060) {
      offset -= 0x1040;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_table_prop_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1060 && offset < 0x1080) {
      offset -= 0x1060;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_counter_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1080 && offset < 0x10a0) {
      offset -= 0x1080;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_ctl_ixbar_map_[ i2 ][ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10a0 && offset < 0x10ac) {
      offset -= 0x10a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_delay_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10b0 && offset < 0x10bc) {
      offset -= 0x10b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += logical_table_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10c0 && offset < 0x10cc) {
      offset -= 0x10c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_glob_exec_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10d0 && offset < 0x10dc) {
      offset -= 0x10d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_long_brch_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10e0 && offset < 0x10ec) {
      offset -= 0x10e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_always_run_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10f0 && offset < 0x1100) {
      offset -= 0x10f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_mapram_color_map_to_logical_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1100 && offset < 0x1110) {
      offset -= 0x1100;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_physical_to_meter_alu_icxbar_map_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1110 && offset < 0x1120) {
      offset -= 0x1110;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_precolor_hash_map_to_logical_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1120 && offset < 0x1130) {
      offset -= 0x1120;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selector_action_entry_size_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1130 && offset < 0x1140) {
      offset -= 0x1130;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += selector_action_adr_shift_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1140 && offset < 0x114c) {
      offset -= 0x1140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mpr_stage_id_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1150 && offset < 0x115c) {
      offset -= 0x1150;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_next_table_out_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1160 && offset < 0x116c) {
      offset -= 0x1160;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_mpr_next_table_out_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1170 && offset < 0x1180) {
      offset -= 0x1170;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_counter_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1180 && offset < 0x1190) {
      offset -= 0x1180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_counter_ctl2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1190 && offset < 0x11a0) {
      offset -= 0x1190;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_counter_ctl3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11a0 && offset < 0x11b0) {
      offset -= 0x11a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_fifo_level_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11b0 && offset < 0x11c0) {
      offset -= 0x11b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_watermark_threshold_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11c0 && offset < 0x11d0) {
      offset -= 0x11c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_cur_watermark_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11d8 && offset < 0x11e0) {
      offset -= 0x11d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += meter_alu_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11e0 && offset < 0x11e8) {
      offset -= 0x11e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_phys_result_delay_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11e8 && offset < 0x11f0) {
      offset -= 0x11e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_phys_result_en_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11f0 && offset < 0x11f8) {
      offset -= 0x11f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_phys_result_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11f8 && offset < 0x1200) {
      offset -= 0x11f8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_map_en_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1400 && offset < 0x1408) {
      offset -= 0x1400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_mode_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1408 && offset < 0x1410) {
      offset -= 0x1408;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_hash_group_expand_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1410 && offset < 0x1418) {
      offset -= 0x1410;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += meter_group_table_vpn_mod_enable_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1418 && offset < 0x1420) {
      offset -= 0x1418;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_alu_to_logical_map_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1420 && offset < 0x1428) {
      offset -= 0x1420;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_logical_to_meter_alu_map_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1428 && offset < 0x1430) {
      offset -= 0x1428;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += action_adr_vpn_mod_enable_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1430 && offset < 0x1438) {
      offset -= 0x1430;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += predication_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1438 && offset < 0x1440) {
      offset -= 0x1438;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mpr_thread_delay_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1440 && offset < 0x1448) {
      offset -= 0x1440;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_exact_shift_ovr_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1448 && offset < 0x1450) {
      offset -= 0x1448;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_table_active_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1450 && offset < 0x1458) {
      offset -= 0x1450;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_capture_datapath_error_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1458 && offset < 0x1460) {
      offset -= 0x1458;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_global_exec_out_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1460 && offset < 0x1468) {
      offset -= 0x1460;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_long_branch_out_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1468 && offset < 0x1470) {
      offset -= 0x1468;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_mpr_global_exec_out_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1470 && offset < 0x1478) {
      offset -= 0x1470;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_mpr_long_branch_out_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1478 && offset < 0x1480) {
      offset -= 0x1478;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_table_counter_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1480 && offset < 0x1488) {
      offset -= 0x1480;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_match_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1488 && offset < 0x1490) {
      offset -= 0x1488;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tind_ecc_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1490 && offset < 0x1498) {
      offset -= 0x1490;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gfm_parity_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1498 && offset < 0x14a0) {
      offset -= 0x1498;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += emm_ecc_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14a0 && offset < 0x14a8) {
      offset -= 0x14a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += prev_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14a8 && offset < 0x14b0) {
      offset -= 0x14a8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += err_idata_ovr_fifo_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14b0 && offset < 0x14b8) {
      offset -= 0x14b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += err_idata_ovr_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14b8 && offset < 0x14c0) {
      offset -= 0x14b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += o_error_fifo_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14c0 && offset < 0x14c8) {
      offset -= 0x14c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += s2p_stats_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14c8 && offset < 0x14d0) {
      offset -= 0x14c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += s2p_meter_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14d0 && offset < 0x14d4) {
      offset -= 0x14d0;
      r += exact_match_logical_result_delay_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14d4 && offset < 0x14d8) {
      offset -= 0x14d4;
      r += exact_match_logical_result_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14d8 && offset < 0x14dc) {
      offset -= 0x14d8;
      r += next_table_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14dc && offset < 0x14e0) {
      offset -= 0x14dc;
      r += next_table_map_en_gateway_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14e0 && offset < 0x14e4) {
      offset -= 0x14e0;
      r += next_table_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14e4 && offset < 0x14e8) {
      offset -= 0x14e4;
      r += pred_long_brch_terminate_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14e8 && offset < 0x14ec) {
      offset -= 0x14e8;
      r += pred_is_a_brch_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14ec && offset < 0x14f0) {
      offset -= 0x14ec;
      r += pred_ghost_thread_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14f0 && offset < 0x14f4) {
      offset -= 0x14f0;
      r += pred_stage_id_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14f4 && offset < 0x14f8) {
      offset -= 0x14f4;
      r += mau_immediate_data_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14f8 && offset < 0x14fc) {
      offset -= 0x14f8;
      r += mau_action_instruction_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14fc && offset < 0x1500) {
      offset -= 0x14fc;
      r += mau_actiondata_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1600 && offset < 0x1800) {
      offset -= 0x1600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_map_loca_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1a00) {
      offset -= 0x1800;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_map_glob_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1a00 && offset < 0x1c00) {
      offset -= 0x1a00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c00 && offset < 0x1e00) {
      offset -= 0x1c00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1e00 && offset < 0x2000) {
      offset -= 0x1e00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2200) {
      offset -= 0x2000;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2200 && offset < 0x2400) {
      offset -= 0x2200;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2400 && offset < 0x2600) {
      offset -= 0x2400;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2600 && offset < 0x2800) {
      offset -= 0x2600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_next_table_lut_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2900) {
      offset -= 0x2800;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += match_to_logical_table_ixbar_outputmap_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2900 && offset < 0x2a00) {
      offset -= 0x2900;
      int i2 = offset / 0x80;
      offset  -= i2 * 0x80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_map_data_[ i2 ][ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2a00 && offset < 0x2ac0) {
      offset -= 0x2a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mpr_next_table_lut_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2b00 && offset < 0x2c00) {
      offset -= 0x2b00;
      int i3 = offset / 0x20;
      offset  -= i3 * 0x20;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_data_[ i3 ][ i2 ][ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c00 && offset < 0x2c04) {
      offset -= 0x2c00;
      r += mau_stats_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c04 && offset < 0x2c08) {
      offset -= 0x2c04;
      r += mau_meter_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c08 && offset < 0x2c0c) {
      offset -= 0x2c08;
      r += mau_match_central_mapram_read_color_oflo_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c0c && offset < 0x2c10) {
      offset -= 0x2c0c;
      r += mau_idletime_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c10 && offset < 0x2c14) {
      offset -= 0x2c10;
      r += mau_selector_hash_sps_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c14 && offset < 0x2c18) {
      offset -= 0x2c14;
      r += mau_hash_group_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c18 && offset < 0x2c1c) {
      offset -= 0x2c18;
      r += mau_hash_group_shiftcount_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c1c && offset < 0x2c20) {
      offset -= 0x2c1c;
      r += meter_group_table_vpn_max_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c20 && offset < 0x2c24) {
      offset -= 0x2c20;
      r += mau_meter_precolor_hash_sel_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c24 && offset < 0x2c28) {
      offset -= 0x2c24;
      r += mpr_bus_dep_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c28 && offset < 0x2c2c) {
      offset -= 0x2c28;
      r += mpr_glob_exec_thread_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c2c && offset < 0x2c30) {
      offset -= 0x2c2c;
      r += mpr_long_brch_thread_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c30 && offset < 0x2c34) {
      offset -= 0x2c30;
      r += mpr_always_run_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c34 && offset < 0x2c38) {
      offset -= 0x2c34;
      r += gateway_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c38 && offset < 0x2c3c) {
      offset -= 0x2c38;
      r += mau_snapshot_logical_table_hit_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c3c && offset < 0x2c40) {
      offset -= 0x2c3c;
      r += mau_snapshot_gateway_table_inhibit_logical_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c80 && offset < 0x2d00) {
      offset -= 0x2c80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_payload_shifter_enable_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d00 && offset < 0x2d80) {
      offset -= 0x2d00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d80 && offset < 0x2e00) {
      offset -= 0x2d80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2e00 && offset < 0x2e80) {
      offset -= 0x2e00;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2e80 && offset < 0x2f00) {
      offset -= 0x2e80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2f00 && offset < 0x2f80) {
      offset -= 0x2f00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2f80 && offset < 0x3000) {
      offset -= 0x2f80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3080) {
      offset -= 0x3000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_vpn_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3080 && offset < 0x3100) {
      offset -= 0x3080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3100 && offset < 0x3180) {
      offset -= 0x3100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3180 && offset < 0x3200) {
      offset -= 0x3180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3200 && offset < 0x3280) {
      offset -= 0x3200;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3280 && offset < 0x3300) {
      offset -= 0x3280;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3300 && offset < 0x3380) {
      offset -= 0x3300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3380 && offset < 0x3400) {
      offset -= 0x3380;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3400 && offset < 0x3480) {
      offset -= 0x3400;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_hole_swizzle_mode_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3480 && offset < 0x3500) {
      offset -= 0x3480;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3500 && offset < 0x3580) {
      offset -= 0x3500;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3580 && offset < 0x3600) {
      offset -= 0x3580;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3600 && offset < 0x3680) {
      offset -= 0x3600;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3680 && offset < 0x3700) {
      offset -= 0x3680;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3700 && offset < 0x3780) {
      offset -= 0x3700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3780 && offset < 0x3800) {
      offset -= 0x3780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3800 && offset < 0x3880) {
      offset -= 0x3800;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3880 && offset < 0x3900) {
      offset -= 0x3880;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3900 && offset < 0x3980) {
      offset -= 0x3900;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selectorlength_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3980 && offset < 0x3a00) {
      offset -= 0x3980;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selectorlength_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3a00 && offset < 0x3a80) {
      offset -= 0x3a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selectorlength_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3a80 && offset < 0x3b00) {
      offset -= 0x3a80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_type_position_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3b00 && offset < 0x3b80) {
      offset -= 0x3b00;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_match_adr_[ i2 ][ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3b80 && offset < 0x3bc0) {
      offset -= 0x3b80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_match_adr_to_physical_oxbar_outputmap_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3bc0 && offset < 0x3c00) {
      offset -= 0x3bc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tind_ram_data_size_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c00 && offset < 0x3c40) {
      offset -= 0x3c00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += next_table_format_data_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c40 && offset < 0x3c80) {
      offset -= 0x3c40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_miss_exec_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c80 && offset < 0x3cc0) {
      offset -= 0x3c80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_miss_long_brch_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3cc0 && offset < 0x3d00) {
      offset -= 0x3cc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pred_long_brch_lt_src_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3d00 && offset < 0x3d40) {
      offset -= 0x3d00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3d40 && offset < 0x3d80) {
      offset -= 0x3d40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3d80 && offset < 0x3dc0) {
      offset -= 0x3d80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3dc0 && offset < 0x3e00) {
      offset -= 0x3dc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3e00 && offset < 0x3e40) {
      offset -= 0x3e00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3e40 && offset < 0x3e80) {
      offset -= 0x3e40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3e80 && offset < 0x3ec0) {
      offset -= 0x3e80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3ec0 && offset < 0x3f00) {
      offset -= 0x3ec0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3f00 && offset < 0x3f40) {
      offset -= 0x3f00;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3f40 && offset < 0x3f80) {
      offset -= 0x3f40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3f80 && offset < 0x3fc0) {
      offset -= 0x3f80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3fc0 && offset < 0x4000) {
      offset -= 0x3fc0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0xe00) {
      offset -= 0x800;
      int i0 = offset / 0x80;
      offset  -= i0 * 0x80;
      r += col_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a1=0;a1<6;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_hash_group_xbar_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mpr_glob_exec_lut_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += stash_hitmap_output_map_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += stash_next_table_lut_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += stash_row_nxtable_bus_drive_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += gateway_to_logicaltable_xbar_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += gateway_inhibit_lut_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += gateway_to_pbus_xbar_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += exit_gateway_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += tind_bus_prop_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_snapshot_physical_tcam_hit_address_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_snapshot_physical_exact_match_hit_address_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<1;++a0) {
        r += mau_table_counter_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    r += mau_table_counter_clear_.to_string(print_zeros,indent_string) ;
    r += mau_stateful_log_counter_clear_.to_string(print_zeros,indent_string) ;
    r += actiondata_error_ctl_.to_string(print_zeros,indent_string) ;
    r += imem_parity_error_ctl_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<8;++a0) {
      r += tcam_hit_to_logical_table_ixbar_outputmap_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<6;++a0) {
      r += mau_hash_group_mask_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += mpr_long_brch_lut_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += gateway_payload_tind_pbus_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += gateway_payload_exact_pbus_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += gateway_payload_exact_disable_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += gateway_payload_tind_disable_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += tcam_table_prop_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<4;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_stateful_log_counter_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a2=0;a2<2;++a2) {
      for (uint32_t a1=0;a1<2;++a1) {
        for (uint32_t a0=0;a0<2;++a0) {
          r += mau_stateful_log_ctl_ixbar_map_[a2][a1][a0].to_string(print_zeros,indent_string) ;
        }
      }
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += exact_match_delay_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += logical_table_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += pred_glob_exec_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += pred_long_brch_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += pred_always_run_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_mapram_color_map_to_logical_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_physical_to_meter_alu_icxbar_map_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_meter_precolor_hash_map_to_logical_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_selector_action_entry_size_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += selector_action_adr_shift_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += mpr_stage_id_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += mau_snapshot_next_table_out_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += mau_snapshot_mpr_next_table_out_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_stateful_log_counter_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_stateful_log_counter_ctl2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_stateful_log_counter_ctl3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_stateful_log_fifo_level_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_stateful_log_watermark_threshold_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_stateful_log_cur_watermark_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += meter_alu_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += exact_match_phys_result_delay_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += exact_match_phys_result_en_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += exact_match_phys_result_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_action_instruction_adr_map_en_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_action_instruction_adr_mode_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_hash_group_expand_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += meter_group_table_vpn_mod_enable_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_meter_alu_to_logical_map_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_logical_to_meter_alu_map_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += action_adr_vpn_mod_enable_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += predication_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mpr_thread_delay_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += gateway_payload_exact_shift_ovr_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_table_active_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_capture_datapath_error_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_global_exec_out_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_long_branch_out_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_mpr_global_exec_out_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_mpr_long_branch_out_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_table_counter_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += tcam_match_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += tind_ecc_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += gfm_parity_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += emm_ecc_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += prev_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += err_idata_ovr_fifo_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += err_idata_ovr_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += o_error_fifo_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += s2p_stats_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += s2p_meter_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    r += exact_match_logical_result_delay_.to_string(print_zeros,indent_string) ;
    r += exact_match_logical_result_en_.to_string(print_zeros,indent_string) ;
    r += next_table_map_en_.to_string(print_zeros,indent_string) ;
    r += next_table_map_en_gateway_.to_string(print_zeros,indent_string) ;
    r += next_table_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += pred_long_brch_terminate_.to_string(print_zeros,indent_string) ;
    r += pred_is_a_brch_.to_string(print_zeros,indent_string) ;
    r += pred_ghost_thread_.to_string(print_zeros,indent_string) ;
    r += pred_stage_id_.to_string(print_zeros,indent_string) ;
    r += mau_immediate_data_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_action_instruction_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_actiondata_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += pred_map_loca_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += pred_map_glob_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_immediate_data_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_action_instruction_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_actiondata_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_stats_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_meter_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_idletime_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += gateway_next_table_lut_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<4;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += match_to_logical_table_ixbar_outputmap_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a2=0;a2<2;++a2) {
      for (uint32_t a1=0;a1<16;++a1) {
        for (uint32_t a0=0;a0<2;++a0) {
          r += mau_action_instruction_adr_map_data_[a2][a1][a0].to_string(print_zeros,indent_string) ;
        }
      }
    }
    for (uint32_t a1=0;a1<3;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mpr_next_table_lut_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a3=0;a3<8;++a3) {
      for (uint32_t a2=0;a2<2;++a2) {
        for (uint32_t a1=0;a1<2;++a1) {
          for (uint32_t a0=0;a0<2;++a0) {
            r += gateway_payload_data_[a3][a2][a1][a0].to_string(print_zeros,indent_string) ;
          }
        }
      }
    }
    r += mau_stats_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_meter_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_match_central_mapram_read_color_oflo_ctl_.to_string(print_zeros,indent_string) ;
    r += mau_idletime_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_selector_hash_sps_enable_.to_string(print_zeros,indent_string) ;
    r += mau_hash_group_config_.to_string(print_zeros,indent_string) ;
    r += mau_hash_group_shiftcount_.to_string(print_zeros,indent_string) ;
    r += meter_group_table_vpn_max_.to_string(print_zeros,indent_string) ;
    r += mau_meter_precolor_hash_sel_.to_string(print_zeros,indent_string) ;
    r += mpr_bus_dep_.to_string(print_zeros,indent_string) ;
    r += mpr_glob_exec_thread_.to_string(print_zeros,indent_string) ;
    r += mpr_long_brch_thread_.to_string(print_zeros,indent_string) ;
    r += mpr_always_run_.to_string(print_zeros,indent_string) ;
    r += gateway_en_.to_string(print_zeros,indent_string) ;
    r += mau_snapshot_logical_table_hit_.to_string(print_zeros,indent_string) ;
    r += mau_snapshot_gateway_table_inhibit_logical_.to_string(print_zeros,indent_string) ;
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_payload_shifter_enable_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_immediate_data_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_immediate_data_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_immediate_data_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_action_instruction_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_action_instruction_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_action_instruction_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_vpn_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_actiondata_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_hole_swizzle_mode_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_stats_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_meter_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_idletime_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_idletime_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_idletime_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_idletime_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_selectorlength_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_selectorlength_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_selectorlength_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_type_position_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a2=0;a2<8;++a2) {
      for (uint32_t a1=0;a1<2;++a1) {
        for (uint32_t a0=0;a0<2;++a0) {
          r += gateway_payload_match_adr_[a2][a1][a0].to_string(print_zeros,indent_string) ;
        }
      }
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += tcam_match_adr_to_physical_oxbar_outputmap_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += tind_ram_data_size_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += next_table_format_data_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += pred_miss_exec_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += pred_miss_long_brch_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += pred_long_brch_lt_src_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_immediate_data_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_immediate_data_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_action_instruction_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_action_instruction_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_actiondata_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_actiondata_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_stats_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_stats_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_meter_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_meter_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_idletime_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_idletime_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<12;++a0) {
      r += col_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< std::array< MauHashGroupXbarCtl, 2 >, 6 > mau_hash_group_xbar_ctl_;
  std::array< MprGlobExecLut, 16 > mpr_glob_exec_lut_;
  std::array< std::array< StashHitmapOutputMap, 8 >, 2 > stash_hitmap_output_map_;
  std::array< std::array< StashNextTableLut, 8 >, 2 > stash_next_table_lut_;
  std::array< std::array< StashRowNxtableBusDrive, 8 >, 2 > stash_row_nxtable_bus_drive_;
  std::array< GatewayToLogicaltableXbarCtl, 16 > gateway_to_logicaltable_xbar_ctl_;
  std::array< GatewayInhibitLut, 16 > gateway_inhibit_lut_;
  std::array< GatewayToPbusXbarCtl, 16 > gateway_to_pbus_xbar_ctl_;
  std::array< ExitGatewayCtl, 16 > exit_gateway_ctl_;
  std::array< TindBusProp, 16 > tind_bus_prop_;
  std::array< MauSnapshotPhysicalTcamHitAddress, 16 > mau_snapshot_physical_tcam_hit_address_;
  std::array< MauSnapshotPhysicalExactMatchHitAddress, 16 > mau_snapshot_physical_exact_match_hit_address_;
  std::array< std::array< MauTableCounter, 1 >, 16 > mau_table_counter_;
  MauTableCounterClear mau_table_counter_clear_;
  MauStatefulLogCounterClear mau_stateful_log_counter_clear_;
  ActiondataErrorCtl actiondata_error_ctl_;
  ImemParityErrorCtl imem_parity_error_ctl_;
  std::array< TcamHitToLogicalTableIxbarOutputmap, 8 > tcam_hit_to_logical_table_ixbar_outputmap_;
  std::array< MauHashGroupMask, 6 > mau_hash_group_mask_;
  std::array< MprLongBrchLut, 8 > mpr_long_brch_lut_;
  std::array< GatewayPayloadTindPbus, 8 > gateway_payload_tind_pbus_;
  std::array< GatewayPayloadExactPbus, 8 > gateway_payload_exact_pbus_;
  std::array< GatewayPayloadExactDisable, 8 > gateway_payload_exact_disable_;
  std::array< GatewayPayloadTindDisable, 8 > gateway_payload_tind_disable_;
  std::array< TcamTableProp, 8 > tcam_table_prop_;
  std::array< std::array< MauStatefulLogCounter, 2 >, 4 > mau_stateful_log_counter_;
  std::array< std::array< std::array< MauStatefulLogCtlIxbarMap, 2 >, 2 >, 2 > mau_stateful_log_ctl_ixbar_map_;
  std::array< ExactMatchDelayThread, 3 > exact_match_delay_thread_;
  std::array< LogicalTableThread, 3 > logical_table_thread_;
  std::array< PredGlobExecThread, 3 > pred_glob_exec_thread_;
  std::array< PredLongBrchThread, 3 > pred_long_brch_thread_;
  std::array< PredAlwaysRun, 3 > pred_always_run_;
  std::array< MauMapramColorMapToLogicalCtl, 4 > mau_mapram_color_map_to_logical_ctl_;
  std::array< std::array< MauPhysicalToMeterAluIcxbarMap, 2 >, 2 > mau_physical_to_meter_alu_icxbar_map_;
  std::array< MauMeterPrecolorHashMapToLogicalCtl, 4 > mau_meter_precolor_hash_map_to_logical_ctl_;
  std::array< MauSelectorActionEntrySize, 4 > mau_selector_action_entry_size_;
  std::array< SelectorActionAdrShift, 4 > selector_action_adr_shift_;
  std::array< MprStageId, 3 > mpr_stage_id_;
  std::array< MauSnapshotNextTableOut, 3 > mau_snapshot_next_table_out_;
  std::array< MauSnapshotMprNextTableOut, 3 > mau_snapshot_mpr_next_table_out_;
  std::array< std::array< MauStatefulLogCounterCtl, 2 >, 2 > mau_stateful_log_counter_ctl_;
  std::array< MauStatefulLogCounterCtl2, 4 > mau_stateful_log_counter_ctl2_;
  std::array< MauStatefulLogCounterCtl3, 4 > mau_stateful_log_counter_ctl3_;
  std::array< MauStatefulLogFifoLevel, 4 > mau_stateful_log_fifo_level_;
  std::array< MauStatefulLogWatermarkThreshold, 4 > mau_stateful_log_watermark_threshold_;
  std::array< MauStatefulLogCurWatermark, 4 > mau_stateful_log_cur_watermark_;
  std::array< MeterAluThread, 2 > meter_alu_thread_;
  std::array< ExactMatchPhysResultDelay, 2 > exact_match_phys_result_delay_;
  std::array< ExactMatchPhysResultEn, 2 > exact_match_phys_result_en_;
  std::array< ExactMatchPhysResultThread, 2 > exact_match_phys_result_thread_;
  std::array< MauActionInstructionAdrMapEn, 2 > mau_action_instruction_adr_map_en_;
  std::array< MauActionInstructionAdrMode, 2 > mau_action_instruction_adr_mode_;
  std::array< MauHashGroupExpand, 2 > mau_hash_group_expand_;
  std::array< MeterGroupTableVpnModEnable, 2 > meter_group_table_vpn_mod_enable_;
  std::array< MauMeterAluToLogicalMap, 2 > mau_meter_alu_to_logical_map_;
  std::array< MauLogicalToMeterAluMap, 2 > mau_logical_to_meter_alu_map_;
  std::array< ActionAdrVpnModEnable, 2 > action_adr_vpn_mod_enable_;
  std::array< PredicationCtl, 2 > predication_ctl_;
  std::array< MprThreadDelay, 2 > mpr_thread_delay_;
  std::array< GatewayPayloadExactShiftOvr, 2 > gateway_payload_exact_shift_ovr_;
  std::array< MauSnapshotTableActive, 2 > mau_snapshot_table_active_;
  std::array< MauSnapshotCaptureDatapathError, 2 > mau_snapshot_capture_datapath_error_;
  std::array< MauSnapshotGlobalExecOut, 2 > mau_snapshot_global_exec_out_;
  std::array< MauSnapshotLongBranchOut, 2 > mau_snapshot_long_branch_out_;
  std::array< MauSnapshotMprGlobalExecOut, 2 > mau_snapshot_mpr_global_exec_out_;
  std::array< MauSnapshotMprLongBranchOut, 2 > mau_snapshot_mpr_long_branch_out_;
  std::array< MauTableCounterCtl, 2 > mau_table_counter_ctl_;
  std::array< TcamMatchErrorCtl, 2 > tcam_match_error_ctl_;
  std::array< TindEccErrorCtl, 2 > tind_ecc_error_ctl_;
  std::array< GfmParityErrorCtl, 2 > gfm_parity_error_ctl_;
  std::array< EmmEccErrorCtl, 2 > emm_ecc_error_ctl_;
  std::array< PrevErrorCtl, 2 > prev_error_ctl_;
  std::array< ErrIdataOvrFifoCtl, 2 > err_idata_ovr_fifo_ctl_;
  std::array< ErrIdataOvrCtl, 2 > err_idata_ovr_ctl_;
  std::array< OErrorFifoCtl, 2 > o_error_fifo_ctl_;
  std::array< S2pStatsErrorCtl, 2 > s2p_stats_error_ctl_;
  std::array< S2pMeterErrorCtl, 2 > s2p_meter_error_ctl_;
  ExactMatchLogicalResultDelay exact_match_logical_result_delay_;
  ExactMatchLogicalResultEn exact_match_logical_result_en_;
  NextTableMapEn next_table_map_en_;
  NextTableMapEnGateway next_table_map_en_gateway_;
  NextTableTcamActionbitMapEn next_table_tcam_actionbit_map_en_;
  PredLongBrchTerminate pred_long_brch_terminate_;
  PredIsABrch pred_is_a_brch_;
  PredGhostThread pred_ghost_thread_;
  PredStageId pred_stage_id_;
  MauImmediateDataTcamActionbitMapEn mau_immediate_data_tcam_actionbit_map_en_;
  MauActionInstructionAdrTcamActionbitMapEn mau_action_instruction_adr_tcam_actionbit_map_en_;
  MauActiondataAdrTcamActionbitMapEn mau_actiondata_adr_tcam_actionbit_map_en_;
  std::array< std::array< PredMapLoca, 8 >, 16 > pred_map_loca_;
  std::array< std::array< PredMapGlob, 8 >, 16 > pred_map_glob_;
  std::array< std::array< MauImmediateDataExactShiftcount, 5 >, 16 > mau_immediate_data_exact_shiftcount_;
  std::array< std::array< MauActionInstructionAdrExactShiftcount, 5 >, 16 > mau_action_instruction_adr_exact_shiftcount_;
  std::array< std::array< MauActiondataAdrExactShiftcount, 5 >, 16 > mau_actiondata_adr_exact_shiftcount_;
  std::array< std::array< MauStatsAdrExactShiftcount, 5 >, 16 > mau_stats_adr_exact_shiftcount_;
  std::array< std::array< MauMeterAdrExactShiftcount, 5 >, 16 > mau_meter_adr_exact_shiftcount_;
  std::array< std::array< MauIdletimeAdrExactShiftcount, 5 >, 16 > mau_idletime_adr_exact_shiftcount_;
  std::array< std::array< GatewayNextTableLut, 5 >, 16 > gateway_next_table_lut_;
  std::array< std::array< MatchToLogicalTableIxbarOutputmap, 16 >, 4 > match_to_logical_table_ixbar_outputmap_;
  std::array< std::array< std::array< MauActionInstructionAdrMapData, 2 >, 16 >, 2 > mau_action_instruction_adr_map_data_;
  std::array< std::array< MprNextTableLut, 16 >, 3 > mpr_next_table_lut_;
  std::array< std::array< std::array< std::array< GatewayPayloadData, 2 >, 2 >, 2 >, 8 > gateway_payload_data_;
  MauStatsAdrTcamActionbitMapEn mau_stats_adr_tcam_actionbit_map_en_;
  MauMeterAdrTcamActionbitMapEn mau_meter_adr_tcam_actionbit_map_en_;
  MauMatchCentralMapramReadColorOfloCtl mau_match_central_mapram_read_color_oflo_ctl_;
  MauIdletimeAdrTcamActionbitMapEn mau_idletime_adr_tcam_actionbit_map_en_;
  MauSelectorHashSpsEnable mau_selector_hash_sps_enable_;
  MauHashGroupConfig mau_hash_group_config_;
  MauHashGroupShiftcount mau_hash_group_shiftcount_;
  MeterGroupTableVpnMax meter_group_table_vpn_max_;
  MauMeterPrecolorHashSel mau_meter_precolor_hash_sel_;
  MprBusDep mpr_bus_dep_;
  MprGlobExecThread mpr_glob_exec_thread_;
  MprLongBrchThread mpr_long_brch_thread_;
  MprAlwaysRun mpr_always_run_;
  GatewayEn gateway_en_;
  MauSnapshotLogicalTableHit mau_snapshot_logical_table_hit_;
  MauSnapshotGatewayTableInhibitLogical mau_snapshot_gateway_table_inhibit_logical_;
  std::array< std::array< MauPayloadShifterEnable, 16 >, 2 > mau_payload_shifter_enable_;
  std::array< std::array< MauImmediateDataMask, 16 >, 2 > mau_immediate_data_mask_;
  std::array< std::array< MauImmediateDataDefault, 16 >, 2 > mau_immediate_data_default_;
  std::array< std::array< MauImmediateDataTcamActionbitMapData, 2 >, 16 > mau_immediate_data_tcam_actionbit_map_data_;
  std::array< std::array< MauActionInstructionAdrMask, 16 >, 2 > mau_action_instruction_adr_mask_;
  std::array< std::array< MauActionInstructionAdrDefault, 16 >, 2 > mau_action_instruction_adr_default_;
  std::array< std::array< MauActionInstructionAdrPerEntryEnMuxCtl, 16 >, 2 > mau_action_instruction_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauActiondataAdrVpnShiftcount, 16 >, 2 > mau_actiondata_adr_vpn_shiftcount_;
  std::array< std::array< MauActiondataAdrMask, 16 >, 2 > mau_actiondata_adr_mask_;
  std::array< std::array< MauActiondataAdrDefault, 16 >, 2 > mau_actiondata_adr_default_;
  std::array< std::array< MauActiondataAdrPerEntryEnMuxCtl, 16 >, 2 > mau_actiondata_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauActiondataAdrTcamActionbitMapData, 2 >, 16 > mau_actiondata_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauStatsAdrMask, 16 >, 2 > mau_stats_adr_mask_;
  std::array< std::array< MauStatsAdrDefault, 16 >, 2 > mau_stats_adr_default_;
  std::array< std::array< MauStatsAdrPerEntryEnMuxCtl, 16 >, 2 > mau_stats_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauStatsAdrHoleSwizzleMode, 16 >, 2 > mau_stats_adr_hole_swizzle_mode_;
  std::array< std::array< MauStatsAdrTcamActionbitMapData, 2 >, 16 > mau_stats_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauMeterAdrMask, 16 >, 2 > mau_meter_adr_mask_;
  std::array< std::array< MauMeterAdrDefault, 16 >, 2 > mau_meter_adr_default_;
  std::array< std::array< MauMeterAdrPerEntryEnMuxCtl, 16 >, 2 > mau_meter_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauMeterAdrTcamActionbitMapData, 2 >, 16 > mau_meter_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauIdletimeAdrMask, 16 >, 2 > mau_idletime_adr_mask_;
  std::array< std::array< MauIdletimeAdrDefault, 16 >, 2 > mau_idletime_adr_default_;
  std::array< std::array< MauIdletimeAdrTcamActionbitMapData, 2 >, 16 > mau_idletime_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauIdletimeAdrPerEntryEnMuxCtl, 16 >, 2 > mau_idletime_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauSelectorlengthShiftcount, 16 >, 2 > mau_selectorlength_shiftcount_;
  std::array< std::array< MauSelectorlengthMask, 16 >, 2 > mau_selectorlength_mask_;
  std::array< std::array< MauSelectorlengthDefault, 16 >, 2 > mau_selectorlength_default_;
  std::array< std::array< MauMeterAdrTypePosition, 16 >, 2 > mau_meter_adr_type_position_;
  std::array< std::array< std::array< GatewayPayloadMatchAdr, 2 >, 2 >, 8 > gateway_payload_match_adr_;
  std::array< TcamMatchAdrToPhysicalOxbarOutputmap, 16 > tcam_match_adr_to_physical_oxbar_outputmap_;
  std::array< TindRamDataSize, 16 > tind_ram_data_size_;
  std::array< NextTableFormatData, 16 > next_table_format_data_;
  std::array< PredMissExec, 16 > pred_miss_exec_;
  std::array< PredMissLongBrch, 16 > pred_miss_long_brch_;
  std::array< PredLongBrchLtSrc, 16 > pred_long_brch_lt_src_;
  std::array< MauImmediateDataTcamShiftcount, 16 > mau_immediate_data_tcam_shiftcount_;
  std::array< MauImmediateDataMissValue, 16 > mau_immediate_data_miss_value_;
  std::array< MauActionInstructionAdrTcamShiftcount, 16 > mau_action_instruction_adr_tcam_shiftcount_;
  std::array< MauActionInstructionAdrMissValue, 16 > mau_action_instruction_adr_miss_value_;
  std::array< MauActiondataAdrTcamShiftcount, 16 > mau_actiondata_adr_tcam_shiftcount_;
  std::array< MauActiondataAdrMissValue, 16 > mau_actiondata_adr_miss_value_;
  std::array< MauStatsAdrTcamShiftcount, 16 > mau_stats_adr_tcam_shiftcount_;
  std::array< MauStatsAdrMissValue, 16 > mau_stats_adr_miss_value_;
  std::array< MauMeterAdrTcamShiftcount, 16 > mau_meter_adr_tcam_shiftcount_;
  std::array< MauMeterAdrMissValue, 16 > mau_meter_adr_miss_value_;
  std::array< MauIdletimeAdrTcamShiftcount, 16 > mau_idletime_adr_tcam_shiftcount_;
  std::array< MauIdletimeAdrMissValue, 16 > mau_idletime_adr_miss_value_;
  std::array< MauMatchMergeColAddrmap, 12 > col_;
private:
  static int StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    int offset=0;
    offset += 0x4000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x1000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x80000; // mau_addrmap[]
    offset += 0x60000; // to get to rams
    offset += 0x18000; // to get to match
    offset += 0x4000; // to get to merge
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace jbay

#endif // __REGISTER_INCLUDES_MAU_MATCH_MERGE_ADDRMAP_H__
