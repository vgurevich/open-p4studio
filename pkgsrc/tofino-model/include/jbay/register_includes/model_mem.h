/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/



#ifndef ___JBAY_REGISTER_INCLUDES_MODEL_MEM_H__
#define ___JBAY_REGISTER_INCLUDES_MODEL_MEM_H__
#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>
namespace jbay {
  namespace memory_classes {









class PgrPhase0Meta : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPhase0Meta(
      int chipNumber, int index_pipe_addrmap, int index_pgr_phase0_meta, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_phase0_meta), 1, false, write_callback, read_callback, std::string("PgrPhase0Meta")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_phase0_meta))
    {
    }
  PgrPhase0Meta(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrPhase0Meta")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0Meta") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0Meta") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_phase0_meta
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    assert(index_pgr_phase0_meta < 72);
    offset += index_pgr_phase0_meta * 0x1; // pgr_phase0_meta[]
    return offset;
  }

};









class PgrPhase0MetaMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPhase0MetaMutable(
      int chipNumber, int index_pipe_addrmap, int index_pgr_phase0_meta, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_phase0_meta), 1, true, write_callback, read_callback, std::string("PgrPhase0MetaMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_phase0_meta))
    {
    }
  PgrPhase0MetaMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrPhase0MetaMutable")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0MetaMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0MetaMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_phase0_meta
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    assert(index_pgr_phase0_meta < 72);
    offset += index_pgr_phase0_meta * 0x1; // pgr_phase0_meta[]
    return offset;
  }

};









class PgrPhase0MetaArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrPhase0MetaArray(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), false, write_callback, read_callback, std::string("PgrPhase0MetaArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrPhase0MetaArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrPhase0MetaArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrPhase0Meta> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PgrPhase0MetaArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrPhase0MetaArrayMutable(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), true, write_callback, read_callback, std::string("PgrPhase0MetaArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrPhase0MetaArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrPhase0MetaArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrPhase0MetaMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PgrPh0Rspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPh0Rspec(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 256, false, write_callback, read_callback, std::string("PgrPh0Rspec")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrPh0Rspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrPh0Rspec")
    {
    }
public:








  PgrPhase0Meta &phase0_mem_word(int j0) { return phase0_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      phase0_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      phase0_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : phase0_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += phase0_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<72;++a0) {
      r += phase0_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrPhase0Meta, 72 > phase0_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

};








class PgrPh0RspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPh0RspecMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 256, true, write_callback, read_callback, std::string("PgrPh0RspecMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrPh0RspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrPh0RspecMutable")
    {
    }
public:








  PgrPhase0MetaMutable &phase0_mem_word(int j0) { return phase0_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      phase0_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      phase0_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : phase0_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += phase0_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<72;++a0) {
      r += phase0_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrPhase0MetaMutable, 72 > phase0_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

};









class PgrBufferMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrBufferMemWord(
      int chipNumber, int index_pipe_addrmap, int index_pgr_buffer_mem_word, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_buffer_mem_word), 1, false, write_callback, read_callback, std::string("PgrBufferMemWord")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_buffer_mem_word))
    {
    }
  PgrBufferMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrBufferMemWord")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWord") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWord") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_buffer_mem_word
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    assert(index_pgr_buffer_mem_word < 1024);
    offset += index_pgr_buffer_mem_word * 0x1; // pgr_buffer_mem_word[]
    return offset;
  }

};









class PgrBufferMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrBufferMemWordMutable(
      int chipNumber, int index_pipe_addrmap, int index_pgr_buffer_mem_word, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_buffer_mem_word), 1, true, write_callback, read_callback, std::string("PgrBufferMemWordMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_buffer_mem_word))
    {
    }
  PgrBufferMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrBufferMemWordMutable")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWordMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWordMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_buffer_mem_word
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    assert(index_pgr_buffer_mem_word < 1024);
    offset += index_pgr_buffer_mem_word * 0x1; // pgr_buffer_mem_word[]
    return offset;
  }

};









class PgrBufferMemWordArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrBufferMemWordArray(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), false, write_callback, read_callback, std::string("PgrBufferMemWordArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrBufferMemWordArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrBufferMemWordArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrBufferMemWord> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PgrBufferMemWordArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrBufferMemWordArrayMutable(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), true, write_callback, read_callback, std::string("PgrBufferMemWordArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrBufferMemWordArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrBufferMemWordArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrBufferMemWordMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PgrMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrMemRspec(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 8192, false, write_callback, read_callback, std::string("PgrMemRspec")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrMemRspec")
    {
    }
public:








  PgrBufferMemWord &buffer_mem_word(int j0) { return buffer_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      buffer_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      buffer_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : buffer_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += buffer_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<1024;++a0) {
      r += buffer_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrBufferMemWord, 1024 > buffer_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

};








class PgrMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrMemRspecMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 8192, true, write_callback, read_callback, std::string("PgrMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrMemRspecMutable")
    {
    }
public:








  PgrBufferMemWordMutable &buffer_mem_word(int j0) { return buffer_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      buffer_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      buffer_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : buffer_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += buffer_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<1024;++a0) {
      r += buffer_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrBufferMemWordMutable, 1024 > buffer_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

};







class PrsrPoCsumCtrlRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, index_prsr_po_csum_ctrl_row), 1, false, write_callback, read_callback, std::string("PrsrPoCsumCtrlRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_csum_ctrl_row))
    {
    }
  PrsrPoCsumCtrlRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrPoCsumCtrlRow")
    {
    }
public:





  uint16_t &add() { return add_; }







  uint8_t &swap(int j0) { return swap_[j0]; }






  uint8_t &shr() { return shr_; }







  uint8_t &mask(int j0) { return mask_[j0]; }






  uint8_t &dst_bit_hdr_end_pos() { return dst_bit_hdr_end_pos_; }






  uint8_t &dst() { return dst_; }







  uint8_t &hdr_end() { return hdr_end_; }







  uint8_t &type() { return type_; }





  uint8_t &start() { return start_; }







  uint8_t &zeros_as_ones() { return zeros_as_ones_; }






  uint8_t &zeros_as_ones_pos() { return zeros_as_ones_pos_; }







  uint8_t &mul_2(int j0) { return mul_2_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= ((static_cast<uint64_t>(swap_[0]) & 0x1) << 16);
    *data0 |= ((static_cast<uint64_t>(swap_[1]) & 0x1) << 17);
    *data0 |= ((static_cast<uint64_t>(swap_[2]) & 0x1) << 18);
    *data0 |= ((static_cast<uint64_t>(swap_[3]) & 0x1) << 19);
    *data0 |= ((static_cast<uint64_t>(swap_[4]) & 0x1) << 20);
    *data0 |= ((static_cast<uint64_t>(swap_[5]) & 0x1) << 21);
    *data0 |= ((static_cast<uint64_t>(swap_[6]) & 0x1) << 22);
    *data0 |= ((static_cast<uint64_t>(swap_[7]) & 0x1) << 23);
    *data0 |= ((static_cast<uint64_t>(swap_[8]) & 0x1) << 24);
    *data0 |= ((static_cast<uint64_t>(swap_[9]) & 0x1) << 25);
    *data0 |= ((static_cast<uint64_t>(swap_[10]) & 0x1) << 26);
    *data0 |= ((static_cast<uint64_t>(swap_[11]) & 0x1) << 27);
    *data0 |= ((static_cast<uint64_t>(swap_[12]) & 0x1) << 28);
    *data0 |= ((static_cast<uint64_t>(swap_[13]) & 0x1) << 29);
    *data0 |= ((static_cast<uint64_t>(swap_[14]) & 0x1) << 30);
    *data0 |= ((static_cast<uint64_t>(swap_[15]) & 0x1) << 31);
    *data0 |= ((static_cast<uint64_t>(swap_[16]) & 0x1) << 32);
    *data0 |= ((static_cast<uint64_t>(shr_) & 0x1) << 33);
    *data0 |= ((static_cast<uint64_t>(mask_[0]) & 0x1) << 34);
    *data0 |= ((static_cast<uint64_t>(mask_[1]) & 0x1) << 35);
    *data0 |= ((static_cast<uint64_t>(mask_[2]) & 0x1) << 36);
    *data0 |= ((static_cast<uint64_t>(mask_[3]) & 0x1) << 37);
    *data0 |= ((static_cast<uint64_t>(mask_[4]) & 0x1) << 38);
    *data0 |= ((static_cast<uint64_t>(mask_[5]) & 0x1) << 39);
    *data0 |= ((static_cast<uint64_t>(mask_[6]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(mask_[7]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(mask_[8]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(mask_[9]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(mask_[10]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(mask_[11]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(mask_[12]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(mask_[13]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(mask_[14]) & 0x1) << 48);
    *data0 |= ((static_cast<uint64_t>(mask_[15]) & 0x1) << 49);
    *data0 |= ((static_cast<uint64_t>(mask_[16]) & 0x1) << 50);
    *data0 |= ((static_cast<uint64_t>(mask_[17]) & 0x1) << 51);
    *data0 |= ((static_cast<uint64_t>(mask_[18]) & 0x1) << 52);
    *data0 |= ((static_cast<uint64_t>(mask_[19]) & 0x1) << 53);
    *data0 |= ((static_cast<uint64_t>(mask_[20]) & 0x1) << 54);
    *data0 |= ((static_cast<uint64_t>(mask_[21]) & 0x1) << 55);
    *data0 |= ((static_cast<uint64_t>(mask_[22]) & 0x1) << 56);
    *data0 |= ((static_cast<uint64_t>(mask_[23]) & 0x1) << 57);
    *data0 |= ((static_cast<uint64_t>(mask_[24]) & 0x1) << 58);
    *data0 |= ((static_cast<uint64_t>(mask_[25]) & 0x1) << 59);
    *data0 |= ((static_cast<uint64_t>(mask_[26]) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(mask_[27]) & 0x1) << 61);
    *data0 |= ((static_cast<uint64_t>(mask_[28]) & 0x1) << 62);
    *data0 |= ((static_cast<uint64_t>(mask_[29]) & 0x1) << 63);
    *data1 = (static_cast<uint64_t>(mask_[30]) & 0x1);
    *data1 |= ((static_cast<uint64_t>(mask_[31]) & 0x1) << 1);
    *data1 |= ((static_cast<uint64_t>(dst_bit_hdr_end_pos_) & 0x1f) << 2);
    *data1 |= (static_cast<uint64_t>(dst_) << 7);
    *data1 |= ((static_cast<uint64_t>(hdr_end_) & 0x1) << 15);
    *data1 |= ((static_cast<uint64_t>(type_) & 0x3) << 16);
    *data1 |= ((static_cast<uint64_t>(start_) & 0x1) << 18);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_) & 0x1) << 19);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_pos_) & 0x1f) << 20);
    *data1 |= ((static_cast<uint64_t>(mul_2_[0]) & 0x1) << 25);
    *data1 |= ((static_cast<uint64_t>(mul_2_[1]) & 0x1) << 26);
    *data1 |= ((static_cast<uint64_t>(mul_2_[2]) & 0x1) << 27);
    *data1 |= ((static_cast<uint64_t>(mul_2_[3]) & 0x1) << 28);
    *data1 |= ((static_cast<uint64_t>(mul_2_[4]) & 0x1) << 29);
    *data1 |= ((static_cast<uint64_t>(mul_2_[5]) & 0x1) << 30);
    *data1 |= ((static_cast<uint64_t>(mul_2_[6]) & 0x1) << 31);
    *data1 |= ((static_cast<uint64_t>(mul_2_[7]) & 0x1) << 32);
    *data1 |= ((static_cast<uint64_t>(mul_2_[8]) & 0x1) << 33);
    *data1 |= ((static_cast<uint64_t>(mul_2_[9]) & 0x1) << 34);
    *data1 |= ((static_cast<uint64_t>(mul_2_[10]) & 0x1) << 35);
    *data1 |= ((static_cast<uint64_t>(mul_2_[11]) & 0x1) << 36);
    *data1 |= ((static_cast<uint64_t>(mul_2_[12]) & 0x1) << 37);
    *data1 |= ((static_cast<uint64_t>(mul_2_[13]) & 0x1) << 38);
    *data1 |= ((static_cast<uint64_t>(mul_2_[14]) & 0x1) << 39);
    *data1 |= ((static_cast<uint64_t>(mul_2_[15]) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(mul_2_[16]) & 0x1) << 41);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    swap_[0] = ((data0 >> 16) & 0x1);
    swap_[1] = ((data0 >> 17) & 0x1);
    swap_[2] = ((data0 >> 18) & 0x1);
    swap_[3] = ((data0 >> 19) & 0x1);
    swap_[4] = ((data0 >> 20) & 0x1);
    swap_[5] = ((data0 >> 21) & 0x1);
    swap_[6] = ((data0 >> 22) & 0x1);
    swap_[7] = ((data0 >> 23) & 0x1);
    swap_[8] = ((data0 >> 24) & 0x1);
    swap_[9] = ((data0 >> 25) & 0x1);
    swap_[10] = ((data0 >> 26) & 0x1);
    swap_[11] = ((data0 >> 27) & 0x1);
    swap_[12] = ((data0 >> 28) & 0x1);
    swap_[13] = ((data0 >> 29) & 0x1);
    swap_[14] = ((data0 >> 30) & 0x1);
    swap_[15] = ((data0 >> 31) & 0x1);
    swap_[16] = ((data0 >> 32) & 0x1);
    shr_ = ((data0 >> 33) & 0x1);
    mask_[0] = ((data0 >> 34) & 0x1);
    mask_[1] = ((data0 >> 35) & 0x1);
    mask_[2] = ((data0 >> 36) & 0x1);
    mask_[3] = ((data0 >> 37) & 0x1);
    mask_[4] = ((data0 >> 38) & 0x1);
    mask_[5] = ((data0 >> 39) & 0x1);
    mask_[6] = ((data0 >> 40) & 0x1);
    mask_[7] = ((data0 >> 41) & 0x1);
    mask_[8] = ((data0 >> 42) & 0x1);
    mask_[9] = ((data0 >> 43) & 0x1);
    mask_[10] = ((data0 >> 44) & 0x1);
    mask_[11] = ((data0 >> 45) & 0x1);
    mask_[12] = ((data0 >> 46) & 0x1);
    mask_[13] = ((data0 >> 47) & 0x1);
    mask_[14] = ((data0 >> 48) & 0x1);
    mask_[15] = ((data0 >> 49) & 0x1);
    mask_[16] = ((data0 >> 50) & 0x1);
    mask_[17] = ((data0 >> 51) & 0x1);
    mask_[18] = ((data0 >> 52) & 0x1);
    mask_[19] = ((data0 >> 53) & 0x1);
    mask_[20] = ((data0 >> 54) & 0x1);
    mask_[21] = ((data0 >> 55) & 0x1);
    mask_[22] = ((data0 >> 56) & 0x1);
    mask_[23] = ((data0 >> 57) & 0x1);
    mask_[24] = ((data0 >> 58) & 0x1);
    mask_[25] = ((data0 >> 59) & 0x1);
    mask_[26] = ((data0 >> 60) & 0x1);
    mask_[27] = ((data0 >> 61) & 0x1);
    mask_[28] = ((data0 >> 62) & 0x1);
    mask_[29] = ((data0 >> 63) & 0x1);
    mask_[30] = (data1 & 0x1);
    mask_[31] = ((data1 >> 1) & 0x1);
    dst_bit_hdr_end_pos_ = ((data1 >> 2) & 0x1f);
    dst_ = (data1 >> 7);
    hdr_end_ = ((data1 >> 15) & 0x1);
    type_ = ((data1 >> 16) & 0x3);
    start_ = ((data1 >> 18) & 0x1);
    zeros_as_ones_ = ((data1 >> 19) & 0x1);
    zeros_as_ones_pos_ = ((data1 >> 20) & 0x1f);
    mul_2_[0] = ((data1 >> 25) & 0x1);
    mul_2_[1] = ((data1 >> 26) & 0x1);
    mul_2_[2] = ((data1 >> 27) & 0x1);
    mul_2_[3] = ((data1 >> 28) & 0x1);
    mul_2_[4] = ((data1 >> 29) & 0x1);
    mul_2_[5] = ((data1 >> 30) & 0x1);
    mul_2_[6] = ((data1 >> 31) & 0x1);
    mul_2_[7] = ((data1 >> 32) & 0x1);
    mul_2_[8] = ((data1 >> 33) & 0x1);
    mul_2_[9] = ((data1 >> 34) & 0x1);
    mul_2_[10] = ((data1 >> 35) & 0x1);
    mul_2_[11] = ((data1 >> 36) & 0x1);
    mul_2_[12] = ((data1 >> 37) & 0x1);
    mul_2_[13] = ((data1 >> 38) & 0x1);
    mul_2_[14] = ((data1 >> 39) & 0x1);
    mul_2_[15] = ((data1 >> 40) & 0x1);
    mul_2_[16] = ((data1 >> 41) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    swap_[0] = 0;
    swap_[1] = 0;
    swap_[2] = 0;
    swap_[3] = 0;
    swap_[4] = 0;
    swap_[5] = 0;
    swap_[6] = 0;
    swap_[7] = 0;
    swap_[8] = 0;
    swap_[9] = 0;
    swap_[10] = 0;
    swap_[11] = 0;
    swap_[12] = 0;
    swap_[13] = 0;
    swap_[14] = 0;
    swap_[15] = 0;
    swap_[16] = 0;
    shr_ = 0;
    mask_[0] = 0;
    mask_[1] = 0;
    mask_[2] = 0;
    mask_[3] = 0;
    mask_[4] = 0;
    mask_[5] = 0;
    mask_[6] = 0;
    mask_[7] = 0;
    mask_[8] = 0;
    mask_[9] = 0;
    mask_[10] = 0;
    mask_[11] = 0;
    mask_[12] = 0;
    mask_[13] = 0;
    mask_[14] = 0;
    mask_[15] = 0;
    mask_[16] = 0;
    mask_[17] = 0;
    mask_[18] = 0;
    mask_[19] = 0;
    mask_[20] = 0;
    mask_[21] = 0;
    mask_[22] = 0;
    mask_[23] = 0;
    mask_[24] = 0;
    mask_[25] = 0;
    mask_[26] = 0;
    mask_[27] = 0;
    mask_[28] = 0;
    mask_[29] = 0;
    mask_[30] = 0;
    mask_[31] = 0;
    dst_bit_hdr_end_pos_ = 0;
    dst_ = 0;
    hdr_end_ = 0;
    type_ = 0;
    start_ = 0;
    zeros_as_ones_ = 0;
    zeros_as_ones_pos_ = 0;
    mul_2_[0] = 0;
    mul_2_[1] = 0;
    mul_2_[2] = 0;
    mul_2_[3] = 0;
    mul_2_[4] = 0;
    mul_2_[5] = 0;
    mul_2_[6] = 0;
    mul_2_[7] = 0;
    mul_2_[8] = 0;
    mul_2_[9] = 0;
    mul_2_[10] = 0;
    mul_2_[11] = 0;
    mul_2_[12] = 0;
    mul_2_[13] = 0;
    mul_2_[14] = 0;
    mul_2_[15] = 0;
    mul_2_[16] = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRow") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRow") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t add_;
  std::array< uint8_t, 17 > swap_;
  uint8_t shr_;
  std::array< uint8_t, 32 > mask_;
  uint8_t dst_bit_hdr_end_pos_;
  uint8_t dst_;
  uint8_t hdr_end_;
  uint8_t type_;
  uint8_t start_;
  uint8_t zeros_as_ones_;
  uint8_t zeros_as_ones_pos_;
  std::array< uint8_t, 17 > mul_2_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class PrsrPoCsumCtrlRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, index_prsr_po_csum_ctrl_row), 1, true, write_callback, read_callback, std::string("PrsrPoCsumCtrlRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_csum_ctrl_row))
    {
    }
  PrsrPoCsumCtrlRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrPoCsumCtrlRowMutable")
    {
    }
public:





  uint16_t add() { return add_; }
  void add(const uint16_t &v) { add_=v; }







  uint8_t swap(int j0) { return swap_[j0]; }
  void swap(int j0,const uint8_t &v) { swap_[j0]=v; }






  uint8_t shr() { return shr_; }
  void shr(const uint8_t &v) { shr_=v; }







  uint8_t mask(int j0) { return mask_[j0]; }
  void mask(int j0,const uint8_t &v) { mask_[j0]=v; }






  uint8_t dst_bit_hdr_end_pos() { return dst_bit_hdr_end_pos_; }
  void dst_bit_hdr_end_pos(const uint8_t &v) { dst_bit_hdr_end_pos_=v; }






  uint8_t dst() { return dst_; }
  void dst(const uint8_t &v) { dst_=v; }







  uint8_t hdr_end() { return hdr_end_; }
  void hdr_end(const uint8_t &v) { hdr_end_=v; }







  uint8_t type() { return type_; }
  void type(const uint8_t &v) { type_=v; }





  uint8_t start() { return start_; }
  void start(const uint8_t &v) { start_=v; }







  uint8_t zeros_as_ones() { return zeros_as_ones_; }
  void zeros_as_ones(const uint8_t &v) { zeros_as_ones_=v; }






  uint8_t zeros_as_ones_pos() { return zeros_as_ones_pos_; }
  void zeros_as_ones_pos(const uint8_t &v) { zeros_as_ones_pos_=v; }







  uint8_t mul_2(int j0) { return mul_2_[j0]; }
  void mul_2(int j0,const uint8_t &v) { mul_2_[j0]=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= ((static_cast<uint64_t>(swap_[0]) & 0x1) << 16);
    *data0 |= ((static_cast<uint64_t>(swap_[1]) & 0x1) << 17);
    *data0 |= ((static_cast<uint64_t>(swap_[2]) & 0x1) << 18);
    *data0 |= ((static_cast<uint64_t>(swap_[3]) & 0x1) << 19);
    *data0 |= ((static_cast<uint64_t>(swap_[4]) & 0x1) << 20);
    *data0 |= ((static_cast<uint64_t>(swap_[5]) & 0x1) << 21);
    *data0 |= ((static_cast<uint64_t>(swap_[6]) & 0x1) << 22);
    *data0 |= ((static_cast<uint64_t>(swap_[7]) & 0x1) << 23);
    *data0 |= ((static_cast<uint64_t>(swap_[8]) & 0x1) << 24);
    *data0 |= ((static_cast<uint64_t>(swap_[9]) & 0x1) << 25);
    *data0 |= ((static_cast<uint64_t>(swap_[10]) & 0x1) << 26);
    *data0 |= ((static_cast<uint64_t>(swap_[11]) & 0x1) << 27);
    *data0 |= ((static_cast<uint64_t>(swap_[12]) & 0x1) << 28);
    *data0 |= ((static_cast<uint64_t>(swap_[13]) & 0x1) << 29);
    *data0 |= ((static_cast<uint64_t>(swap_[14]) & 0x1) << 30);
    *data0 |= ((static_cast<uint64_t>(swap_[15]) & 0x1) << 31);
    *data0 |= ((static_cast<uint64_t>(swap_[16]) & 0x1) << 32);
    *data0 |= ((static_cast<uint64_t>(shr_) & 0x1) << 33);
    *data0 |= ((static_cast<uint64_t>(mask_[0]) & 0x1) << 34);
    *data0 |= ((static_cast<uint64_t>(mask_[1]) & 0x1) << 35);
    *data0 |= ((static_cast<uint64_t>(mask_[2]) & 0x1) << 36);
    *data0 |= ((static_cast<uint64_t>(mask_[3]) & 0x1) << 37);
    *data0 |= ((static_cast<uint64_t>(mask_[4]) & 0x1) << 38);
    *data0 |= ((static_cast<uint64_t>(mask_[5]) & 0x1) << 39);
    *data0 |= ((static_cast<uint64_t>(mask_[6]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(mask_[7]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(mask_[8]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(mask_[9]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(mask_[10]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(mask_[11]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(mask_[12]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(mask_[13]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(mask_[14]) & 0x1) << 48);
    *data0 |= ((static_cast<uint64_t>(mask_[15]) & 0x1) << 49);
    *data0 |= ((static_cast<uint64_t>(mask_[16]) & 0x1) << 50);
    *data0 |= ((static_cast<uint64_t>(mask_[17]) & 0x1) << 51);
    *data0 |= ((static_cast<uint64_t>(mask_[18]) & 0x1) << 52);
    *data0 |= ((static_cast<uint64_t>(mask_[19]) & 0x1) << 53);
    *data0 |= ((static_cast<uint64_t>(mask_[20]) & 0x1) << 54);
    *data0 |= ((static_cast<uint64_t>(mask_[21]) & 0x1) << 55);
    *data0 |= ((static_cast<uint64_t>(mask_[22]) & 0x1) << 56);
    *data0 |= ((static_cast<uint64_t>(mask_[23]) & 0x1) << 57);
    *data0 |= ((static_cast<uint64_t>(mask_[24]) & 0x1) << 58);
    *data0 |= ((static_cast<uint64_t>(mask_[25]) & 0x1) << 59);
    *data0 |= ((static_cast<uint64_t>(mask_[26]) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(mask_[27]) & 0x1) << 61);
    *data0 |= ((static_cast<uint64_t>(mask_[28]) & 0x1) << 62);
    *data0 |= ((static_cast<uint64_t>(mask_[29]) & 0x1) << 63);
    *data1 = (static_cast<uint64_t>(mask_[30]) & 0x1);
    *data1 |= ((static_cast<uint64_t>(mask_[31]) & 0x1) << 1);
    *data1 |= ((static_cast<uint64_t>(dst_bit_hdr_end_pos_) & 0x1f) << 2);
    *data1 |= (static_cast<uint64_t>(dst_) << 7);
    *data1 |= ((static_cast<uint64_t>(hdr_end_) & 0x1) << 15);
    *data1 |= ((static_cast<uint64_t>(type_) & 0x3) << 16);
    *data1 |= ((static_cast<uint64_t>(start_) & 0x1) << 18);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_) & 0x1) << 19);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_pos_) & 0x1f) << 20);
    *data1 |= ((static_cast<uint64_t>(mul_2_[0]) & 0x1) << 25);
    *data1 |= ((static_cast<uint64_t>(mul_2_[1]) & 0x1) << 26);
    *data1 |= ((static_cast<uint64_t>(mul_2_[2]) & 0x1) << 27);
    *data1 |= ((static_cast<uint64_t>(mul_2_[3]) & 0x1) << 28);
    *data1 |= ((static_cast<uint64_t>(mul_2_[4]) & 0x1) << 29);
    *data1 |= ((static_cast<uint64_t>(mul_2_[5]) & 0x1) << 30);
    *data1 |= ((static_cast<uint64_t>(mul_2_[6]) & 0x1) << 31);
    *data1 |= ((static_cast<uint64_t>(mul_2_[7]) & 0x1) << 32);
    *data1 |= ((static_cast<uint64_t>(mul_2_[8]) & 0x1) << 33);
    *data1 |= ((static_cast<uint64_t>(mul_2_[9]) & 0x1) << 34);
    *data1 |= ((static_cast<uint64_t>(mul_2_[10]) & 0x1) << 35);
    *data1 |= ((static_cast<uint64_t>(mul_2_[11]) & 0x1) << 36);
    *data1 |= ((static_cast<uint64_t>(mul_2_[12]) & 0x1) << 37);
    *data1 |= ((static_cast<uint64_t>(mul_2_[13]) & 0x1) << 38);
    *data1 |= ((static_cast<uint64_t>(mul_2_[14]) & 0x1) << 39);
    *data1 |= ((static_cast<uint64_t>(mul_2_[15]) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(mul_2_[16]) & 0x1) << 41);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    swap_[0] = ((data0 >> 16) & 0x1);
    swap_[1] = ((data0 >> 17) & 0x1);
    swap_[2] = ((data0 >> 18) & 0x1);
    swap_[3] = ((data0 >> 19) & 0x1);
    swap_[4] = ((data0 >> 20) & 0x1);
    swap_[5] = ((data0 >> 21) & 0x1);
    swap_[6] = ((data0 >> 22) & 0x1);
    swap_[7] = ((data0 >> 23) & 0x1);
    swap_[8] = ((data0 >> 24) & 0x1);
    swap_[9] = ((data0 >> 25) & 0x1);
    swap_[10] = ((data0 >> 26) & 0x1);
    swap_[11] = ((data0 >> 27) & 0x1);
    swap_[12] = ((data0 >> 28) & 0x1);
    swap_[13] = ((data0 >> 29) & 0x1);
    swap_[14] = ((data0 >> 30) & 0x1);
    swap_[15] = ((data0 >> 31) & 0x1);
    swap_[16] = ((data0 >> 32) & 0x1);
    shr_ = ((data0 >> 33) & 0x1);
    mask_[0] = ((data0 >> 34) & 0x1);
    mask_[1] = ((data0 >> 35) & 0x1);
    mask_[2] = ((data0 >> 36) & 0x1);
    mask_[3] = ((data0 >> 37) & 0x1);
    mask_[4] = ((data0 >> 38) & 0x1);
    mask_[5] = ((data0 >> 39) & 0x1);
    mask_[6] = ((data0 >> 40) & 0x1);
    mask_[7] = ((data0 >> 41) & 0x1);
    mask_[8] = ((data0 >> 42) & 0x1);
    mask_[9] = ((data0 >> 43) & 0x1);
    mask_[10] = ((data0 >> 44) & 0x1);
    mask_[11] = ((data0 >> 45) & 0x1);
    mask_[12] = ((data0 >> 46) & 0x1);
    mask_[13] = ((data0 >> 47) & 0x1);
    mask_[14] = ((data0 >> 48) & 0x1);
    mask_[15] = ((data0 >> 49) & 0x1);
    mask_[16] = ((data0 >> 50) & 0x1);
    mask_[17] = ((data0 >> 51) & 0x1);
    mask_[18] = ((data0 >> 52) & 0x1);
    mask_[19] = ((data0 >> 53) & 0x1);
    mask_[20] = ((data0 >> 54) & 0x1);
    mask_[21] = ((data0 >> 55) & 0x1);
    mask_[22] = ((data0 >> 56) & 0x1);
    mask_[23] = ((data0 >> 57) & 0x1);
    mask_[24] = ((data0 >> 58) & 0x1);
    mask_[25] = ((data0 >> 59) & 0x1);
    mask_[26] = ((data0 >> 60) & 0x1);
    mask_[27] = ((data0 >> 61) & 0x1);
    mask_[28] = ((data0 >> 62) & 0x1);
    mask_[29] = ((data0 >> 63) & 0x1);
    mask_[30] = (data1 & 0x1);
    mask_[31] = ((data1 >> 1) & 0x1);
    dst_bit_hdr_end_pos_ = ((data1 >> 2) & 0x1f);
    dst_ = (data1 >> 7);
    hdr_end_ = ((data1 >> 15) & 0x1);
    type_ = ((data1 >> 16) & 0x3);
    start_ = ((data1 >> 18) & 0x1);
    zeros_as_ones_ = ((data1 >> 19) & 0x1);
    zeros_as_ones_pos_ = ((data1 >> 20) & 0x1f);
    mul_2_[0] = ((data1 >> 25) & 0x1);
    mul_2_[1] = ((data1 >> 26) & 0x1);
    mul_2_[2] = ((data1 >> 27) & 0x1);
    mul_2_[3] = ((data1 >> 28) & 0x1);
    mul_2_[4] = ((data1 >> 29) & 0x1);
    mul_2_[5] = ((data1 >> 30) & 0x1);
    mul_2_[6] = ((data1 >> 31) & 0x1);
    mul_2_[7] = ((data1 >> 32) & 0x1);
    mul_2_[8] = ((data1 >> 33) & 0x1);
    mul_2_[9] = ((data1 >> 34) & 0x1);
    mul_2_[10] = ((data1 >> 35) & 0x1);
    mul_2_[11] = ((data1 >> 36) & 0x1);
    mul_2_[12] = ((data1 >> 37) & 0x1);
    mul_2_[13] = ((data1 >> 38) & 0x1);
    mul_2_[14] = ((data1 >> 39) & 0x1);
    mul_2_[15] = ((data1 >> 40) & 0x1);
    mul_2_[16] = ((data1 >> 41) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    swap_[0] = 0;
    swap_[1] = 0;
    swap_[2] = 0;
    swap_[3] = 0;
    swap_[4] = 0;
    swap_[5] = 0;
    swap_[6] = 0;
    swap_[7] = 0;
    swap_[8] = 0;
    swap_[9] = 0;
    swap_[10] = 0;
    swap_[11] = 0;
    swap_[12] = 0;
    swap_[13] = 0;
    swap_[14] = 0;
    swap_[15] = 0;
    swap_[16] = 0;
    shr_ = 0;
    mask_[0] = 0;
    mask_[1] = 0;
    mask_[2] = 0;
    mask_[3] = 0;
    mask_[4] = 0;
    mask_[5] = 0;
    mask_[6] = 0;
    mask_[7] = 0;
    mask_[8] = 0;
    mask_[9] = 0;
    mask_[10] = 0;
    mask_[11] = 0;
    mask_[12] = 0;
    mask_[13] = 0;
    mask_[14] = 0;
    mask_[15] = 0;
    mask_[16] = 0;
    mask_[17] = 0;
    mask_[18] = 0;
    mask_[19] = 0;
    mask_[20] = 0;
    mask_[21] = 0;
    mask_[22] = 0;
    mask_[23] = 0;
    mask_[24] = 0;
    mask_[25] = 0;
    mask_[26] = 0;
    mask_[27] = 0;
    mask_[28] = 0;
    mask_[29] = 0;
    mask_[30] = 0;
    mask_[31] = 0;
    dst_bit_hdr_end_pos_ = 0;
    dst_ = 0;
    hdr_end_ = 0;
    type_ = 0;
    start_ = 0;
    zeros_as_ones_ = 0;
    zeros_as_ones_pos_ = 0;
    mul_2_[0] = 0;
    mul_2_[1] = 0;
    mul_2_[2] = 0;
    mul_2_[3] = 0;
    mul_2_[4] = 0;
    mul_2_[5] = 0;
    mul_2_[6] = 0;
    mul_2_[7] = 0;
    mul_2_[8] = 0;
    mul_2_[9] = 0;
    mul_2_[10] = 0;
    mul_2_[11] = 0;
    mul_2_[12] = 0;
    mul_2_[13] = 0;
    mul_2_[14] = 0;
    mul_2_[15] = 0;
    mul_2_[16] = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRowMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRowMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t add_;
  std::array< uint8_t, 17 > swap_;
  uint8_t shr_;
  std::array< uint8_t, 32 > mask_;
  uint8_t dst_bit_hdr_end_pos_;
  uint8_t dst_;
  uint8_t hdr_end_;
  uint8_t type_;
  uint8_t start_;
  uint8_t zeros_as_ones_;
  uint8_t zeros_as_ones_pos_;
  std::array< uint8_t, 17 > mul_2_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class PrsrPoCsumCtrlRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrPoCsumCtrlRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint16_t &add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }







  uint8_t &swap(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].swap(j0);
  }






  uint8_t &shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr();
  }







  uint8_t &mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask(j0);
  }






  uint8_t &dst_bit_hdr_end_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_bit_hdr_end_pos();
  }






  uint8_t &dst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst();
  }







  uint8_t &hdr_end(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_end();
  }







  uint8_t &type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].type();
  }





  uint8_t &start(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].start();
  }







  uint8_t &zeros_as_ones(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones();
  }






  uint8_t &zeros_as_ones_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones_pos();
  }







  uint8_t &mul_2(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mul_2(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoCsumCtrlRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoCsumCtrlRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoCsumCtrlRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class PrsrPoCsumCtrlRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrPoCsumCtrlRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint16_t add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }
  void add(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].add(v);
  }







  uint8_t swap(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].swap(j0);
  }
  void swap(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].swap(j0,v);
  }






  uint8_t shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr();
  }
  void shr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].shr(v);
  }







  uint8_t mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask(j0);
  }
  void mask(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mask(j0,v);
  }






  uint8_t dst_bit_hdr_end_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_bit_hdr_end_pos();
  }
  void dst_bit_hdr_end_pos(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst_bit_hdr_end_pos(v);
  }






  uint8_t dst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst();
  }
  void dst(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst(v);
  }







  uint8_t hdr_end(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_end();
  }
  void hdr_end(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].hdr_end(v);
  }







  uint8_t type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].type();
  }
  void type(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].type(v);
  }





  uint8_t start(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].start();
  }
  void start(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].start(v);
  }







  uint8_t zeros_as_ones(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones();
  }
  void zeros_as_ones(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].zeros_as_ones(v);
  }






  uint8_t zeros_as_ones_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones_pos();
  }
  void zeros_as_ones_pos(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].zeros_as_ones_pos(v);
  }







  uint8_t mul_2(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mul_2(j0);
  }
  void mul_2(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mul_2(j0,v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoCsumCtrlRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoCsumCtrlRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoCsumCtrlRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlCtrInitRamM : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamM(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ctr_init_ram_m), 1, false, write_callback, read_callback, std::string("PrsrMlCtrInitRamM")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ctr_init_ram_m))
    {
    }
  PrsrMlCtrInitRamM(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMlCtrInitRamM")
    {
    }
public:





  uint8_t &add() { return add_; }





  uint8_t &mask_8() { return mask_8_; }





  uint8_t &rotate() { return rotate_; }





  uint8_t &max() { return max_; }





  uint8_t &src() { return src_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= (static_cast<uint64_t>(mask_8_) << 8);
    *data0 |= ((static_cast<uint64_t>(rotate_) & 0x7) << 16);
    *data0 |= (static_cast<uint64_t>(max_) << 19);
    *data0 |= ((static_cast<uint64_t>(src_) & 0x3) << 27);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    mask_8_ = (data0 >> 8);
    rotate_ = ((data0 >> 16) & 0x7);
    max_ = (data0 >> 19);
    src_ = ((data0 >> 27) & 0x3);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    mask_8_ = 0;
    rotate_ = 0;
    max_ = 0;
    src_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamM") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamM") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t add_;
  uint8_t mask_8_;
  uint8_t rotate_;
  uint8_t max_;
  uint8_t src_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlCtrInitRamMMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamMMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ctr_init_ram_m), 1, true, write_callback, read_callback, std::string("PrsrMlCtrInitRamMMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ctr_init_ram_m))
    {
    }
  PrsrMlCtrInitRamMMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMlCtrInitRamMMutable")
    {
    }
public:





  uint8_t add() { return add_; }
  void add(const uint8_t &v) { add_=v; }





  uint8_t mask_8() { return mask_8_; }
  void mask_8(const uint8_t &v) { mask_8_=v; }





  uint8_t rotate() { return rotate_; }
  void rotate(const uint8_t &v) { rotate_=v; }





  uint8_t max() { return max_; }
  void max(const uint8_t &v) { max_=v; }





  uint8_t src() { return src_; }
  void src(const uint8_t &v) { src_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= (static_cast<uint64_t>(mask_8_) << 8);
    *data0 |= ((static_cast<uint64_t>(rotate_) & 0x7) << 16);
    *data0 |= (static_cast<uint64_t>(max_) << 19);
    *data0 |= ((static_cast<uint64_t>(src_) & 0x3) << 27);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    mask_8_ = (data0 >> 8);
    rotate_ = ((data0 >> 16) & 0x7);
    max_ = (data0 >> 19);
    src_ = ((data0 >> 27) & 0x3);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    mask_8_ = 0;
    rotate_ = 0;
    max_ = 0;
    src_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamMMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamMMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t add_;
  uint8_t mask_8_;
  uint8_t rotate_;
  uint8_t max_;
  uint8_t src_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlCtrInitRamMArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamMArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrMlCtrInitRamMArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint8_t &add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }





  uint8_t &mask_8(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask_8();
  }





  uint8_t &rotate(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rotate();
  }





  uint8_t &max(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].max();
  }





  uint8_t &src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].src();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlCtrInitRamMArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlCtrInitRamMArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlCtrInitRamM> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlCtrInitRamMArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamMArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrMlCtrInitRamMArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint8_t add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }
  void add(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].add(v);
  }





  uint8_t mask_8(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask_8();
  }
  void mask_8(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mask_8(v);
  }





  uint8_t rotate(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rotate();
  }
  void rotate(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rotate(v);
  }





  uint8_t max(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].max();
  }
  void max(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].max(v);
  }





  uint8_t src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].src();
  }
  void src(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].src(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlCtrInitRamMArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlCtrInitRamMArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlCtrInitRamMMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlEaRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ea_row), 1, false, write_callback, read_callback, std::string("PrsrMlEaRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ea_row))
    {
    }
  PrsrMlEaRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMlEaRow")
    {
    }
public:




  uint8_t &nxt_state() { return nxt_state_; }





  uint8_t &nxt_state_mask() { return nxt_state_mask_; }








  uint8_t &lookup_offset_8(int j0) { return lookup_offset_8_[j0]; }






  uint8_t &ld_lookup_8(int j0) { return ld_lookup_8_[j0]; }






  uint8_t &sv_lookup_8(int j0) { return sv_lookup_8_[j0]; }





  uint8_t &shift_amt() { return shift_amt_; }






  uint8_t &buf_req() { return buf_req_; }






  uint8_t &done() { return done_; }





  uint8_t &ctr_op() { return ctr_op_; }





  uint8_t &ctr_amt_idx() { return ctr_amt_idx_; }






  uint8_t &ctr_stack_push() { return ctr_stack_push_; }






  uint8_t &ctr_stack_upd_w_top() { return ctr_stack_upd_w_top_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(nxt_state_);
    *data0 |= (static_cast<uint64_t>(nxt_state_mask_) << 8);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[0]) & 0x3f) << 16);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[1]) & 0x3f) << 22);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[2]) & 0x3f) << 28);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[3]) & 0x3f) << 34);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[0]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[1]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[2]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[3]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[0]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[1]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[2]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[3]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(shift_amt_) & 0x3f) << 48);
    *data0 |= ((static_cast<uint64_t>(buf_req_) & 0x3f) << 54);
    *data0 |= ((static_cast<uint64_t>(done_) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(ctr_op_) & 0x3) << 61);
    *data0 |= ((static_cast<uint64_t>(ctr_amt_idx_) & 0x1) << 63);
    *data1 = ((static_cast<uint64_t>(ctr_amt_idx_) & 0xfe) >> 1);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_push_) & 0x1) << 7);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_upd_w_top_) & 0x1) << 8);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    nxt_state_ = data0;
    nxt_state_mask_ = (data0 >> 8);
    lookup_offset_8_[0] = ((data0 >> 16) & 0x3f);
    lookup_offset_8_[1] = ((data0 >> 22) & 0x3f);
    lookup_offset_8_[2] = ((data0 >> 28) & 0x3f);
    lookup_offset_8_[3] = ((data0 >> 34) & 0x3f);
    ld_lookup_8_[0] = ((data0 >> 40) & 0x1);
    ld_lookup_8_[1] = ((data0 >> 41) & 0x1);
    ld_lookup_8_[2] = ((data0 >> 42) & 0x1);
    ld_lookup_8_[3] = ((data0 >> 43) & 0x1);
    sv_lookup_8_[0] = ((data0 >> 44) & 0x1);
    sv_lookup_8_[1] = ((data0 >> 45) & 0x1);
    sv_lookup_8_[2] = ((data0 >> 46) & 0x1);
    sv_lookup_8_[3] = ((data0 >> 47) & 0x1);
    shift_amt_ = ((data0 >> 48) & 0x3f);
    buf_req_ = ((data0 >> 54) & 0x3f);
    done_ = ((data0 >> 60) & 0x1);
    ctr_op_ = ((data0 >> 61) & 0x3);
    ctr_amt_idx_ = (((data0 >> 63) & 0x1) | (ctr_amt_idx_ & 0xfe));
    ctr_amt_idx_ = (((data1 << 1) & 0xfe) | (ctr_amt_idx_ & 0x1));
    ctr_stack_push_ = ((data1 >> 7) & 0x1);
    ctr_stack_upd_w_top_ = ((data1 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    nxt_state_ = 0;
    nxt_state_mask_ = 0;
    lookup_offset_8_[0] = 0x0;
    lookup_offset_8_[1] = 0x0;
    lookup_offset_8_[2] = 0x0;
    lookup_offset_8_[3] = 0x0;
    ld_lookup_8_[0] = 0;
    ld_lookup_8_[1] = 0;
    ld_lookup_8_[2] = 0;
    ld_lookup_8_[3] = 0;
    sv_lookup_8_[0] = 0;
    sv_lookup_8_[1] = 0;
    sv_lookup_8_[2] = 0;
    sv_lookup_8_[3] = 0;
    shift_amt_ = 0;
    buf_req_ = 0;
    done_ = 0;
    ctr_op_ = 0;
    ctr_amt_idx_ = 0;
    ctr_stack_push_ = 0;
    ctr_stack_upd_w_top_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRow") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRow") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t nxt_state_;
  uint8_t nxt_state_mask_;
  std::array< uint8_t, 4 > lookup_offset_8_;
  std::array< uint8_t, 4 > ld_lookup_8_;
  std::array< uint8_t, 4 > sv_lookup_8_;
  uint8_t shift_amt_;
  uint8_t buf_req_;
  uint8_t done_;
  uint8_t ctr_op_;
  uint8_t ctr_amt_idx_;
  uint8_t ctr_stack_push_;
  uint8_t ctr_stack_upd_w_top_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlEaRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ea_row), 1, true, write_callback, read_callback, std::string("PrsrMlEaRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ea_row))
    {
    }
  PrsrMlEaRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMlEaRowMutable")
    {
    }
public:




  uint8_t nxt_state() { return nxt_state_; }
  void nxt_state(const uint8_t &v) { nxt_state_=v; }





  uint8_t nxt_state_mask() { return nxt_state_mask_; }
  void nxt_state_mask(const uint8_t &v) { nxt_state_mask_=v; }








  uint8_t lookup_offset_8(int j0) { return lookup_offset_8_[j0]; }
  void lookup_offset_8(int j0,const uint8_t &v) { lookup_offset_8_[j0]=v; }






  uint8_t ld_lookup_8(int j0) { return ld_lookup_8_[j0]; }
  void ld_lookup_8(int j0,const uint8_t &v) { ld_lookup_8_[j0]=v; }






  uint8_t sv_lookup_8(int j0) { return sv_lookup_8_[j0]; }
  void sv_lookup_8(int j0,const uint8_t &v) { sv_lookup_8_[j0]=v; }





  uint8_t shift_amt() { return shift_amt_; }
  void shift_amt(const uint8_t &v) { shift_amt_=v; }






  uint8_t buf_req() { return buf_req_; }
  void buf_req(const uint8_t &v) { buf_req_=v; }






  uint8_t done() { return done_; }
  void done(const uint8_t &v) { done_=v; }





  uint8_t ctr_op() { return ctr_op_; }
  void ctr_op(const uint8_t &v) { ctr_op_=v; }





  uint8_t ctr_amt_idx() { return ctr_amt_idx_; }
  void ctr_amt_idx(const uint8_t &v) { ctr_amt_idx_=v; }






  uint8_t ctr_stack_push() { return ctr_stack_push_; }
  void ctr_stack_push(const uint8_t &v) { ctr_stack_push_=v; }






  uint8_t ctr_stack_upd_w_top() { return ctr_stack_upd_w_top_; }
  void ctr_stack_upd_w_top(const uint8_t &v) { ctr_stack_upd_w_top_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(nxt_state_);
    *data0 |= (static_cast<uint64_t>(nxt_state_mask_) << 8);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[0]) & 0x3f) << 16);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[1]) & 0x3f) << 22);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[2]) & 0x3f) << 28);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[3]) & 0x3f) << 34);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[0]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[1]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[2]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[3]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[0]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[1]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[2]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[3]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(shift_amt_) & 0x3f) << 48);
    *data0 |= ((static_cast<uint64_t>(buf_req_) & 0x3f) << 54);
    *data0 |= ((static_cast<uint64_t>(done_) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(ctr_op_) & 0x3) << 61);
    *data0 |= ((static_cast<uint64_t>(ctr_amt_idx_) & 0x1) << 63);
    *data1 = ((static_cast<uint64_t>(ctr_amt_idx_) & 0xfe) >> 1);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_push_) & 0x1) << 7);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_upd_w_top_) & 0x1) << 8);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    nxt_state_ = data0;
    nxt_state_mask_ = (data0 >> 8);
    lookup_offset_8_[0] = ((data0 >> 16) & 0x3f);
    lookup_offset_8_[1] = ((data0 >> 22) & 0x3f);
    lookup_offset_8_[2] = ((data0 >> 28) & 0x3f);
    lookup_offset_8_[3] = ((data0 >> 34) & 0x3f);
    ld_lookup_8_[0] = ((data0 >> 40) & 0x1);
    ld_lookup_8_[1] = ((data0 >> 41) & 0x1);
    ld_lookup_8_[2] = ((data0 >> 42) & 0x1);
    ld_lookup_8_[3] = ((data0 >> 43) & 0x1);
    sv_lookup_8_[0] = ((data0 >> 44) & 0x1);
    sv_lookup_8_[1] = ((data0 >> 45) & 0x1);
    sv_lookup_8_[2] = ((data0 >> 46) & 0x1);
    sv_lookup_8_[3] = ((data0 >> 47) & 0x1);
    shift_amt_ = ((data0 >> 48) & 0x3f);
    buf_req_ = ((data0 >> 54) & 0x3f);
    done_ = ((data0 >> 60) & 0x1);
    ctr_op_ = ((data0 >> 61) & 0x3);
    ctr_amt_idx_ = (((data0 >> 63) & 0x1) | (ctr_amt_idx_ & 0xfe));
    ctr_amt_idx_ = (((data1 << 1) & 0xfe) | (ctr_amt_idx_ & 0x1));
    ctr_stack_push_ = ((data1 >> 7) & 0x1);
    ctr_stack_upd_w_top_ = ((data1 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    nxt_state_ = 0;
    nxt_state_mask_ = 0;
    lookup_offset_8_[0] = 0x0;
    lookup_offset_8_[1] = 0x0;
    lookup_offset_8_[2] = 0x0;
    lookup_offset_8_[3] = 0x0;
    ld_lookup_8_[0] = 0;
    ld_lookup_8_[1] = 0;
    ld_lookup_8_[2] = 0;
    ld_lookup_8_[3] = 0;
    sv_lookup_8_[0] = 0;
    sv_lookup_8_[1] = 0;
    sv_lookup_8_[2] = 0;
    sv_lookup_8_[3] = 0;
    shift_amt_ = 0;
    buf_req_ = 0;
    done_ = 0;
    ctr_op_ = 0;
    ctr_amt_idx_ = 0;
    ctr_stack_push_ = 0;
    ctr_stack_upd_w_top_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRowMutable") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRowMutable") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t nxt_state_;
  uint8_t nxt_state_mask_;
  std::array< uint8_t, 4 > lookup_offset_8_;
  std::array< uint8_t, 4 > ld_lookup_8_;
  std::array< uint8_t, 4 > sv_lookup_8_;
  uint8_t shift_amt_;
  uint8_t buf_req_;
  uint8_t done_;
  uint8_t ctr_op_;
  uint8_t ctr_amt_idx_;
  uint8_t ctr_stack_push_;
  uint8_t ctr_stack_upd_w_top_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlEaRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrMlEaRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:




  uint8_t &nxt_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state();
  }





  uint8_t &nxt_state_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state_mask();
  }








  uint8_t &lookup_offset_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].lookup_offset_8(j0);
  }






  uint8_t &ld_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ld_lookup_8(j0);
  }






  uint8_t &sv_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].sv_lookup_8(j0);
  }





  uint8_t &shift_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shift_amt();
  }






  uint8_t &buf_req(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].buf_req();
  }






  uint8_t &done(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].done();
  }





  uint8_t &ctr_op(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_op();
  }





  uint8_t &ctr_amt_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_amt_idx();
  }






  uint8_t &ctr_stack_push(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_push();
  }






  uint8_t &ctr_stack_upd_w_top(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_upd_w_top();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlEaRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlEaRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlEaRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlEaRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrMlEaRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:




  uint8_t nxt_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state();
  }
  void nxt_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].nxt_state(v);
  }





  uint8_t nxt_state_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state_mask();
  }
  void nxt_state_mask(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].nxt_state_mask(v);
  }








  uint8_t lookup_offset_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].lookup_offset_8(j0);
  }
  void lookup_offset_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].lookup_offset_8(j0,v);
  }






  uint8_t ld_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ld_lookup_8(j0);
  }
  void ld_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ld_lookup_8(j0,v);
  }






  uint8_t sv_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].sv_lookup_8(j0);
  }
  void sv_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].sv_lookup_8(j0,v);
  }





  uint8_t shift_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shift_amt();
  }
  void shift_amt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].shift_amt(v);
  }






  uint8_t buf_req(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].buf_req();
  }
  void buf_req(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].buf_req(v);
  }






  uint8_t done(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].done();
  }
  void done(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].done(v);
  }





  uint8_t ctr_op(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_op();
  }
  void ctr_op(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_op(v);
  }





  uint8_t ctr_amt_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_amt_idx();
  }
  void ctr_amt_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_amt_idx(v);
  }






  uint8_t ctr_stack_push(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_push();
  }
  void ctr_stack_push(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_stack_push(v);
  }






  uint8_t ctr_stack_upd_w_top(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_upd_w_top();
  }
  void ctr_stack_upd_w_top(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_stack_upd_w_top(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlEaRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlEaRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlEaRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PrsrMlTcamRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_tcam_row), 1, false, write_callback, read_callback, std::string("PrsrMlTcamRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_tcam_row))
    {
    }
  PrsrMlTcamRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMlTcamRow")
    {
    }
public:






  uint8_t &w0_lookup_8(int j0) { return w0_lookup_8_[j0]; }




  uint8_t &w0_curr_state() { return w0_curr_state_; }





  uint8_t &w0_ctr_zero() { return w0_ctr_zero_; }





  uint8_t &w0_ctr_neg() { return w0_ctr_neg_; }





  uint8_t &w0_ver_0() { return w0_ver_0_; }





  uint8_t &w0_ver_1() { return w0_ver_1_; }






  uint8_t &w1_lookup_8(int j0) { return w1_lookup_8_[j0]; }




  uint8_t &w1_curr_state() { return w1_curr_state_; }





  uint8_t &w1_ctr_zero() { return w1_ctr_zero_; }





  uint8_t &w1_ctr_neg() { return w1_ctr_neg_; }





  uint8_t &w1_ver_0() { return w1_ver_0_; }





  uint8_t &w1_ver_1() { return w1_ver_1_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(w0_lookup_8_[0]);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[1]) << 8);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[2]) << 16);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[3]) << 24);
    *data0 |= (static_cast<uint64_t>(w0_curr_state_) << 32);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_zero_) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_neg_) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(w0_ver_0_) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(w0_ver_1_) & 0x1) << 43);
    *data1 = static_cast<uint64_t>(w1_lookup_8_[0]);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[1]) << 8);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[2]) << 16);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[3]) << 24);
    *data1 |= (static_cast<uint64_t>(w1_curr_state_) << 32);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_zero_) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_neg_) & 0x1) << 41);
    *data1 |= ((static_cast<uint64_t>(w1_ver_0_) & 0x1) << 42);
    *data1 |= ((static_cast<uint64_t>(w1_ver_1_) & 0x1) << 43);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    w0_lookup_8_[0] = data0;
    w0_lookup_8_[1] = (data0 >> 8);
    w0_lookup_8_[2] = (data0 >> 16);
    w0_lookup_8_[3] = (data0 >> 24);
    w0_curr_state_ = (data0 >> 32);
    w0_ctr_zero_ = ((data0 >> 40) & 0x1);
    w0_ctr_neg_ = ((data0 >> 41) & 0x1);
    w0_ver_0_ = ((data0 >> 42) & 0x1);
    w0_ver_1_ = ((data0 >> 43) & 0x1);
    w1_lookup_8_[0] = data1;
    w1_lookup_8_[1] = (data1 >> 8);
    w1_lookup_8_[2] = (data1 >> 16);
    w1_lookup_8_[3] = (data1 >> 24);
    w1_curr_state_ = (data1 >> 32);
    w1_ctr_zero_ = ((data1 >> 40) & 0x1);
    w1_ctr_neg_ = ((data1 >> 41) & 0x1);
    w1_ver_0_ = ((data1 >> 42) & 0x1);
    w1_ver_1_ = ((data1 >> 43) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    w0_lookup_8_[0] = 0;
    w0_lookup_8_[1] = 0;
    w0_lookup_8_[2] = 0;
    w0_lookup_8_[3] = 0;
    w0_curr_state_ = 0;
    w0_ctr_zero_ = 0;
    w0_ctr_neg_ = 0;
    w0_ver_0_ = 0;
    w0_ver_1_ = 0;
    w1_lookup_8_[0] = 0;
    w1_lookup_8_[1] = 0;
    w1_lookup_8_[2] = 0;
    w1_lookup_8_[3] = 0;
    w1_curr_state_ = 0;
    w1_ctr_zero_ = 0;
    w1_ctr_neg_ = 0;
    w1_ver_0_ = 0;
    w1_ver_1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRow") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRow") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 4 > w0_lookup_8_;
  uint8_t w0_curr_state_;
  uint8_t w0_ctr_zero_;
  uint8_t w0_ctr_neg_;
  uint8_t w0_ver_0_;
  uint8_t w0_ver_1_;
  std::array< uint8_t, 4 > w1_lookup_8_;
  uint8_t w1_curr_state_;
  uint8_t w1_ctr_zero_;
  uint8_t w1_ctr_neg_;
  uint8_t w1_ver_0_;
  uint8_t w1_ver_1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class PrsrMlTcamRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_tcam_row), 1, true, write_callback, read_callback, std::string("PrsrMlTcamRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_tcam_row))
    {
    }
  PrsrMlTcamRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMlTcamRowMutable")
    {
    }
public:






  uint8_t w0_lookup_8(int j0) { return w0_lookup_8_[j0]; }
  void w0_lookup_8(int j0,const uint8_t &v) { w0_lookup_8_[j0]=v; }




  uint8_t w0_curr_state() { return w0_curr_state_; }
  void w0_curr_state(const uint8_t &v) { w0_curr_state_=v; }





  uint8_t w0_ctr_zero() { return w0_ctr_zero_; }
  void w0_ctr_zero(const uint8_t &v) { w0_ctr_zero_=v; }





  uint8_t w0_ctr_neg() { return w0_ctr_neg_; }
  void w0_ctr_neg(const uint8_t &v) { w0_ctr_neg_=v; }





  uint8_t w0_ver_0() { return w0_ver_0_; }
  void w0_ver_0(const uint8_t &v) { w0_ver_0_=v; }





  uint8_t w0_ver_1() { return w0_ver_1_; }
  void w0_ver_1(const uint8_t &v) { w0_ver_1_=v; }






  uint8_t w1_lookup_8(int j0) { return w1_lookup_8_[j0]; }
  void w1_lookup_8(int j0,const uint8_t &v) { w1_lookup_8_[j0]=v; }




  uint8_t w1_curr_state() { return w1_curr_state_; }
  void w1_curr_state(const uint8_t &v) { w1_curr_state_=v; }





  uint8_t w1_ctr_zero() { return w1_ctr_zero_; }
  void w1_ctr_zero(const uint8_t &v) { w1_ctr_zero_=v; }





  uint8_t w1_ctr_neg() { return w1_ctr_neg_; }
  void w1_ctr_neg(const uint8_t &v) { w1_ctr_neg_=v; }





  uint8_t w1_ver_0() { return w1_ver_0_; }
  void w1_ver_0(const uint8_t &v) { w1_ver_0_=v; }





  uint8_t w1_ver_1() { return w1_ver_1_; }
  void w1_ver_1(const uint8_t &v) { w1_ver_1_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(w0_lookup_8_[0]);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[1]) << 8);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[2]) << 16);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[3]) << 24);
    *data0 |= (static_cast<uint64_t>(w0_curr_state_) << 32);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_zero_) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_neg_) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(w0_ver_0_) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(w0_ver_1_) & 0x1) << 43);
    *data1 = static_cast<uint64_t>(w1_lookup_8_[0]);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[1]) << 8);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[2]) << 16);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[3]) << 24);
    *data1 |= (static_cast<uint64_t>(w1_curr_state_) << 32);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_zero_) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_neg_) & 0x1) << 41);
    *data1 |= ((static_cast<uint64_t>(w1_ver_0_) & 0x1) << 42);
    *data1 |= ((static_cast<uint64_t>(w1_ver_1_) & 0x1) << 43);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    w0_lookup_8_[0] = data0;
    w0_lookup_8_[1] = (data0 >> 8);
    w0_lookup_8_[2] = (data0 >> 16);
    w0_lookup_8_[3] = (data0 >> 24);
    w0_curr_state_ = (data0 >> 32);
    w0_ctr_zero_ = ((data0 >> 40) & 0x1);
    w0_ctr_neg_ = ((data0 >> 41) & 0x1);
    w0_ver_0_ = ((data0 >> 42) & 0x1);
    w0_ver_1_ = ((data0 >> 43) & 0x1);
    w1_lookup_8_[0] = data1;
    w1_lookup_8_[1] = (data1 >> 8);
    w1_lookup_8_[2] = (data1 >> 16);
    w1_lookup_8_[3] = (data1 >> 24);
    w1_curr_state_ = (data1 >> 32);
    w1_ctr_zero_ = ((data1 >> 40) & 0x1);
    w1_ctr_neg_ = ((data1 >> 41) & 0x1);
    w1_ver_0_ = ((data1 >> 42) & 0x1);
    w1_ver_1_ = ((data1 >> 43) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    w0_lookup_8_[0] = 0;
    w0_lookup_8_[1] = 0;
    w0_lookup_8_[2] = 0;
    w0_lookup_8_[3] = 0;
    w0_curr_state_ = 0;
    w0_ctr_zero_ = 0;
    w0_ctr_neg_ = 0;
    w0_ver_0_ = 0;
    w0_ver_1_ = 0;
    w1_lookup_8_[0] = 0;
    w1_lookup_8_[1] = 0;
    w1_lookup_8_[2] = 0;
    w1_lookup_8_[3] = 0;
    w1_curr_state_ = 0;
    w1_ctr_zero_ = 0;
    w1_ctr_neg_ = 0;
    w1_ver_0_ = 0;
    w1_ver_1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRowMutable") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRowMutable") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 4 > w0_lookup_8_;
  uint8_t w0_curr_state_;
  uint8_t w0_ctr_zero_;
  uint8_t w0_ctr_neg_;
  uint8_t w0_ver_0_;
  uint8_t w0_ver_1_;
  std::array< uint8_t, 4 > w1_lookup_8_;
  uint8_t w1_curr_state_;
  uint8_t w1_ctr_zero_;
  uint8_t w1_ctr_neg_;
  uint8_t w1_ver_0_;
  uint8_t w1_ver_1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class PrsrMlTcamRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrMlTcamRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:






  uint8_t &w0_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_lookup_8(j0);
  }




  uint8_t &w0_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_curr_state();
  }





  uint8_t &w0_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_zero();
  }





  uint8_t &w0_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_neg();
  }





  uint8_t &w0_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_0();
  }





  uint8_t &w0_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_1();
  }






  uint8_t &w1_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_lookup_8(j0);
  }




  uint8_t &w1_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_curr_state();
  }





  uint8_t &w1_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_zero();
  }





  uint8_t &w1_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_neg();
  }





  uint8_t &w1_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_0();
  }





  uint8_t &w1_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_1();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlTcamRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlTcamRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlTcamRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PrsrMlTcamRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrMlTcamRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:






  uint8_t w0_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_lookup_8(j0);
  }
  void w0_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_lookup_8(j0,v);
  }




  uint8_t w0_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_curr_state();
  }
  void w0_curr_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_curr_state(v);
  }





  uint8_t w0_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_zero();
  }
  void w0_ctr_zero(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ctr_zero(v);
  }





  uint8_t w0_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_neg();
  }
  void w0_ctr_neg(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ctr_neg(v);
  }





  uint8_t w0_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_0();
  }
  void w0_ver_0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ver_0(v);
  }





  uint8_t w0_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_1();
  }
  void w0_ver_1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ver_1(v);
  }






  uint8_t w1_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_lookup_8(j0);
  }
  void w1_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_lookup_8(j0,v);
  }




  uint8_t w1_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_curr_state();
  }
  void w1_curr_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_curr_state(v);
  }





  uint8_t w1_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_zero();
  }
  void w1_ctr_zero(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ctr_zero(v);
  }





  uint8_t w1_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_neg();
  }
  void w1_ctr_neg(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ctr_neg(v);
  }





  uint8_t w1_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_0();
  }
  void w1_ver_0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ver_0(v);
  }





  uint8_t w1_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_1();
  }
  void w1_ver_1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ver_1(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlTcamRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlTcamRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlTcamRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrPoActionRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_po_action_row), 4, false, write_callback, read_callback, std::string("PrsrPoActionRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_action_row))
    {
    }
  PrsrPoActionRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrPoActionRow")
    {
    }
public:








  uint8_t &phv_src(int j0) { return phv_src_[j0]; }







  uint8_t &phv_dst(int j0) { return phv_dst_[j0]; }








  uint8_t &phv_offset_add_dst(int j0) { return phv_offset_add_dst_[j0]; }







  uint8_t &extract_type(int j0) { return extract_type_[j0]; }






  uint8_t &csum_addr(int j0) { return csum_addr_[j0]; }






  uint8_t &csum_en(int j0) { return csum_en_[j0]; }






  uint8_t &dst_offset_inc() { return dst_offset_inc_; }






  uint8_t &dst_offset_rst() { return dst_offset_rst_; }






  uint8_t &pri_upd_type() { return pri_upd_type_; }






  uint8_t &pri_upd_src() { return pri_upd_src_; }







  uint8_t &pri_upd_en_shr() { return pri_upd_en_shr_; }






  uint8_t &pri_upd_val_mask() { return pri_upd_val_mask_; }






  uint8_t &ver_upd_type() { return ver_upd_type_; }






  uint8_t &ver_upd_src() { return ver_upd_src_; }







  uint8_t &ver_upd_en_shr() { return ver_upd_en_shr_; }






  uint8_t &ver_upd_val_mask() { return ver_upd_val_mask_; }







  uint16_t &val_const(int j0) { return val_const_[j0]; }







  uint8_t &val_const_rot(int j0) { return val_const_rot_[j0]; }





  uint8_t &val_const_32b_bond() { return val_const_32b_bond_; }








  uint8_t &clot_type(int j0) { return clot_type_[j0]; }









  uint8_t &clot_len_src(int j0) { return clot_len_src_[j0]; }









  uint8_t &clot_en_len_shr(int j0) { return clot_en_len_shr_[j0]; }







  uint8_t &clot_len_mask(int j0) { return clot_len_mask_[j0]; }









  uint8_t &clot_len_add() { return clot_len_add_; }







  uint8_t &clot_offset(int j0) { return clot_offset_[j0]; }







  uint8_t &clot_tag(int j0) { return clot_tag_[j0]; }







  uint8_t &clot_tag_offset_add(int j0) { return clot_tag_offset_add_[j0]; }







  uint8_t &clot_has_csum(int j0) { return clot_has_csum_[j0]; }






  uint8_t &hdr_len_inc_stop() { return hdr_len_inc_stop_; }





  uint8_t &hdr_len_inc_final_amt() { return hdr_len_inc_final_amt_; }





  uint8_t &disable_partial_hdr_err() { return disable_partial_hdr_err_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      if (read_callback_) read_callback_();
      *data0 = (static_cast<uint64_t>(phv_src_[0]) & 0x3f);
      *data0 |= ((static_cast<uint64_t>(phv_src_[1]) & 0x3f) << 6);
      *data0 |= ((static_cast<uint64_t>(phv_src_[2]) & 0x3f) << 12);
      *data0 |= ((static_cast<uint64_t>(phv_src_[3]) & 0x3f) << 18);
      *data0 |= ((static_cast<uint64_t>(phv_src_[4]) & 0x3f) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_src_[5]) & 0x3f) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_src_[6]) & 0x3f) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_src_[7]) & 0x3f) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_src_[8]) & 0x3f) << 48);
      *data0 |= ((static_cast<uint64_t>(phv_src_[9]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(phv_src_[10]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(phv_src_[10]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(phv_src_[11]) & 0x3f) << 2);
      *data1 |= ((static_cast<uint64_t>(phv_src_[12]) & 0x3f) << 8);
      *data1 |= ((static_cast<uint64_t>(phv_src_[13]) & 0x3f) << 14);
      *data1 |= ((static_cast<uint64_t>(phv_src_[14]) & 0x3f) << 20);
      *data1 |= ((static_cast<uint64_t>(phv_src_[15]) & 0x3f) << 26);
      *data1 |= ((static_cast<uint64_t>(phv_src_[16]) & 0x3f) << 32);
      *data1 |= ((static_cast<uint64_t>(phv_src_[17]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(phv_src_[18]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(phv_src_[19]) & 0x3f) << 50);
      *data1 |= (static_cast<uint64_t>(phv_dst_[0]) << 56);
    }
    else if (offset >= 0x1 && offset < 0x2) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[1]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[2]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[3]) << 16);
      *data0 |= (static_cast<uint64_t>(phv_dst_[4]) << 24);
      *data0 |= (static_cast<uint64_t>(phv_dst_[5]) << 32);
      *data0 |= (static_cast<uint64_t>(phv_dst_[6]) << 40);
      *data0 |= (static_cast<uint64_t>(phv_dst_[7]) << 48);
      *data0 |= (static_cast<uint64_t>(phv_dst_[8]) << 56);
      *data1 = static_cast<uint64_t>(phv_dst_[9]);
      *data1 |= (static_cast<uint64_t>(phv_dst_[10]) << 8);
      *data1 |= (static_cast<uint64_t>(phv_dst_[11]) << 16);
      *data1 |= (static_cast<uint64_t>(phv_dst_[12]) << 24);
      *data1 |= (static_cast<uint64_t>(phv_dst_[13]) << 32);
      *data1 |= (static_cast<uint64_t>(phv_dst_[14]) << 40);
      *data1 |= (static_cast<uint64_t>(phv_dst_[15]) << 48);
      *data1 |= (static_cast<uint64_t>(phv_dst_[16]) << 56);
    }
    else if (offset >= 0x2 && offset < 0x3) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[17]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[18]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[19]) << 16);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[0]) & 0x1) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[1]) & 0x1) << 25);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[2]) & 0x1) << 26);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[3]) & 0x1) << 27);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[4]) & 0x1) << 28);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[5]) & 0x1) << 29);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[6]) & 0x1) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[7]) & 0x1) << 31);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[8]) & 0x1) << 32);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[9]) & 0x1) << 33);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[10]) & 0x1) << 34);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[11]) & 0x1) << 35);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[12]) & 0x1) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[13]) & 0x1) << 37);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[14]) & 0x1) << 38);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[15]) & 0x1) << 39);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[16]) & 0x1) << 40);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[17]) & 0x1) << 41);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[18]) & 0x1) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[19]) & 0x1) << 43);
      *data0 |= ((static_cast<uint64_t>(extract_type_[0]) & 0x3) << 44);
      *data0 |= ((static_cast<uint64_t>(extract_type_[1]) & 0x3) << 46);
      *data0 |= ((static_cast<uint64_t>(extract_type_[2]) & 0x3) << 48);
      *data0 |= ((static_cast<uint64_t>(extract_type_[3]) & 0x3) << 50);
      *data0 |= ((static_cast<uint64_t>(extract_type_[4]) & 0x3) << 52);
      *data0 |= ((static_cast<uint64_t>(extract_type_[5]) & 0x3) << 54);
      *data0 |= ((static_cast<uint64_t>(extract_type_[6]) & 0x3) << 56);
      *data0 |= ((static_cast<uint64_t>(extract_type_[7]) & 0x3) << 58);
      *data0 |= ((static_cast<uint64_t>(extract_type_[8]) & 0x3) << 60);
      *data0 |= ((static_cast<uint64_t>(extract_type_[9]) & 0x3) << 62);
      *data1 = (static_cast<uint64_t>(extract_type_[10]) & 0x3);
      *data1 |= ((static_cast<uint64_t>(extract_type_[11]) & 0x3) << 2);
      *data1 |= ((static_cast<uint64_t>(extract_type_[12]) & 0x3) << 4);
      *data1 |= ((static_cast<uint64_t>(extract_type_[13]) & 0x3) << 6);
      *data1 |= ((static_cast<uint64_t>(extract_type_[14]) & 0x3) << 8);
      *data1 |= ((static_cast<uint64_t>(extract_type_[15]) & 0x3) << 10);
      *data1 |= ((static_cast<uint64_t>(extract_type_[16]) & 0x3) << 12);
      *data1 |= ((static_cast<uint64_t>(extract_type_[17]) & 0x3) << 14);
      *data1 |= ((static_cast<uint64_t>(extract_type_[18]) & 0x3) << 16);
      *data1 |= ((static_cast<uint64_t>(extract_type_[19]) & 0x3) << 18);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[0]) & 0x1f) << 20);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[1]) & 0x1f) << 25);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[2]) & 0x1f) << 30);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[3]) & 0x1f) << 35);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[4]) & 0x1f) << 40);
      *data1 |= ((static_cast<uint64_t>(csum_en_[0]) & 0x1) << 45);
      *data1 |= ((static_cast<uint64_t>(csum_en_[1]) & 0x1) << 46);
      *data1 |= ((static_cast<uint64_t>(csum_en_[2]) & 0x1) << 47);
      *data1 |= ((static_cast<uint64_t>(csum_en_[3]) & 0x1) << 48);
      *data1 |= ((static_cast<uint64_t>(csum_en_[4]) & 0x1) << 49);
      *data1 |= ((static_cast<uint64_t>(dst_offset_inc_) & 0x1f) << 50);
      *data1 |= ((static_cast<uint64_t>(dst_offset_rst_) & 0x1) << 55);
      *data1 |= ((static_cast<uint64_t>(pri_upd_type_) & 0x1) << 56);
      *data1 |= ((static_cast<uint64_t>(pri_upd_src_) & 0x1f) << 57);
      *data1 |= ((static_cast<uint64_t>(pri_upd_en_shr_) & 0x3) << 62);
    }
    else if (offset >= 0x3 && offset < 0x4) {
      if (read_callback_) read_callback_();
      *data0 = ((static_cast<uint64_t>(pri_upd_en_shr_) & 0xc) >> 2);
      *data0 |= ((static_cast<uint64_t>(pri_upd_val_mask_) & 0x7) << 2);
      *data0 |= ((static_cast<uint64_t>(ver_upd_type_) & 0x1) << 5);
      *data0 |= ((static_cast<uint64_t>(ver_upd_src_) & 0x1f) << 6);
      *data0 |= ((static_cast<uint64_t>(ver_upd_en_shr_) & 0xf) << 11);
      *data0 |= ((static_cast<uint64_t>(ver_upd_val_mask_) & 0x3) << 15);
      *data0 |= (static_cast<uint64_t>(val_const_[0]) << 17);
      *data0 |= (static_cast<uint64_t>(val_const_[1]) << 33);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[0]) & 0x1) << 49);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[1]) & 0x1) << 50);
      *data0 |= ((static_cast<uint64_t>(val_const_32b_bond_) & 0x1) << 51);
      *data0 |= ((static_cast<uint64_t>(clot_type_[0]) & 0x1) << 52);
      *data0 |= ((static_cast<uint64_t>(clot_type_[1]) & 0x1) << 53);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[0]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[1]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(clot_len_src_[1]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[0]) & 0xf) << 2);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[1]) & 0xf) << 6);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[0]) & 0x3f) << 10);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[1]) & 0x3f) << 16);
      *data1 |= ((static_cast<uint64_t>(clot_len_add_) & 0x3f) << 22);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[0]) & 0x1f) << 28);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[1]) & 0x1f) << 33);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[0]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[1]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[0]) & 0x1) << 50);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[1]) & 0x1) << 51);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[0]) & 0x1) << 52);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[1]) & 0x1) << 53);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_stop_) & 0x1) << 54);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_final_amt_) & 0x3f) << 55);
      *data1 |= ((static_cast<uint64_t>(disable_partial_hdr_err_) & 0x1) << 61);
    }
    else {
      assert(0);
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      phv_src_[0] = (data0 & 0x3f);
      phv_src_[1] = ((data0 >> 6) & 0x3f);
      phv_src_[2] = ((data0 >> 12) & 0x3f);
      phv_src_[3] = ((data0 >> 18) & 0x3f);
      phv_src_[4] = ((data0 >> 24) & 0x3f);
      phv_src_[5] = ((data0 >> 30) & 0x3f);
      phv_src_[6] = ((data0 >> 36) & 0x3f);
      phv_src_[7] = ((data0 >> 42) & 0x3f);
      phv_src_[8] = ((data0 >> 48) & 0x3f);
      phv_src_[9] = ((data0 >> 54) & 0x3f);
      phv_src_[10] = (((data0 >> 60) & 0xf) | (phv_src_[10] & 0x30));
      phv_src_[10] = (((data1 << 4) & 0x30) | (phv_src_[10] & 0xf));
      phv_src_[11] = ((data1 >> 2) & 0x3f);
      phv_src_[12] = ((data1 >> 8) & 0x3f);
      phv_src_[13] = ((data1 >> 14) & 0x3f);
      phv_src_[14] = ((data1 >> 20) & 0x3f);
      phv_src_[15] = ((data1 >> 26) & 0x3f);
      phv_src_[16] = ((data1 >> 32) & 0x3f);
      phv_src_[17] = ((data1 >> 38) & 0x3f);
      phv_src_[18] = ((data1 >> 44) & 0x3f);
      phv_src_[19] = ((data1 >> 50) & 0x3f);
      phv_dst_[0] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1 && offset < 0x2) {
      phv_dst_[1] = data0;
      phv_dst_[2] = (data0 >> 8);
      phv_dst_[3] = (data0 >> 16);
      phv_dst_[4] = (data0 >> 24);
      phv_dst_[5] = (data0 >> 32);
      phv_dst_[6] = (data0 >> 40);
      phv_dst_[7] = (data0 >> 48);
      phv_dst_[8] = (data0 >> 56);
      phv_dst_[9] = data1;
      phv_dst_[10] = (data1 >> 8);
      phv_dst_[11] = (data1 >> 16);
      phv_dst_[12] = (data1 >> 24);
      phv_dst_[13] = (data1 >> 32);
      phv_dst_[14] = (data1 >> 40);
      phv_dst_[15] = (data1 >> 48);
      phv_dst_[16] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2 && offset < 0x3) {
      phv_dst_[17] = data0;
      phv_dst_[18] = (data0 >> 8);
      phv_dst_[19] = (data0 >> 16);
      phv_offset_add_dst_[0] = ((data0 >> 24) & 0x1);
      phv_offset_add_dst_[1] = ((data0 >> 25) & 0x1);
      phv_offset_add_dst_[2] = ((data0 >> 26) & 0x1);
      phv_offset_add_dst_[3] = ((data0 >> 27) & 0x1);
      phv_offset_add_dst_[4] = ((data0 >> 28) & 0x1);
      phv_offset_add_dst_[5] = ((data0 >> 29) & 0x1);
      phv_offset_add_dst_[6] = ((data0 >> 30) & 0x1);
      phv_offset_add_dst_[7] = ((data0 >> 31) & 0x1);
      phv_offset_add_dst_[8] = ((data0 >> 32) & 0x1);
      phv_offset_add_dst_[9] = ((data0 >> 33) & 0x1);
      phv_offset_add_dst_[10] = ((data0 >> 34) & 0x1);
      phv_offset_add_dst_[11] = ((data0 >> 35) & 0x1);
      phv_offset_add_dst_[12] = ((data0 >> 36) & 0x1);
      phv_offset_add_dst_[13] = ((data0 >> 37) & 0x1);
      phv_offset_add_dst_[14] = ((data0 >> 38) & 0x1);
      phv_offset_add_dst_[15] = ((data0 >> 39) & 0x1);
      phv_offset_add_dst_[16] = ((data0 >> 40) & 0x1);
      phv_offset_add_dst_[17] = ((data0 >> 41) & 0x1);
      phv_offset_add_dst_[18] = ((data0 >> 42) & 0x1);
      phv_offset_add_dst_[19] = ((data0 >> 43) & 0x1);
      extract_type_[0] = ((data0 >> 44) & 0x3);
      extract_type_[1] = ((data0 >> 46) & 0x3);
      extract_type_[2] = ((data0 >> 48) & 0x3);
      extract_type_[3] = ((data0 >> 50) & 0x3);
      extract_type_[4] = ((data0 >> 52) & 0x3);
      extract_type_[5] = ((data0 >> 54) & 0x3);
      extract_type_[6] = ((data0 >> 56) & 0x3);
      extract_type_[7] = ((data0 >> 58) & 0x3);
      extract_type_[8] = ((data0 >> 60) & 0x3);
      extract_type_[9] = ((data0 >> 62) & 0x3);
      extract_type_[10] = (data1 & 0x3);
      extract_type_[11] = ((data1 >> 2) & 0x3);
      extract_type_[12] = ((data1 >> 4) & 0x3);
      extract_type_[13] = ((data1 >> 6) & 0x3);
      extract_type_[14] = ((data1 >> 8) & 0x3);
      extract_type_[15] = ((data1 >> 10) & 0x3);
      extract_type_[16] = ((data1 >> 12) & 0x3);
      extract_type_[17] = ((data1 >> 14) & 0x3);
      extract_type_[18] = ((data1 >> 16) & 0x3);
      extract_type_[19] = ((data1 >> 18) & 0x3);
      csum_addr_[0] = ((data1 >> 20) & 0x1f);
      csum_addr_[1] = ((data1 >> 25) & 0x1f);
      csum_addr_[2] = ((data1 >> 30) & 0x1f);
      csum_addr_[3] = ((data1 >> 35) & 0x1f);
      csum_addr_[4] = ((data1 >> 40) & 0x1f);
      csum_en_[0] = ((data1 >> 45) & 0x1);
      csum_en_[1] = ((data1 >> 46) & 0x1);
      csum_en_[2] = ((data1 >> 47) & 0x1);
      csum_en_[3] = ((data1 >> 48) & 0x1);
      csum_en_[4] = ((data1 >> 49) & 0x1);
      dst_offset_inc_ = ((data1 >> 50) & 0x1f);
      dst_offset_rst_ = ((data1 >> 55) & 0x1);
      pri_upd_type_ = ((data1 >> 56) & 0x1);
      pri_upd_src_ = ((data1 >> 57) & 0x1f);
      pri_upd_en_shr_ = (((data1 >> 62) & 0x3) | (pri_upd_en_shr_ & 0xc));
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3 && offset < 0x4) {
      pri_upd_en_shr_ = (((data0 << 2) & 0xc) | (pri_upd_en_shr_ & 0x3));
      pri_upd_val_mask_ = ((data0 >> 2) & 0x7);
      ver_upd_type_ = ((data0 >> 5) & 0x1);
      ver_upd_src_ = ((data0 >> 6) & 0x1f);
      ver_upd_en_shr_ = ((data0 >> 11) & 0xf);
      ver_upd_val_mask_ = ((data0 >> 15) & 0x3);
      val_const_[0] = (data0 >> 17);
      val_const_[1] = (data0 >> 33);
      val_const_rot_[0] = ((data0 >> 49) & 0x1);
      val_const_rot_[1] = ((data0 >> 50) & 0x1);
      val_const_32b_bond_ = ((data0 >> 51) & 0x1);
      clot_type_[0] = ((data0 >> 52) & 0x1);
      clot_type_[1] = ((data0 >> 53) & 0x1);
      clot_len_src_[0] = ((data0 >> 54) & 0x3f);
      clot_len_src_[1] = (((data0 >> 60) & 0xf) | (clot_len_src_[1] & 0x30));
      clot_len_src_[1] = (((data1 << 4) & 0x30) | (clot_len_src_[1] & 0xf));
      clot_en_len_shr_[0] = ((data1 >> 2) & 0xf);
      clot_en_len_shr_[1] = ((data1 >> 6) & 0xf);
      clot_len_mask_[0] = ((data1 >> 10) & 0x3f);
      clot_len_mask_[1] = ((data1 >> 16) & 0x3f);
      clot_len_add_ = ((data1 >> 22) & 0x3f);
      clot_offset_[0] = ((data1 >> 28) & 0x1f);
      clot_offset_[1] = ((data1 >> 33) & 0x1f);
      clot_tag_[0] = ((data1 >> 38) & 0x3f);
      clot_tag_[1] = ((data1 >> 44) & 0x3f);
      clot_tag_offset_add_[0] = ((data1 >> 50) & 0x1);
      clot_tag_offset_add_[1] = ((data1 >> 51) & 0x1);
      clot_has_csum_[0] = ((data1 >> 52) & 0x1);
      clot_has_csum_[1] = ((data1 >> 53) & 0x1);
      hdr_len_inc_stop_ = ((data1 >> 54) & 0x1);
      hdr_len_inc_final_amt_ = ((data1 >> 55) & 0x3f);
      disable_partial_hdr_err_ = ((data1 >> 61) & 0x1);
      if (write_callback_) write_callback_();
    }
    else {
      assert(0);
    }
    return true;
  }

  void reset(
      
      ) {
    phv_src_[0] = 0;
    phv_src_[1] = 0;
    phv_src_[2] = 0;
    phv_src_[3] = 0;
    phv_src_[4] = 0;
    phv_src_[5] = 0;
    phv_src_[6] = 0;
    phv_src_[7] = 0;
    phv_src_[8] = 0;
    phv_src_[9] = 0;
    phv_src_[10] = 0;
    phv_src_[11] = 0;
    phv_src_[12] = 0;
    phv_src_[13] = 0;
    phv_src_[14] = 0;
    phv_src_[15] = 0;
    phv_src_[16] = 0;
    phv_src_[17] = 0;
    phv_src_[18] = 0;
    phv_src_[19] = 0;
    phv_dst_[0] = 0;
    phv_dst_[1] = 0;
    phv_dst_[2] = 0;
    phv_dst_[3] = 0;
    phv_dst_[4] = 0;
    phv_dst_[5] = 0;
    phv_dst_[6] = 0;
    phv_dst_[7] = 0;
    phv_dst_[8] = 0;
    phv_dst_[9] = 0;
    phv_dst_[10] = 0;
    phv_dst_[11] = 0;
    phv_dst_[12] = 0;
    phv_dst_[13] = 0;
    phv_dst_[14] = 0;
    phv_dst_[15] = 0;
    phv_dst_[16] = 0;
    phv_dst_[17] = 0;
    phv_dst_[18] = 0;
    phv_dst_[19] = 0;
    phv_offset_add_dst_[0] = 0;
    phv_offset_add_dst_[1] = 0;
    phv_offset_add_dst_[2] = 0;
    phv_offset_add_dst_[3] = 0;
    phv_offset_add_dst_[4] = 0;
    phv_offset_add_dst_[5] = 0;
    phv_offset_add_dst_[6] = 0;
    phv_offset_add_dst_[7] = 0;
    phv_offset_add_dst_[8] = 0;
    phv_offset_add_dst_[9] = 0;
    phv_offset_add_dst_[10] = 0;
    phv_offset_add_dst_[11] = 0;
    phv_offset_add_dst_[12] = 0;
    phv_offset_add_dst_[13] = 0;
    phv_offset_add_dst_[14] = 0;
    phv_offset_add_dst_[15] = 0;
    phv_offset_add_dst_[16] = 0;
    phv_offset_add_dst_[17] = 0;
    phv_offset_add_dst_[18] = 0;
    phv_offset_add_dst_[19] = 0;
    extract_type_[0] = 0;
    extract_type_[1] = 0;
    extract_type_[2] = 0;
    extract_type_[3] = 0;
    extract_type_[4] = 0;
    extract_type_[5] = 0;
    extract_type_[6] = 0;
    extract_type_[7] = 0;
    extract_type_[8] = 0;
    extract_type_[9] = 0;
    extract_type_[10] = 0;
    extract_type_[11] = 0;
    extract_type_[12] = 0;
    extract_type_[13] = 0;
    extract_type_[14] = 0;
    extract_type_[15] = 0;
    extract_type_[16] = 0;
    extract_type_[17] = 0;
    extract_type_[18] = 0;
    extract_type_[19] = 0;
    csum_addr_[0] = 0;
    csum_addr_[1] = 0;
    csum_addr_[2] = 0;
    csum_addr_[3] = 0;
    csum_addr_[4] = 0;
    csum_en_[0] = 0;
    csum_en_[1] = 0;
    csum_en_[2] = 0;
    csum_en_[3] = 0;
    csum_en_[4] = 0;
    dst_offset_inc_ = 0;
    dst_offset_rst_ = 0;
    pri_upd_type_ = 0;
    pri_upd_src_ = 0;
    pri_upd_en_shr_ = 0;
    pri_upd_val_mask_ = 0;
    ver_upd_type_ = 0;
    ver_upd_src_ = 0;
    ver_upd_en_shr_ = 0;
    ver_upd_val_mask_ = 0;
    val_const_[0] = 0;
    val_const_[1] = 0;
    val_const_rot_[0] = 0;
    val_const_rot_[1] = 0;
    val_const_32b_bond_ = 0;
    clot_type_[0] = 0;
    clot_type_[1] = 0;
    clot_len_src_[0] = 0;
    clot_len_src_[1] = 0;
    clot_en_len_shr_[0] = 0;
    clot_en_len_shr_[1] = 0;
    clot_len_mask_[0] = 0;
    clot_len_mask_[1] = 0;
    clot_len_add_ = 0;
    clot_offset_[0] = 0;
    clot_offset_[1] = 0;
    clot_tag_[0] = 0;
    clot_tag_[1] = 0;
    clot_tag_offset_add_[0] = 0;
    clot_tag_offset_add_[1] = 0;
    clot_has_csum_[0] = 0;
    clot_has_csum_[1] = 0;
    hdr_len_inc_stop_ = 0;
    hdr_len_inc_final_amt_ = 0;
    disable_partial_hdr_err_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRow") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRow") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 20 > phv_src_;
  std::array< uint8_t, 20 > phv_dst_;
  std::array< uint8_t, 20 > phv_offset_add_dst_;
  std::array< uint8_t, 20 > extract_type_;
  std::array< uint8_t, 5 > csum_addr_;
  std::array< uint8_t, 5 > csum_en_;
  uint8_t dst_offset_inc_;
  uint8_t dst_offset_rst_;
  uint8_t pri_upd_type_;
  uint8_t pri_upd_src_;
  uint8_t pri_upd_en_shr_;
  uint8_t pri_upd_val_mask_;
  uint8_t ver_upd_type_;
  uint8_t ver_upd_src_;
  uint8_t ver_upd_en_shr_;
  uint8_t ver_upd_val_mask_;
  std::array< uint16_t, 2 > val_const_;
  std::array< uint8_t, 2 > val_const_rot_;
  uint8_t val_const_32b_bond_;
  std::array< uint8_t, 2 > clot_type_;
  std::array< uint8_t, 2 > clot_len_src_;
  std::array< uint8_t, 2 > clot_en_len_shr_;
  std::array< uint8_t, 2 > clot_len_mask_;
  uint8_t clot_len_add_;
  std::array< uint8_t, 2 > clot_offset_;
  std::array< uint8_t, 2 > clot_tag_;
  std::array< uint8_t, 2 > clot_tag_offset_add_;
  std::array< uint8_t, 2 > clot_has_csum_;
  uint8_t hdr_len_inc_stop_;
  uint8_t hdr_len_inc_final_amt_;
  uint8_t disable_partial_hdr_err_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrPoActionRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_po_action_row), 4, true, write_callback, read_callback, std::string("PrsrPoActionRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_action_row))
    {
    }
  PrsrPoActionRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrPoActionRowMutable")
    {
    }
public:








  uint8_t phv_src(int j0) { return phv_src_[j0]; }
  void phv_src(int j0,const uint8_t &v) { phv_src_[j0]=v; }







  uint8_t phv_dst(int j0) { return phv_dst_[j0]; }
  void phv_dst(int j0,const uint8_t &v) { phv_dst_[j0]=v; }








  uint8_t phv_offset_add_dst(int j0) { return phv_offset_add_dst_[j0]; }
  void phv_offset_add_dst(int j0,const uint8_t &v) { phv_offset_add_dst_[j0]=v; }







  uint8_t extract_type(int j0) { return extract_type_[j0]; }
  void extract_type(int j0,const uint8_t &v) { extract_type_[j0]=v; }






  uint8_t csum_addr(int j0) { return csum_addr_[j0]; }
  void csum_addr(int j0,const uint8_t &v) { csum_addr_[j0]=v; }






  uint8_t csum_en(int j0) { return csum_en_[j0]; }
  void csum_en(int j0,const uint8_t &v) { csum_en_[j0]=v; }






  uint8_t dst_offset_inc() { return dst_offset_inc_; }
  void dst_offset_inc(const uint8_t &v) { dst_offset_inc_=v; }






  uint8_t dst_offset_rst() { return dst_offset_rst_; }
  void dst_offset_rst(const uint8_t &v) { dst_offset_rst_=v; }






  uint8_t pri_upd_type() { return pri_upd_type_; }
  void pri_upd_type(const uint8_t &v) { pri_upd_type_=v; }






  uint8_t pri_upd_src() { return pri_upd_src_; }
  void pri_upd_src(const uint8_t &v) { pri_upd_src_=v; }







  uint8_t pri_upd_en_shr() { return pri_upd_en_shr_; }
  void pri_upd_en_shr(const uint8_t &v) { pri_upd_en_shr_=v; }






  uint8_t pri_upd_val_mask() { return pri_upd_val_mask_; }
  void pri_upd_val_mask(const uint8_t &v) { pri_upd_val_mask_=v; }






  uint8_t ver_upd_type() { return ver_upd_type_; }
  void ver_upd_type(const uint8_t &v) { ver_upd_type_=v; }






  uint8_t ver_upd_src() { return ver_upd_src_; }
  void ver_upd_src(const uint8_t &v) { ver_upd_src_=v; }







  uint8_t ver_upd_en_shr() { return ver_upd_en_shr_; }
  void ver_upd_en_shr(const uint8_t &v) { ver_upd_en_shr_=v; }






  uint8_t ver_upd_val_mask() { return ver_upd_val_mask_; }
  void ver_upd_val_mask(const uint8_t &v) { ver_upd_val_mask_=v; }







  uint16_t val_const(int j0) { return val_const_[j0]; }
  void val_const(int j0,const uint16_t &v) { val_const_[j0]=v; }







  uint8_t val_const_rot(int j0) { return val_const_rot_[j0]; }
  void val_const_rot(int j0,const uint8_t &v) { val_const_rot_[j0]=v; }





  uint8_t val_const_32b_bond() { return val_const_32b_bond_; }
  void val_const_32b_bond(const uint8_t &v) { val_const_32b_bond_=v; }








  uint8_t clot_type(int j0) { return clot_type_[j0]; }
  void clot_type(int j0,const uint8_t &v) { clot_type_[j0]=v; }









  uint8_t clot_len_src(int j0) { return clot_len_src_[j0]; }
  void clot_len_src(int j0,const uint8_t &v) { clot_len_src_[j0]=v; }









  uint8_t clot_en_len_shr(int j0) { return clot_en_len_shr_[j0]; }
  void clot_en_len_shr(int j0,const uint8_t &v) { clot_en_len_shr_[j0]=v; }







  uint8_t clot_len_mask(int j0) { return clot_len_mask_[j0]; }
  void clot_len_mask(int j0,const uint8_t &v) { clot_len_mask_[j0]=v; }









  uint8_t clot_len_add() { return clot_len_add_; }
  void clot_len_add(const uint8_t &v) { clot_len_add_=v; }







  uint8_t clot_offset(int j0) { return clot_offset_[j0]; }
  void clot_offset(int j0,const uint8_t &v) { clot_offset_[j0]=v; }







  uint8_t clot_tag(int j0) { return clot_tag_[j0]; }
  void clot_tag(int j0,const uint8_t &v) { clot_tag_[j0]=v; }







  uint8_t clot_tag_offset_add(int j0) { return clot_tag_offset_add_[j0]; }
  void clot_tag_offset_add(int j0,const uint8_t &v) { clot_tag_offset_add_[j0]=v; }







  uint8_t clot_has_csum(int j0) { return clot_has_csum_[j0]; }
  void clot_has_csum(int j0,const uint8_t &v) { clot_has_csum_[j0]=v; }






  uint8_t hdr_len_inc_stop() { return hdr_len_inc_stop_; }
  void hdr_len_inc_stop(const uint8_t &v) { hdr_len_inc_stop_=v; }





  uint8_t hdr_len_inc_final_amt() { return hdr_len_inc_final_amt_; }
  void hdr_len_inc_final_amt(const uint8_t &v) { hdr_len_inc_final_amt_=v; }





  uint8_t disable_partial_hdr_err() { return disable_partial_hdr_err_; }
  void disable_partial_hdr_err(const uint8_t &v) { disable_partial_hdr_err_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      if (read_callback_) read_callback_();
      *data0 = (static_cast<uint64_t>(phv_src_[0]) & 0x3f);
      *data0 |= ((static_cast<uint64_t>(phv_src_[1]) & 0x3f) << 6);
      *data0 |= ((static_cast<uint64_t>(phv_src_[2]) & 0x3f) << 12);
      *data0 |= ((static_cast<uint64_t>(phv_src_[3]) & 0x3f) << 18);
      *data0 |= ((static_cast<uint64_t>(phv_src_[4]) & 0x3f) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_src_[5]) & 0x3f) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_src_[6]) & 0x3f) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_src_[7]) & 0x3f) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_src_[8]) & 0x3f) << 48);
      *data0 |= ((static_cast<uint64_t>(phv_src_[9]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(phv_src_[10]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(phv_src_[10]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(phv_src_[11]) & 0x3f) << 2);
      *data1 |= ((static_cast<uint64_t>(phv_src_[12]) & 0x3f) << 8);
      *data1 |= ((static_cast<uint64_t>(phv_src_[13]) & 0x3f) << 14);
      *data1 |= ((static_cast<uint64_t>(phv_src_[14]) & 0x3f) << 20);
      *data1 |= ((static_cast<uint64_t>(phv_src_[15]) & 0x3f) << 26);
      *data1 |= ((static_cast<uint64_t>(phv_src_[16]) & 0x3f) << 32);
      *data1 |= ((static_cast<uint64_t>(phv_src_[17]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(phv_src_[18]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(phv_src_[19]) & 0x3f) << 50);
      *data1 |= (static_cast<uint64_t>(phv_dst_[0]) << 56);
    }
    else if (offset >= 0x1 && offset < 0x2) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[1]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[2]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[3]) << 16);
      *data0 |= (static_cast<uint64_t>(phv_dst_[4]) << 24);
      *data0 |= (static_cast<uint64_t>(phv_dst_[5]) << 32);
      *data0 |= (static_cast<uint64_t>(phv_dst_[6]) << 40);
      *data0 |= (static_cast<uint64_t>(phv_dst_[7]) << 48);
      *data0 |= (static_cast<uint64_t>(phv_dst_[8]) << 56);
      *data1 = static_cast<uint64_t>(phv_dst_[9]);
      *data1 |= (static_cast<uint64_t>(phv_dst_[10]) << 8);
      *data1 |= (static_cast<uint64_t>(phv_dst_[11]) << 16);
      *data1 |= (static_cast<uint64_t>(phv_dst_[12]) << 24);
      *data1 |= (static_cast<uint64_t>(phv_dst_[13]) << 32);
      *data1 |= (static_cast<uint64_t>(phv_dst_[14]) << 40);
      *data1 |= (static_cast<uint64_t>(phv_dst_[15]) << 48);
      *data1 |= (static_cast<uint64_t>(phv_dst_[16]) << 56);
    }
    else if (offset >= 0x2 && offset < 0x3) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[17]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[18]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[19]) << 16);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[0]) & 0x1) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[1]) & 0x1) << 25);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[2]) & 0x1) << 26);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[3]) & 0x1) << 27);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[4]) & 0x1) << 28);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[5]) & 0x1) << 29);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[6]) & 0x1) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[7]) & 0x1) << 31);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[8]) & 0x1) << 32);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[9]) & 0x1) << 33);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[10]) & 0x1) << 34);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[11]) & 0x1) << 35);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[12]) & 0x1) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[13]) & 0x1) << 37);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[14]) & 0x1) << 38);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[15]) & 0x1) << 39);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[16]) & 0x1) << 40);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[17]) & 0x1) << 41);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[18]) & 0x1) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[19]) & 0x1) << 43);
      *data0 |= ((static_cast<uint64_t>(extract_type_[0]) & 0x3) << 44);
      *data0 |= ((static_cast<uint64_t>(extract_type_[1]) & 0x3) << 46);
      *data0 |= ((static_cast<uint64_t>(extract_type_[2]) & 0x3) << 48);
      *data0 |= ((static_cast<uint64_t>(extract_type_[3]) & 0x3) << 50);
      *data0 |= ((static_cast<uint64_t>(extract_type_[4]) & 0x3) << 52);
      *data0 |= ((static_cast<uint64_t>(extract_type_[5]) & 0x3) << 54);
      *data0 |= ((static_cast<uint64_t>(extract_type_[6]) & 0x3) << 56);
      *data0 |= ((static_cast<uint64_t>(extract_type_[7]) & 0x3) << 58);
      *data0 |= ((static_cast<uint64_t>(extract_type_[8]) & 0x3) << 60);
      *data0 |= ((static_cast<uint64_t>(extract_type_[9]) & 0x3) << 62);
      *data1 = (static_cast<uint64_t>(extract_type_[10]) & 0x3);
      *data1 |= ((static_cast<uint64_t>(extract_type_[11]) & 0x3) << 2);
      *data1 |= ((static_cast<uint64_t>(extract_type_[12]) & 0x3) << 4);
      *data1 |= ((static_cast<uint64_t>(extract_type_[13]) & 0x3) << 6);
      *data1 |= ((static_cast<uint64_t>(extract_type_[14]) & 0x3) << 8);
      *data1 |= ((static_cast<uint64_t>(extract_type_[15]) & 0x3) << 10);
      *data1 |= ((static_cast<uint64_t>(extract_type_[16]) & 0x3) << 12);
      *data1 |= ((static_cast<uint64_t>(extract_type_[17]) & 0x3) << 14);
      *data1 |= ((static_cast<uint64_t>(extract_type_[18]) & 0x3) << 16);
      *data1 |= ((static_cast<uint64_t>(extract_type_[19]) & 0x3) << 18);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[0]) & 0x1f) << 20);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[1]) & 0x1f) << 25);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[2]) & 0x1f) << 30);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[3]) & 0x1f) << 35);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[4]) & 0x1f) << 40);
      *data1 |= ((static_cast<uint64_t>(csum_en_[0]) & 0x1) << 45);
      *data1 |= ((static_cast<uint64_t>(csum_en_[1]) & 0x1) << 46);
      *data1 |= ((static_cast<uint64_t>(csum_en_[2]) & 0x1) << 47);
      *data1 |= ((static_cast<uint64_t>(csum_en_[3]) & 0x1) << 48);
      *data1 |= ((static_cast<uint64_t>(csum_en_[4]) & 0x1) << 49);
      *data1 |= ((static_cast<uint64_t>(dst_offset_inc_) & 0x1f) << 50);
      *data1 |= ((static_cast<uint64_t>(dst_offset_rst_) & 0x1) << 55);
      *data1 |= ((static_cast<uint64_t>(pri_upd_type_) & 0x1) << 56);
      *data1 |= ((static_cast<uint64_t>(pri_upd_src_) & 0x1f) << 57);
      *data1 |= ((static_cast<uint64_t>(pri_upd_en_shr_) & 0x3) << 62);
    }
    else if (offset >= 0x3 && offset < 0x4) {
      if (read_callback_) read_callback_();
      *data0 = ((static_cast<uint64_t>(pri_upd_en_shr_) & 0xc) >> 2);
      *data0 |= ((static_cast<uint64_t>(pri_upd_val_mask_) & 0x7) << 2);
      *data0 |= ((static_cast<uint64_t>(ver_upd_type_) & 0x1) << 5);
      *data0 |= ((static_cast<uint64_t>(ver_upd_src_) & 0x1f) << 6);
      *data0 |= ((static_cast<uint64_t>(ver_upd_en_shr_) & 0xf) << 11);
      *data0 |= ((static_cast<uint64_t>(ver_upd_val_mask_) & 0x3) << 15);
      *data0 |= (static_cast<uint64_t>(val_const_[0]) << 17);
      *data0 |= (static_cast<uint64_t>(val_const_[1]) << 33);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[0]) & 0x1) << 49);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[1]) & 0x1) << 50);
      *data0 |= ((static_cast<uint64_t>(val_const_32b_bond_) & 0x1) << 51);
      *data0 |= ((static_cast<uint64_t>(clot_type_[0]) & 0x1) << 52);
      *data0 |= ((static_cast<uint64_t>(clot_type_[1]) & 0x1) << 53);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[0]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[1]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(clot_len_src_[1]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[0]) & 0xf) << 2);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[1]) & 0xf) << 6);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[0]) & 0x3f) << 10);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[1]) & 0x3f) << 16);
      *data1 |= ((static_cast<uint64_t>(clot_len_add_) & 0x3f) << 22);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[0]) & 0x1f) << 28);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[1]) & 0x1f) << 33);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[0]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[1]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[0]) & 0x1) << 50);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[1]) & 0x1) << 51);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[0]) & 0x1) << 52);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[1]) & 0x1) << 53);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_stop_) & 0x1) << 54);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_final_amt_) & 0x3f) << 55);
      *data1 |= ((static_cast<uint64_t>(disable_partial_hdr_err_) & 0x1) << 61);
    }
    else {
      assert(0);
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      phv_src_[0] = (data0 & 0x3f);
      phv_src_[1] = ((data0 >> 6) & 0x3f);
      phv_src_[2] = ((data0 >> 12) & 0x3f);
      phv_src_[3] = ((data0 >> 18) & 0x3f);
      phv_src_[4] = ((data0 >> 24) & 0x3f);
      phv_src_[5] = ((data0 >> 30) & 0x3f);
      phv_src_[6] = ((data0 >> 36) & 0x3f);
      phv_src_[7] = ((data0 >> 42) & 0x3f);
      phv_src_[8] = ((data0 >> 48) & 0x3f);
      phv_src_[9] = ((data0 >> 54) & 0x3f);
      phv_src_[10] = (((data0 >> 60) & 0xf) | (phv_src_[10] & 0x30));
      phv_src_[10] = (((data1 << 4) & 0x30) | (phv_src_[10] & 0xf));
      phv_src_[11] = ((data1 >> 2) & 0x3f);
      phv_src_[12] = ((data1 >> 8) & 0x3f);
      phv_src_[13] = ((data1 >> 14) & 0x3f);
      phv_src_[14] = ((data1 >> 20) & 0x3f);
      phv_src_[15] = ((data1 >> 26) & 0x3f);
      phv_src_[16] = ((data1 >> 32) & 0x3f);
      phv_src_[17] = ((data1 >> 38) & 0x3f);
      phv_src_[18] = ((data1 >> 44) & 0x3f);
      phv_src_[19] = ((data1 >> 50) & 0x3f);
      phv_dst_[0] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1 && offset < 0x2) {
      phv_dst_[1] = data0;
      phv_dst_[2] = (data0 >> 8);
      phv_dst_[3] = (data0 >> 16);
      phv_dst_[4] = (data0 >> 24);
      phv_dst_[5] = (data0 >> 32);
      phv_dst_[6] = (data0 >> 40);
      phv_dst_[7] = (data0 >> 48);
      phv_dst_[8] = (data0 >> 56);
      phv_dst_[9] = data1;
      phv_dst_[10] = (data1 >> 8);
      phv_dst_[11] = (data1 >> 16);
      phv_dst_[12] = (data1 >> 24);
      phv_dst_[13] = (data1 >> 32);
      phv_dst_[14] = (data1 >> 40);
      phv_dst_[15] = (data1 >> 48);
      phv_dst_[16] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2 && offset < 0x3) {
      phv_dst_[17] = data0;
      phv_dst_[18] = (data0 >> 8);
      phv_dst_[19] = (data0 >> 16);
      phv_offset_add_dst_[0] = ((data0 >> 24) & 0x1);
      phv_offset_add_dst_[1] = ((data0 >> 25) & 0x1);
      phv_offset_add_dst_[2] = ((data0 >> 26) & 0x1);
      phv_offset_add_dst_[3] = ((data0 >> 27) & 0x1);
      phv_offset_add_dst_[4] = ((data0 >> 28) & 0x1);
      phv_offset_add_dst_[5] = ((data0 >> 29) & 0x1);
      phv_offset_add_dst_[6] = ((data0 >> 30) & 0x1);
      phv_offset_add_dst_[7] = ((data0 >> 31) & 0x1);
      phv_offset_add_dst_[8] = ((data0 >> 32) & 0x1);
      phv_offset_add_dst_[9] = ((data0 >> 33) & 0x1);
      phv_offset_add_dst_[10] = ((data0 >> 34) & 0x1);
      phv_offset_add_dst_[11] = ((data0 >> 35) & 0x1);
      phv_offset_add_dst_[12] = ((data0 >> 36) & 0x1);
      phv_offset_add_dst_[13] = ((data0 >> 37) & 0x1);
      phv_offset_add_dst_[14] = ((data0 >> 38) & 0x1);
      phv_offset_add_dst_[15] = ((data0 >> 39) & 0x1);
      phv_offset_add_dst_[16] = ((data0 >> 40) & 0x1);
      phv_offset_add_dst_[17] = ((data0 >> 41) & 0x1);
      phv_offset_add_dst_[18] = ((data0 >> 42) & 0x1);
      phv_offset_add_dst_[19] = ((data0 >> 43) & 0x1);
      extract_type_[0] = ((data0 >> 44) & 0x3);
      extract_type_[1] = ((data0 >> 46) & 0x3);
      extract_type_[2] = ((data0 >> 48) & 0x3);
      extract_type_[3] = ((data0 >> 50) & 0x3);
      extract_type_[4] = ((data0 >> 52) & 0x3);
      extract_type_[5] = ((data0 >> 54) & 0x3);
      extract_type_[6] = ((data0 >> 56) & 0x3);
      extract_type_[7] = ((data0 >> 58) & 0x3);
      extract_type_[8] = ((data0 >> 60) & 0x3);
      extract_type_[9] = ((data0 >> 62) & 0x3);
      extract_type_[10] = (data1 & 0x3);
      extract_type_[11] = ((data1 >> 2) & 0x3);
      extract_type_[12] = ((data1 >> 4) & 0x3);
      extract_type_[13] = ((data1 >> 6) & 0x3);
      extract_type_[14] = ((data1 >> 8) & 0x3);
      extract_type_[15] = ((data1 >> 10) & 0x3);
      extract_type_[16] = ((data1 >> 12) & 0x3);
      extract_type_[17] = ((data1 >> 14) & 0x3);
      extract_type_[18] = ((data1 >> 16) & 0x3);
      extract_type_[19] = ((data1 >> 18) & 0x3);
      csum_addr_[0] = ((data1 >> 20) & 0x1f);
      csum_addr_[1] = ((data1 >> 25) & 0x1f);
      csum_addr_[2] = ((data1 >> 30) & 0x1f);
      csum_addr_[3] = ((data1 >> 35) & 0x1f);
      csum_addr_[4] = ((data1 >> 40) & 0x1f);
      csum_en_[0] = ((data1 >> 45) & 0x1);
      csum_en_[1] = ((data1 >> 46) & 0x1);
      csum_en_[2] = ((data1 >> 47) & 0x1);
      csum_en_[3] = ((data1 >> 48) & 0x1);
      csum_en_[4] = ((data1 >> 49) & 0x1);
      dst_offset_inc_ = ((data1 >> 50) & 0x1f);
      dst_offset_rst_ = ((data1 >> 55) & 0x1);
      pri_upd_type_ = ((data1 >> 56) & 0x1);
      pri_upd_src_ = ((data1 >> 57) & 0x1f);
      pri_upd_en_shr_ = (((data1 >> 62) & 0x3) | (pri_upd_en_shr_ & 0xc));
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3 && offset < 0x4) {
      pri_upd_en_shr_ = (((data0 << 2) & 0xc) | (pri_upd_en_shr_ & 0x3));
      pri_upd_val_mask_ = ((data0 >> 2) & 0x7);
      ver_upd_type_ = ((data0 >> 5) & 0x1);
      ver_upd_src_ = ((data0 >> 6) & 0x1f);
      ver_upd_en_shr_ = ((data0 >> 11) & 0xf);
      ver_upd_val_mask_ = ((data0 >> 15) & 0x3);
      val_const_[0] = (data0 >> 17);
      val_const_[1] = (data0 >> 33);
      val_const_rot_[0] = ((data0 >> 49) & 0x1);
      val_const_rot_[1] = ((data0 >> 50) & 0x1);
      val_const_32b_bond_ = ((data0 >> 51) & 0x1);
      clot_type_[0] = ((data0 >> 52) & 0x1);
      clot_type_[1] = ((data0 >> 53) & 0x1);
      clot_len_src_[0] = ((data0 >> 54) & 0x3f);
      clot_len_src_[1] = (((data0 >> 60) & 0xf) | (clot_len_src_[1] & 0x30));
      clot_len_src_[1] = (((data1 << 4) & 0x30) | (clot_len_src_[1] & 0xf));
      clot_en_len_shr_[0] = ((data1 >> 2) & 0xf);
      clot_en_len_shr_[1] = ((data1 >> 6) & 0xf);
      clot_len_mask_[0] = ((data1 >> 10) & 0x3f);
      clot_len_mask_[1] = ((data1 >> 16) & 0x3f);
      clot_len_add_ = ((data1 >> 22) & 0x3f);
      clot_offset_[0] = ((data1 >> 28) & 0x1f);
      clot_offset_[1] = ((data1 >> 33) & 0x1f);
      clot_tag_[0] = ((data1 >> 38) & 0x3f);
      clot_tag_[1] = ((data1 >> 44) & 0x3f);
      clot_tag_offset_add_[0] = ((data1 >> 50) & 0x1);
      clot_tag_offset_add_[1] = ((data1 >> 51) & 0x1);
      clot_has_csum_[0] = ((data1 >> 52) & 0x1);
      clot_has_csum_[1] = ((data1 >> 53) & 0x1);
      hdr_len_inc_stop_ = ((data1 >> 54) & 0x1);
      hdr_len_inc_final_amt_ = ((data1 >> 55) & 0x3f);
      disable_partial_hdr_err_ = ((data1 >> 61) & 0x1);
      if (write_callback_) write_callback_();
    }
    else {
      assert(0);
    }
    return true;
  }

  void reset(
      
      ) {
    phv_src_[0] = 0;
    phv_src_[1] = 0;
    phv_src_[2] = 0;
    phv_src_[3] = 0;
    phv_src_[4] = 0;
    phv_src_[5] = 0;
    phv_src_[6] = 0;
    phv_src_[7] = 0;
    phv_src_[8] = 0;
    phv_src_[9] = 0;
    phv_src_[10] = 0;
    phv_src_[11] = 0;
    phv_src_[12] = 0;
    phv_src_[13] = 0;
    phv_src_[14] = 0;
    phv_src_[15] = 0;
    phv_src_[16] = 0;
    phv_src_[17] = 0;
    phv_src_[18] = 0;
    phv_src_[19] = 0;
    phv_dst_[0] = 0;
    phv_dst_[1] = 0;
    phv_dst_[2] = 0;
    phv_dst_[3] = 0;
    phv_dst_[4] = 0;
    phv_dst_[5] = 0;
    phv_dst_[6] = 0;
    phv_dst_[7] = 0;
    phv_dst_[8] = 0;
    phv_dst_[9] = 0;
    phv_dst_[10] = 0;
    phv_dst_[11] = 0;
    phv_dst_[12] = 0;
    phv_dst_[13] = 0;
    phv_dst_[14] = 0;
    phv_dst_[15] = 0;
    phv_dst_[16] = 0;
    phv_dst_[17] = 0;
    phv_dst_[18] = 0;
    phv_dst_[19] = 0;
    phv_offset_add_dst_[0] = 0;
    phv_offset_add_dst_[1] = 0;
    phv_offset_add_dst_[2] = 0;
    phv_offset_add_dst_[3] = 0;
    phv_offset_add_dst_[4] = 0;
    phv_offset_add_dst_[5] = 0;
    phv_offset_add_dst_[6] = 0;
    phv_offset_add_dst_[7] = 0;
    phv_offset_add_dst_[8] = 0;
    phv_offset_add_dst_[9] = 0;
    phv_offset_add_dst_[10] = 0;
    phv_offset_add_dst_[11] = 0;
    phv_offset_add_dst_[12] = 0;
    phv_offset_add_dst_[13] = 0;
    phv_offset_add_dst_[14] = 0;
    phv_offset_add_dst_[15] = 0;
    phv_offset_add_dst_[16] = 0;
    phv_offset_add_dst_[17] = 0;
    phv_offset_add_dst_[18] = 0;
    phv_offset_add_dst_[19] = 0;
    extract_type_[0] = 0;
    extract_type_[1] = 0;
    extract_type_[2] = 0;
    extract_type_[3] = 0;
    extract_type_[4] = 0;
    extract_type_[5] = 0;
    extract_type_[6] = 0;
    extract_type_[7] = 0;
    extract_type_[8] = 0;
    extract_type_[9] = 0;
    extract_type_[10] = 0;
    extract_type_[11] = 0;
    extract_type_[12] = 0;
    extract_type_[13] = 0;
    extract_type_[14] = 0;
    extract_type_[15] = 0;
    extract_type_[16] = 0;
    extract_type_[17] = 0;
    extract_type_[18] = 0;
    extract_type_[19] = 0;
    csum_addr_[0] = 0;
    csum_addr_[1] = 0;
    csum_addr_[2] = 0;
    csum_addr_[3] = 0;
    csum_addr_[4] = 0;
    csum_en_[0] = 0;
    csum_en_[1] = 0;
    csum_en_[2] = 0;
    csum_en_[3] = 0;
    csum_en_[4] = 0;
    dst_offset_inc_ = 0;
    dst_offset_rst_ = 0;
    pri_upd_type_ = 0;
    pri_upd_src_ = 0;
    pri_upd_en_shr_ = 0;
    pri_upd_val_mask_ = 0;
    ver_upd_type_ = 0;
    ver_upd_src_ = 0;
    ver_upd_en_shr_ = 0;
    ver_upd_val_mask_ = 0;
    val_const_[0] = 0;
    val_const_[1] = 0;
    val_const_rot_[0] = 0;
    val_const_rot_[1] = 0;
    val_const_32b_bond_ = 0;
    clot_type_[0] = 0;
    clot_type_[1] = 0;
    clot_len_src_[0] = 0;
    clot_len_src_[1] = 0;
    clot_en_len_shr_[0] = 0;
    clot_en_len_shr_[1] = 0;
    clot_len_mask_[0] = 0;
    clot_len_mask_[1] = 0;
    clot_len_add_ = 0;
    clot_offset_[0] = 0;
    clot_offset_[1] = 0;
    clot_tag_[0] = 0;
    clot_tag_[1] = 0;
    clot_tag_offset_add_[0] = 0;
    clot_tag_offset_add_[1] = 0;
    clot_has_csum_[0] = 0;
    clot_has_csum_[1] = 0;
    hdr_len_inc_stop_ = 0;
    hdr_len_inc_final_amt_ = 0;
    disable_partial_hdr_err_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRowMutable") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRowMutable") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 20 > phv_src_;
  std::array< uint8_t, 20 > phv_dst_;
  std::array< uint8_t, 20 > phv_offset_add_dst_;
  std::array< uint8_t, 20 > extract_type_;
  std::array< uint8_t, 5 > csum_addr_;
  std::array< uint8_t, 5 > csum_en_;
  uint8_t dst_offset_inc_;
  uint8_t dst_offset_rst_;
  uint8_t pri_upd_type_;
  uint8_t pri_upd_src_;
  uint8_t pri_upd_en_shr_;
  uint8_t pri_upd_val_mask_;
  uint8_t ver_upd_type_;
  uint8_t ver_upd_src_;
  uint8_t ver_upd_en_shr_;
  uint8_t ver_upd_val_mask_;
  std::array< uint16_t, 2 > val_const_;
  std::array< uint8_t, 2 > val_const_rot_;
  uint8_t val_const_32b_bond_;
  std::array< uint8_t, 2 > clot_type_;
  std::array< uint8_t, 2 > clot_len_src_;
  std::array< uint8_t, 2 > clot_en_len_shr_;
  std::array< uint8_t, 2 > clot_len_mask_;
  uint8_t clot_len_add_;
  std::array< uint8_t, 2 > clot_offset_;
  std::array< uint8_t, 2 > clot_tag_;
  std::array< uint8_t, 2 > clot_tag_offset_add_;
  std::array< uint8_t, 2 > clot_has_csum_;
  uint8_t hdr_len_inc_stop_;
  uint8_t hdr_len_inc_final_amt_;
  uint8_t disable_partial_hdr_err_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrPoActionRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 4 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrPoActionRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:








  uint8_t &phv_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_src(j0);
  }







  uint8_t &phv_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_dst(j0);
  }








  uint8_t &phv_offset_add_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_offset_add_dst(j0);
  }







  uint8_t &extract_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].extract_type(j0);
  }






  uint8_t &csum_addr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_addr(j0);
  }






  uint8_t &csum_en(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_en(j0);
  }






  uint8_t &dst_offset_inc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_inc();
  }






  uint8_t &dst_offset_rst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_rst();
  }






  uint8_t &pri_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_type();
  }






  uint8_t &pri_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_src();
  }







  uint8_t &pri_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_en_shr();
  }






  uint8_t &pri_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_val_mask();
  }






  uint8_t &ver_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_type();
  }






  uint8_t &ver_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_src();
  }







  uint8_t &ver_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_en_shr();
  }






  uint8_t &ver_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_val_mask();
  }







  uint16_t &val_const(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const(j0);
  }







  uint8_t &val_const_rot(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_rot(j0);
  }





  uint8_t &val_const_32b_bond(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_32b_bond();
  }








  uint8_t &clot_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_type(j0);
  }









  uint8_t &clot_len_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_src(j0);
  }









  uint8_t &clot_en_len_shr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_en_len_shr(j0);
  }







  uint8_t &clot_len_mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_mask(j0);
  }









  uint8_t &clot_len_add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_add();
  }







  uint8_t &clot_offset(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_offset(j0);
  }







  uint8_t &clot_tag(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag(j0);
  }







  uint8_t &clot_tag_offset_add(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag_offset_add(j0);
  }







  uint8_t &clot_has_csum(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_has_csum(j0);
  }






  uint8_t &hdr_len_inc_stop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_stop();
  }





  uint8_t &hdr_len_inc_final_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_final_amt();
  }





  uint8_t &disable_partial_hdr_err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].disable_partial_hdr_err();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/4;
    (*offset) -= (i*4);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoActionRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoActionRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoActionRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrPoActionRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 4 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrPoActionRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:








  uint8_t phv_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_src(j0);
  }
  void phv_src(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].phv_src(j0,v);
  }







  uint8_t phv_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_dst(j0);
  }
  void phv_dst(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].phv_dst(j0,v);
  }








  uint8_t phv_offset_add_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_offset_add_dst(j0);
  }
  void phv_offset_add_dst(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].phv_offset_add_dst(j0,v);
  }







  uint8_t extract_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].extract_type(j0);
  }
  void extract_type(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].extract_type(j0,v);
  }






  uint8_t csum_addr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_addr(j0);
  }
  void csum_addr(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].csum_addr(j0,v);
  }






  uint8_t csum_en(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_en(j0);
  }
  void csum_en(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].csum_en(j0,v);
  }






  uint8_t dst_offset_inc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_inc();
  }
  void dst_offset_inc(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst_offset_inc(v);
  }






  uint8_t dst_offset_rst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_rst();
  }
  void dst_offset_rst(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst_offset_rst(v);
  }






  uint8_t pri_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_type();
  }
  void pri_upd_type(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_type(v);
  }






  uint8_t pri_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_src();
  }
  void pri_upd_src(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_src(v);
  }







  uint8_t pri_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_en_shr();
  }
  void pri_upd_en_shr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_en_shr(v);
  }






  uint8_t pri_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_val_mask();
  }
  void pri_upd_val_mask(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_val_mask(v);
  }






  uint8_t ver_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_type();
  }
  void ver_upd_type(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_type(v);
  }






  uint8_t ver_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_src();
  }
  void ver_upd_src(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_src(v);
  }







  uint8_t ver_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_en_shr();
  }
  void ver_upd_en_shr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_en_shr(v);
  }






  uint8_t ver_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_val_mask();
  }
  void ver_upd_val_mask(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_val_mask(v);
  }







  uint16_t val_const(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const(j0);
  }
  void val_const(uint32_t a0,int j0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].val_const(j0,v);
  }







  uint8_t val_const_rot(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_rot(j0);
  }
  void val_const_rot(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].val_const_rot(j0,v);
  }





  uint8_t val_const_32b_bond(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_32b_bond();
  }
  void val_const_32b_bond(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].val_const_32b_bond(v);
  }








  uint8_t clot_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_type(j0);
  }
  void clot_type(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_type(j0,v);
  }









  uint8_t clot_len_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_src(j0);
  }
  void clot_len_src(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_len_src(j0,v);
  }









  uint8_t clot_en_len_shr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_en_len_shr(j0);
  }
  void clot_en_len_shr(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_en_len_shr(j0,v);
  }







  uint8_t clot_len_mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_mask(j0);
  }
  void clot_len_mask(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_len_mask(j0,v);
  }









  uint8_t clot_len_add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_add();
  }
  void clot_len_add(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_len_add(v);
  }







  uint8_t clot_offset(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_offset(j0);
  }
  void clot_offset(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_offset(j0,v);
  }







  uint8_t clot_tag(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag(j0);
  }
  void clot_tag(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_tag(j0,v);
  }







  uint8_t clot_tag_offset_add(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag_offset_add(j0);
  }
  void clot_tag_offset_add(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_tag_offset_add(j0,v);
  }







  uint8_t clot_has_csum(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_has_csum(j0);
  }
  void clot_has_csum(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_has_csum(j0,v);
  }






  uint8_t hdr_len_inc_stop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_stop();
  }
  void hdr_len_inc_stop(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].hdr_len_inc_stop(v);
  }





  uint8_t hdr_len_inc_final_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_final_amt();
  }
  void hdr_len_inc_final_amt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].hdr_len_inc_final_amt(v);
  }





  uint8_t disable_partial_hdr_err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].disable_partial_hdr_err();
  }
  void disable_partial_hdr_err(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].disable_partial_hdr_err(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/4;
    (*offset) -= (i*4);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoActionRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoActionRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoActionRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};




class PrsrMemMainRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspec(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1728, false, write_callback, read_callback, std::string("PrsrMemMainRspec")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec))
    {
    }
  PrsrMemMainRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMemMainRspec")
    {
    }
public:







  PrsrPoActionRow &po_action_row(int j0) { return po_action_row_[j0]; }








  PrsrMlTcamRow &ml_tcam_row(int j0) { return ml_tcam_row_[j0]; }







  PrsrMlEaRow &ml_ea_row(int j0) { return ml_ea_row_[j0]; }







  PrsrMlCtrInitRamM &ml_ctr_init_ram(int j0) { return ml_ctr_init_ram_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_0_row(int j0) { return po_csum_ctrl_0_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_1_row(int j0) { return po_csum_ctrl_1_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_2_row(int j0) { return po_csum_ctrl_2_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_3_row(int j0) { return po_csum_ctrl_3_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_4_row(int j0) { return po_csum_ctrl_4_row_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      po_action_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_tcam_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ea_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ctr_init_ram_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_0_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_1_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_2_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_3_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_4_row_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      po_action_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_tcam_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ea_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ctr_init_ram_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_0_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_1_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_2_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_3_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_4_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : po_action_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_tcam_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ea_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ctr_init_ram_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_0_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_1_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_2_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_3_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_4_row_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += po_action_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_tcam_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ea_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ctr_init_ram_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_0_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_1_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_2_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_3_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_4_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<256;++a0) {
      r += po_action_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_tcam_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_ea_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += ml_ctr_init_ram_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_0_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_1_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_2_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_3_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_4_row_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrPoActionRow, 256 > po_action_row_;
  std::array< PrsrMlTcamRow, 256 > ml_tcam_row_;
  std::array< PrsrMlEaRow, 256 > ml_ea_row_;
  std::array< PrsrMlCtrInitRamM, 16 > ml_ctr_init_ram_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_0_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_1_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_2_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_3_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_4_row_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};




class PrsrMemMainRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspecMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1728, true, write_callback, read_callback, std::string("PrsrMemMainRspecMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec))
    {
    }
  PrsrMemMainRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMemMainRspecMutable")
    {
    }
public:







  PrsrPoActionRowMutable &po_action_row(int j0) { return po_action_row_[j0]; }








  PrsrMlTcamRowMutable &ml_tcam_row(int j0) { return ml_tcam_row_[j0]; }







  PrsrMlEaRowMutable &ml_ea_row(int j0) { return ml_ea_row_[j0]; }







  PrsrMlCtrInitRamMMutable &ml_ctr_init_ram(int j0) { return ml_ctr_init_ram_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_0_row(int j0) { return po_csum_ctrl_0_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_1_row(int j0) { return po_csum_ctrl_1_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_2_row(int j0) { return po_csum_ctrl_2_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_3_row(int j0) { return po_csum_ctrl_3_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_4_row(int j0) { return po_csum_ctrl_4_row_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      po_action_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_tcam_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ea_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ctr_init_ram_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_0_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_1_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_2_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_3_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_4_row_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      po_action_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_tcam_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ea_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ctr_init_ram_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_0_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_1_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_2_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_3_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_4_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : po_action_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_tcam_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ea_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ctr_init_ram_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_0_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_1_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_2_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_3_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_4_row_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += po_action_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_tcam_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ea_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ctr_init_ram_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_0_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_1_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_2_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_3_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_4_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<256;++a0) {
      r += po_action_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_tcam_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_ea_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += ml_ctr_init_ram_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_0_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_1_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_2_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_3_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_4_row_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrPoActionRowMutable, 256 > po_action_row_;
  std::array< PrsrMlTcamRowMutable, 256 > ml_tcam_row_;
  std::array< PrsrMlEaRowMutable, 256 > ml_ea_row_;
  std::array< PrsrMlCtrInitRamMMutable, 16 > ml_ctr_init_ram_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_0_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_1_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_2_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_3_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_4_row_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};




class PrsrMemMainRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspecArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem), 2048 * ArraySize(index_pipe_addrmap, selector_parde_mem, -1), false, write_callback, read_callback, std::string("PrsrMemMainRspecArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, 0))
    {
    }
public:







  PrsrPoActionRow &po_action_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_action_row(j0);
  }








  PrsrMlTcamRow &ml_tcam_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_tcam_row(j0);
  }







  PrsrMlEaRow &ml_ea_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ea_row(j0);
  }







  PrsrMlCtrInitRamM &ml_ctr_init_ram(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ctr_init_ram(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_0_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_0_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_1_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_1_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_2_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_2_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_3_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_3_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_4_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_4_row(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/2048;
    (*offset) -= (i*2048);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMemMainRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMemMainRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMemMainRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        break;
      case kIPrsrMem:
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};




class PrsrMemMainRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspecArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem), 2048 * ArraySize(index_pipe_addrmap, selector_parde_mem, -1), true, write_callback, read_callback, std::string("PrsrMemMainRspecArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, 0))
    {
    }
public:







  PrsrPoActionRowMutable &po_action_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_action_row(j0);
  }








  PrsrMlTcamRowMutable &ml_tcam_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_tcam_row(j0);
  }







  PrsrMlEaRowMutable &ml_ea_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ea_row(j0);
  }







  PrsrMlCtrInitRamMMutable &ml_ctr_init_ram(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ctr_init_ram(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_0_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_0_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_1_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_1_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_2_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_2_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_3_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_3_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_4_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_4_row(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/2048;
    (*offset) -= (i*2048);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMemMainRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMemMainRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMemMainRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        break;
      case kIPrsrMem:
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PardeMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PardeMem(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 221440, false, write_callback, read_callback, std::string("PardeMem")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PardeMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PardeMem")
    {
    }
public:



  PrsrMemMainRspec &i_prsr_mem(int j0) { return i_prsr_mem_[j0]; }



  PrsrMemMainRspec &e_prsr_mem(int j0) { return e_prsr_mem_[j0]; }





  PgrMemRspec &pgr_mem_rspec() { return pgr_mem_rspec_; }





  PgrPh0Rspec &pgr_ph0_rspec() { return pgr_ph0_rspec_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      i_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      e_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      if (read_callback_) read_callback_();
      pgr_mem_rspec_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      if (read_callback_) read_callback_();
      pgr_ph0_rspec_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      i_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      e_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      pgr_mem_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      pgr_ph0_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : i_prsr_mem_) {
      f0.reset();
    }
    for (auto &f0 : e_prsr_mem_) {
      f0.reset();
    }
    pgr_mem_rspec_.reset();
    pgr_ph0_rspec_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += i_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += e_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      r += pgr_mem_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      r += pgr_ph0_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<36;++a0) {
      r += i_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<36;++a0) {
      r += e_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pgr_mem_rspec_.to_string(print_zeros,indent_string) ;
    r += pgr_ph0_rspec_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrMemMainRspec, 36 > i_prsr_mem_;
  std::array< PrsrMemMainRspec, 36 > e_prsr_mem_;
  PgrMemRspec pgr_mem_rspec_;
  PgrPh0Rspec pgr_ph0_rspec_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    return offset;
  }

};








class PardeMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PardeMemMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 221440, true, write_callback, read_callback, std::string("PardeMemMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PardeMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PardeMemMutable")
    {
    }
public:



  PrsrMemMainRspecMutable &i_prsr_mem(int j0) { return i_prsr_mem_[j0]; }



  PrsrMemMainRspecMutable &e_prsr_mem(int j0) { return e_prsr_mem_[j0]; }





  PgrMemRspecMutable &pgr_mem_rspec() { return pgr_mem_rspec_; }





  PgrPh0RspecMutable &pgr_ph0_rspec() { return pgr_ph0_rspec_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      i_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      e_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      if (read_callback_) read_callback_();
      pgr_mem_rspec_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      if (read_callback_) read_callback_();
      pgr_ph0_rspec_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      i_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      e_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      pgr_mem_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      pgr_ph0_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : i_prsr_mem_) {
      f0.reset();
    }
    for (auto &f0 : e_prsr_mem_) {
      f0.reset();
    }
    pgr_mem_rspec_.reset();
    pgr_ph0_rspec_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += i_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += e_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      r += pgr_mem_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      r += pgr_ph0_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<36;++a0) {
      r += i_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<36;++a0) {
      r += e_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pgr_mem_rspec_.to_string(print_zeros,indent_string) ;
    r += pgr_ph0_rspec_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrMemMainRspecMutable, 36 > i_prsr_mem_;
  std::array< PrsrMemMainRspecMutable, 36 > e_prsr_mem_;
  PgrMemRspecMutable pgr_mem_rspec_;
  PgrPh0RspecMutable pgr_ph0_rspec_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    return offset;
  }

};




class MauAddrmapDummyRegister : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmapDummyRegister(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, false, write_callback, read_callback, std::string("MauAddrmapDummyRegister")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmapDummyRegister(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "MauAddrmapDummyRegister")
    {
    }
public:
  uint64_t &dummy_field0() { return dummy_field0_; }
  uint64_t &dummy_field1() { return dummy_field1_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = dummy_field0_;
    *data1 = dummy_field1_;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    dummy_field0_ = data0;
    dummy_field1_ = data1;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    dummy_field0_ = UINT64_C(0);
    dummy_field1_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegister") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegister") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t dummy_field0_;
  uint64_t dummy_field1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};




class MauAddrmapDummyRegisterMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmapDummyRegisterMutable(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, true, write_callback, read_callback, std::string("MauAddrmapDummyRegisterMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmapDummyRegisterMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "MauAddrmapDummyRegisterMutable")
    {
    }
public:
  uint64_t dummy_field0() { return dummy_field0_; }
  void dummy_field0(const uint64_t &v) { dummy_field0_=v; }
  uint64_t dummy_field1() { return dummy_field1_; }
  void dummy_field1(const uint64_t &v) { dummy_field1_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = dummy_field0_;
    *data1 = dummy_field1_;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    dummy_field0_ = data0;
    dummy_field1_ = data1;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    dummy_field0_ = UINT64_C(0);
    dummy_field1_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegisterMutable") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegisterMutable") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t dummy_field0_;
  uint64_t dummy_field1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};








class MauAddrmap : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmap(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, false, write_callback, read_callback, std::string("MauAddrmap")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmap(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "MauAddrmap")
    {
    }
public:
  MauAddrmapDummyRegister &dummy_register() { return dummy_register_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      dummy_register_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      offset -= 0x0;
      dummy_register_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    dummy_register_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x1) {
      offset -= 0x0;
      r += dummy_register_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += dummy_register_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  MauAddrmapDummyRegister dummy_register_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};








class MauAddrmapMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmapMutable(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, true, write_callback, read_callback, std::string("MauAddrmapMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmapMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "MauAddrmapMutable")
    {
    }
public:
  MauAddrmapDummyRegisterMutable &dummy_register() { return dummy_register_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      dummy_register_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      offset -= 0x0;
      dummy_register_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    dummy_register_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x1) {
      offset -= 0x0;
      r += dummy_register_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += dummy_register_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  MauAddrmapDummyRegisterMutable dummy_register_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};








class MauAddrmapArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  MauAddrmapArray(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 17179869184 * ArraySize(index_pipe_addrmap, -1), false, write_callback, read_callback, std::string("MauAddrmapArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:
  MauAddrmapDummyRegister &dummy_register(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dummy_register();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/17179869184;
    (*offset) -= (i*17179869184);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("MauAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("MauAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<MauAddrmap> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class MauAddrmapArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  MauAddrmapArrayMutable(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 17179869184 * ArraySize(index_pipe_addrmap, -1), true, write_callback, read_callback, std::string("MauAddrmapArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:
  MauAddrmapDummyRegisterMutable &dummy_register(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dummy_register();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/17179869184;
    (*offset) -= (i*17179869184);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("MauAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("MauAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<MauAddrmapMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PipeAddrmap : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PipeAddrmap(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 414464565504, false, write_callback, read_callback, std::string("PipeAddrmap")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PipeAddrmap(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PipeAddrmap")
    {
    }
public:







  MauAddrmap &mau(int j0) { return mau_[j0]; }





  PardeMem &parde() { return parde_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      if (read_callback_) read_callback_();
      mau_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      if (read_callback_) read_callback_();
      parde_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      mau_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      parde_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mau_) {
      f0.reset();
    }
    parde_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      r += mau_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      r += parde_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<20;++a0) {
      r += mau_[a0].to_string(print_zeros,indent_string) ;
    }
    r += parde_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< MauAddrmap, 20 > mau_;
  PardeMem parde_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

};








class PipeAddrmapMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PipeAddrmapMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 414464565504, true, write_callback, read_callback, std::string("PipeAddrmapMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PipeAddrmapMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PipeAddrmapMutable")
    {
    }
public:







  MauAddrmapMutable &mau(int j0) { return mau_[j0]; }





  PardeMemMutable &parde() { return parde_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      if (read_callback_) read_callback_();
      mau_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      if (read_callback_) read_callback_();
      parde_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      mau_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      parde_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mau_) {
      f0.reset();
    }
    parde_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      r += mau_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      r += parde_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<20;++a0) {
      r += mau_[a0].to_string(print_zeros,indent_string) ;
    }
    r += parde_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< MauAddrmapMutable, 20 > mau_;
  PardeMemMutable parde_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

};








class PipeAddrmapArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PipeAddrmapArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 549755813888 * ArraySize(-1), false, write_callback, read_callback, std::string("PipeAddrmapArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  MauAddrmap &mau(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mau(j0);
  }





  PardeMem &parde(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].parde();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/549755813888;
    (*offset) -= (i*549755813888);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PipeAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PipeAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PipeAddrmap> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PipeAddrmapArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PipeAddrmapArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 549755813888 * ArraySize(-1), true, write_callback, read_callback, std::string("PipeAddrmapArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  MauAddrmapMutable &mau(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mau(j0);
  }





  PardeMemMutable &parde(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].parde();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/549755813888;
    (*offset) -= (i*549755813888);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PipeAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PipeAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PipeAddrmapMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};











class PscBlockFreePtrMemoryEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPscMemTopRspecEnum {
    kPscBlockGrp0,
    kPscBlockGrp1,
    kPscBlockGrp2,
    kPscBlockGrp3,
    kPscBlockGrp4,
    kPscBlockGrp5
  };
public:
  PscBlockFreePtrMemoryEntry(
      int chipNumber, TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int index_psc_block_free_ptr_memory_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_psc_mem_top_rspec, index_psc_block_free_ptr_memory_entry), 1, false, write_callback, read_callback, std::string("PscBlockFreePtrMemoryEntry")+":"+boost::lexical_cast<std::string>(selector_tm_psc_mem_top_rspec) + "," + boost::lexical_cast<std::string>(index_psc_block_free_ptr_memory_entry))
    {
    }
  PscBlockFreePtrMemoryEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PscBlockFreePtrMemoryEntry")
    {
    }
public:
  uint16_t &ptr0() { return ptr0_; }
  uint16_t &ptr1() { return ptr1_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ptr0_) & 0x3ff);
    *data0 |= ((static_cast<uint64_t>(ptr1_) & 0x3ff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ptr0_ = (data0 & 0x3ff);
    ptr1_ = ((data0 >> 10) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ptr0_ = 0;
    ptr1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PscBlockFreePtrMemoryEntry") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PscBlockFreePtrMemoryEntry") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t ptr0_;
  uint16_t ptr1_;
private:
  static uint64_t StartOffset(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int index_psc_block_free_ptr_memory_entry
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp1:
        offset += 0x8000; // to get to psc_block_grp1
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp2:
        offset += 0x10000; // to get to psc_block_grp2
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp3:
        offset += 0x18000; // to get to psc_block_grp3
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp4:
        offset += 0x20000; // to get to psc_block_grp4
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp5:
        offset += 0x28000; // to get to psc_block_grp5
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class PscBlockFreePtrMemoryEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPscMemTopRspecEnum {
    kPscBlockGrp0,
    kPscBlockGrp1,
    kPscBlockGrp2,
    kPscBlockGrp3,
    kPscBlockGrp4,
    kPscBlockGrp5
  };
public:
  PscBlockFreePtrMemoryEntryMutable(
      int chipNumber, TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int index_psc_block_free_ptr_memory_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_psc_mem_top_rspec, index_psc_block_free_ptr_memory_entry), 1, true, write_callback, read_callback, std::string("PscBlockFreePtrMemoryEntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_psc_mem_top_rspec) + "," + boost::lexical_cast<std::string>(index_psc_block_free_ptr_memory_entry))
    {
    }
  PscBlockFreePtrMemoryEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PscBlockFreePtrMemoryEntryMutable")
    {
    }
public:
  uint16_t ptr0() { return ptr0_; }
  void ptr0(const uint16_t &v) { ptr0_=v; }
  uint16_t ptr1() { return ptr1_; }
  void ptr1(const uint16_t &v) { ptr1_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ptr0_) & 0x3ff);
    *data0 |= ((static_cast<uint64_t>(ptr1_) & 0x3ff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ptr0_ = (data0 & 0x3ff);
    ptr1_ = ((data0 >> 10) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ptr0_ = 0;
    ptr1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PscBlockFreePtrMemoryEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PscBlockFreePtrMemoryEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t ptr0_;
  uint16_t ptr1_;
private:
  static uint64_t StartOffset(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int index_psc_block_free_ptr_memory_entry
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp1:
        offset += 0x8000; // to get to psc_block_grp1
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp2:
        offset += 0x10000; // to get to psc_block_grp2
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp3:
        offset += 0x18000; // to get to psc_block_grp3
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp4:
        offset += 0x20000; // to get to psc_block_grp4
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      case kPscBlockGrp5:
        offset += 0x28000; // to get to psc_block_grp5
        assert(index_psc_block_free_ptr_memory_entry < 32768);
        offset += index_psc_block_free_ptr_memory_entry * 0x1; // psc_block_free_ptr_memory_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class PscBlockFreePtrMemoryEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPscMemTopRspecEnum {
    kPscBlockGrp0,
    kPscBlockGrp1,
    kPscBlockGrp2,
    kPscBlockGrp3,
    kPscBlockGrp4,
    kPscBlockGrp5
  };
public:
  PscBlockFreePtrMemoryEntryArray(
      int chipNumber, TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_psc_mem_top_rspec), 1 * ArraySize(selector_tm_psc_mem_top_rspec, -1), false, write_callback, read_callback, std::string("PscBlockFreePtrMemoryEntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_psc_mem_top_rspec)),
    array(RealArraySize(selector_tm_psc_mem_top_rspec, -1)),
    size0_(ArraySize(selector_tm_psc_mem_top_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_psc_mem_top_rspec, 0))
    {
    }
public:
  uint16_t &ptr0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr0();
  }
  uint16_t &ptr1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr1();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PscBlockFreePtrMemoryEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PscBlockFreePtrMemoryEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PscBlockFreePtrMemoryEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        break;
      case kPscBlockGrp1:
        offset += 0x8000; // to get to psc_block_grp1
        break;
      case kPscBlockGrp2:
        offset += 0x10000; // to get to psc_block_grp2
        break;
      case kPscBlockGrp3:
        offset += 0x18000; // to get to psc_block_grp3
        break;
      case kPscBlockGrp4:
        offset += 0x20000; // to get to psc_block_grp4
        break;
      case kPscBlockGrp5:
        offset += 0x28000; // to get to psc_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class PscBlockFreePtrMemoryEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPscMemTopRspecEnum {
    kPscBlockGrp0,
    kPscBlockGrp1,
    kPscBlockGrp2,
    kPscBlockGrp3,
    kPscBlockGrp4,
    kPscBlockGrp5
  };
public:
  PscBlockFreePtrMemoryEntryArrayMutable(
      int chipNumber, TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_psc_mem_top_rspec), 1 * ArraySize(selector_tm_psc_mem_top_rspec, -1), true, write_callback, read_callback, std::string("PscBlockFreePtrMemoryEntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_psc_mem_top_rspec)),
    array(RealArraySize(selector_tm_psc_mem_top_rspec, -1)),
    size0_(ArraySize(selector_tm_psc_mem_top_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_psc_mem_top_rspec, 0))
    {
    }
public:
  uint16_t ptr0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr0();
  }
  void ptr0(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ptr0(v);
  }
  uint16_t ptr1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr1();
  }
  void ptr1(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ptr1(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PscBlockFreePtrMemoryEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PscBlockFreePtrMemoryEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PscBlockFreePtrMemoryEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        break;
      case kPscBlockGrp1:
        offset += 0x8000; // to get to psc_block_grp1
        break;
      case kPscBlockGrp2:
        offset += 0x10000; // to get to psc_block_grp2
        break;
      case kPscBlockGrp3:
        offset += 0x18000; // to get to psc_block_grp3
        break;
      case kPscBlockGrp4:
        offset += 0x20000; // to get to psc_block_grp4
        break;
      case kPscBlockGrp5:
        offset += 0x28000; // to get to psc_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPscBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPscMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPscMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPscMemTopRspec"))
    {
    }
  TmPscMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPscMemTopRspec")
    {
    }
public:










  PscBlockFreePtrMemoryEntry &psc_block_grp0(int j0) { return psc_block_grp0_[j0]; }










  PscBlockFreePtrMemoryEntry &psc_block_grp1(int j0) { return psc_block_grp1_[j0]; }










  PscBlockFreePtrMemoryEntry &psc_block_grp2(int j0) { return psc_block_grp2_[j0]; }










  PscBlockFreePtrMemoryEntry &psc_block_grp3(int j0) { return psc_block_grp3_[j0]; }










  PscBlockFreePtrMemoryEntry &psc_block_grp4(int j0) { return psc_block_grp4_[j0]; }










  PscBlockFreePtrMemoryEntry &psc_block_grp5(int j0) { return psc_block_grp5_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp4_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp5_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp4_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp5_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : psc_block_grp0_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp1_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp2_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp3_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp4_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp5_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp4_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp5_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp4_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp5_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PscBlockFreePtrMemoryEntry, 32768 > psc_block_grp0_;
  std::array< PscBlockFreePtrMemoryEntry, 32768 > psc_block_grp1_;
  std::array< PscBlockFreePtrMemoryEntry, 32768 > psc_block_grp2_;
  std::array< PscBlockFreePtrMemoryEntry, 32768 > psc_block_grp3_;
  std::array< PscBlockFreePtrMemoryEntry, 32768 > psc_block_grp4_;
  std::array< PscBlockFreePtrMemoryEntry, 32768 > psc_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    return offset;
  }

};








class TmPscMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPscMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPscMemTopRspecMutable"))
    {
    }
  TmPscMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPscMemTopRspecMutable")
    {
    }
public:










  PscBlockFreePtrMemoryEntryMutable &psc_block_grp0(int j0) { return psc_block_grp0_[j0]; }










  PscBlockFreePtrMemoryEntryMutable &psc_block_grp1(int j0) { return psc_block_grp1_[j0]; }










  PscBlockFreePtrMemoryEntryMutable &psc_block_grp2(int j0) { return psc_block_grp2_[j0]; }










  PscBlockFreePtrMemoryEntryMutable &psc_block_grp3(int j0) { return psc_block_grp3_[j0]; }










  PscBlockFreePtrMemoryEntryMutable &psc_block_grp4(int j0) { return psc_block_grp4_[j0]; }










  PscBlockFreePtrMemoryEntryMutable &psc_block_grp5(int j0) { return psc_block_grp5_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp4_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      psc_block_grp5_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp4_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      psc_block_grp5_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : psc_block_grp0_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp1_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp2_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp3_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp4_) {
      f0.reset();
    }
    for (auto &f0 : psc_block_grp5_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp4_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += psc_block_grp5_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp4_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += psc_block_grp5_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PscBlockFreePtrMemoryEntryMutable, 32768 > psc_block_grp0_;
  std::array< PscBlockFreePtrMemoryEntryMutable, 32768 > psc_block_grp1_;
  std::array< PscBlockFreePtrMemoryEntryMutable, 32768 > psc_block_grp2_;
  std::array< PscBlockFreePtrMemoryEntryMutable, 32768 > psc_block_grp3_;
  std::array< PscBlockFreePtrMemoryEntryMutable, 32768 > psc_block_grp4_;
  std::array< PscBlockFreePtrMemoryEntryMutable, 32768 > psc_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    return offset;
  }

};








class TmPrePmtMemWordEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPmt0MemWord0,
    kPmt0MemWord1,
    kPmt0MemWord2,
    kPmt0MemWord3,
    kPmt1MemWord0,
    kPmt1MemWord1,
    kPmt1MemWord2,
    kPmt1MemWord3
  };
public:
  TmPrePmtMemWordEntry(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pmt_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_pmt_mem_word_entry), 1, false, write_callback, read_callback, std::string("TmPrePmtMemWordEntry")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_pmt_mem_word_entry))
    {
    }
  TmPrePmtMemWordEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrePmtMemWordEntry")
    {
    }
public:




  BitVector<72> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xff), 64,8);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePmtMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePmtMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<72> mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pmt_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        offset += 0x80200000; // to get to pmt0_mem_word0
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt0MemWord1:
        offset += 0x80240000; // to get to pmt0_mem_word1
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt0MemWord2:
        offset += 0x80280000; // to get to pmt0_mem_word2
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt0MemWord3:
        offset += 0x802c0000; // to get to pmt0_mem_word3
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord0:
        offset += 0x80300000; // to get to pmt1_mem_word0
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord1:
        offset += 0x80340000; // to get to pmt1_mem_word1
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord2:
        offset += 0x80380000; // to get to pmt1_mem_word2
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord3:
        offset += 0x803c0000; // to get to pmt1_mem_word3
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPrePmtMemWordEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPmt0MemWord0,
    kPmt0MemWord1,
    kPmt0MemWord2,
    kPmt0MemWord3,
    kPmt1MemWord0,
    kPmt1MemWord1,
    kPmt1MemWord2,
    kPmt1MemWord3
  };
public:
  TmPrePmtMemWordEntryMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pmt_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_pmt_mem_word_entry), 1, true, write_callback, read_callback, std::string("TmPrePmtMemWordEntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_pmt_mem_word_entry))
    {
    }
  TmPrePmtMemWordEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrePmtMemWordEntryMutable")
    {
    }
public:




  BitVector<72> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xff), 64,8);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePmtMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePmtMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<72> mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pmt_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        offset += 0x80200000; // to get to pmt0_mem_word0
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt0MemWord1:
        offset += 0x80240000; // to get to pmt0_mem_word1
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt0MemWord2:
        offset += 0x80280000; // to get to pmt0_mem_word2
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt0MemWord3:
        offset += 0x802c0000; // to get to pmt0_mem_word3
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord0:
        offset += 0x80300000; // to get to pmt1_mem_word0
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord1:
        offset += 0x80340000; // to get to pmt1_mem_word1
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord2:
        offset += 0x80380000; // to get to pmt1_mem_word2
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      case kPmt1MemWord3:
        offset += 0x803c0000; // to get to pmt1_mem_word3
        assert(index_tm_pre_pmt_mem_word_entry < 288);
        offset += index_tm_pre_pmt_mem_word_entry * 0x1; // tm_pre_pmt_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPrePmtMemWordEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPmt0MemWord0,
    kPmt0MemWord1,
    kPmt0MemWord2,
    kPmt0MemWord3,
    kPmt1MemWord0,
    kPmt1MemWord1,
    kPmt1MemWord2,
    kPmt1MemWord3
  };
public:
  TmPrePmtMemWordEntryArray(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), false, write_callback, read_callback, std::string("TmPrePmtMemWordEntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  BitVector<72> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePmtMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePmtMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePmtMemWordEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        offset += 0x80200000; // to get to pmt0_mem_word0
        break;
      case kPmt0MemWord1:
        offset += 0x80240000; // to get to pmt0_mem_word1
        break;
      case kPmt0MemWord2:
        offset += 0x80280000; // to get to pmt0_mem_word2
        break;
      case kPmt0MemWord3:
        offset += 0x802c0000; // to get to pmt0_mem_word3
        break;
      case kPmt1MemWord0:
        offset += 0x80300000; // to get to pmt1_mem_word0
        break;
      case kPmt1MemWord1:
        offset += 0x80340000; // to get to pmt1_mem_word1
        break;
      case kPmt1MemWord2:
        offset += 0x80380000; // to get to pmt1_mem_word2
        break;
      case kPmt1MemWord3:
        offset += 0x803c0000; // to get to pmt1_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrePmtMemWordEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPmt0MemWord0,
    kPmt0MemWord1,
    kPmt0MemWord2,
    kPmt0MemWord3,
    kPmt1MemWord0,
    kPmt1MemWord1,
    kPmt1MemWord2,
    kPmt1MemWord3
  };
public:
  TmPrePmtMemWordEntryArrayMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), true, write_callback, read_callback, std::string("TmPrePmtMemWordEntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  BitVector<72> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePmtMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePmtMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePmtMemWordEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        offset += 0x80200000; // to get to pmt0_mem_word0
        break;
      case kPmt0MemWord1:
        offset += 0x80240000; // to get to pmt0_mem_word1
        break;
      case kPmt0MemWord2:
        offset += 0x80280000; // to get to pmt0_mem_word2
        break;
      case kPmt0MemWord3:
        offset += 0x802c0000; // to get to pmt0_mem_word3
        break;
      case kPmt1MemWord0:
        offset += 0x80300000; // to get to pmt1_mem_word0
        break;
      case kPmt1MemWord1:
        offset += 0x80340000; // to get to pmt1_mem_word1
        break;
      case kPmt1MemWord2:
        offset += 0x80380000; // to get to pmt1_mem_word2
        break;
      case kPmt1MemWord3:
        offset += 0x803c0000; // to get to pmt1_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt0MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord0:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord1:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord2:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPmt1MemWord3:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreLitBmMemWordEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0BmMemWord0,
    kLit0BmMemWord1,
    kLit0BmMemWord2,
    kLit0BmMemWord3,
    kLit1BmMemWord0,
    kLit1BmMemWord1,
    kLit1BmMemWord2,
    kLit1BmMemWord3
  };
public:
  TmPreLitBmMemWordEntry(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_bm_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_lit_bm_mem_word_entry), 1, false, write_callback, read_callback, std::string("TmPreLitBmMemWordEntry")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_lit_bm_mem_word_entry))
    {
    }
  TmPreLitBmMemWordEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreLitBmMemWordEntry")
    {
    }
public:




  BitVector<72> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xff), 64,8);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitBmMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitBmMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<72> mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_bm_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        offset += 0x80000000; // to get to lit0_bm_mem_word0
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit0BmMemWord1:
        offset += 0x80040000; // to get to lit0_bm_mem_word1
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit0BmMemWord2:
        offset += 0x80080000; // to get to lit0_bm_mem_word2
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit0BmMemWord3:
        offset += 0x800c0000; // to get to lit0_bm_mem_word3
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord0:
        offset += 0x80100000; // to get to lit1_bm_mem_word0
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord1:
        offset += 0x80140000; // to get to lit1_bm_mem_word1
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord2:
        offset += 0x80180000; // to get to lit1_bm_mem_word2
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord3:
        offset += 0x801c0000; // to get to lit1_bm_mem_word3
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitBmMemWordEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0BmMemWord0,
    kLit0BmMemWord1,
    kLit0BmMemWord2,
    kLit0BmMemWord3,
    kLit1BmMemWord0,
    kLit1BmMemWord1,
    kLit1BmMemWord2,
    kLit1BmMemWord3
  };
public:
  TmPreLitBmMemWordEntryMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_bm_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_lit_bm_mem_word_entry), 1, true, write_callback, read_callback, std::string("TmPreLitBmMemWordEntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_lit_bm_mem_word_entry))
    {
    }
  TmPreLitBmMemWordEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreLitBmMemWordEntryMutable")
    {
    }
public:




  BitVector<72> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xff), 64,8);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitBmMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitBmMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<72> mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_bm_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        offset += 0x80000000; // to get to lit0_bm_mem_word0
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit0BmMemWord1:
        offset += 0x80040000; // to get to lit0_bm_mem_word1
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit0BmMemWord2:
        offset += 0x80080000; // to get to lit0_bm_mem_word2
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit0BmMemWord3:
        offset += 0x800c0000; // to get to lit0_bm_mem_word3
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord0:
        offset += 0x80100000; // to get to lit1_bm_mem_word0
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord1:
        offset += 0x80140000; // to get to lit1_bm_mem_word1
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord2:
        offset += 0x80180000; // to get to lit1_bm_mem_word2
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      case kLit1BmMemWord3:
        offset += 0x801c0000; // to get to lit1_bm_mem_word3
        assert(index_tm_pre_lit_bm_mem_word_entry < 256);
        offset += index_tm_pre_lit_bm_mem_word_entry * 0x1; // tm_pre_lit_bm_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitBmMemWordEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0BmMemWord0,
    kLit0BmMemWord1,
    kLit0BmMemWord2,
    kLit0BmMemWord3,
    kLit1BmMemWord0,
    kLit1BmMemWord1,
    kLit1BmMemWord2,
    kLit1BmMemWord3
  };
public:
  TmPreLitBmMemWordEntryArray(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), false, write_callback, read_callback, std::string("TmPreLitBmMemWordEntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  BitVector<72> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreLitBmMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreLitBmMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreLitBmMemWordEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        offset += 0x80000000; // to get to lit0_bm_mem_word0
        break;
      case kLit0BmMemWord1:
        offset += 0x80040000; // to get to lit0_bm_mem_word1
        break;
      case kLit0BmMemWord2:
        offset += 0x80080000; // to get to lit0_bm_mem_word2
        break;
      case kLit0BmMemWord3:
        offset += 0x800c0000; // to get to lit0_bm_mem_word3
        break;
      case kLit1BmMemWord0:
        offset += 0x80100000; // to get to lit1_bm_mem_word0
        break;
      case kLit1BmMemWord1:
        offset += 0x80140000; // to get to lit1_bm_mem_word1
        break;
      case kLit1BmMemWord2:
        offset += 0x80180000; // to get to lit1_bm_mem_word2
        break;
      case kLit1BmMemWord3:
        offset += 0x801c0000; // to get to lit1_bm_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreLitBmMemWordEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0BmMemWord0,
    kLit0BmMemWord1,
    kLit0BmMemWord2,
    kLit0BmMemWord3,
    kLit1BmMemWord0,
    kLit1BmMemWord1,
    kLit1BmMemWord2,
    kLit1BmMemWord3
  };
public:
  TmPreLitBmMemWordEntryArrayMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), true, write_callback, read_callback, std::string("TmPreLitBmMemWordEntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  BitVector<72> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreLitBmMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreLitBmMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreLitBmMemWordEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        offset += 0x80000000; // to get to lit0_bm_mem_word0
        break;
      case kLit0BmMemWord1:
        offset += 0x80040000; // to get to lit0_bm_mem_word1
        break;
      case kLit0BmMemWord2:
        offset += 0x80080000; // to get to lit0_bm_mem_word2
        break;
      case kLit0BmMemWord3:
        offset += 0x800c0000; // to get to lit0_bm_mem_word3
        break;
      case kLit1BmMemWord0:
        offset += 0x80100000; // to get to lit1_bm_mem_word0
        break;
      case kLit1BmMemWord1:
        offset += 0x80140000; // to get to lit1_bm_mem_word1
        break;
      case kLit1BmMemWord2:
        offset += 0x80180000; // to get to lit1_bm_mem_word2
        break;
      case kLit1BmMemWord3:
        offset += 0x801c0000; // to get to lit1_bm_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit0BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord0:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord1:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord2:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1BmMemWord3:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreLitNpMemWordEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0NpMemWord,
    kLit1NpMemWord
  };
public:
  TmPreLitNpMemWordEntry(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_np_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_lit_np_mem_word_entry), 1, false, write_callback, read_callback, std::string("TmPreLitNpMemWordEntry")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_lit_np_mem_word_entry))
    {
    }
  TmPreLitNpMemWordEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreLitNpMemWordEntry")
    {
    }
public:




  uint32_t &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(mem_word_) & 0x3ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_ = (data0 & 0x3ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitNpMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitNpMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_np_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        offset += 0x40200000; // to get to lit0_np_mem_word
        assert(index_tm_pre_lit_np_mem_word_entry < 256);
        offset += index_tm_pre_lit_np_mem_word_entry * 0x1; // tm_pre_lit_np_mem_word_entry[]
        break;
      case kLit1NpMemWord:
        offset += 0x40300000; // to get to lit1_np_mem_word
        assert(index_tm_pre_lit_np_mem_word_entry < 256);
        offset += index_tm_pre_lit_np_mem_word_entry * 0x1; // tm_pre_lit_np_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitNpMemWordEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0NpMemWord,
    kLit1NpMemWord
  };
public:
  TmPreLitNpMemWordEntryMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_np_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_lit_np_mem_word_entry), 1, true, write_callback, read_callback, std::string("TmPreLitNpMemWordEntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_lit_np_mem_word_entry))
    {
    }
  TmPreLitNpMemWordEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreLitNpMemWordEntryMutable")
    {
    }
public:




  uint32_t mem_word() { return mem_word_; }
  void mem_word(const uint32_t &v) { mem_word_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(mem_word_) & 0x3ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_ = (data0 & 0x3ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitNpMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreLitNpMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_lit_np_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        offset += 0x40200000; // to get to lit0_np_mem_word
        assert(index_tm_pre_lit_np_mem_word_entry < 256);
        offset += index_tm_pre_lit_np_mem_word_entry * 0x1; // tm_pre_lit_np_mem_word_entry[]
        break;
      case kLit1NpMemWord:
        offset += 0x40300000; // to get to lit1_np_mem_word
        assert(index_tm_pre_lit_np_mem_word_entry < 256);
        offset += index_tm_pre_lit_np_mem_word_entry * 0x1; // tm_pre_lit_np_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitNpMemWordEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0NpMemWord,
    kLit1NpMemWord
  };
public:
  TmPreLitNpMemWordEntryArray(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), false, write_callback, read_callback, std::string("TmPreLitNpMemWordEntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  uint32_t &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreLitNpMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreLitNpMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreLitNpMemWordEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        offset += 0x40200000; // to get to lit0_np_mem_word
        break;
      case kLit1NpMemWord:
        offset += 0x40300000; // to get to lit1_np_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreLitNpMemWordEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0NpMemWord,
    kLit1NpMemWord
  };
public:
  TmPreLitNpMemWordEntryArrayMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), true, write_callback, read_callback, std::string("TmPreLitNpMemWordEntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  uint32_t mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  void mem_word(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mem_word(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreLitNpMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreLitNpMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreLitNpMemWordEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        offset += 0x40200000; // to get to lit0_np_mem_word
        break;
      case kLit1NpMemWord:
        offset += 0x40300000; // to get to lit1_np_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kLit1NpMemWord:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrePbtMemWordEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPbt0MemWord,
    kPbt1MemWord
  };
public:
  TmPrePbtMemWordEntry(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pbt_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_pbt_mem_word_entry), 1, false, write_callback, read_callback, std::string("TmPrePbtMemWordEntry")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_pbt_mem_word_entry))
    {
    }
  TmPrePbtMemWordEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrePbtMemWordEntry")
    {
    }
public:




  uint16_t &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(mem_word_) & 0x1ff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_ = (data0 & 0x1ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePbtMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePbtMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pbt_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        offset += 0x40000000; // to get to pbt0_mem_word
        assert(index_tm_pre_pbt_mem_word_entry < 288);
        offset += index_tm_pre_pbt_mem_word_entry * 0x1; // tm_pre_pbt_mem_word_entry[]
        break;
      case kPbt1MemWord:
        offset += 0x40100000; // to get to pbt1_mem_word
        assert(index_tm_pre_pbt_mem_word_entry < 288);
        offset += index_tm_pre_pbt_mem_word_entry * 0x1; // tm_pre_pbt_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPrePbtMemWordEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPbt0MemWord,
    kPbt1MemWord
  };
public:
  TmPrePbtMemWordEntryMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pbt_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec, index_tm_pre_pbt_mem_word_entry), 1, true, write_callback, read_callback, std::string("TmPrePbtMemWordEntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_pbt_mem_word_entry))
    {
    }
  TmPrePbtMemWordEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrePbtMemWordEntryMutable")
    {
    }
public:




  uint16_t mem_word() { return mem_word_; }
  void mem_word(const uint16_t &v) { mem_word_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(mem_word_) & 0x1ff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_ = (data0 & 0x1ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePbtMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPrePbtMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mem_word_) ) + "\n";
    all_zeros &= (0 == mem_word_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t mem_word_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int index_tm_pre_pbt_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        offset += 0x40000000; // to get to pbt0_mem_word
        assert(index_tm_pre_pbt_mem_word_entry < 288);
        offset += index_tm_pre_pbt_mem_word_entry * 0x1; // tm_pre_pbt_mem_word_entry[]
        break;
      case kPbt1MemWord:
        offset += 0x40100000; // to get to pbt1_mem_word
        assert(index_tm_pre_pbt_mem_word_entry < 288);
        offset += index_tm_pre_pbt_mem_word_entry * 0x1; // tm_pre_pbt_mem_word_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPrePbtMemWordEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPbt0MemWord,
    kPbt1MemWord
  };
public:
  TmPrePbtMemWordEntryArray(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), false, write_callback, read_callback, std::string("TmPrePbtMemWordEntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  uint16_t &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePbtMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePbtMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePbtMemWordEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        offset += 0x40000000; // to get to pbt0_mem_word
        break;
      case kPbt1MemWord:
        offset += 0x40100000; // to get to pbt1_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPbt1MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPbt1MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrePbtMemWordEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPbt0MemWord,
    kPbt1MemWord
  };
public:
  TmPrePbtMemWordEntryArrayMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 1 * ArraySize(selector_tm_pre_common_mem_rspec, -1), true, write_callback, read_callback, std::string("TmPrePbtMemWordEntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec)),
    array(RealArraySize(selector_tm_pre_common_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_pre_common_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_pre_common_mem_rspec, 0))
    {
    }
public:




  uint16_t mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  void mem_word(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mem_word(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePbtMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePbtMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePbtMemWordEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        offset += 0x40000000; // to get to pbt0_mem_word
        break;
      case kPbt1MemWord:
        offset += 0x40100000; // to get to pbt1_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPbt1MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, int dimension
      ) {
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kPbt1MemWord:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreRdmMemWordEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreRdmMemWordEntry(
      int chipNumber, int index_tm_pre_rdm_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_rdm_mem_word_entry), 1, false, write_callback, read_callback, std::string("TmPreRdmMemWordEntry")+":"+boost::lexical_cast<std::string>(index_tm_pre_rdm_mem_word_entry))
    {
    }
  TmPreRdmMemWordEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreRdmMemWordEntry")
    {
    }
public:




  BitVector<80> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xffff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xffff), 64,16);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreRdmMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreRdmMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<80> mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_rdm_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    offset += 0x400000; // to get to rdm_mem_word
    assert(index_tm_pre_rdm_mem_word_entry < 524288);
    offset += index_tm_pre_rdm_mem_word_entry * 0x1; // tm_pre_rdm_mem_word_entry[]
    return offset;
  }

};








class TmPreRdmMemWordEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreRdmMemWordEntryMutable(
      int chipNumber, int index_tm_pre_rdm_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_rdm_mem_word_entry), 1, true, write_callback, read_callback, std::string("TmPreRdmMemWordEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_pre_rdm_mem_word_entry))
    {
    }
  TmPreRdmMemWordEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreRdmMemWordEntryMutable")
    {
    }
public:




  BitVector<80> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xffff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xffff), 64,16);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreRdmMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreRdmMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<80> mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_rdm_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    offset += 0x400000; // to get to rdm_mem_word
    assert(index_tm_pre_rdm_mem_word_entry < 524288);
    offset += index_tm_pre_rdm_mem_word_entry * 0x1; // tm_pre_rdm_mem_word_entry[]
    return offset;
  }

};








class TmPreRdmMemWordEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPreRdmMemWordEntryArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 1 * ArraySize(-1), false, write_callback, read_callback, std::string("TmPreRdmMemWordEntryArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:




  BitVector<80> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreRdmMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreRdmMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreRdmMemWordEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    offset += 0x400000; // to get to rdm_mem_word
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 524288;
        break;
      case 0:
        return 524288;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 524288;
        break;
      case 0:
        return 524288;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreRdmMemWordEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPreRdmMemWordEntryArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 1 * ArraySize(-1), true, write_callback, read_callback, std::string("TmPreRdmMemWordEntryArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:




  BitVector<80> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreRdmMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreRdmMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreRdmMemWordEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    offset += 0x400000; // to get to rdm_mem_word
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 524288;
        break;
      case 0:
        return 524288;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 524288;
        break;
      case 0:
        return 524288;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreCommonMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreCommonMemRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4294967296, false, write_callback, read_callback, std::string("TmPreCommonMemRspec"))
    {
    }
  TmPreCommonMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreCommonMemRspec")
    {
    }
public:







  TmPreRdmMemWordEntry &rdm_mem_word(int j0) { return rdm_mem_word_[j0]; }







  TmPrePbtMemWordEntry &pbt0_mem_word(int j0) { return pbt0_mem_word_[j0]; }







  TmPrePbtMemWordEntry &pbt1_mem_word(int j0) { return pbt1_mem_word_[j0]; }







  TmPreLitNpMemWordEntry &lit0_np_mem_word(int j0) { return lit0_np_mem_word_[j0]; }







  TmPreLitNpMemWordEntry &lit1_np_mem_word(int j0) { return lit1_np_mem_word_[j0]; }







  TmPreLitBmMemWordEntry &lit0_bm_mem_word0(int j0) { return lit0_bm_mem_word0_[j0]; }







  TmPreLitBmMemWordEntry &lit0_bm_mem_word1(int j0) { return lit0_bm_mem_word1_[j0]; }







  TmPreLitBmMemWordEntry &lit0_bm_mem_word2(int j0) { return lit0_bm_mem_word2_[j0]; }







  TmPreLitBmMemWordEntry &lit0_bm_mem_word3(int j0) { return lit0_bm_mem_word3_[j0]; }







  TmPreLitBmMemWordEntry &lit1_bm_mem_word0(int j0) { return lit1_bm_mem_word0_[j0]; }







  TmPreLitBmMemWordEntry &lit1_bm_mem_word1(int j0) { return lit1_bm_mem_word1_[j0]; }







  TmPreLitBmMemWordEntry &lit1_bm_mem_word2(int j0) { return lit1_bm_mem_word2_[j0]; }







  TmPreLitBmMemWordEntry &lit1_bm_mem_word3(int j0) { return lit1_bm_mem_word3_[j0]; }







  TmPrePmtMemWordEntry &pmt0_mem_word0(int j0) { return pmt0_mem_word0_[j0]; }







  TmPrePmtMemWordEntry &pmt0_mem_word1(int j0) { return pmt0_mem_word1_[j0]; }







  TmPrePmtMemWordEntry &pmt0_mem_word2(int j0) { return pmt0_mem_word2_[j0]; }







  TmPrePmtMemWordEntry &pmt0_mem_word3(int j0) { return pmt0_mem_word3_[j0]; }







  TmPrePmtMemWordEntry &pmt1_mem_word0(int j0) { return pmt1_mem_word0_[j0]; }







  TmPrePmtMemWordEntry &pmt1_mem_word1(int j0) { return pmt1_mem_word1_[j0]; }







  TmPrePmtMemWordEntry &pmt1_mem_word2(int j0) { return pmt1_mem_word2_[j0]; }







  TmPrePmtMemWordEntry &pmt1_mem_word3(int j0) { return pmt1_mem_word3_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      rdm_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pbt0_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pbt1_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_np_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_np_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      rdm_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pbt0_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pbt1_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_np_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_np_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : rdm_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : pbt0_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : pbt1_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : lit0_np_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : lit1_np_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word3_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word3_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word3_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word3_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += rdm_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pbt0_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pbt1_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_np_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_np_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<524288;++a0) {
      r += rdm_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pbt0_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pbt1_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_np_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_np_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPreRdmMemWordEntry, 524288 > rdm_mem_word_;
  std::array< TmPrePbtMemWordEntry, 288 > pbt0_mem_word_;
  std::array< TmPrePbtMemWordEntry, 288 > pbt1_mem_word_;
  std::array< TmPreLitNpMemWordEntry, 256 > lit0_np_mem_word_;
  std::array< TmPreLitNpMemWordEntry, 256 > lit1_np_mem_word_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit0_bm_mem_word0_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit0_bm_mem_word1_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit0_bm_mem_word2_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit0_bm_mem_word3_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit1_bm_mem_word0_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit1_bm_mem_word1_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit1_bm_mem_word2_;
  std::array< TmPreLitBmMemWordEntry, 256 > lit1_bm_mem_word3_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt0_mem_word0_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt0_mem_word1_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt0_mem_word2_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt0_mem_word3_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt1_mem_word0_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt1_mem_word1_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt1_mem_word2_;
  std::array< TmPrePmtMemWordEntry, 288 > pmt1_mem_word3_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    return offset;
  }

};








class TmPreCommonMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreCommonMemRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4294967296, true, write_callback, read_callback, std::string("TmPreCommonMemRspecMutable"))
    {
    }
  TmPreCommonMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreCommonMemRspecMutable")
    {
    }
public:







  TmPreRdmMemWordEntryMutable &rdm_mem_word(int j0) { return rdm_mem_word_[j0]; }







  TmPrePbtMemWordEntryMutable &pbt0_mem_word(int j0) { return pbt0_mem_word_[j0]; }







  TmPrePbtMemWordEntryMutable &pbt1_mem_word(int j0) { return pbt1_mem_word_[j0]; }







  TmPreLitNpMemWordEntryMutable &lit0_np_mem_word(int j0) { return lit0_np_mem_word_[j0]; }







  TmPreLitNpMemWordEntryMutable &lit1_np_mem_word(int j0) { return lit1_np_mem_word_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit0_bm_mem_word0(int j0) { return lit0_bm_mem_word0_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit0_bm_mem_word1(int j0) { return lit0_bm_mem_word1_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit0_bm_mem_word2(int j0) { return lit0_bm_mem_word2_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit0_bm_mem_word3(int j0) { return lit0_bm_mem_word3_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit1_bm_mem_word0(int j0) { return lit1_bm_mem_word0_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit1_bm_mem_word1(int j0) { return lit1_bm_mem_word1_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit1_bm_mem_word2(int j0) { return lit1_bm_mem_word2_[j0]; }







  TmPreLitBmMemWordEntryMutable &lit1_bm_mem_word3(int j0) { return lit1_bm_mem_word3_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt0_mem_word0(int j0) { return pmt0_mem_word0_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt0_mem_word1(int j0) { return pmt0_mem_word1_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt0_mem_word2(int j0) { return pmt0_mem_word2_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt0_mem_word3(int j0) { return pmt0_mem_word3_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt1_mem_word0(int j0) { return pmt1_mem_word0_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt1_mem_word1(int j0) { return pmt1_mem_word1_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt1_mem_word2(int j0) { return pmt1_mem_word2_[j0]; }







  TmPrePmtMemWordEntryMutable &pmt1_mem_word3(int j0) { return pmt1_mem_word3_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      rdm_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pbt0_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pbt1_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_np_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_np_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt0_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      pmt1_mem_word3_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      rdm_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pbt0_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pbt1_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_np_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_np_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit0_bm_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      lit1_bm_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt0_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      pmt1_mem_word3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : rdm_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : pbt0_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : pbt1_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : lit0_np_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : lit1_np_mem_word_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : lit0_bm_mem_word3_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : lit1_bm_mem_word3_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : pmt0_mem_word3_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word0_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word1_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word2_) {
      f0.reset();
    }
    for (auto &f0 : pmt1_mem_word3_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += rdm_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pbt0_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pbt1_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_np_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_np_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit0_bm_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += lit1_bm_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt0_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += pmt1_mem_word3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<524288;++a0) {
      r += rdm_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pbt0_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pbt1_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_np_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_np_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit0_bm_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += lit1_bm_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt0_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += pmt1_mem_word3_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPreRdmMemWordEntryMutable, 524288 > rdm_mem_word_;
  std::array< TmPrePbtMemWordEntryMutable, 288 > pbt0_mem_word_;
  std::array< TmPrePbtMemWordEntryMutable, 288 > pbt1_mem_word_;
  std::array< TmPreLitNpMemWordEntryMutable, 256 > lit0_np_mem_word_;
  std::array< TmPreLitNpMemWordEntryMutable, 256 > lit1_np_mem_word_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit0_bm_mem_word0_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit0_bm_mem_word1_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit0_bm_mem_word2_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit0_bm_mem_word3_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit1_bm_mem_word0_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit1_bm_mem_word1_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit1_bm_mem_word2_;
  std::array< TmPreLitBmMemWordEntryMutable, 256 > lit1_bm_mem_word3_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt0_mem_word0_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt0_mem_word1_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt0_mem_word2_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt0_mem_word3_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt1_mem_word0_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt1_mem_word1_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt1_mem_word2_;
  std::array< TmPrePmtMemWordEntryMutable, 288 > pmt1_mem_word3_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    return offset;
  }

};








class TmPreMitMemWordEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMitMemWordEntry(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, int index_tm_pre_mit_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec, index_tm_pre_mit_mem_word_entry), 1, false, write_callback, read_callback, std::string("TmPreMitMemWordEntry")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_mit_mem_word_entry))
    {
    }
  TmPreMitMemWordEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreMitMemWordEntry")
    {
    }
public:




  BitVector<80> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xffff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xffff), 64,16);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreMitMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreMitMemWordEntry") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<80> mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec, int index_tm_pre_mit_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    assert(index_tm_pre_mit_mem_word_entry < 16384);
    offset += index_tm_pre_mit_mem_word_entry * 0x1; // tm_pre_mit_mem_word_entry[]
    return offset;
  }

};








class TmPreMitMemWordEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMitMemWordEntryMutable(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, int index_tm_pre_mit_mem_word_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec, index_tm_pre_mit_mem_word_entry), 1, true, write_callback, read_callback, std::string("TmPreMitMemWordEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_pre_mit_mem_word_entry))
    {
    }
  TmPreMitMemWordEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreMitMemWordEntryMutable")
    {
    }
public:




  BitVector<80> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = (mem_word_.get_word(64) & 0xffff);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word((data1 & 0xffff), 64,16);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreMitMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmPreMitMemWordEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<80> mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec, int index_tm_pre_mit_mem_word_entry
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    assert(index_tm_pre_mit_mem_word_entry < 16384);
    offset += index_tm_pre_mit_mem_word_entry * 0x1; // tm_pre_mit_mem_word_entry[]
    return offset;
  }

};








class TmPreMitMemWordEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPreMitMemWordEntryArray(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 1 * ArraySize(index_tm_pre_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmPreMitMemWordEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec)),
    array(RealArraySize(index_tm_pre_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_pre_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_pre_pipe_mem_rspec, 0))
    {
    }
public:




  BitVector<80> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreMitMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreMitMemWordEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreMitMemWordEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_pre_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 16384;
        break;
      case 0:
        return 16384;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_pre_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 16384;
        break;
      case 0:
        return 16384;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreMitMemWordEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPreMitMemWordEntryArrayMutable(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 1 * ArraySize(index_tm_pre_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmPreMitMemWordEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec)),
    array(RealArraySize(index_tm_pre_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_pre_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_pre_pipe_mem_rspec, 0))
    {
    }
public:




  BitVector<80> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPreMitMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPreMitMemWordEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPreMitMemWordEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_pre_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 16384;
        break;
      case 0:
        return 16384;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_pre_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 16384;
        break;
      case 0:
        return 16384;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrePipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrePipeMemRspec(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 1048576, false, write_callback, read_callback, std::string("TmPrePipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec))
    {
    }
  TmPrePipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrePipeMemRspec")
    {
    }
public:







  TmPreMitMemWordEntry &mit_mem_word(int j0) { return mit_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x4000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      mit_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x4000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      mit_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mit_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x4000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += mit_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<16384;++a0) {
      r += mit_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPreMitMemWordEntry, 16384 > mit_mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrePipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrePipeMemRspecMutable(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 1048576, true, write_callback, read_callback, std::string("TmPrePipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec))
    {
    }
  TmPrePipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrePipeMemRspecMutable")
    {
    }
public:







  TmPreMitMemWordEntryMutable &mit_mem_word(int j0) { return mit_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x4000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      mit_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x4000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      mit_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mit_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x4000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += mit_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<16384;++a0) {
      r += mit_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPreMitMemWordEntryMutable, 16384 > mit_mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrePipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrePipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 1048576 * ArraySize(-1), false, write_callback, read_callback, std::string("TmPrePipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  TmPreMitMemWordEntry &mit_mem_word(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mit_mem_word(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1048576;
    (*offset) -= (i*1048576);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrePipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrePipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 1048576 * ArraySize(-1), true, write_callback, read_callback, std::string("TmPrePipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  TmPreMitMemWordEntryMutable &mit_mem_word(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mit_mem_word(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1048576;
    (*offset) -= (i*1048576);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPreMemTopRspec"))
    {
    }
  TmPreMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreMemTopRspec")
    {
    }
public:







  TmPrePipeMemRspec &pre_pipe_mem(int j0) { return pre_pipe_mem_[j0]; }





  TmPreCommonMemRspec &pre_common_mem() { return pre_common_mem_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      if (read_callback_) read_callback_();
      pre_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      if (read_callback_) read_callback_();
      pre_common_mem_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      pre_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      pre_common_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pre_pipe_mem_) {
      f0.reset();
    }
    pre_common_mem_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      r += pre_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      r += pre_common_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pre_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pre_common_mem_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrePipeMemRspec, 4 > pre_pipe_mem_;
  TmPreCommonMemRspec pre_common_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

};








class TmPreMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPreMemTopRspecMutable"))
    {
    }
  TmPreMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreMemTopRspecMutable")
    {
    }
public:







  TmPrePipeMemRspecMutable &pre_pipe_mem(int j0) { return pre_pipe_mem_[j0]; }





  TmPreCommonMemRspecMutable &pre_common_mem() { return pre_common_mem_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      if (read_callback_) read_callback_();
      pre_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      if (read_callback_) read_callback_();
      pre_common_mem_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      pre_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      pre_common_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pre_pipe_mem_) {
      f0.reset();
    }
    pre_common_mem_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      r += pre_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      r += pre_common_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pre_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pre_common_mem_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrePipeMemRspecMutable, 4 > pre_pipe_mem_;
  TmPreCommonMemRspecMutable pre_common_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

};










class PrcTagEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcTagEntry(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, int index_prc_tag_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, index_prc_tag_entry), 1, false, write_callback, read_callback, std::string("PrcTagEntry")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_tag_entry))
    {
    }
  PrcTagEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcTagEntry")
    {
    }
public:
  uint16_t &tag() { return tag_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(tag_) & 0x3ff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    tag_ = (data0 & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    tag_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcTagEntry") + ":\n";
    r += indent_string + "  " + std::string("tag") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(tag_) ) + "\n";
    all_zeros &= (0 == tag_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcTagEntry") + ":\n";
    r += indent_string + "  " + std::string("tag") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(tag_) ) + "\n";
    all_zeros &= (0 == tag_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t tag_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, int index_prc_tag_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x22400; // to get to csr_memory_prc_tag
    assert(index_prc_tag_entry < 512);
    offset += index_prc_tag_entry * 0x1; // prc_tag_entry[]
    return offset;
  }

};










class PrcTagEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcTagEntryMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, int index_prc_tag_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, index_prc_tag_entry), 1, true, write_callback, read_callback, std::string("PrcTagEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_tag_entry))
    {
    }
  PrcTagEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcTagEntryMutable")
    {
    }
public:
  uint16_t tag() { return tag_; }
  void tag(const uint16_t &v) { tag_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(tag_) & 0x3ff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    tag_ = (data0 & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    tag_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcTagEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("tag") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(tag_) ) + "\n";
    all_zeros &= (0 == tag_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcTagEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("tag") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(tag_) ) + "\n";
    all_zeros &= (0 == tag_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t tag_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, int index_prc_tag_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x22400; // to get to csr_memory_prc_tag
    assert(index_prc_tag_entry < 512);
    offset += index_prc_tag_entry * 0x1; // prc_tag_entry[]
    return offset;
  }

};










class PrcTagEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PrcTagEntryArray(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("PrcTagEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint16_t &tag(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].tag();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcTagEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcTagEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcTagEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x22400; // to get to csr_memory_prc_tag
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 512;
        break;
      case 0:
        return 512;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 512;
        break;
      case 0:
        return 512;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class PrcTagEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PrcTagEntryArrayMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("PrcTagEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint16_t tag(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].tag();
  }
  void tag(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].tag(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcTagEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcTagEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcTagEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x22400; // to get to csr_memory_prc_tag
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 512;
        break;
      case 0:
        return 512;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 512;
        break;
      case 0:
        return 512;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrcCacheEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPrcPipeMemRspecEnum {
    kCsrMemoryPrcCache0,
    kCsrMemoryPrcCache1
  };
public:
  PrcCacheEntry(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int index_prc_cache_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, index_prc_cache_entry), 1, false, write_callback, read_callback, std::string("PrcCacheEntry")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_cache_entry))
    {
    }
  PrcCacheEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcCacheEntry")
    {
    }
public:
  uint32_t &cache0() { return cache0_; }
  uint32_t &cache1() { return cache1_; }
  uint32_t &cache2() { return cache2_; }
  uint32_t &cache3() { return cache3_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cache0_) & 0x3ffff);
    *data0 |= ((static_cast<uint64_t>(cache1_) & 0x3ffff) << 18);
    *data0 |= ((static_cast<uint64_t>(cache2_) & 0x3ffff) << 36);
    *data0 |= ((static_cast<uint64_t>(cache3_) & 0x3ff) << 54);
    *data1 = ((static_cast<uint64_t>(cache3_) & 0x3fc00) >> 10);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cache0_ = (data0 & 0x3ffff);
    cache1_ = ((data0 >> 18) & 0x3ffff);
    cache2_ = ((data0 >> 36) & 0x3ffff);
    cache3_ = (((data0 >> 54) & 0x3ff) | (cache3_ & 0x3fc00));
    cache3_ = (((data1 << 10) & 0x3fc00) | (cache3_ & 0x3ff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cache0_ = 0;
    cache1_ = 0;
    cache2_ = 0;
    cache3_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcCacheEntry") + ":\n";
    r += indent_string + "  " + std::string("cache0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache0_) ) + "\n";
    all_zeros &= (0 == cache0_);
    r += indent_string + "  " + std::string("cache1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache1_) ) + "\n";
    all_zeros &= (0 == cache1_);
    r += indent_string + "  " + std::string("cache2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache2_) ) + "\n";
    all_zeros &= (0 == cache2_);
    r += indent_string + "  " + std::string("cache3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache3_) ) + "\n";
    all_zeros &= (0 == cache3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcCacheEntry") + ":\n";
    r += indent_string + "  " + std::string("cache0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache0_) ) + "\n";
    all_zeros &= (0 == cache0_);
    r += indent_string + "  " + std::string("cache1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache1_) ) + "\n";
    all_zeros &= (0 == cache1_);
    r += indent_string + "  " + std::string("cache2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache2_) ) + "\n";
    all_zeros &= (0 == cache2_);
    r += indent_string + "  " + std::string("cache3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache3_) ) + "\n";
    all_zeros &= (0 == cache3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cache0_;
  uint32_t cache1_;
  uint32_t cache2_;
  uint32_t cache3_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int index_prc_cache_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        offset += 0x22000; // to get to csr_memory_prc_cache0
        assert(index_prc_cache_entry < 512);
        offset += index_prc_cache_entry * 0x1; // prc_cache_entry[]
        break;
      case kCsrMemoryPrcCache1:
        offset += 0x22200; // to get to csr_memory_prc_cache1
        assert(index_prc_cache_entry < 512);
        offset += index_prc_cache_entry * 0x1; // prc_cache_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrcCacheEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPrcPipeMemRspecEnum {
    kCsrMemoryPrcCache0,
    kCsrMemoryPrcCache1
  };
public:
  PrcCacheEntryMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int index_prc_cache_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, index_prc_cache_entry), 1, true, write_callback, read_callback, std::string("PrcCacheEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_cache_entry))
    {
    }
  PrcCacheEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcCacheEntryMutable")
    {
    }
public:
  uint32_t cache0() { return cache0_; }
  void cache0(const uint32_t &v) { cache0_=v; }
  uint32_t cache1() { return cache1_; }
  void cache1(const uint32_t &v) { cache1_=v; }
  uint32_t cache2() { return cache2_; }
  void cache2(const uint32_t &v) { cache2_=v; }
  uint32_t cache3() { return cache3_; }
  void cache3(const uint32_t &v) { cache3_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cache0_) & 0x3ffff);
    *data0 |= ((static_cast<uint64_t>(cache1_) & 0x3ffff) << 18);
    *data0 |= ((static_cast<uint64_t>(cache2_) & 0x3ffff) << 36);
    *data0 |= ((static_cast<uint64_t>(cache3_) & 0x3ff) << 54);
    *data1 = ((static_cast<uint64_t>(cache3_) & 0x3fc00) >> 10);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cache0_ = (data0 & 0x3ffff);
    cache1_ = ((data0 >> 18) & 0x3ffff);
    cache2_ = ((data0 >> 36) & 0x3ffff);
    cache3_ = (((data0 >> 54) & 0x3ff) | (cache3_ & 0x3fc00));
    cache3_ = (((data1 << 10) & 0x3fc00) | (cache3_ & 0x3ff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cache0_ = 0;
    cache1_ = 0;
    cache2_ = 0;
    cache3_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcCacheEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cache0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache0_) ) + "\n";
    all_zeros &= (0 == cache0_);
    r += indent_string + "  " + std::string("cache1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache1_) ) + "\n";
    all_zeros &= (0 == cache1_);
    r += indent_string + "  " + std::string("cache2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache2_) ) + "\n";
    all_zeros &= (0 == cache2_);
    r += indent_string + "  " + std::string("cache3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache3_) ) + "\n";
    all_zeros &= (0 == cache3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcCacheEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cache0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache0_) ) + "\n";
    all_zeros &= (0 == cache0_);
    r += indent_string + "  " + std::string("cache1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache1_) ) + "\n";
    all_zeros &= (0 == cache1_);
    r += indent_string + "  " + std::string("cache2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache2_) ) + "\n";
    all_zeros &= (0 == cache2_);
    r += indent_string + "  " + std::string("cache3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cache3_) ) + "\n";
    all_zeros &= (0 == cache3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cache0_;
  uint32_t cache1_;
  uint32_t cache2_;
  uint32_t cache3_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int index_prc_cache_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        offset += 0x22000; // to get to csr_memory_prc_cache0
        assert(index_prc_cache_entry < 512);
        offset += index_prc_cache_entry * 0x1; // prc_cache_entry[]
        break;
      case kCsrMemoryPrcCache1:
        offset += 0x22200; // to get to csr_memory_prc_cache1
        assert(index_prc_cache_entry < 512);
        offset += index_prc_cache_entry * 0x1; // prc_cache_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrcCacheEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPrcPipeMemRspecEnum {
    kCsrMemoryPrcCache0,
    kCsrMemoryPrcCache1
  };
public:
  PrcCacheEntryArray(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("PrcCacheEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cache0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache0();
  }
  uint32_t &cache1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache1();
  }
  uint32_t &cache2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache2();
  }
  uint32_t &cache3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache3();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcCacheEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcCacheEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcCacheEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        offset += 0x22000; // to get to csr_memory_prc_cache0
        break;
      case kCsrMemoryPrcCache1:
        offset += 0x22200; // to get to csr_memory_prc_cache1
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryPrcCache1:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryPrcCache1:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrcCacheEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmPrcPipeMemRspecEnum {
    kCsrMemoryPrcCache0,
    kCsrMemoryPrcCache1
  };
public:
  PrcCacheEntryArrayMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("PrcCacheEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cache0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache0();
  }
  void cache0(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cache0(v);
  }
  uint32_t cache1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache1();
  }
  void cache1(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cache1(v);
  }
  uint32_t cache2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache2();
  }
  void cache2(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cache2(v);
  }
  uint32_t cache3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cache3();
  }
  void cache3(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cache3(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcCacheEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcCacheEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcCacheEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        offset += 0x22000; // to get to csr_memory_prc_cache0
        break;
      case kCsrMemoryPrcCache1:
        offset += 0x22200; // to get to csr_memory_prc_cache1
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryPrcCache1:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryPrcCache1:
        switch (dimension) {
          case -1:
            return 512;
            break;
          case 0:
            return 512;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrcMapEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcMapEntry(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, int index_prc_map_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, index_prc_map_entry), 1, false, write_callback, read_callback, std::string("PrcMapEntry")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_map_entry))
    {
    }
  PrcMapEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcMapEntry")
    {
    }
public:
  uint64_t &map() { return map_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = map_;
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    map_ = data0;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    map_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcMapEntry") + ":\n";
    r += indent_string + "  " + std::string("map") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(map_) ) + "\n";
    all_zeros &= (0 == map_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcMapEntry") + ":\n";
    r += indent_string + "  " + std::string("map") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(map_) ) + "\n";
    all_zeros &= (0 == map_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t map_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, int index_prc_map_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x20000; // to get to csr_memory_prc_map
    assert(index_prc_map_entry < 6144);
    offset += index_prc_map_entry * 0x1; // prc_map_entry[]
    return offset;
  }

};








class PrcMapEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcMapEntryMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, int index_prc_map_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, index_prc_map_entry), 1, true, write_callback, read_callback, std::string("PrcMapEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_map_entry))
    {
    }
  PrcMapEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcMapEntryMutable")
    {
    }
public:
  uint64_t map() { return map_; }
  void map(const uint64_t &v) { map_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = map_;
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    map_ = data0;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    map_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcMapEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("map") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(map_) ) + "\n";
    all_zeros &= (0 == map_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcMapEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("map") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(map_) ) + "\n";
    all_zeros &= (0 == map_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t map_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, int index_prc_map_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x20000; // to get to csr_memory_prc_map
    assert(index_prc_map_entry < 6144);
    offset += index_prc_map_entry * 0x1; // prc_map_entry[]
    return offset;
  }

};








class PrcMapEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PrcMapEntryArray(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("PrcMapEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t &map(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].map();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcMapEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcMapEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcMapEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x20000; // to get to csr_memory_prc_map
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 6144;
        break;
      case 0:
        return 6144;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 6144;
        break;
      case 0:
        return 6144;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrcMapEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PrcMapEntryArrayMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("PrcMapEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t map(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].map();
  }
  void map(uint32_t a0,const uint64_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].map(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcMapEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcMapEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcMapEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x20000; // to get to csr_memory_prc_map
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 6144;
        break;
      case 0:
        return 6144;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 6144;
        break;
      case 0:
        return 6144;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class PrcPrmEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcPrmEntry(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, int index_prc_prm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, index_prc_prm_entry), 1, false, write_callback, read_callback, std::string("PrcPrmEntry")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_prm_entry))
    {
    }
  PrcPrmEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcPrmEntry")
    {
    }
public:
  uint32_t &cnt0() { return cnt0_; }
  uint32_t &cnt1() { return cnt1_; }
  uint32_t &cnt2() { return cnt2_; }
  uint32_t &cnt3() { return cnt3_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt0_) & 0x3ffff);
    *data0 |= ((static_cast<uint64_t>(cnt1_) & 0x3ffff) << 18);
    *data0 |= ((static_cast<uint64_t>(cnt2_) & 0x3ffff) << 36);
    *data0 |= ((static_cast<uint64_t>(cnt3_) & 0x3ff) << 54);
    *data1 = ((static_cast<uint64_t>(cnt3_) & 0x3fc00) >> 10);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt0_ = (data0 & 0x3ffff);
    cnt1_ = ((data0 >> 18) & 0x3ffff);
    cnt2_ = ((data0 >> 36) & 0x3ffff);
    cnt3_ = (((data0 >> 54) & 0x3ff) | (cnt3_ & 0x3fc00));
    cnt3_ = (((data1 << 10) & 0x3fc00) | (cnt3_ & 0x3ff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt0_ = 0;
    cnt1_ = 0;
    cnt2_ = 0;
    cnt3_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcPrmEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt0_) ) + "\n";
    all_zeros &= (0 == cnt0_);
    r += indent_string + "  " + std::string("cnt1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt1_) ) + "\n";
    all_zeros &= (0 == cnt1_);
    r += indent_string + "  " + std::string("cnt2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt2_) ) + "\n";
    all_zeros &= (0 == cnt2_);
    r += indent_string + "  " + std::string("cnt3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt3_) ) + "\n";
    all_zeros &= (0 == cnt3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcPrmEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt0_) ) + "\n";
    all_zeros &= (0 == cnt0_);
    r += indent_string + "  " + std::string("cnt1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt1_) ) + "\n";
    all_zeros &= (0 == cnt1_);
    r += indent_string + "  " + std::string("cnt2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt2_) ) + "\n";
    all_zeros &= (0 == cnt2_);
    r += indent_string + "  " + std::string("cnt3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt3_) ) + "\n";
    all_zeros &= (0 == cnt3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt0_;
  uint32_t cnt1_;
  uint32_t cnt2_;
  uint32_t cnt3_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, int index_prc_prm_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    assert(index_prc_prm_entry < 98304);
    offset += index_prc_prm_entry * 0x1; // prc_prm_entry[]
    return offset;
  }

};










class PrcPrmEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcPrmEntryMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, int index_prc_prm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, index_prc_prm_entry), 1, true, write_callback, read_callback, std::string("PrcPrmEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_prc_prm_entry))
    {
    }
  PrcPrmEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcPrmEntryMutable")
    {
    }
public:
  uint32_t cnt0() { return cnt0_; }
  void cnt0(const uint32_t &v) { cnt0_=v; }
  uint32_t cnt1() { return cnt1_; }
  void cnt1(const uint32_t &v) { cnt1_=v; }
  uint32_t cnt2() { return cnt2_; }
  void cnt2(const uint32_t &v) { cnt2_=v; }
  uint32_t cnt3() { return cnt3_; }
  void cnt3(const uint32_t &v) { cnt3_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt0_) & 0x3ffff);
    *data0 |= ((static_cast<uint64_t>(cnt1_) & 0x3ffff) << 18);
    *data0 |= ((static_cast<uint64_t>(cnt2_) & 0x3ffff) << 36);
    *data0 |= ((static_cast<uint64_t>(cnt3_) & 0x3ff) << 54);
    *data1 = ((static_cast<uint64_t>(cnt3_) & 0x3fc00) >> 10);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt0_ = (data0 & 0x3ffff);
    cnt1_ = ((data0 >> 18) & 0x3ffff);
    cnt2_ = ((data0 >> 36) & 0x3ffff);
    cnt3_ = (((data0 >> 54) & 0x3ff) | (cnt3_ & 0x3fc00));
    cnt3_ = (((data1 << 10) & 0x3fc00) | (cnt3_ & 0x3ff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt0_ = 0;
    cnt1_ = 0;
    cnt2_ = 0;
    cnt3_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcPrmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt0_) ) + "\n";
    all_zeros &= (0 == cnt0_);
    r += indent_string + "  " + std::string("cnt1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt1_) ) + "\n";
    all_zeros &= (0 == cnt1_);
    r += indent_string + "  " + std::string("cnt2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt2_) ) + "\n";
    all_zeros &= (0 == cnt2_);
    r += indent_string + "  " + std::string("cnt3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt3_) ) + "\n";
    all_zeros &= (0 == cnt3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrcPrmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt0_) ) + "\n";
    all_zeros &= (0 == cnt0_);
    r += indent_string + "  " + std::string("cnt1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt1_) ) + "\n";
    all_zeros &= (0 == cnt1_);
    r += indent_string + "  " + std::string("cnt2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt2_) ) + "\n";
    all_zeros &= (0 == cnt2_);
    r += indent_string + "  " + std::string("cnt3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt3_) ) + "\n";
    all_zeros &= (0 == cnt3_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt0_;
  uint32_t cnt1_;
  uint32_t cnt2_;
  uint32_t cnt3_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, int index_prc_prm_entry
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    assert(index_prc_prm_entry < 98304);
    offset += index_prc_prm_entry * 0x1; // prc_prm_entry[]
    return offset;
  }

};










class PrcPrmEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PrcPrmEntryArray(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("PrcPrmEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt0();
  }
  uint32_t &cnt1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt1();
  }
  uint32_t &cnt2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt2();
  }
  uint32_t &cnt3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt3();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcPrmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcPrmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcPrmEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 98304;
        break;
      case 0:
        return 98304;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 98304;
        break;
      case 0:
        return 98304;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class PrcPrmEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PrcPrmEntryArrayMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 1 * ArraySize(index_tm_prc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("PrcPrmEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_prc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_prc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_prc_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt0();
  }
  void cnt0(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt0(v);
  }
  uint32_t cnt1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt1();
  }
  void cnt1(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt1(v);
  }
  uint32_t cnt2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt2();
  }
  void cnt2(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt2(v);
  }
  uint32_t cnt3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt3();
  }
  void cnt3(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt3(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrcPrmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrcPrmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrcPrmEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 98304;
        break;
      case 0:
        return 98304;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_prc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 98304;
        break;
      case 0:
        return 98304;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrcPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcPipeMemRspec(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmPrcPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  TmPrcPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrcPipeMemRspec")
    {
    }
public:









  PrcPrmEntry &csr_memory_prc_prm(int j0) { return csr_memory_prc_prm_[j0]; }







  PrcMapEntry &csr_memory_prc_map(int j0) { return csr_memory_prc_map_[j0]; }







  PrcCacheEntry &csr_memory_prc_cache0(int j0) { return csr_memory_prc_cache0_[j0]; }







  PrcCacheEntry &csr_memory_prc_cache1(int j0) { return csr_memory_prc_cache1_[j0]; }









  PrcTagEntry &csr_memory_prc_tag(int j0) { return csr_memory_prc_tag_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x18000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_prm_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_map_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_tag_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x18000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_prm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_map_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_cache0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_cache1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_tag_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_prc_prm_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_map_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_cache0_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_cache1_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_tag_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x18000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_prm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_map_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_cache0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_cache1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_tag_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<98304;++a0) {
      r += csr_memory_prc_prm_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<6144;++a0) {
      r += csr_memory_prc_map_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<512;++a0) {
      r += csr_memory_prc_cache0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<512;++a0) {
      r += csr_memory_prc_cache1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<512;++a0) {
      r += csr_memory_prc_tag_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrcPrmEntry, 98304 > csr_memory_prc_prm_;
  std::array< PrcMapEntry, 6144 > csr_memory_prc_map_;
  std::array< PrcCacheEntry, 512 > csr_memory_prc_cache0_;
  std::array< PrcCacheEntry, 512 > csr_memory_prc_cache1_;
  std::array< PrcTagEntry, 512 > csr_memory_prc_tag_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrcPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcPipeMemRspecMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmPrcPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  TmPrcPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrcPipeMemRspecMutable")
    {
    }
public:









  PrcPrmEntryMutable &csr_memory_prc_prm(int j0) { return csr_memory_prc_prm_[j0]; }







  PrcMapEntryMutable &csr_memory_prc_map(int j0) { return csr_memory_prc_map_[j0]; }







  PrcCacheEntryMutable &csr_memory_prc_cache0(int j0) { return csr_memory_prc_cache0_[j0]; }







  PrcCacheEntryMutable &csr_memory_prc_cache1(int j0) { return csr_memory_prc_cache1_[j0]; }









  PrcTagEntryMutable &csr_memory_prc_tag(int j0) { return csr_memory_prc_tag_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x18000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_prm_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_map_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_prc_tag_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x18000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_prm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_map_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_cache0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_cache1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_prc_tag_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_prc_prm_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_map_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_cache0_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_cache1_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_prc_tag_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x18000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_prm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_map_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_cache0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_cache1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_prc_tag_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<98304;++a0) {
      r += csr_memory_prc_prm_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<6144;++a0) {
      r += csr_memory_prc_map_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<512;++a0) {
      r += csr_memory_prc_cache0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<512;++a0) {
      r += csr_memory_prc_cache1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<512;++a0) {
      r += csr_memory_prc_tag_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrcPrmEntryMutable, 98304 > csr_memory_prc_prm_;
  std::array< PrcMapEntryMutable, 6144 > csr_memory_prc_map_;
  std::array< PrcCacheEntryMutable, 512 > csr_memory_prc_cache0_;
  std::array< PrcCacheEntryMutable, 512 > csr_memory_prc_cache1_;
  std::array< PrcTagEntryMutable, 512 > csr_memory_prc_tag_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrcPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrcPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmPrcPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:









  PrcPrmEntry &csr_memory_prc_prm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_prm(j0);
  }







  PrcMapEntry &csr_memory_prc_map(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_map(j0);
  }







  PrcCacheEntry &csr_memory_prc_cache0(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache0(j0);
  }







  PrcCacheEntry &csr_memory_prc_cache1(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache1(j0);
  }









  PrcTagEntry &csr_memory_prc_tag(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_tag(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrcPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrcPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrcPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmPrcPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:









  PrcPrmEntryMutable &csr_memory_prc_prm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_prm(j0);
  }







  PrcMapEntryMutable &csr_memory_prc_map(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_map(j0);
  }







  PrcCacheEntryMutable &csr_memory_prc_cache0(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache0(j0);
  }







  PrcCacheEntryMutable &csr_memory_prc_cache1(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache1(j0);
  }









  PrcTagEntryMutable &csr_memory_prc_tag(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_tag(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrcPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrcMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPrcMemTopRspec"))
    {
    }
  TmPrcMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrcMemTopRspec")
    {
    }
public:







  TmPrcPipeMemRspec &prc_mem(int j0) { return prc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      prc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      prc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : prc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += prc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += prc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrcPipeMemRspec, 4 > prc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

};








class TmPrcMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPrcMemTopRspecMutable"))
    {
    }
  TmPrcMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrcMemTopRspecMutable")
    {
    }
public:







  TmPrcPipeMemRspecMutable &prc_mem(int j0) { return prc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      prc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      prc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : prc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += prc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += prc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrcPipeMemRspecMutable, 4 > prc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

};








class QlcVqEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcVqEntry(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, int index_qlc_vq_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec, index_qlc_vq_entry), 1, false, write_callback, read_callback, std::string("QlcVqEntry")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qlc_vq_entry))
    {
    }
  QlcVqEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QlcVqEntry")
    {
    }
public:
  uint16_t &base() { return base_; }
  uint8_t &cap() { return cap_; }
  uint8_t &h() { return h_; }
  uint8_t &t() { return t_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(base_) & 0x7ff);
    *data0 |= ((static_cast<uint64_t>(cap_) & 0x7) << 11);
    *data0 |= ((static_cast<uint64_t>(h_) & 0x7) << 14);
    *data0 |= ((static_cast<uint64_t>(t_) & 0x7) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    base_ = (data0 & 0x7ff);
    cap_ = ((data0 >> 11) & 0x7);
    h_ = ((data0 >> 14) & 0x7);
    t_ = ((data0 >> 17) & 0x7);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    base_ = 0;
    cap_ = 0;
    h_ = 0;
    t_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcVqEntry") + ":\n";
    r += indent_string + "  " + std::string("base") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(base_) ) + "\n";
    all_zeros &= (0 == base_);
    r += indent_string + "  " + std::string("cap") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cap_) ) + "\n";
    all_zeros &= (0 == cap_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcVqEntry") + ":\n";
    r += indent_string + "  " + std::string("base") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(base_) ) + "\n";
    all_zeros &= (0 == base_);
    r += indent_string + "  " + std::string("cap") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cap_) ) + "\n";
    all_zeros &= (0 == cap_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t base_;
  uint8_t cap_;
  uint8_t h_;
  uint8_t t_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec, int index_qlc_vq_entry
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80800; // to get to csr_memory_qlc_vq
    assert(index_qlc_vq_entry < 1152);
    offset += index_qlc_vq_entry * 0x1; // qlc_vq_entry[]
    return offset;
  }

};








class QlcVqEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcVqEntryMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, int index_qlc_vq_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec, index_qlc_vq_entry), 1, true, write_callback, read_callback, std::string("QlcVqEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qlc_vq_entry))
    {
    }
  QlcVqEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QlcVqEntryMutable")
    {
    }
public:
  uint16_t base() { return base_; }
  void base(const uint16_t &v) { base_=v; }
  uint8_t cap() { return cap_; }
  void cap(const uint8_t &v) { cap_=v; }
  uint8_t h() { return h_; }
  void h(const uint8_t &v) { h_=v; }
  uint8_t t() { return t_; }
  void t(const uint8_t &v) { t_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(base_) & 0x7ff);
    *data0 |= ((static_cast<uint64_t>(cap_) & 0x7) << 11);
    *data0 |= ((static_cast<uint64_t>(h_) & 0x7) << 14);
    *data0 |= ((static_cast<uint64_t>(t_) & 0x7) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    base_ = (data0 & 0x7ff);
    cap_ = ((data0 >> 11) & 0x7);
    h_ = ((data0 >> 14) & 0x7);
    t_ = ((data0 >> 17) & 0x7);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    base_ = 0;
    cap_ = 0;
    h_ = 0;
    t_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcVqEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("base") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(base_) ) + "\n";
    all_zeros &= (0 == base_);
    r += indent_string + "  " + std::string("cap") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cap_) ) + "\n";
    all_zeros &= (0 == cap_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcVqEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("base") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(base_) ) + "\n";
    all_zeros &= (0 == base_);
    r += indent_string + "  " + std::string("cap") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cap_) ) + "\n";
    all_zeros &= (0 == cap_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t base_;
  uint8_t cap_;
  uint8_t h_;
  uint8_t t_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec, int index_qlc_vq_entry
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80800; // to get to csr_memory_qlc_vq
    assert(index_qlc_vq_entry < 1152);
    offset += index_qlc_vq_entry * 0x1; // qlc_vq_entry[]
    return offset;
  }

};








class QlcVqEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QlcVqEntryArray(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 1 * ArraySize(index_tm_qlc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QlcVqEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qlc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qlc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qlc_pipe_mem_rspec, 0))
    {
    }
public:
  uint16_t &base(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].base();
  }
  uint8_t &cap(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cap();
  }
  uint8_t &h(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].h();
  }
  uint8_t &t(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].t();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QlcVqEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QlcVqEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QlcVqEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80800; // to get to csr_memory_qlc_vq
    return offset;
  }

  static int ArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class QlcVqEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QlcVqEntryArrayMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 1 * ArraySize(index_tm_qlc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QlcVqEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qlc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qlc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qlc_pipe_mem_rspec, 0))
    {
    }
public:
  uint16_t base(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].base();
  }
  void base(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].base(v);
  }
  uint8_t cap(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cap();
  }
  void cap(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cap(v);
  }
  uint8_t h(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].h();
  }
  void h(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].h(v);
  }
  uint8_t t(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].t();
  }
  void t(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].t(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QlcVqEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QlcVqEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QlcVqEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80800; // to get to csr_memory_qlc_vq
    return offset;
  }

  static int ArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class QlcHtEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcHtEntry(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, int index_qlc_ht_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec, index_qlc_ht_entry), 1, false, write_callback, read_callback, std::string("QlcHtEntry")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qlc_ht_entry))
    {
    }
  QlcHtEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QlcHtEntry")
    {
    }
public:
  uint8_t &vld() { return vld_; }
  uint16_t &t() { return t_; }
  uint16_t &h() { return h_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(vld_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(t_) & 0x7ff) << 1);
    *data0 |= ((static_cast<uint64_t>(h_) & 0x7ff) << 12);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    vld_ = (data0 & 0x1);
    t_ = ((data0 >> 1) & 0x7ff);
    h_ = ((data0 >> 12) & 0x7ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    vld_ = 0;
    t_ = 0;
    h_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcHtEntry") + ":\n";
    r += indent_string + "  " + std::string("vld") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(vld_) ) + "\n";
    all_zeros &= (0 == vld_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcHtEntry") + ":\n";
    r += indent_string + "  " + std::string("vld") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(vld_) ) + "\n";
    all_zeros &= (0 == vld_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t vld_;
  uint16_t t_;
  uint16_t h_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec, int index_qlc_ht_entry
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80000; // to get to csr_memory_qlc_ht
    assert(index_qlc_ht_entry < 1152);
    offset += index_qlc_ht_entry * 0x1; // qlc_ht_entry[]
    return offset;
  }

};








class QlcHtEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcHtEntryMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, int index_qlc_ht_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec, index_qlc_ht_entry), 1, true, write_callback, read_callback, std::string("QlcHtEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qlc_ht_entry))
    {
    }
  QlcHtEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QlcHtEntryMutable")
    {
    }
public:
  uint8_t vld() { return vld_; }
  void vld(const uint8_t &v) { vld_=v; }
  uint16_t t() { return t_; }
  void t(const uint16_t &v) { t_=v; }
  uint16_t h() { return h_; }
  void h(const uint16_t &v) { h_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(vld_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(t_) & 0x7ff) << 1);
    *data0 |= ((static_cast<uint64_t>(h_) & 0x7ff) << 12);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    vld_ = (data0 & 0x1);
    t_ = ((data0 >> 1) & 0x7ff);
    h_ = ((data0 >> 12) & 0x7ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    vld_ = 0;
    t_ = 0;
    h_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcHtEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("vld") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(vld_) ) + "\n";
    all_zeros &= (0 == vld_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcHtEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("vld") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(vld_) ) + "\n";
    all_zeros &= (0 == vld_);
    r += indent_string + "  " + std::string("t") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(t_) ) + "\n";
    all_zeros &= (0 == t_);
    r += indent_string + "  " + std::string("h") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(h_) ) + "\n";
    all_zeros &= (0 == h_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t vld_;
  uint16_t t_;
  uint16_t h_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec, int index_qlc_ht_entry
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80000; // to get to csr_memory_qlc_ht
    assert(index_qlc_ht_entry < 1152);
    offset += index_qlc_ht_entry * 0x1; // qlc_ht_entry[]
    return offset;
  }

};








class QlcHtEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QlcHtEntryArray(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 1 * ArraySize(index_tm_qlc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QlcHtEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qlc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qlc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qlc_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &vld(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].vld();
  }
  uint16_t &t(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].t();
  }
  uint16_t &h(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].h();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QlcHtEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QlcHtEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QlcHtEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80000; // to get to csr_memory_qlc_ht
    return offset;
  }

  static int ArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class QlcHtEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QlcHtEntryArrayMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 1 * ArraySize(index_tm_qlc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QlcHtEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qlc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qlc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qlc_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t vld(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].vld();
  }
  void vld(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].vld(v);
  }
  uint16_t t(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].t();
  }
  void t(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].t(v);
  }
  uint16_t h(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].h();
  }
  void h(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].h(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QlcHtEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QlcHtEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QlcHtEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80000; // to get to csr_memory_qlc_ht
    return offset;
  }

  static int ArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class QlcQlmEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcQlmEntry(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, int index_qlc_qlm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec, index_qlc_qlm_entry), 1, false, write_callback, read_callback, std::string("QlcQlmEntry")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qlc_qlm_entry))
    {
    }
  QlcQlmEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QlcQlmEntry")
    {
    }
public:
  uint32_t &ptr() { return ptr_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ptr_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ptr_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ptr_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcQlmEntry") + ":\n";
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcQlmEntry") + ":\n";
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t ptr_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec, int index_qlc_qlm_entry
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    assert(index_qlc_qlm_entry < 393216);
    offset += index_qlc_qlm_entry * 0x1; // qlc_qlm_entry[]
    return offset;
  }

};










class QlcQlmEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcQlmEntryMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, int index_qlc_qlm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec, index_qlc_qlm_entry), 1, true, write_callback, read_callback, std::string("QlcQlmEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qlc_qlm_entry))
    {
    }
  QlcQlmEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QlcQlmEntryMutable")
    {
    }
public:
  uint32_t ptr() { return ptr_; }
  void ptr(const uint32_t &v) { ptr_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ptr_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ptr_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ptr_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcQlmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QlcQlmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t ptr_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec, int index_qlc_qlm_entry
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    assert(index_qlc_qlm_entry < 393216);
    offset += index_qlc_qlm_entry * 0x1; // qlc_qlm_entry[]
    return offset;
  }

};










class QlcQlmEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QlcQlmEntryArray(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 1 * ArraySize(index_tm_qlc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QlcQlmEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qlc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qlc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qlc_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &ptr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QlcQlmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QlcQlmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QlcQlmEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class QlcQlmEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QlcQlmEntryArrayMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 1 * ArraySize(index_tm_qlc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QlcQlmEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qlc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qlc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qlc_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t ptr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr();
  }
  void ptr(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ptr(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QlcQlmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QlcQlmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QlcQlmEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qlc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQlcPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcPipeMemRspec(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmQlcPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  TmQlcPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQlcPipeMemRspec")
    {
    }
public:









  QlcQlmEntry &csr_memory_qlc_qlm(int j0) { return csr_memory_qlc_qlm_[j0]; }







  QlcHtEntry &csr_memory_qlc_ht(int j0) { return csr_memory_qlc_ht_[j0]; }







  QlcVqEntry &csr_memory_qlc_vq(int j0) { return csr_memory_qlc_vq_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qlc_qlm_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000 && offset < 0x80480) {
      offset -= 0x80000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qlc_ht_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80800 && offset < 0x80c80) {
      offset -= 0x80800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qlc_vq_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qlc_qlm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000 && offset < 0x80480) {
      offset -= 0x80000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qlc_ht_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80800 && offset < 0x80c80) {
      offset -= 0x80800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qlc_vq_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_qlc_qlm_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qlc_ht_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qlc_vq_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qlc_qlm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000 && offset < 0x80480) {
      offset -= 0x80000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qlc_ht_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80800 && offset < 0x80c80) {
      offset -= 0x80800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qlc_vq_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<393216;++a0) {
      r += csr_memory_qlc_qlm_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qlc_ht_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qlc_vq_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< QlcQlmEntry, 393216 > csr_memory_qlc_qlm_;
  std::array< QlcHtEntry, 1152 > csr_memory_qlc_ht_;
  std::array< QlcVqEntry, 1152 > csr_memory_qlc_vq_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

};








class TmQlcPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcPipeMemRspecMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmQlcPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  TmQlcPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQlcPipeMemRspecMutable")
    {
    }
public:









  QlcQlmEntryMutable &csr_memory_qlc_qlm(int j0) { return csr_memory_qlc_qlm_[j0]; }







  QlcHtEntryMutable &csr_memory_qlc_ht(int j0) { return csr_memory_qlc_ht_[j0]; }







  QlcVqEntryMutable &csr_memory_qlc_vq(int j0) { return csr_memory_qlc_vq_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qlc_qlm_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000 && offset < 0x80480) {
      offset -= 0x80000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qlc_ht_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80800 && offset < 0x80c80) {
      offset -= 0x80800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qlc_vq_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qlc_qlm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000 && offset < 0x80480) {
      offset -= 0x80000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qlc_ht_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80800 && offset < 0x80c80) {
      offset -= 0x80800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qlc_vq_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_qlc_qlm_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qlc_ht_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qlc_vq_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qlc_qlm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000 && offset < 0x80480) {
      offset -= 0x80000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qlc_ht_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80800 && offset < 0x80c80) {
      offset -= 0x80800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qlc_vq_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<393216;++a0) {
      r += csr_memory_qlc_qlm_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qlc_ht_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qlc_vq_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< QlcQlmEntryMutable, 393216 > csr_memory_qlc_qlm_;
  std::array< QlcHtEntryMutable, 1152 > csr_memory_qlc_ht_;
  std::array< QlcVqEntryMutable, 1152 > csr_memory_qlc_vq_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

};








class TmQlcPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQlcPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmQlcPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:









  QlcQlmEntry &csr_memory_qlc_qlm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_qlm(j0);
  }







  QlcHtEntry &csr_memory_qlc_ht(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_ht(j0);
  }







  QlcVqEntry &csr_memory_qlc_vq(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_vq(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQlcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQlcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQlcPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQlcPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQlcPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmQlcPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:









  QlcQlmEntryMutable &csr_memory_qlc_qlm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_qlm(j0);
  }







  QlcHtEntryMutable &csr_memory_qlc_ht(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_ht(j0);
  }







  QlcVqEntryMutable &csr_memory_qlc_vq(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_vq(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQlcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQlcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQlcPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQlcMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmQlcMemTopRspec"))
    {
    }
  TmQlcMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQlcMemTopRspec")
    {
    }
public:







  TmQlcPipeMemRspec &qlc_mem(int j0) { return qlc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qlc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qlc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qlc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qlc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qlc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQlcPipeMemRspec, 4 > qlc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

};








class TmQlcMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmQlcMemTopRspecMutable"))
    {
    }
  TmQlcMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQlcMemTopRspecMutable")
    {
    }
public:







  TmQlcPipeMemRspecMutable &qlc_mem(int j0) { return qlc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qlc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qlc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qlc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qlc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qlc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQlcPipeMemRspecMutable, 4 > qlc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

};








class PexClmEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PexClmEntry(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, int index_pex_clm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec, index_pex_clm_entry), 1, false, write_callback, read_callback, std::string("PexClmEntry")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_pex_clm_entry))
    {
    }
  PexClmEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PexClmEntry")
    {
    }
public:
  uint8_t &err() { return err_; }
  uint8_t &eop() { return eop_; }
  uint8_t &bcnt() { return bcnt_; }
  uint32_t &ptr() { return ptr_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(err_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(eop_) & 0x1) << 1);
    *data0 |= (static_cast<uint64_t>(bcnt_) << 2);
    *data0 |= ((static_cast<uint64_t>(ptr_) & 0x7ffff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    err_ = (data0 & 0x1);
    eop_ = ((data0 >> 1) & 0x1);
    bcnt_ = (data0 >> 2);
    ptr_ = ((data0 >> 10) & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    err_ = 0;
    eop_ = 0;
    bcnt_ = 0;
    ptr_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PexClmEntry") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PexClmEntry") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t err_;
  uint8_t eop_;
  uint8_t bcnt_;
  uint32_t ptr_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec, int index_pex_clm_entry
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    assert(index_pex_clm_entry < 393216);
    offset += index_pex_clm_entry * 0x1; // pex_clm_entry[]
    return offset;
  }

};








class PexClmEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PexClmEntryMutable(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, int index_pex_clm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec, index_pex_clm_entry), 1, true, write_callback, read_callback, std::string("PexClmEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_pex_clm_entry))
    {
    }
  PexClmEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PexClmEntryMutable")
    {
    }
public:
  uint8_t err() { return err_; }
  void err(const uint8_t &v) { err_=v; }
  uint8_t eop() { return eop_; }
  void eop(const uint8_t &v) { eop_=v; }
  uint8_t bcnt() { return bcnt_; }
  void bcnt(const uint8_t &v) { bcnt_=v; }
  uint32_t ptr() { return ptr_; }
  void ptr(const uint32_t &v) { ptr_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(err_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(eop_) & 0x1) << 1);
    *data0 |= (static_cast<uint64_t>(bcnt_) << 2);
    *data0 |= ((static_cast<uint64_t>(ptr_) & 0x7ffff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    err_ = (data0 & 0x1);
    eop_ = ((data0 >> 1) & 0x1);
    bcnt_ = (data0 >> 2);
    ptr_ = ((data0 >> 10) & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    err_ = 0;
    eop_ = 0;
    bcnt_ = 0;
    ptr_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PexClmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PexClmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t err_;
  uint8_t eop_;
  uint8_t bcnt_;
  uint32_t ptr_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec, int index_pex_clm_entry
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    assert(index_pex_clm_entry < 393216);
    offset += index_pex_clm_entry * 0x1; // pex_clm_entry[]
    return offset;
  }

};








class PexClmEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PexClmEntryArray(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 1 * ArraySize(index_tm_pex_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("PexClmEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec)),
    array(RealArraySize(index_tm_pex_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_pex_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_pex_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].err();
  }
  uint8_t &eop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].eop();
  }
  uint8_t &bcnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bcnt();
  }
  uint32_t &ptr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PexClmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PexClmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PexClmEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_pex_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_pex_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PexClmEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PexClmEntryArrayMutable(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 1 * ArraySize(index_tm_pex_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("PexClmEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec)),
    array(RealArraySize(index_tm_pex_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_pex_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_pex_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].err();
  }
  void err(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].err(v);
  }
  uint8_t eop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].eop();
  }
  void eop(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].eop(v);
  }
  uint8_t bcnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bcnt();
  }
  void bcnt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bcnt(v);
  }
  uint32_t ptr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr();
  }
  void ptr(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ptr(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PexClmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PexClmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PexClmEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_pex_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_pex_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPexPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexPipeMemRspec(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmPexPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec))
    {
    }
  TmPexPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPexPipeMemRspec")
    {
    }
public:







  PexClmEntry &csr_memory_pex_clm(int j0) { return csr_memory_pex_clm_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_pex_clm_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_pex_clm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_pex_clm_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_pex_clm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<393216;++a0) {
      r += csr_memory_pex_clm_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PexClmEntry, 393216 > csr_memory_pex_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

};








class TmPexPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexPipeMemRspecMutable(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmPexPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec))
    {
    }
  TmPexPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPexPipeMemRspecMutable")
    {
    }
public:







  PexClmEntryMutable &csr_memory_pex_clm(int j0) { return csr_memory_pex_clm_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_pex_clm_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_pex_clm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_pex_clm_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_pex_clm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<393216;++a0) {
      r += csr_memory_pex_clm_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PexClmEntryMutable, 393216 > csr_memory_pex_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

};








class TmPexPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPexPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmPexPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  PexClmEntry &csr_memory_pex_clm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_pex_clm(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPexPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPexPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPexPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPexPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPexPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmPexPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  PexClmEntryMutable &csr_memory_pex_clm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_pex_clm(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPexPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPexPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPexPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPexMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPexMemTopRspec"))
    {
    }
  TmPexMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPexMemTopRspec")
    {
    }
public:







  TmPexPipeMemRspec &pex(int j0) { return pex_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      pex_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      pex_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pex_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += pex_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pex_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPexPipeMemRspec, 4 > pex_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

};








class TmPexMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPexMemTopRspecMutable"))
    {
    }
  TmPexMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPexMemTopRspecMutable")
    {
    }
public:







  TmPexPipeMemRspecMutable &pex(int j0) { return pex_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      pex_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      pex_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pex_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += pex_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pex_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPexPipeMemRspecMutable, 4 > pex_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

};








class ClcClmEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  ClcClmEntry(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, int index_clc_clm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec, index_clc_clm_entry), 1, false, write_callback, read_callback, std::string("ClcClmEntry")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_clc_clm_entry))
    {
    }
  ClcClmEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "ClcClmEntry")
    {
    }
public:
  uint8_t &err() { return err_; }
  uint8_t &eop() { return eop_; }
  uint8_t &bcnt() { return bcnt_; }
  uint32_t &ptr() { return ptr_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(err_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(eop_) & 0x1) << 1);
    *data0 |= (static_cast<uint64_t>(bcnt_) << 2);
    *data0 |= ((static_cast<uint64_t>(ptr_) & 0x7ffff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    err_ = (data0 & 0x1);
    eop_ = ((data0 >> 1) & 0x1);
    bcnt_ = (data0 >> 2);
    ptr_ = ((data0 >> 10) & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    err_ = 0;
    eop_ = 0;
    bcnt_ = 0;
    ptr_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("ClcClmEntry") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("ClcClmEntry") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t err_;
  uint8_t eop_;
  uint8_t bcnt_;
  uint32_t ptr_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec, int index_clc_clm_entry
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    assert(index_clc_clm_entry < 393216);
    offset += index_clc_clm_entry * 0x1; // clc_clm_entry[]
    return offset;
  }

};








class ClcClmEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  ClcClmEntryMutable(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, int index_clc_clm_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec, index_clc_clm_entry), 1, true, write_callback, read_callback, std::string("ClcClmEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_clc_clm_entry))
    {
    }
  ClcClmEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "ClcClmEntryMutable")
    {
    }
public:
  uint8_t err() { return err_; }
  void err(const uint8_t &v) { err_=v; }
  uint8_t eop() { return eop_; }
  void eop(const uint8_t &v) { eop_=v; }
  uint8_t bcnt() { return bcnt_; }
  void bcnt(const uint8_t &v) { bcnt_=v; }
  uint32_t ptr() { return ptr_; }
  void ptr(const uint32_t &v) { ptr_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(err_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(eop_) & 0x1) << 1);
    *data0 |= (static_cast<uint64_t>(bcnt_) << 2);
    *data0 |= ((static_cast<uint64_t>(ptr_) & 0x7ffff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    err_ = (data0 & 0x1);
    eop_ = ((data0 >> 1) & 0x1);
    bcnt_ = (data0 >> 2);
    ptr_ = ((data0 >> 10) & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    err_ = 0;
    eop_ = 0;
    bcnt_ = 0;
    ptr_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("ClcClmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("ClcClmEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(err_) ) + "\n";
    all_zeros &= (0 == err_);
    r += indent_string + "  " + std::string("eop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(eop_) ) + "\n";
    all_zeros &= (0 == eop_);
    r += indent_string + "  " + std::string("bcnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bcnt_) ) + "\n";
    all_zeros &= (0 == bcnt_);
    r += indent_string + "  " + std::string("ptr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr_) ) + "\n";
    all_zeros &= (0 == ptr_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t err_;
  uint8_t eop_;
  uint8_t bcnt_;
  uint32_t ptr_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec, int index_clc_clm_entry
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    assert(index_clc_clm_entry < 393216);
    offset += index_clc_clm_entry * 0x1; // clc_clm_entry[]
    return offset;
  }

};








class ClcClmEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  ClcClmEntryArray(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 1 * ArraySize(index_tm_clc_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("ClcClmEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_clc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_clc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_clc_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].err();
  }
  uint8_t &eop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].eop();
  }
  uint8_t &bcnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bcnt();
  }
  uint32_t &ptr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("ClcClmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("ClcClmEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<ClcClmEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_clc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_clc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class ClcClmEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  ClcClmEntryArrayMutable(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 1 * ArraySize(index_tm_clc_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("ClcClmEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec)),
    array(RealArraySize(index_tm_clc_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_clc_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_clc_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].err();
  }
  void err(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].err(v);
  }
  uint8_t eop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].eop();
  }
  void eop(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].eop(v);
  }
  uint8_t bcnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bcnt();
  }
  void bcnt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bcnt(v);
  }
  uint32_t ptr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr();
  }
  void ptr(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ptr(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("ClcClmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("ClcClmEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<ClcClmEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_clc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_clc_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 393216;
        break;
      case 0:
        return 393216;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmClcPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcPipeMemRspec(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmClcPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec))
    {
    }
  TmClcPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmClcPipeMemRspec")
    {
    }
public:







  ClcClmEntry &csr_memory_clc_clm(int j0) { return csr_memory_clc_clm_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_clc_clm_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_clc_clm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_clc_clm_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_clc_clm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<393216;++a0) {
      r += csr_memory_clc_clm_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< ClcClmEntry, 393216 > csr_memory_clc_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

};








class TmClcPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcPipeMemRspecMutable(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmClcPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec))
    {
    }
  TmClcPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmClcPipeMemRspecMutable")
    {
    }
public:







  ClcClmEntryMutable &csr_memory_clc_clm(int j0) { return csr_memory_clc_clm_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_clc_clm_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_clc_clm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_clc_clm_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_clc_clm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<393216;++a0) {
      r += csr_memory_clc_clm_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< ClcClmEntryMutable, 393216 > csr_memory_clc_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

};








class TmClcPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmClcPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmClcPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  ClcClmEntry &csr_memory_clc_clm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_clc_clm(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmClcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmClcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmClcPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmClcPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmClcPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmClcPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  ClcClmEntryMutable &csr_memory_clc_clm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_clc_clm(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmClcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmClcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmClcPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmClcMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmClcMemTopRspec"))
    {
    }
  TmClcMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmClcMemTopRspec")
    {
    }
public:







  TmClcPipeMemRspec &clc(int j0) { return clc_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      clc_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      clc_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : clc_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += clc_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += clc_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmClcPipeMemRspec, 4 > clc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

};








class TmClcMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmClcMemTopRspecMutable"))
    {
    }
  TmClcMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmClcMemTopRspecMutable")
    {
    }
public:







  TmClcPipeMemRspecMutable &clc(int j0) { return clc_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      clc_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      clc_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : clc_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += clc_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += clc_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmClcPipeMemRspecMutable, 4 > clc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

};







class SchQOccREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQOccREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_occ_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_q_occ_r_entry), 1, false, write_callback, read_callback, std::string("SchQOccREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_q_occ_r_entry))
    {
    }
  SchQOccREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQOccREntry")
    {
    }
public:
  uint8_t &node_occ_cntr() { return node_occ_cntr_; }
  uint8_t &node_occ() { return node_occ_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(node_occ_cntr_) & 0xf);
    *data0 |= ((static_cast<uint64_t>(node_occ_) & 0x1) << 4);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    node_occ_cntr_ = (data0 & 0xf);
    node_occ_ = ((data0 >> 4) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    node_occ_cntr_ = 0;
    node_occ_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQOccREntry") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQOccREntry") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t node_occ_cntr_;
  uint8_t node_occ_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_occ_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        assert(index_sch_q_occ_r_entry < 1152);
        offset += index_sch_q_occ_r_entry * 0x1; // sch_q_occ_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        assert(index_sch_q_occ_r_entry < 1152);
        offset += index_sch_q_occ_r_entry * 0x1; // sch_q_occ_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQOccREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQOccREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_occ_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_q_occ_r_entry), 1, true, write_callback, read_callback, std::string("SchQOccREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_q_occ_r_entry))
    {
    }
  SchQOccREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQOccREntryMutable")
    {
    }
public:
  uint8_t node_occ_cntr() { return node_occ_cntr_; }
  void node_occ_cntr(const uint8_t &v) { node_occ_cntr_=v; }
  uint8_t node_occ() { return node_occ_; }
  void node_occ(const uint8_t &v) { node_occ_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(node_occ_cntr_) & 0xf);
    *data0 |= ((static_cast<uint64_t>(node_occ_) & 0x1) << 4);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    node_occ_cntr_ = (data0 & 0xf);
    node_occ_ = ((data0 >> 4) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    node_occ_cntr_ = 0;
    node_occ_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQOccREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQOccREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t node_occ_cntr_;
  uint8_t node_occ_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_occ_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        assert(index_sch_q_occ_r_entry < 1152);
        offset += index_sch_q_occ_r_entry * 0x1; // sch_q_occ_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        assert(index_sch_q_occ_r_entry < 1152);
        offset += index_sch_q_occ_r_entry * 0x1; // sch_q_occ_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQOccREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQOccREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchQOccREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &node_occ_cntr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ_cntr();
  }
  uint8_t &node_occ(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQOccREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQOccREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQOccREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchQOccREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQOccREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchQOccREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t node_occ_cntr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ_cntr();
  }
  void node_occ_cntr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].node_occ_cntr(v);
  }
  uint8_t node_occ(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ();
  }
  void node_occ(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].node_occ(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQOccREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQOccREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQOccREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchL1OccREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1OccREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_occ_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_l1_occ_r_entry), 1, false, write_callback, read_callback, std::string("SchL1OccREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_l1_occ_r_entry))
    {
    }
  SchL1OccREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchL1OccREntry")
    {
    }
public:
  uint8_t &node_occ_cntr() { return node_occ_cntr_; }
  uint8_t &node_occ() { return node_occ_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(node_occ_cntr_);
    *data0 |= ((static_cast<uint64_t>(node_occ_) & 0x1) << 8);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    node_occ_cntr_ = data0;
    node_occ_ = ((data0 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    node_occ_cntr_ = 0;
    node_occ_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1OccREntry") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1OccREntry") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t node_occ_cntr_;
  uint8_t node_occ_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_occ_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        assert(index_sch_l1_occ_r_entry < 288);
        offset += index_sch_l1_occ_r_entry * 0x1; // sch_l1_occ_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        assert(index_sch_l1_occ_r_entry < 288);
        offset += index_sch_l1_occ_r_entry * 0x1; // sch_l1_occ_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchL1OccREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1OccREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_occ_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_l1_occ_r_entry), 1, true, write_callback, read_callback, std::string("SchL1OccREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_l1_occ_r_entry))
    {
    }
  SchL1OccREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchL1OccREntryMutable")
    {
    }
public:
  uint8_t node_occ_cntr() { return node_occ_cntr_; }
  void node_occ_cntr(const uint8_t &v) { node_occ_cntr_=v; }
  uint8_t node_occ() { return node_occ_; }
  void node_occ(const uint8_t &v) { node_occ_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(node_occ_cntr_);
    *data0 |= ((static_cast<uint64_t>(node_occ_) & 0x1) << 8);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    node_occ_cntr_ = data0;
    node_occ_ = ((data0 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    node_occ_cntr_ = 0;
    node_occ_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1OccREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1OccREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t node_occ_cntr_;
  uint8_t node_occ_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_occ_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        assert(index_sch_l1_occ_r_entry < 288);
        offset += index_sch_l1_occ_r_entry * 0x1; // sch_l1_occ_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        assert(index_sch_l1_occ_r_entry < 288);
        offset += index_sch_l1_occ_r_entry * 0x1; // sch_l1_occ_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchL1OccREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1OccREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchL1OccREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &node_occ_cntr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ_cntr();
  }
  uint8_t &node_occ(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchL1OccREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchL1OccREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchL1OccREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchL1OccREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1OccREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchL1OccREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t node_occ_cntr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ_cntr();
  }
  void node_occ_cntr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].node_occ_cntr(v);
  }
  uint8_t node_occ(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ();
  }
  void node_occ(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].node_occ(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchL1OccREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchL1OccREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchL1OccREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchPOccREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPOccREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_occ_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_p_occ_r_entry), 1, false, write_callback, read_callback, std::string("SchPOccREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_p_occ_r_entry))
    {
    }
  SchPOccREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchPOccREntry")
    {
    }
public:
  uint8_t &node_occ_cntr() { return node_occ_cntr_; }
  uint8_t &node_occ() { return node_occ_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(node_occ_cntr_);
    *data0 |= ((static_cast<uint64_t>(node_occ_) & 0x1) << 8);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    node_occ_cntr_ = data0;
    node_occ_ = ((data0 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    node_occ_cntr_ = 0;
    node_occ_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPOccREntry") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPOccREntry") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t node_occ_cntr_;
  uint8_t node_occ_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_occ_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        assert(index_sch_p_occ_r_entry < 72);
        offset += index_sch_p_occ_r_entry * 0x1; // sch_p_occ_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        assert(index_sch_p_occ_r_entry < 72);
        offset += index_sch_p_occ_r_entry * 0x1; // sch_p_occ_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchPOccREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPOccREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_occ_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_p_occ_r_entry), 1, true, write_callback, read_callback, std::string("SchPOccREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_p_occ_r_entry))
    {
    }
  SchPOccREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchPOccREntryMutable")
    {
    }
public:
  uint8_t node_occ_cntr() { return node_occ_cntr_; }
  void node_occ_cntr(const uint8_t &v) { node_occ_cntr_=v; }
  uint8_t node_occ() { return node_occ_; }
  void node_occ(const uint8_t &v) { node_occ_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(node_occ_cntr_);
    *data0 |= ((static_cast<uint64_t>(node_occ_) & 0x1) << 8);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    node_occ_cntr_ = data0;
    node_occ_ = ((data0 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    node_occ_cntr_ = 0;
    node_occ_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPOccREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPOccREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("node_occ_cntr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_cntr_) ) + "\n";
    all_zeros &= (0 == node_occ_cntr_);
    r += indent_string + "  " + std::string("node_occ") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(node_occ_) ) + "\n";
    all_zeros &= (0 == node_occ_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t node_occ_cntr_;
  uint8_t node_occ_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_occ_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        assert(index_sch_p_occ_r_entry < 72);
        offset += index_sch_p_occ_r_entry * 0x1; // sch_p_occ_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        assert(index_sch_p_occ_r_entry < 72);
        offset += index_sch_p_occ_r_entry * 0x1; // sch_p_occ_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchPOccREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPOccREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchPOccREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &node_occ_cntr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ_cntr();
  }
  uint8_t &node_occ(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchPOccREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchPOccREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchPOccREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchPOccREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPOccREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchPOccREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t node_occ_cntr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ_cntr();
  }
  void node_occ_cntr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].node_occ_cntr(v);
  }
  uint8_t node_occ(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].node_occ();
  }
  void node_occ(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].node_occ(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchPOccREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchPOccREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchPOccREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchQueueAdvFcStatusREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueueAdvFcStatusREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_adv_fc_status_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_queue_adv_fc_status_r_entry), 1, false, write_callback, read_callback, std::string("SchQueueAdvFcStatusREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_queue_adv_fc_status_r_entry))
    {
    }
  SchQueueAdvFcStatusREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQueueAdvFcStatusREntry")
    {
    }
public:
  uint8_t &adv_fc() { return adv_fc_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(adv_fc_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    adv_fc_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    adv_fc_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueueAdvFcStatusREntry") + ":\n";
    r += indent_string + "  " + std::string("adv_fc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(adv_fc_) ) + "\n";
    all_zeros &= (0 == adv_fc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueueAdvFcStatusREntry") + ":\n";
    r += indent_string + "  " + std::string("adv_fc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(adv_fc_) ) + "\n";
    all_zeros &= (0 == adv_fc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t adv_fc_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_adv_fc_status_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        assert(index_sch_queue_adv_fc_status_r_entry < 1152);
        offset += index_sch_queue_adv_fc_status_r_entry * 0x1; // sch_queue_adv_fc_status_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        assert(index_sch_queue_adv_fc_status_r_entry < 1152);
        offset += index_sch_queue_adv_fc_status_r_entry * 0x1; // sch_queue_adv_fc_status_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueueAdvFcStatusREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueueAdvFcStatusREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_adv_fc_status_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_queue_adv_fc_status_r_entry), 1, true, write_callback, read_callback, std::string("SchQueueAdvFcStatusREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_queue_adv_fc_status_r_entry))
    {
    }
  SchQueueAdvFcStatusREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQueueAdvFcStatusREntryMutable")
    {
    }
public:
  uint8_t adv_fc() { return adv_fc_; }
  void adv_fc(const uint8_t &v) { adv_fc_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(adv_fc_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    adv_fc_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    adv_fc_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueueAdvFcStatusREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("adv_fc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(adv_fc_) ) + "\n";
    all_zeros &= (0 == adv_fc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueueAdvFcStatusREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("adv_fc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(adv_fc_) ) + "\n";
    all_zeros &= (0 == adv_fc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t adv_fc_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_adv_fc_status_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        assert(index_sch_queue_adv_fc_status_r_entry < 1152);
        offset += index_sch_queue_adv_fc_status_r_entry * 0x1; // sch_queue_adv_fc_status_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        assert(index_sch_queue_adv_fc_status_r_entry < 1152);
        offset += index_sch_queue_adv_fc_status_r_entry * 0x1; // sch_queue_adv_fc_status_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueueAdvFcStatusREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueueAdvFcStatusREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchQueueAdvFcStatusREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &adv_fc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].adv_fc();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQueueAdvFcStatusREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQueueAdvFcStatusREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQueueAdvFcStatusREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchQueueAdvFcStatusREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueueAdvFcStatusREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchQueueAdvFcStatusREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t adv_fc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].adv_fc();
  }
  void adv_fc(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].adv_fc(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQueueAdvFcStatusREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQueueAdvFcStatusREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQueueAdvFcStatusREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchQueuePfcStatusREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueuePfcStatusREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_pfc_status_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_queue_pfc_status_r_entry), 1, false, write_callback, read_callback, std::string("SchQueuePfcStatusREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_queue_pfc_status_r_entry))
    {
    }
  SchQueuePfcStatusREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQueuePfcStatusREntry")
    {
    }
public:
  uint8_t &pfc_pause() { return pfc_pause_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pfc_pause_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pfc_pause_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pfc_pause_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueuePfcStatusREntry") + ":\n";
    r += indent_string + "  " + std::string("pfc_pause") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_pause_) ) + "\n";
    all_zeros &= (0 == pfc_pause_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueuePfcStatusREntry") + ":\n";
    r += indent_string + "  " + std::string("pfc_pause") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_pause_) ) + "\n";
    all_zeros &= (0 == pfc_pause_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pfc_pause_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_pfc_status_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        assert(index_sch_queue_pfc_status_r_entry < 1152);
        offset += index_sch_queue_pfc_status_r_entry * 0x1; // sch_queue_pfc_status_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        assert(index_sch_queue_pfc_status_r_entry < 1152);
        offset += index_sch_queue_pfc_status_r_entry * 0x1; // sch_queue_pfc_status_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueuePfcStatusREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueuePfcStatusREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_pfc_status_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_queue_pfc_status_r_entry), 1, true, write_callback, read_callback, std::string("SchQueuePfcStatusREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_queue_pfc_status_r_entry))
    {
    }
  SchQueuePfcStatusREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQueuePfcStatusREntryMutable")
    {
    }
public:
  uint8_t pfc_pause() { return pfc_pause_; }
  void pfc_pause(const uint8_t &v) { pfc_pause_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pfc_pause_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pfc_pause_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pfc_pause_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueuePfcStatusREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pfc_pause") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_pause_) ) + "\n";
    all_zeros &= (0 == pfc_pause_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQueuePfcStatusREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pfc_pause") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_pause_) ) + "\n";
    all_zeros &= (0 == pfc_pause_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pfc_pause_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_queue_pfc_status_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        assert(index_sch_queue_pfc_status_r_entry < 1152);
        offset += index_sch_queue_pfc_status_r_entry * 0x1; // sch_queue_pfc_status_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        assert(index_sch_queue_pfc_status_r_entry < 1152);
        offset += index_sch_queue_pfc_status_r_entry * 0x1; // sch_queue_pfc_status_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueuePfcStatusREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueuePfcStatusREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchQueuePfcStatusREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &pfc_pause(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pfc_pause();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQueuePfcStatusREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQueuePfcStatusREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQueuePfcStatusREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class SchQueuePfcStatusREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueuePfcStatusREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchQueuePfcStatusREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t pfc_pause(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pfc_pause();
  }
  void pfc_pause(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pfc_pause(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQueuePfcStatusREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQueuePfcStatusREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQueuePfcStatusREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchQExcessbucketDynamicREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketDynamicREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_dynamic_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_q_excessbucket_dynamic_r_entry), 1, false, write_callback, read_callback, std::string("SchQExcessbucketDynamicREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_q_excessbucket_dynamic_r_entry))
    {
    }
  SchQExcessbucketDynamicREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQExcessbucketDynamicREntry")
    {
    }
public:






  uint32_t &level() { return level_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1fffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1fffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketDynamicREntry") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketDynamicREntry") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_dynamic_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        assert(index_sch_q_excessbucket_dynamic_r_entry < 1152);
        offset += index_sch_q_excessbucket_dynamic_r_entry * 0x1; // sch_q_excessbucket_dynamic_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        assert(index_sch_q_excessbucket_dynamic_r_entry < 1152);
        offset += index_sch_q_excessbucket_dynamic_r_entry * 0x1; // sch_q_excessbucket_dynamic_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketDynamicREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketDynamicREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_dynamic_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_q_excessbucket_dynamic_r_entry), 1, true, write_callback, read_callback, std::string("SchQExcessbucketDynamicREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_q_excessbucket_dynamic_r_entry))
    {
    }
  SchQExcessbucketDynamicREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQExcessbucketDynamicREntryMutable")
    {
    }
public:






  uint32_t level() { return level_; }
  void level(const uint32_t &v) { level_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1fffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1fffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketDynamicREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketDynamicREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_dynamic_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        assert(index_sch_q_excessbucket_dynamic_r_entry < 1152);
        offset += index_sch_q_excessbucket_dynamic_r_entry * 0x1; // sch_q_excessbucket_dynamic_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        assert(index_sch_q_excessbucket_dynamic_r_entry < 1152);
        offset += index_sch_q_excessbucket_dynamic_r_entry * 0x1; // sch_q_excessbucket_dynamic_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketDynamicREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketDynamicREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchQExcessbucketDynamicREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t &level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQExcessbucketDynamicREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQExcessbucketDynamicREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQExcessbucketDynamicREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchQExcessbucketDynamicREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketDynamicREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchQExcessbucketDynamicREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  void level(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].level(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQExcessbucketDynamicREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQExcessbucketDynamicREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQExcessbucketDynamicREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchQExcessbucketStaticREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketStaticREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_static_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_q_excessbucket_static_r_entry), 1, false, write_callback, read_callback, std::string("SchQExcessbucketStaticREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_q_excessbucket_static_r_entry))
    {
    }
  SchQExcessbucketStaticREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQExcessbucketStaticREntry")
    {
    }
public:





  uint8_t &pps() { return pps_; }







  uint16_t &wt() { return wt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(wt_) & 0x3ff) << 1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    wt_ = ((data0 >> 1) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    wt_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketStaticREntry") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketStaticREntry") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint16_t wt_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_static_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        assert(index_sch_q_excessbucket_static_r_entry < 1152);
        offset += index_sch_q_excessbucket_static_r_entry * 0x1; // sch_q_excessbucket_static_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        assert(index_sch_q_excessbucket_static_r_entry < 1152);
        offset += index_sch_q_excessbucket_static_r_entry * 0x1; // sch_q_excessbucket_static_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketStaticREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketStaticREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_static_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_q_excessbucket_static_r_entry), 1, true, write_callback, read_callback, std::string("SchQExcessbucketStaticREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_q_excessbucket_static_r_entry))
    {
    }
  SchQExcessbucketStaticREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQExcessbucketStaticREntryMutable")
    {
    }
public:





  uint8_t pps() { return pps_; }
  void pps(const uint8_t &v) { pps_=v; }







  uint16_t wt() { return wt_; }
  void wt(const uint16_t &v) { wt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(wt_) & 0x3ff) << 1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    wt_ = ((data0 >> 1) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    wt_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketStaticREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchQExcessbucketStaticREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint16_t wt_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_q_excessbucket_static_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        assert(index_sch_q_excessbucket_static_r_entry < 1152);
        offset += index_sch_q_excessbucket_static_r_entry * 0x1; // sch_q_excessbucket_static_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        assert(index_sch_q_excessbucket_static_r_entry < 1152);
        offset += index_sch_q_excessbucket_static_r_entry * 0x1; // sch_q_excessbucket_static_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketStaticREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketStaticREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchQExcessbucketStaticREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t &pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }







  uint16_t &wt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].wt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQExcessbucketStaticREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQExcessbucketStaticREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQExcessbucketStaticREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchQExcessbucketStaticREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketStaticREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchQExcessbucketStaticREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }
  void pps(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pps(v);
  }







  uint16_t wt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].wt();
  }
  void wt(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].wt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchQExcessbucketStaticREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchQExcessbucketStaticREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchQExcessbucketStaticREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecQMaxLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecQMaxLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMaxLbDynamicMem")
    {
    }
public:






  uint32_t &level() { return level_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMaxLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecQMaxLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMaxLbDynamicMemMutable")
    {
    }
public:






  uint32_t level() { return level_; }
  void level(const uint32_t &v) { level_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMaxLbDynamicMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbDynamicMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbDynamicMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t &level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMaxLbDynamicMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecQMaxLbDynamicMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbDynamicMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbDynamicMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  void level(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].level(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMaxLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMaxLbDynamicMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecQMaxLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem))
    {
    }
  TmSchPipeMemRspecQMaxLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMaxLbStaticMem")
    {
    }
public:





  uint8_t &pps() { return pps_; }




  uint8_t &bs_exp() { return bs_exp_; }








  uint8_t &bs_mant() { return bs_mant_; }




  uint8_t &rate_exp() { return rate_exp_; }









  uint16_t &rate_mant() { return rate_mant_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMaxLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem))
    {
    }
  TmSchPipeMemRspecQMaxLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMaxLbStaticMemMutable")
    {
    }
public:





  uint8_t pps() { return pps_; }
  void pps(const uint8_t &v) { pps_=v; }




  uint8_t bs_exp() { return bs_exp_; }
  void bs_exp(const uint8_t &v) { bs_exp_=v; }








  uint8_t bs_mant() { return bs_mant_; }
  void bs_mant(const uint8_t &v) { bs_mant_=v; }




  uint8_t rate_exp() { return rate_exp_; }
  void rate_exp(const uint8_t &v) { rate_exp_=v; }









  uint16_t rate_mant() { return rate_mant_; }
  void rate_mant(const uint16_t &v) { rate_mant_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_max_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMaxLbStaticMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbStaticMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbStaticMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t &pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }




  uint8_t &bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }








  uint8_t &bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }




  uint8_t &rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }









  uint16_t &rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMaxLbStaticMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecQMaxLbStaticMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbStaticMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbStaticMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }
  void pps(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pps(v);
  }




  uint8_t bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }
  void bs_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_exp(v);
  }








  uint8_t bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }
  void bs_mant(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_mant(v);
  }




  uint8_t rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }
  void rate_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_exp(v);
  }









  uint16_t rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  void rate_mant(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_mant(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMaxLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMaxLbStaticMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecQMinLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecQMinLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMinLbDynamicMem")
    {
    }
public:






  uint32_t &level() { return level_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMinLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecQMinLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMinLbDynamicMemMutable")
    {
    }
public:






  uint32_t level() { return level_; }
  void level(const uint32_t &v) { level_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMinLbDynamicMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbDynamicMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbDynamicMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t &level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMinLbDynamicMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecQMinLbDynamicMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbDynamicMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbDynamicMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  void level(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].level(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMinLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMinLbDynamicMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecQMinLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem))
    {
    }
  TmSchPipeMemRspecQMinLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMinLbStaticMem")
    {
    }
public:





  uint8_t &pps() { return pps_; }




  uint8_t &bs_exp() { return bs_exp_; }








  uint8_t &bs_mant() { return bs_mant_; }




  uint8_t &rate_exp() { return rate_exp_; }









  uint16_t &rate_mant() { return rate_mant_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMinLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem))
    {
    }
  TmSchPipeMemRspecQMinLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMinLbStaticMemMutable")
    {
    }
public:





  uint8_t pps() { return pps_; }
  void pps(const uint8_t &v) { pps_=v; }




  uint8_t bs_exp() { return bs_exp_; }
  void bs_exp(const uint8_t &v) { bs_exp_=v; }








  uint8_t bs_mant() { return bs_mant_; }
  void bs_mant(const uint8_t &v) { bs_mant_=v; }




  uint8_t rate_exp() { return rate_exp_; }
  void rate_exp(const uint8_t &v) { rate_exp_=v; }









  uint16_t rate_mant() { return rate_mant_; }
  void rate_mant(const uint16_t &v) { rate_mant_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem < 1152);
        offset += index_tm_sch_pipe_mem_rspec_q_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_q_min_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMinLbStaticMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbStaticMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbStaticMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t &pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }




  uint8_t &bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }








  uint8_t &bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }




  uint8_t &rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }









  uint16_t &rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMinLbStaticMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecQMinLbStaticMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbStaticMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbStaticMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }
  void pps(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pps(v);
  }




  uint8_t bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }
  void bs_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_exp(v);
  }








  uint8_t bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }
  void bs_mant(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_mant(v);
  }




  uint8_t rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }
  void rate_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_exp(v);
  }









  uint16_t rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  void rate_mant(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_mant(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecQMinLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecQMinLbStaticMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 1152;
            break;
          case 0:
            return 1152;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchL1ExcessbucketDynamicREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketDynamicREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_dynamic_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_l1_excessbucket_dynamic_r_entry), 1, false, write_callback, read_callback, std::string("SchL1ExcessbucketDynamicREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_l1_excessbucket_dynamic_r_entry))
    {
    }
  SchL1ExcessbucketDynamicREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchL1ExcessbucketDynamicREntry")
    {
    }
public:






  uint32_t &level() { return level_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1fffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1fffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketDynamicREntry") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketDynamicREntry") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_dynamic_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        assert(index_sch_l1_excessbucket_dynamic_r_entry < 288);
        offset += index_sch_l1_excessbucket_dynamic_r_entry * 0x1; // sch_l1_excessbucket_dynamic_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        assert(index_sch_l1_excessbucket_dynamic_r_entry < 288);
        offset += index_sch_l1_excessbucket_dynamic_r_entry * 0x1; // sch_l1_excessbucket_dynamic_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketDynamicREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketDynamicREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_dynamic_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_l1_excessbucket_dynamic_r_entry), 1, true, write_callback, read_callback, std::string("SchL1ExcessbucketDynamicREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_l1_excessbucket_dynamic_r_entry))
    {
    }
  SchL1ExcessbucketDynamicREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchL1ExcessbucketDynamicREntryMutable")
    {
    }
public:






  uint32_t level() { return level_; }
  void level(const uint32_t &v) { level_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1fffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1fffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketDynamicREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketDynamicREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_dynamic_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        assert(index_sch_l1_excessbucket_dynamic_r_entry < 288);
        offset += index_sch_l1_excessbucket_dynamic_r_entry * 0x1; // sch_l1_excessbucket_dynamic_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        assert(index_sch_l1_excessbucket_dynamic_r_entry < 288);
        offset += index_sch_l1_excessbucket_dynamic_r_entry * 0x1; // sch_l1_excessbucket_dynamic_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketDynamicREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketDynamicREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchL1ExcessbucketDynamicREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t &level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchL1ExcessbucketDynamicREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchL1ExcessbucketDynamicREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchL1ExcessbucketDynamicREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchL1ExcessbucketDynamicREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketDynamicREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchL1ExcessbucketDynamicREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  void level(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].level(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchL1ExcessbucketDynamicREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchL1ExcessbucketDynamicREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchL1ExcessbucketDynamicREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchL1ExcessbucketStaticREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketStaticREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_static_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_l1_excessbucket_static_r_entry), 1, false, write_callback, read_callback, std::string("SchL1ExcessbucketStaticREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_l1_excessbucket_static_r_entry))
    {
    }
  SchL1ExcessbucketStaticREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchL1ExcessbucketStaticREntry")
    {
    }
public:





  uint8_t &pps() { return pps_; }







  uint16_t &wt() { return wt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(wt_) & 0x3ff) << 1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    wt_ = ((data0 >> 1) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    wt_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketStaticREntry") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketStaticREntry") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint16_t wt_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_static_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        assert(index_sch_l1_excessbucket_static_r_entry < 288);
        offset += index_sch_l1_excessbucket_static_r_entry * 0x1; // sch_l1_excessbucket_static_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        assert(index_sch_l1_excessbucket_static_r_entry < 288);
        offset += index_sch_l1_excessbucket_static_r_entry * 0x1; // sch_l1_excessbucket_static_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketStaticREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketStaticREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_static_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_l1_excessbucket_static_r_entry), 1, true, write_callback, read_callback, std::string("SchL1ExcessbucketStaticREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_l1_excessbucket_static_r_entry))
    {
    }
  SchL1ExcessbucketStaticREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchL1ExcessbucketStaticREntryMutable")
    {
    }
public:





  uint8_t pps() { return pps_; }
  void pps(const uint8_t &v) { pps_=v; }







  uint16_t wt() { return wt_; }
  void wt(const uint16_t &v) { wt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(wt_) & 0x3ff) << 1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    wt_ = ((data0 >> 1) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    wt_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketStaticREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchL1ExcessbucketStaticREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("wt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(wt_) ) + "\n";
    all_zeros &= (0 == wt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint16_t wt_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_l1_excessbucket_static_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        assert(index_sch_l1_excessbucket_static_r_entry < 288);
        offset += index_sch_l1_excessbucket_static_r_entry * 0x1; // sch_l1_excessbucket_static_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        assert(index_sch_l1_excessbucket_static_r_entry < 288);
        offset += index_sch_l1_excessbucket_static_r_entry * 0x1; // sch_l1_excessbucket_static_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketStaticREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketStaticREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchL1ExcessbucketStaticREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t &pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }







  uint16_t &wt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].wt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchL1ExcessbucketStaticREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchL1ExcessbucketStaticREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchL1ExcessbucketStaticREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchL1ExcessbucketStaticREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketStaticREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchL1ExcessbucketStaticREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }
  void pps(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pps(v);
  }







  uint16_t wt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].wt();
  }
  void wt(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].wt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchL1ExcessbucketStaticREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchL1ExcessbucketStaticREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchL1ExcessbucketStaticREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecL1MaxLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecL1MaxLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MaxLbDynamicMem")
    {
    }
public:






  uint32_t &level() { return level_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MaxLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecL1MaxLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MaxLbDynamicMemMutable")
    {
    }
public:






  uint32_t level() { return level_; }
  void level(const uint32_t &v) { level_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MaxLbDynamicMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbDynamicMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbDynamicMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t &level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MaxLbDynamicMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecL1MaxLbDynamicMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbDynamicMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbDynamicMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  void level(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].level(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MaxLbDynamicMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecL1MaxLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem))
    {
    }
  TmSchPipeMemRspecL1MaxLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MaxLbStaticMem")
    {
    }
public:





  uint8_t &pps() { return pps_; }




  uint8_t &bs_exp() { return bs_exp_; }








  uint8_t &bs_mant() { return bs_mant_; }




  uint8_t &rate_exp() { return rate_exp_; }









  uint16_t &rate_mant() { return rate_mant_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MaxLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem))
    {
    }
  TmSchPipeMemRspecL1MaxLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MaxLbStaticMemMutable")
    {
    }
public:





  uint8_t pps() { return pps_; }
  void pps(const uint8_t &v) { pps_=v; }




  uint8_t bs_exp() { return bs_exp_; }
  void bs_exp(const uint8_t &v) { bs_exp_=v; }








  uint8_t bs_mant() { return bs_mant_; }
  void bs_mant(const uint8_t &v) { bs_mant_=v; }




  uint8_t rate_exp() { return rate_exp_; }
  void rate_exp(const uint8_t &v) { rate_exp_=v; }









  uint16_t rate_mant() { return rate_mant_; }
  void rate_mant(const uint16_t &v) { rate_mant_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_max_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_max_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MaxLbStaticMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbStaticMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbStaticMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t &pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }




  uint8_t &bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }








  uint8_t &bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }




  uint8_t &rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }









  uint16_t &rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MaxLbStaticMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecL1MaxLbStaticMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbStaticMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbStaticMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }
  void pps(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pps(v);
  }




  uint8_t bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }
  void bs_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_exp(v);
  }








  uint8_t bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }
  void bs_mant(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_mant(v);
  }




  uint8_t rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }
  void rate_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_exp(v);
  }









  uint16_t rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  void rate_mant(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_mant(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MaxLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MaxLbStaticMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecL1MinLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecL1MinLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MinLbDynamicMem")
    {
    }
public:






  uint32_t &level() { return level_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMem") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MinLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem))
    {
    }
  TmSchPipeMemRspecL1MinLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MinLbDynamicMemMutable")
    {
    }
public:






  uint32_t level() { return level_; }
  void level(const uint32_t &v) { level_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMemMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_dynamic_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MinLbDynamicMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbDynamicMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbDynamicMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t &level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MinLbDynamicMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class TmSchPipeMemRspecL1MinLbDynamicMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbDynamicMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbDynamicMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  void level(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].level(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MinLbDynamicMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MinLbDynamicMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecL1MinLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem), 1, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem))
    {
    }
  TmSchPipeMemRspecL1MinLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MinLbStaticMem")
    {
    }
public:





  uint8_t &pps() { return pps_; }




  uint8_t &bs_exp() { return bs_exp_; }








  uint8_t &bs_mant() { return bs_mant_; }




  uint8_t &rate_exp() { return rate_exp_; }









  uint16_t &rate_mant() { return rate_mant_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMem") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MinLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem), 1, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem))
    {
    }
  TmSchPipeMemRspecL1MinLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MinLbStaticMemMutable")
    {
    }
public:





  uint8_t pps() { return pps_; }
  void pps(const uint8_t &v) { pps_=v; }




  uint8_t bs_exp() { return bs_exp_; }
  void bs_exp(const uint8_t &v) { bs_exp_=v; }








  uint8_t bs_mant() { return bs_mant_; }
  void bs_mant(const uint8_t &v) { bs_mant_=v; }




  uint8_t rate_exp() { return rate_exp_; }
  void rate_exp(const uint8_t &v) { rate_exp_=v; }









  uint16_t rate_mant() { return rate_mant_; }
  void rate_mant(const uint16_t &v) { rate_mant_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMemMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_static_mem[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        assert(index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem < 288);
        offset += index_tm_sch_pipe_mem_rspec_l1_min_lb_static_mem * 0x1; // tm_sch_pipe_mem_rspec_l1_min_lb_static_mem[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MinLbStaticMemArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbStaticMemArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbStaticMemArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t &pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }




  uint8_t &bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }








  uint8_t &bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }




  uint8_t &rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }









  uint16_t &rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMemArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MinLbStaticMem> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class TmSchPipeMemRspecL1MinLbStaticMemArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbStaticMemArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbStaticMemArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }
  void pps(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pps(v);
  }




  uint8_t bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }
  void bs_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_exp(v);
  }








  uint8_t bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }
  void bs_mant(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_mant(v);
  }




  uint8_t rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }
  void rate_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_exp(v);
  }









  uint16_t rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  void rate_mant(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_mant(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecL1MinLbStaticMemArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecL1MinLbStaticMemMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 288;
            break;
          case 0:
            return 288;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchPLeakybucketDynamicREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketDynamicREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_dynamic_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_p_leakybucket_dynamic_r_entry), 1, false, write_callback, read_callback, std::string("SchPLeakybucketDynamicREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_p_leakybucket_dynamic_r_entry))
    {
    }
  SchPLeakybucketDynamicREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchPLeakybucketDynamicREntry")
    {
    }
public:






  uint32_t &level() { return level_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketDynamicREntry") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketDynamicREntry") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_dynamic_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        assert(index_sch_p_leakybucket_dynamic_r_entry < 72);
        offset += index_sch_p_leakybucket_dynamic_r_entry * 0x1; // sch_p_leakybucket_dynamic_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        assert(index_sch_p_leakybucket_dynamic_r_entry < 72);
        offset += index_sch_p_leakybucket_dynamic_r_entry * 0x1; // sch_p_leakybucket_dynamic_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchPLeakybucketDynamicREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketDynamicREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_dynamic_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_p_leakybucket_dynamic_r_entry), 1, true, write_callback, read_callback, std::string("SchPLeakybucketDynamicREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_p_leakybucket_dynamic_r_entry))
    {
    }
  SchPLeakybucketDynamicREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchPLeakybucketDynamicREntryMutable")
    {
    }
public:






  uint32_t level() { return level_; }
  void level(const uint32_t &v) { level_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(level_) & 0x1ffffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    level_ = (data0 & 0x1ffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    level_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketDynamicREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketDynamicREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("level") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(level_) ) + "\n";
    all_zeros &= (0 == level_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t level_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_dynamic_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        assert(index_sch_p_leakybucket_dynamic_r_entry < 72);
        offset += index_sch_p_leakybucket_dynamic_r_entry * 0x1; // sch_p_leakybucket_dynamic_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        assert(index_sch_p_leakybucket_dynamic_r_entry < 72);
        offset += index_sch_p_leakybucket_dynamic_r_entry * 0x1; // sch_p_leakybucket_dynamic_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchPLeakybucketDynamicREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketDynamicREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchPLeakybucketDynamicREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t &level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchPLeakybucketDynamicREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchPLeakybucketDynamicREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchPLeakybucketDynamicREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class SchPLeakybucketDynamicREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketDynamicREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchPLeakybucketDynamicREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:






  uint32_t level(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].level();
  }
  void level(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].level(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchPLeakybucketDynamicREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchPLeakybucketDynamicREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchPLeakybucketDynamicREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class SchPLeakybucketStaticREntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketStaticREntry(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_static_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_p_leakybucket_static_r_entry), 1, false, write_callback, read_callback, std::string("SchPLeakybucketStaticREntry")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_p_leakybucket_static_r_entry))
    {
    }
  SchPLeakybucketStaticREntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchPLeakybucketStaticREntry")
    {
    }
public:





  uint8_t &pps() { return pps_; }




  uint8_t &bs_exp() { return bs_exp_; }








  uint8_t &bs_mant() { return bs_mant_; }




  uint8_t &rate_exp() { return rate_exp_; }









  uint16_t &rate_mant() { return rate_mant_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketStaticREntry") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketStaticREntry") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_static_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        assert(index_sch_p_leakybucket_static_r_entry < 72);
        offset += index_sch_p_leakybucket_static_r_entry * 0x1; // sch_p_leakybucket_static_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        assert(index_sch_p_leakybucket_static_r_entry < 72);
        offset += index_sch_p_leakybucket_static_r_entry * 0x1; // sch_p_leakybucket_static_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class SchPLeakybucketStaticREntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketStaticREntryMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_static_r_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, index_sch_p_leakybucket_static_r_entry), 1, true, write_callback, read_callback, std::string("SchPLeakybucketStaticREntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_sch_p_leakybucket_static_r_entry))
    {
    }
  SchPLeakybucketStaticREntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchPLeakybucketStaticREntryMutable")
    {
    }
public:





  uint8_t pps() { return pps_; }
  void pps(const uint8_t &v) { pps_=v; }




  uint8_t bs_exp() { return bs_exp_; }
  void bs_exp(const uint8_t &v) { bs_exp_=v; }








  uint8_t bs_mant() { return bs_mant_; }
  void bs_mant(const uint8_t &v) { bs_mant_=v; }




  uint8_t rate_exp() { return rate_exp_; }
  void rate_exp(const uint8_t &v) { rate_exp_=v; }









  uint16_t rate_mant() { return rate_mant_; }
  void rate_mant(const uint16_t &v) { rate_mant_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pps_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(bs_exp_) & 0xf) << 1);
    *data0 |= (static_cast<uint64_t>(bs_mant_) << 5);
    *data0 |= ((static_cast<uint64_t>(rate_exp_) & 0xf) << 13);
    *data0 |= ((static_cast<uint64_t>(rate_mant_) & 0xfff) << 17);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pps_ = (data0 & 0x1);
    bs_exp_ = ((data0 >> 1) & 0xf);
    bs_mant_ = (data0 >> 5);
    rate_exp_ = ((data0 >> 13) & 0xf);
    rate_mant_ = ((data0 >> 17) & 0xfff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pps_ = 0x0;
    bs_exp_ = 0x7;
    bs_mant_ = 0xf;
    rate_exp_ = 0x0;
    rate_mant_ = 0xfff;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketStaticREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("SchPLeakybucketStaticREntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pps") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pps_) ) + "\n";
    all_zeros &= (0 == pps_);
    r += indent_string + "  " + std::string("bs_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_exp_) ) + "\n";
    all_zeros &= (0 == bs_exp_);
    r += indent_string + "  " + std::string("bs_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(bs_mant_) ) + "\n";
    all_zeros &= (0 == bs_mant_);
    r += indent_string + "  " + std::string("rate_exp") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_exp_) ) + "\n";
    all_zeros &= (0 == rate_exp_);
    r += indent_string + "  " + std::string("rate_mant") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rate_mant_) ) + "\n";
    all_zeros &= (0 == rate_mant_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pps_;
  uint8_t bs_exp_;
  uint8_t bs_mant_;
  uint8_t rate_exp_;
  uint16_t rate_mant_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int index_sch_p_leakybucket_static_r_entry
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        assert(index_sch_p_leakybucket_static_r_entry < 72);
        offset += index_sch_p_leakybucket_static_r_entry * 0x1; // sch_p_leakybucket_static_r_entry[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        assert(index_sch_p_leakybucket_static_r_entry < 72);
        offset += index_sch_p_leakybucket_static_r_entry * 0x1; // sch_p_leakybucket_static_r_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class SchPLeakybucketStaticREntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketStaticREntryArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("SchPLeakybucketStaticREntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t &pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }




  uint8_t &bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }








  uint8_t &bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }




  uint8_t &rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }









  uint16_t &rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchPLeakybucketStaticREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchPLeakybucketStaticREntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchPLeakybucketStaticREntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class SchPLeakybucketStaticREntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketStaticREntryArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1 * ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("SchPLeakybucketStaticREntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec, 0))
    {
    }
public:





  uint8_t pps(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pps();
  }
  void pps(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pps(v);
  }




  uint8_t bs_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_exp();
  }
  void bs_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_exp(v);
  }








  uint8_t bs_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].bs_mant();
  }
  void bs_mant(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].bs_mant(v);
  }




  uint8_t rate_exp(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_exp();
  }
  void rate_exp(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_exp(v);
  }









  uint16_t rate_mant(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rate_mant();
  }
  void rate_mant(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rate_mant(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("SchPLeakybucketStaticREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("SchPLeakybucketStaticREntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<SchPLeakybucketStaticREntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 72;
            break;
          case 0:
            return 72;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmSchPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspec(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmSchPipeMemRspec")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspec")
    {
    }
public:








  SchPLeakybucketStaticREntry &port_max_lb_static_mem(int j0) { return port_max_lb_static_mem_[j0]; }










  SchPLeakybucketDynamicREntry &port_max_lb_dynamic_mem(int j0) { return port_max_lb_dynamic_mem_[j0]; }








  TmSchPipeMemRspecL1MinLbStaticMem &l1_min_lb_static_mem(int j0) { return l1_min_lb_static_mem_[j0]; }










  TmSchPipeMemRspecL1MinLbDynamicMem &l1_min_lb_dynamic_mem(int j0) { return l1_min_lb_dynamic_mem_[j0]; }








  TmSchPipeMemRspecL1MaxLbStaticMem &l1_max_lb_static_mem(int j0) { return l1_max_lb_static_mem_[j0]; }










  TmSchPipeMemRspecL1MaxLbDynamicMem &l1_max_lb_dynamic_mem(int j0) { return l1_max_lb_dynamic_mem_[j0]; }










  SchL1ExcessbucketStaticREntry &l1_exc_static_mem(int j0) { return l1_exc_static_mem_[j0]; }










  SchL1ExcessbucketDynamicREntry &l1_exc_dynamic_mem(int j0) { return l1_exc_dynamic_mem_[j0]; }








  TmSchPipeMemRspecQMinLbStaticMem &q_min_lb_static_mem(int j0) { return q_min_lb_static_mem_[j0]; }










  TmSchPipeMemRspecQMinLbDynamicMem &q_min_lb_dynamic_mem(int j0) { return q_min_lb_dynamic_mem_[j0]; }








  TmSchPipeMemRspecQMaxLbStaticMem &q_max_lb_static_mem(int j0) { return q_max_lb_static_mem_[j0]; }










  TmSchPipeMemRspecQMaxLbDynamicMem &q_max_lb_dynamic_mem(int j0) { return q_max_lb_dynamic_mem_[j0]; }










  SchQExcessbucketStaticREntry &q_exc_static_mem(int j0) { return q_exc_static_mem_[j0]; }










  SchQExcessbucketDynamicREntry &q_exc_dynamic_mem(int j0) { return q_exc_dynamic_mem_[j0]; }






  SchQueuePfcStatusREntry &q_pfc_status_mem(int j0) { return q_pfc_status_mem_[j0]; }






  SchQueueAdvFcStatusREntry &q_adv_fc_status_mem(int j0) { return q_adv_fc_status_mem_[j0]; }






  SchPOccREntry &p_occ_mem(int j0) { return p_occ_mem_[j0]; }






  SchL1OccREntry &l1_occ_mem(int j0) { return l1_occ_mem_[j0]; }






  SchQOccREntry &q_occ_mem(int j0) { return q_occ_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      port_max_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      port_max_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_min_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_min_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_max_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_max_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_exc_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_exc_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_min_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_min_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_max_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_max_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_exc_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_exc_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_pfc_status_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_adv_fc_status_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      p_occ_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_occ_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_occ_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      port_max_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      port_max_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_min_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_min_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_max_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_max_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_exc_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_exc_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_min_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_min_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_max_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_max_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_exc_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_exc_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_pfc_status_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_adv_fc_status_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      p_occ_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_occ_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_occ_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : port_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : port_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_min_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_min_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_exc_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_exc_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_min_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_min_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_exc_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_exc_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_pfc_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_adv_fc_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : p_occ_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_occ_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_occ_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += port_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += port_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_min_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_min_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_exc_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_exc_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_min_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_min_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_exc_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_exc_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_pfc_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_adv_fc_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += p_occ_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_occ_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_occ_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_min_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_min_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_exc_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_exc_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_min_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_min_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_exc_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_exc_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_pfc_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_adv_fc_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += p_occ_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_occ_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_occ_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< SchPLeakybucketStaticREntry, 72 > port_max_lb_static_mem_;
  std::array< SchPLeakybucketDynamicREntry, 72 > port_max_lb_dynamic_mem_;
  std::array< TmSchPipeMemRspecL1MinLbStaticMem, 288 > l1_min_lb_static_mem_;
  std::array< TmSchPipeMemRspecL1MinLbDynamicMem, 288 > l1_min_lb_dynamic_mem_;
  std::array< TmSchPipeMemRspecL1MaxLbStaticMem, 288 > l1_max_lb_static_mem_;
  std::array< TmSchPipeMemRspecL1MaxLbDynamicMem, 288 > l1_max_lb_dynamic_mem_;
  std::array< SchL1ExcessbucketStaticREntry, 288 > l1_exc_static_mem_;
  std::array< SchL1ExcessbucketDynamicREntry, 288 > l1_exc_dynamic_mem_;
  std::array< TmSchPipeMemRspecQMinLbStaticMem, 1152 > q_min_lb_static_mem_;
  std::array< TmSchPipeMemRspecQMinLbDynamicMem, 1152 > q_min_lb_dynamic_mem_;
  std::array< TmSchPipeMemRspecQMaxLbStaticMem, 1152 > q_max_lb_static_mem_;
  std::array< TmSchPipeMemRspecQMaxLbDynamicMem, 1152 > q_max_lb_dynamic_mem_;
  std::array< SchQExcessbucketStaticREntry, 1152 > q_exc_static_mem_;
  std::array< SchQExcessbucketDynamicREntry, 1152 > q_exc_dynamic_mem_;
  std::array< SchQueuePfcStatusREntry, 1152 > q_pfc_status_mem_;
  std::array< SchQueueAdvFcStatusREntry, 1152 > q_adv_fc_status_mem_;
  std::array< SchPOccREntry, 72 > p_occ_mem_;
  std::array< SchL1OccREntry, 288 > l1_occ_mem_;
  std::array< SchQOccREntry, 1152 > q_occ_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmSchPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmSchPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecMutable")
    {
    }
public:








  SchPLeakybucketStaticREntryMutable &port_max_lb_static_mem(int j0) { return port_max_lb_static_mem_[j0]; }










  SchPLeakybucketDynamicREntryMutable &port_max_lb_dynamic_mem(int j0) { return port_max_lb_dynamic_mem_[j0]; }








  TmSchPipeMemRspecL1MinLbStaticMemMutable &l1_min_lb_static_mem(int j0) { return l1_min_lb_static_mem_[j0]; }










  TmSchPipeMemRspecL1MinLbDynamicMemMutable &l1_min_lb_dynamic_mem(int j0) { return l1_min_lb_dynamic_mem_[j0]; }








  TmSchPipeMemRspecL1MaxLbStaticMemMutable &l1_max_lb_static_mem(int j0) { return l1_max_lb_static_mem_[j0]; }










  TmSchPipeMemRspecL1MaxLbDynamicMemMutable &l1_max_lb_dynamic_mem(int j0) { return l1_max_lb_dynamic_mem_[j0]; }










  SchL1ExcessbucketStaticREntryMutable &l1_exc_static_mem(int j0) { return l1_exc_static_mem_[j0]; }










  SchL1ExcessbucketDynamicREntryMutable &l1_exc_dynamic_mem(int j0) { return l1_exc_dynamic_mem_[j0]; }








  TmSchPipeMemRspecQMinLbStaticMemMutable &q_min_lb_static_mem(int j0) { return q_min_lb_static_mem_[j0]; }










  TmSchPipeMemRspecQMinLbDynamicMemMutable &q_min_lb_dynamic_mem(int j0) { return q_min_lb_dynamic_mem_[j0]; }








  TmSchPipeMemRspecQMaxLbStaticMemMutable &q_max_lb_static_mem(int j0) { return q_max_lb_static_mem_[j0]; }










  TmSchPipeMemRspecQMaxLbDynamicMemMutable &q_max_lb_dynamic_mem(int j0) { return q_max_lb_dynamic_mem_[j0]; }










  SchQExcessbucketStaticREntryMutable &q_exc_static_mem(int j0) { return q_exc_static_mem_[j0]; }










  SchQExcessbucketDynamicREntryMutable &q_exc_dynamic_mem(int j0) { return q_exc_dynamic_mem_[j0]; }






  SchQueuePfcStatusREntryMutable &q_pfc_status_mem(int j0) { return q_pfc_status_mem_[j0]; }






  SchQueueAdvFcStatusREntryMutable &q_adv_fc_status_mem(int j0) { return q_adv_fc_status_mem_[j0]; }






  SchPOccREntryMutable &p_occ_mem(int j0) { return p_occ_mem_[j0]; }






  SchL1OccREntryMutable &l1_occ_mem(int j0) { return l1_occ_mem_[j0]; }






  SchQOccREntryMutable &q_occ_mem(int j0) { return q_occ_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      port_max_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      port_max_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_min_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_min_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_max_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_max_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_exc_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_exc_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_min_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_min_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_max_lb_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_max_lb_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_exc_static_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_exc_dynamic_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_pfc_status_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_adv_fc_status_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      p_occ_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      l1_occ_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      q_occ_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      port_max_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      port_max_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_min_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_min_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_max_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_max_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_exc_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_exc_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_min_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_min_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_max_lb_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_max_lb_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_exc_static_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_exc_dynamic_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_pfc_status_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_adv_fc_status_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      p_occ_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      l1_occ_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      q_occ_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : port_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : port_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_min_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_min_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_exc_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_exc_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_min_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_min_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_exc_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_exc_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_pfc_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_adv_fc_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : p_occ_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_occ_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_occ_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += port_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += port_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_min_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_min_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_exc_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_exc_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_min_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_min_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_exc_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_exc_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_pfc_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_adv_fc_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += p_occ_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += l1_occ_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += q_occ_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_min_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_min_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_exc_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_exc_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_min_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_min_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_exc_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_exc_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_pfc_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_adv_fc_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += p_occ_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_occ_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += q_occ_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< SchPLeakybucketStaticREntryMutable, 72 > port_max_lb_static_mem_;
  std::array< SchPLeakybucketDynamicREntryMutable, 72 > port_max_lb_dynamic_mem_;
  std::array< TmSchPipeMemRspecL1MinLbStaticMemMutable, 288 > l1_min_lb_static_mem_;
  std::array< TmSchPipeMemRspecL1MinLbDynamicMemMutable, 288 > l1_min_lb_dynamic_mem_;
  std::array< TmSchPipeMemRspecL1MaxLbStaticMemMutable, 288 > l1_max_lb_static_mem_;
  std::array< TmSchPipeMemRspecL1MaxLbDynamicMemMutable, 288 > l1_max_lb_dynamic_mem_;
  std::array< SchL1ExcessbucketStaticREntryMutable, 288 > l1_exc_static_mem_;
  std::array< SchL1ExcessbucketDynamicREntryMutable, 288 > l1_exc_dynamic_mem_;
  std::array< TmSchPipeMemRspecQMinLbStaticMemMutable, 1152 > q_min_lb_static_mem_;
  std::array< TmSchPipeMemRspecQMinLbDynamicMemMutable, 1152 > q_min_lb_dynamic_mem_;
  std::array< TmSchPipeMemRspecQMaxLbStaticMemMutable, 1152 > q_max_lb_static_mem_;
  std::array< TmSchPipeMemRspecQMaxLbDynamicMemMutable, 1152 > q_max_lb_dynamic_mem_;
  std::array< SchQExcessbucketStaticREntryMutable, 1152 > q_exc_static_mem_;
  std::array< SchQExcessbucketDynamicREntryMutable, 1152 > q_exc_dynamic_mem_;
  std::array< SchQueuePfcStatusREntryMutable, 1152 > q_pfc_status_mem_;
  std::array< SchQueueAdvFcStatusREntryMutable, 1152 > q_adv_fc_status_mem_;
  std::array< SchPOccREntryMutable, 72 > p_occ_mem_;
  std::array< SchL1OccREntryMutable, 288 > l1_occ_mem_;
  std::array< SchQOccREntryMutable, 1152 > q_occ_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmSchPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 268435456 * ArraySize(selector_tm_top_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, 0))
    {
    }
public:








  SchPLeakybucketStaticREntry &port_max_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_static_mem(j0);
  }










  SchPLeakybucketDynamicREntry &port_max_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_dynamic_mem(j0);
  }








  TmSchPipeMemRspecL1MinLbStaticMem &l1_min_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_static_mem(j0);
  }










  TmSchPipeMemRspecL1MinLbDynamicMem &l1_min_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_dynamic_mem(j0);
  }








  TmSchPipeMemRspecL1MaxLbStaticMem &l1_max_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_static_mem(j0);
  }










  TmSchPipeMemRspecL1MaxLbDynamicMem &l1_max_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_dynamic_mem(j0);
  }










  SchL1ExcessbucketStaticREntry &l1_exc_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_static_mem(j0);
  }










  SchL1ExcessbucketDynamicREntry &l1_exc_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_dynamic_mem(j0);
  }








  TmSchPipeMemRspecQMinLbStaticMem &q_min_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_static_mem(j0);
  }










  TmSchPipeMemRspecQMinLbDynamicMem &q_min_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_dynamic_mem(j0);
  }








  TmSchPipeMemRspecQMaxLbStaticMem &q_max_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_static_mem(j0);
  }










  TmSchPipeMemRspecQMaxLbDynamicMem &q_max_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_dynamic_mem(j0);
  }










  SchQExcessbucketStaticREntry &q_exc_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_static_mem(j0);
  }










  SchQExcessbucketDynamicREntry &q_exc_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_dynamic_mem(j0);
  }






  SchQueuePfcStatusREntry &q_pfc_status_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_pfc_status_mem(j0);
  }






  SchQueueAdvFcStatusREntry &q_adv_fc_status_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_adv_fc_status_mem(j0);
  }






  SchPOccREntry &p_occ_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].p_occ_mem(j0);
  }






  SchL1OccREntry &l1_occ_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_occ_mem(j0);
  }






  SchQOccREntry &q_occ_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_occ_mem(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmSchPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 268435456 * ArraySize(selector_tm_top_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, 0))
    {
    }
public:








  SchPLeakybucketStaticREntryMutable &port_max_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_static_mem(j0);
  }










  SchPLeakybucketDynamicREntryMutable &port_max_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_dynamic_mem(j0);
  }








  TmSchPipeMemRspecL1MinLbStaticMemMutable &l1_min_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_static_mem(j0);
  }










  TmSchPipeMemRspecL1MinLbDynamicMemMutable &l1_min_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_dynamic_mem(j0);
  }








  TmSchPipeMemRspecL1MaxLbStaticMemMutable &l1_max_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_static_mem(j0);
  }










  TmSchPipeMemRspecL1MaxLbDynamicMemMutable &l1_max_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_dynamic_mem(j0);
  }










  SchL1ExcessbucketStaticREntryMutable &l1_exc_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_static_mem(j0);
  }










  SchL1ExcessbucketDynamicREntryMutable &l1_exc_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_dynamic_mem(j0);
  }








  TmSchPipeMemRspecQMinLbStaticMemMutable &q_min_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_static_mem(j0);
  }










  TmSchPipeMemRspecQMinLbDynamicMemMutable &q_min_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_dynamic_mem(j0);
  }








  TmSchPipeMemRspecQMaxLbStaticMemMutable &q_max_lb_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_static_mem(j0);
  }










  TmSchPipeMemRspecQMaxLbDynamicMemMutable &q_max_lb_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_dynamic_mem(j0);
  }










  SchQExcessbucketStaticREntryMutable &q_exc_static_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_static_mem(j0);
  }










  SchQExcessbucketDynamicREntryMutable &q_exc_dynamic_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_dynamic_mem(j0);
  }






  SchQueuePfcStatusREntryMutable &q_pfc_status_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_pfc_status_mem(j0);
  }






  SchQueueAdvFcStatusREntryMutable &q_adv_fc_status_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_adv_fc_status_mem(j0);
  }






  SchPOccREntryMutable &p_occ_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].p_occ_mem(j0);
  }






  SchL1OccREntryMutable &l1_occ_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_occ_mem(j0);
  }






  SchQOccREntryMutable &q_occ_mem(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_occ_mem(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmSchMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchMemTopRspec(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 8589934592, false, write_callback, read_callback, std::string("TmSchMemTopRspec")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec))
    {
    }
  TmSchMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchMemTopRspec")
    {
    }
public:







  TmSchPipeMemRspec &sch_pipe_mem(int j0) { return sch_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      sch_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      sch_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : sch_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += sch_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<2;++a0) {
      r += sch_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmSchPipeMemRspec, 2 > sch_pipe_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmSchMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchMemTopRspecMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 8589934592, true, write_callback, read_callback, std::string("TmSchMemTopRspecMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec))
    {
    }
  TmSchMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchMemTopRspecMutable")
    {
    }
public:







  TmSchPipeMemRspecMutable &sch_pipe_mem(int j0) { return sch_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      sch_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      sch_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : sch_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += sch_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<2;++a0) {
      r += sch_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmSchPipeMemRspecMutable, 2 > sch_pipe_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};










class QacQidMappingEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQidMappingEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_qid_mapping_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_qid_mapping_entry), 1, false, write_callback, read_callback, std::string("QacQidMappingEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_qid_mapping_entry))
    {
    }
  QacQidMappingEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQidMappingEntry")
    {
    }
public:
  uint8_t &qid_mid0() { return qid_mid0_; }
  uint8_t &qid_mid1() { return qid_mid1_; }
  uint8_t &qid_mid2() { return qid_mid2_; }
  uint8_t &qid_mid3() { return qid_mid3_; }
  uint8_t &qid_mid4() { return qid_mid4_; }
  uint8_t &qid_mid5() { return qid_mid5_; }
  uint8_t &qid_mid6() { return qid_mid6_; }
  uint8_t &qid_mid7() { return qid_mid7_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(qid_mid0_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(qid_mid1_) & 0x1f) << 5);
    *data0 |= ((static_cast<uint64_t>(qid_mid2_) & 0x1f) << 10);
    *data0 |= ((static_cast<uint64_t>(qid_mid3_) & 0x1f) << 15);
    *data0 |= ((static_cast<uint64_t>(qid_mid4_) & 0x1f) << 20);
    *data0 |= ((static_cast<uint64_t>(qid_mid5_) & 0x1f) << 25);
    *data0 |= ((static_cast<uint64_t>(qid_mid6_) & 0x1f) << 30);
    *data0 |= ((static_cast<uint64_t>(qid_mid7_) & 0x1f) << 35);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    qid_mid0_ = (data0 & 0x1f);
    qid_mid1_ = ((data0 >> 5) & 0x1f);
    qid_mid2_ = ((data0 >> 10) & 0x1f);
    qid_mid3_ = ((data0 >> 15) & 0x1f);
    qid_mid4_ = ((data0 >> 20) & 0x1f);
    qid_mid5_ = ((data0 >> 25) & 0x1f);
    qid_mid6_ = ((data0 >> 30) & 0x1f);
    qid_mid7_ = ((data0 >> 35) & 0x1f);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    qid_mid0_ = 0;
    qid_mid1_ = 0;
    qid_mid2_ = 0;
    qid_mid3_ = 0;
    qid_mid4_ = 0;
    qid_mid5_ = 0;
    qid_mid6_ = 0;
    qid_mid7_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQidMappingEntry") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQidMappingEntry") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t qid_mid0_;
  uint8_t qid_mid1_;
  uint8_t qid_mid2_;
  uint8_t qid_mid3_;
  uint8_t qid_mid4_;
  uint8_t qid_mid5_;
  uint8_t qid_mid6_;
  uint8_t qid_mid7_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_qid_mapping_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3600; // to get to csr_memory_qac_qid_mapping
    assert(index_qac_qid_mapping_entry < 288);
    offset += index_qac_qid_mapping_entry * 0x1; // qac_qid_mapping_entry[]
    return offset;
  }

};










class QacQidMappingEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQidMappingEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_qid_mapping_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_qid_mapping_entry), 1, true, write_callback, read_callback, std::string("QacQidMappingEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_qid_mapping_entry))
    {
    }
  QacQidMappingEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQidMappingEntryMutable")
    {
    }
public:
  uint8_t qid_mid0() { return qid_mid0_; }
  void qid_mid0(const uint8_t &v) { qid_mid0_=v; }
  uint8_t qid_mid1() { return qid_mid1_; }
  void qid_mid1(const uint8_t &v) { qid_mid1_=v; }
  uint8_t qid_mid2() { return qid_mid2_; }
  void qid_mid2(const uint8_t &v) { qid_mid2_=v; }
  uint8_t qid_mid3() { return qid_mid3_; }
  void qid_mid3(const uint8_t &v) { qid_mid3_=v; }
  uint8_t qid_mid4() { return qid_mid4_; }
  void qid_mid4(const uint8_t &v) { qid_mid4_=v; }
  uint8_t qid_mid5() { return qid_mid5_; }
  void qid_mid5(const uint8_t &v) { qid_mid5_=v; }
  uint8_t qid_mid6() { return qid_mid6_; }
  void qid_mid6(const uint8_t &v) { qid_mid6_=v; }
  uint8_t qid_mid7() { return qid_mid7_; }
  void qid_mid7(const uint8_t &v) { qid_mid7_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(qid_mid0_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(qid_mid1_) & 0x1f) << 5);
    *data0 |= ((static_cast<uint64_t>(qid_mid2_) & 0x1f) << 10);
    *data0 |= ((static_cast<uint64_t>(qid_mid3_) & 0x1f) << 15);
    *data0 |= ((static_cast<uint64_t>(qid_mid4_) & 0x1f) << 20);
    *data0 |= ((static_cast<uint64_t>(qid_mid5_) & 0x1f) << 25);
    *data0 |= ((static_cast<uint64_t>(qid_mid6_) & 0x1f) << 30);
    *data0 |= ((static_cast<uint64_t>(qid_mid7_) & 0x1f) << 35);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    qid_mid0_ = (data0 & 0x1f);
    qid_mid1_ = ((data0 >> 5) & 0x1f);
    qid_mid2_ = ((data0 >> 10) & 0x1f);
    qid_mid3_ = ((data0 >> 15) & 0x1f);
    qid_mid4_ = ((data0 >> 20) & 0x1f);
    qid_mid5_ = ((data0 >> 25) & 0x1f);
    qid_mid6_ = ((data0 >> 30) & 0x1f);
    qid_mid7_ = ((data0 >> 35) & 0x1f);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    qid_mid0_ = 0;
    qid_mid1_ = 0;
    qid_mid2_ = 0;
    qid_mid3_ = 0;
    qid_mid4_ = 0;
    qid_mid5_ = 0;
    qid_mid6_ = 0;
    qid_mid7_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQidMappingEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQidMappingEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t qid_mid0_;
  uint8_t qid_mid1_;
  uint8_t qid_mid2_;
  uint8_t qid_mid3_;
  uint8_t qid_mid4_;
  uint8_t qid_mid5_;
  uint8_t qid_mid6_;
  uint8_t qid_mid7_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_qid_mapping_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3600; // to get to csr_memory_qac_qid_mapping
    assert(index_qac_qid_mapping_entry < 288);
    offset += index_qac_qid_mapping_entry * 0x1; // qac_qid_mapping_entry[]
    return offset;
  }

};










class QacQidMappingEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQidMappingEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacQidMappingEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &qid_mid0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid0();
  }
  uint8_t &qid_mid1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid1();
  }
  uint8_t &qid_mid2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid2();
  }
  uint8_t &qid_mid3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid3();
  }
  uint8_t &qid_mid4(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid4();
  }
  uint8_t &qid_mid5(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid5();
  }
  uint8_t &qid_mid6(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid6();
  }
  uint8_t &qid_mid7(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid7();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQidMappingEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQidMappingEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQidMappingEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3600; // to get to csr_memory_qac_qid_mapping
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 288;
        break;
      case 0:
        return 288;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 288;
        break;
      case 0:
        return 288;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class QacQidMappingEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQidMappingEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacQidMappingEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t qid_mid0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid0();
  }
  void qid_mid0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid0(v);
  }
  uint8_t qid_mid1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid1();
  }
  void qid_mid1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid1(v);
  }
  uint8_t qid_mid2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid2();
  }
  void qid_mid2(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid2(v);
  }
  uint8_t qid_mid3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid3();
  }
  void qid_mid3(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid3(v);
  }
  uint8_t qid_mid4(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid4();
  }
  void qid_mid4(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid4(v);
  }
  uint8_t qid_mid5(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid5();
  }
  void qid_mid5(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid5(v);
  }
  uint8_t qid_mid6(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid6();
  }
  void qid_mid6(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid6(v);
  }
  uint8_t qid_mid7(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid7();
  }
  void qid_mid7(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid7(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQidMappingEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQidMappingEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQidMappingEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3600; // to get to csr_memory_qac_qid_mapping
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 288;
        break;
      case 0:
        return 288;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 288;
        break;
      case 0:
        return 288;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class QacDropCountQueueEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountQueueEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_queue_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_drop_count_queue_entry), 1, false, write_callback, read_callback, std::string("QacDropCountQueueEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_drop_count_queue_entry))
    {
    }
  QacDropCountQueueEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacDropCountQueueEntry")
    {
    }
public:
  uint64_t &count() { return count_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(count_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    count_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    count_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountQueueEntry") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountQueueEntry") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_queue_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3000; // to get to csr_memory_qac_drop_count_queue
    assert(index_qac_drop_count_queue_entry < 1152);
    offset += index_qac_drop_count_queue_entry * 0x1; // qac_drop_count_queue_entry[]
    return offset;
  }

};








class QacDropCountQueueEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountQueueEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_queue_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_drop_count_queue_entry), 1, true, write_callback, read_callback, std::string("QacDropCountQueueEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_drop_count_queue_entry))
    {
    }
  QacDropCountQueueEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacDropCountQueueEntryMutable")
    {
    }
public:
  uint64_t count() { return count_; }
  void count(const uint64_t &v) { count_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(count_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    count_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    count_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountQueueEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountQueueEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_queue_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3000; // to get to csr_memory_qac_drop_count_queue
    assert(index_qac_drop_count_queue_entry < 1152);
    offset += index_qac_drop_count_queue_entry * 0x1; // qac_drop_count_queue_entry[]
    return offset;
  }

};








class QacDropCountQueueEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacDropCountQueueEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacDropCountQueueEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t &count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].count();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacDropCountQueueEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacDropCountQueueEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacDropCountQueueEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3000; // to get to csr_memory_qac_drop_count_queue
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class QacDropCountQueueEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacDropCountQueueEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacDropCountQueueEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].count();
  }
  void count(uint32_t a0,const uint64_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].count(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacDropCountQueueEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacDropCountQueueEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacDropCountQueueEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3000; // to get to csr_memory_qac_drop_count_queue
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class QacDropCountPortEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountPortEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_port_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_drop_count_port_entry), 1, false, write_callback, read_callback, std::string("QacDropCountPortEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_drop_count_port_entry))
    {
    }
  QacDropCountPortEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacDropCountPortEntry")
    {
    }
public:
  uint64_t &count() { return count_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(count_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    count_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    count_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountPortEntry") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountPortEntry") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_port_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2e00; // to get to csr_memory_qac_drop_count_port
    assert(index_qac_drop_count_port_entry < 216);
    offset += index_qac_drop_count_port_entry * 0x1; // qac_drop_count_port_entry[]
    return offset;
  }

};








class QacDropCountPortEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountPortEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_port_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_drop_count_port_entry), 1, true, write_callback, read_callback, std::string("QacDropCountPortEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_drop_count_port_entry))
    {
    }
  QacDropCountPortEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacDropCountPortEntryMutable")
    {
    }
public:
  uint64_t count() { return count_; }
  void count(const uint64_t &v) { count_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(count_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    count_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    count_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountPortEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacDropCountPortEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(count_) ) + "\n";
    all_zeros &= (0 == count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_drop_count_port_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2e00; // to get to csr_memory_qac_drop_count_port
    assert(index_qac_drop_count_port_entry < 216);
    offset += index_qac_drop_count_port_entry * 0x1; // qac_drop_count_port_entry[]
    return offset;
  }

};








class QacDropCountPortEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacDropCountPortEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacDropCountPortEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t &count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].count();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacDropCountPortEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacDropCountPortEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacDropCountPortEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2e00; // to get to csr_memory_qac_drop_count_port
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 216;
        break;
      case 0:
        return 216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 216;
        break;
      case 0:
        return 216;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class QacDropCountPortEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacDropCountPortEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacDropCountPortEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].count();
  }
  void count(uint32_t a0,const uint64_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].count(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacDropCountPortEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacDropCountPortEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacDropCountPortEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2e00; // to get to csr_memory_qac_drop_count_port
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 216;
        break;
      case 0:
        return 216;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 216;
        break;
      case 0:
        return 216;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacPortCellCountEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortCellCountEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_port_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_port_cell_count_entry), 1, false, write_callback, read_callback, std::string("QacPortCellCountEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_port_cell_count_entry))
    {
    }
  QacPortCellCountEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacPortCellCountEntry")
    {
    }
public:
  uint32_t &port_cell_count() { return port_cell_count_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(port_cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    port_cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    port_cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("port_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_cell_count_) ) + "\n";
    all_zeros &= (0 == port_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("port_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_cell_count_) ) + "\n";
    all_zeros &= (0 == port_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t port_cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_port_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d80; // to get to csr_memory_qac_port_cell_count
    assert(index_qac_port_cell_count_entry < 72);
    offset += index_qac_port_cell_count_entry * 0x1; // qac_port_cell_count_entry[]
    return offset;
  }

};









class QacPortCellCountEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortCellCountEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_port_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_port_cell_count_entry), 1, true, write_callback, read_callback, std::string("QacPortCellCountEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_port_cell_count_entry))
    {
    }
  QacPortCellCountEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacPortCellCountEntryMutable")
    {
    }
public:
  uint32_t port_cell_count() { return port_cell_count_; }
  void port_cell_count(const uint32_t &v) { port_cell_count_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(port_cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    port_cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    port_cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("port_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_cell_count_) ) + "\n";
    all_zeros &= (0 == port_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("port_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_cell_count_) ) + "\n";
    all_zeros &= (0 == port_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t port_cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_port_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d80; // to get to csr_memory_qac_port_cell_count
    assert(index_qac_port_cell_count_entry < 72);
    offset += index_qac_port_cell_count_entry * 0x1; // qac_port_cell_count_entry[]
    return offset;
  }

};









class QacPortCellCountEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacPortCellCountEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacPortCellCountEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &port_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_cell_count();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacPortCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacPortCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacPortCellCountEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d80; // to get to csr_memory_qac_port_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacPortCellCountEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacPortCellCountEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacPortCellCountEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t port_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_cell_count();
  }
  void port_cell_count(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].port_cell_count(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacPortCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacPortCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacPortCellCountEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d80; // to get to csr_memory_qac_port_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacPortConfigEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortConfigEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_port_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_port_config_entry), 1, false, write_callback, read_callback, std::string("QacPortConfigEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_port_config_entry))
    {
    }
  QacPortConfigEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacPortConfigEntry")
    {
    }
public:
  uint32_t &port_thrd() { return port_thrd_; }
  uint8_t &offset_idx() { return offset_idx_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(port_thrd_) & 0x7ffff);
    *data0 |= ((static_cast<uint64_t>(offset_idx_) & 0x1f) << 19);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    port_thrd_ = (data0 & 0x7ffff);
    offset_idx_ = ((data0 >> 19) & 0x1f);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    port_thrd_ = 0;
    offset_idx_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("port_thrd") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_thrd_) ) + "\n";
    all_zeros &= (0 == port_thrd_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("port_thrd") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_thrd_) ) + "\n";
    all_zeros &= (0 == port_thrd_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t port_thrd_;
  uint8_t offset_idx_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_port_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d00; // to get to csr_memory_qac_port_config
    assert(index_qac_port_config_entry < 72);
    offset += index_qac_port_config_entry * 0x1; // qac_port_config_entry[]
    return offset;
  }

};









class QacPortConfigEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortConfigEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_port_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_port_config_entry), 1, true, write_callback, read_callback, std::string("QacPortConfigEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_port_config_entry))
    {
    }
  QacPortConfigEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacPortConfigEntryMutable")
    {
    }
public:
  uint32_t port_thrd() { return port_thrd_; }
  void port_thrd(const uint32_t &v) { port_thrd_=v; }
  uint8_t offset_idx() { return offset_idx_; }
  void offset_idx(const uint8_t &v) { offset_idx_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(port_thrd_) & 0x7ffff);
    *data0 |= ((static_cast<uint64_t>(offset_idx_) & 0x1f) << 19);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    port_thrd_ = (data0 & 0x7ffff);
    offset_idx_ = ((data0 >> 19) & 0x1f);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    port_thrd_ = 0;
    offset_idx_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("port_thrd") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_thrd_) ) + "\n";
    all_zeros &= (0 == port_thrd_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("port_thrd") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_thrd_) ) + "\n";
    all_zeros &= (0 == port_thrd_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t port_thrd_;
  uint8_t offset_idx_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_port_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d00; // to get to csr_memory_qac_port_config
    assert(index_qac_port_config_entry < 72);
    offset += index_qac_port_config_entry * 0x1; // qac_port_config_entry[]
    return offset;
  }

};









class QacPortConfigEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacPortConfigEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacPortConfigEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &port_thrd(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_thrd();
  }
  uint8_t &offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].offset_idx();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacPortConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacPortConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacPortConfigEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d00; // to get to csr_memory_qac_port_config
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacPortConfigEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacPortConfigEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacPortConfigEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t port_thrd(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_thrd();
  }
  void port_thrd(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].port_thrd(v);
  }
  uint8_t offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].offset_idx();
  }
  void offset_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].offset_idx(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacPortConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacPortConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacPortConfigEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d00; // to get to csr_memory_qac_port_config
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacPortWmCellCountEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortWmCellCountEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_port_wm_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_port_wm_cell_count_entry), 1, false, write_callback, read_callback, std::string("QacPortWmCellCountEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_port_wm_cell_count_entry))
    {
    }
  QacPortWmCellCountEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacPortWmCellCountEntry")
    {
    }
public:
  uint32_t &cell_count() { return cell_count_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortWmCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortWmCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_port_wm_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2c80; // to get to csr_memory_qac_port_wm_cell_count
    assert(index_qac_port_wm_cell_count_entry < 72);
    offset += index_qac_port_wm_cell_count_entry * 0x1; // qac_port_wm_cell_count_entry[]
    return offset;
  }

};









class QacPortWmCellCountEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortWmCellCountEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_port_wm_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_port_wm_cell_count_entry), 1, true, write_callback, read_callback, std::string("QacPortWmCellCountEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_port_wm_cell_count_entry))
    {
    }
  QacPortWmCellCountEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacPortWmCellCountEntryMutable")
    {
    }
public:
  uint32_t cell_count() { return cell_count_; }
  void cell_count(const uint32_t &v) { cell_count_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortWmCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacPortWmCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_port_wm_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2c80; // to get to csr_memory_qac_port_wm_cell_count
    assert(index_qac_port_wm_cell_count_entry < 72);
    offset += index_qac_port_wm_cell_count_entry * 0x1; // qac_port_wm_cell_count_entry[]
    return offset;
  }

};









class QacPortWmCellCountEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacPortWmCellCountEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacPortWmCellCountEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cell_count();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacPortWmCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacPortWmCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacPortWmCellCountEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2c80; // to get to csr_memory_qac_port_wm_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacPortWmCellCountEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacPortWmCellCountEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacPortWmCellCountEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cell_count();
  }
  void cell_count(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cell_count(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacPortWmCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacPortWmCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacPortWmCellCountEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2c80; // to get to csr_memory_qac_port_wm_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueWmCellCountEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueWmCellCountEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_wm_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_wm_cell_count_entry), 1, false, write_callback, read_callback, std::string("QacQueueWmCellCountEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_wm_cell_count_entry))
    {
    }
  QacQueueWmCellCountEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueWmCellCountEntry")
    {
    }
public:
  uint32_t &cell_count() { return cell_count_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueWmCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueWmCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_wm_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2800; // to get to csr_memory_qac_queue_wm_cell_count
    assert(index_qac_queue_wm_cell_count_entry < 1152);
    offset += index_qac_queue_wm_cell_count_entry * 0x1; // qac_queue_wm_cell_count_entry[]
    return offset;
  }

};









class QacQueueWmCellCountEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueWmCellCountEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_wm_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_wm_cell_count_entry), 1, true, write_callback, read_callback, std::string("QacQueueWmCellCountEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_wm_cell_count_entry))
    {
    }
  QacQueueWmCellCountEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueWmCellCountEntryMutable")
    {
    }
public:
  uint32_t cell_count() { return cell_count_; }
  void cell_count(const uint32_t &v) { cell_count_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueWmCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueWmCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cell_count_) ) + "\n";
    all_zeros &= (0 == cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_wm_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2800; // to get to csr_memory_qac_queue_wm_cell_count
    assert(index_qac_queue_wm_cell_count_entry < 1152);
    offset += index_qac_queue_wm_cell_count_entry * 0x1; // qac_queue_wm_cell_count_entry[]
    return offset;
  }

};









class QacQueueWmCellCountEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueWmCellCountEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacQueueWmCellCountEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cell_count();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueWmCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueWmCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueWmCellCountEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2800; // to get to csr_memory_qac_queue_wm_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueWmCellCountEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueWmCellCountEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacQueueWmCellCountEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cell_count();
  }
  void cell_count(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cell_count(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueWmCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueWmCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueWmCellCountEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2800; // to get to csr_memory_qac_queue_wm_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueCellCountEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueCellCountEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_cell_count_entry), 1, false, write_callback, read_callback, std::string("QacQueueCellCountEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_cell_count_entry))
    {
    }
  QacQueueCellCountEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueCellCountEntry")
    {
    }
public:
  uint32_t &queue_cell_count() { return queue_cell_count_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(queue_cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    queue_cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    queue_cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("queue_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(queue_cell_count_) ) + "\n";
    all_zeros &= (0 == queue_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueCellCountEntry") + ":\n";
    r += indent_string + "  " + std::string("queue_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(queue_cell_count_) ) + "\n";
    all_zeros &= (0 == queue_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t queue_cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_qac_queue_cell_count
    assert(index_qac_queue_cell_count_entry < 1152);
    offset += index_qac_queue_cell_count_entry * 0x1; // qac_queue_cell_count_entry[]
    return offset;
  }

};









class QacQueueCellCountEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueCellCountEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_cell_count_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_cell_count_entry), 1, true, write_callback, read_callback, std::string("QacQueueCellCountEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_cell_count_entry))
    {
    }
  QacQueueCellCountEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueCellCountEntryMutable")
    {
    }
public:
  uint32_t queue_cell_count() { return queue_cell_count_; }
  void queue_cell_count(const uint32_t &v) { queue_cell_count_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(queue_cell_count_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    queue_cell_count_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    queue_cell_count_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("queue_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(queue_cell_count_) ) + "\n";
    all_zeros &= (0 == queue_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueCellCountEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("queue_cell_count") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(queue_cell_count_) ) + "\n";
    all_zeros &= (0 == queue_cell_count_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t queue_cell_count_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_cell_count_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_qac_queue_cell_count
    assert(index_qac_queue_cell_count_entry < 1152);
    offset += index_qac_queue_cell_count_entry * 0x1; // qac_queue_cell_count_entry[]
    return offset;
  }

};









class QacQueueCellCountEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueCellCountEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacQueueCellCountEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &queue_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].queue_cell_count();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueCellCountEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueCellCountEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_qac_queue_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueCellCountEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueCellCountEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacQueueCellCountEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t queue_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].queue_cell_count();
  }
  void queue_cell_count(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].queue_cell_count(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueCellCountEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueCellCountEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_qac_queue_cell_count
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class QacQueueColorLimitEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueColorLimitEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_color_limit_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_color_limit_entry), 1, false, write_callback, read_callback, std::string("QacQueueColorLimitEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_color_limit_entry))
    {
    }
  QacQueueColorLimitEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueColorLimitEntry")
    {
    }
public:
  uint8_t &red_lmt_perc() { return red_lmt_perc_; }
  uint8_t &red_offset_idx() { return red_offset_idx_; }
  uint8_t &yel_lmt_perc() { return yel_lmt_perc_; }
  uint8_t &yel_offset_idx() { return yel_offset_idx_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(red_lmt_perc_) & 0xf);
    *data0 |= ((static_cast<uint64_t>(red_offset_idx_) & 0xf) << 4);
    *data0 |= ((static_cast<uint64_t>(yel_lmt_perc_) & 0xf) << 8);
    *data0 |= ((static_cast<uint64_t>(yel_offset_idx_) & 0xf) << 12);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    red_lmt_perc_ = (data0 & 0xf);
    red_offset_idx_ = ((data0 >> 4) & 0xf);
    yel_lmt_perc_ = ((data0 >> 8) & 0xf);
    yel_offset_idx_ = ((data0 >> 12) & 0xf);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    red_lmt_perc_ = 0;
    red_offset_idx_ = 0;
    yel_lmt_perc_ = 0;
    yel_offset_idx_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueColorLimitEntry") + ":\n";
    r += indent_string + "  " + std::string("red_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_lmt_perc_) ) + "\n";
    all_zeros &= (0 == red_lmt_perc_);
    r += indent_string + "  " + std::string("red_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_offset_idx_) ) + "\n";
    all_zeros &= (0 == red_offset_idx_);
    r += indent_string + "  " + std::string("yel_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_lmt_perc_) ) + "\n";
    all_zeros &= (0 == yel_lmt_perc_);
    r += indent_string + "  " + std::string("yel_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_offset_idx_) ) + "\n";
    all_zeros &= (0 == yel_offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueColorLimitEntry") + ":\n";
    r += indent_string + "  " + std::string("red_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_lmt_perc_) ) + "\n";
    all_zeros &= (0 == red_lmt_perc_);
    r += indent_string + "  " + std::string("red_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_offset_idx_) ) + "\n";
    all_zeros &= (0 == red_offset_idx_);
    r += indent_string + "  " + std::string("yel_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_lmt_perc_) ) + "\n";
    all_zeros &= (0 == yel_lmt_perc_);
    r += indent_string + "  " + std::string("yel_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_offset_idx_) ) + "\n";
    all_zeros &= (0 == yel_offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t red_lmt_perc_;
  uint8_t red_offset_idx_;
  uint8_t yel_lmt_perc_;
  uint8_t yel_offset_idx_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_color_limit_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_qac_queue_color_limit
    assert(index_qac_queue_color_limit_entry < 1152);
    offset += index_qac_queue_color_limit_entry * 0x1; // qac_queue_color_limit_entry[]
    return offset;
  }

};










class QacQueueColorLimitEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueColorLimitEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_color_limit_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_color_limit_entry), 1, true, write_callback, read_callback, std::string("QacQueueColorLimitEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_color_limit_entry))
    {
    }
  QacQueueColorLimitEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueColorLimitEntryMutable")
    {
    }
public:
  uint8_t red_lmt_perc() { return red_lmt_perc_; }
  void red_lmt_perc(const uint8_t &v) { red_lmt_perc_=v; }
  uint8_t red_offset_idx() { return red_offset_idx_; }
  void red_offset_idx(const uint8_t &v) { red_offset_idx_=v; }
  uint8_t yel_lmt_perc() { return yel_lmt_perc_; }
  void yel_lmt_perc(const uint8_t &v) { yel_lmt_perc_=v; }
  uint8_t yel_offset_idx() { return yel_offset_idx_; }
  void yel_offset_idx(const uint8_t &v) { yel_offset_idx_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(red_lmt_perc_) & 0xf);
    *data0 |= ((static_cast<uint64_t>(red_offset_idx_) & 0xf) << 4);
    *data0 |= ((static_cast<uint64_t>(yel_lmt_perc_) & 0xf) << 8);
    *data0 |= ((static_cast<uint64_t>(yel_offset_idx_) & 0xf) << 12);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    red_lmt_perc_ = (data0 & 0xf);
    red_offset_idx_ = ((data0 >> 4) & 0xf);
    yel_lmt_perc_ = ((data0 >> 8) & 0xf);
    yel_offset_idx_ = ((data0 >> 12) & 0xf);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    red_lmt_perc_ = 0;
    red_offset_idx_ = 0;
    yel_lmt_perc_ = 0;
    yel_offset_idx_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueColorLimitEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("red_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_lmt_perc_) ) + "\n";
    all_zeros &= (0 == red_lmt_perc_);
    r += indent_string + "  " + std::string("red_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_offset_idx_) ) + "\n";
    all_zeros &= (0 == red_offset_idx_);
    r += indent_string + "  " + std::string("yel_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_lmt_perc_) ) + "\n";
    all_zeros &= (0 == yel_lmt_perc_);
    r += indent_string + "  " + std::string("yel_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_offset_idx_) ) + "\n";
    all_zeros &= (0 == yel_offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueColorLimitEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("red_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_lmt_perc_) ) + "\n";
    all_zeros &= (0 == red_lmt_perc_);
    r += indent_string + "  " + std::string("red_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_offset_idx_) ) + "\n";
    all_zeros &= (0 == red_offset_idx_);
    r += indent_string + "  " + std::string("yel_lmt_perc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_lmt_perc_) ) + "\n";
    all_zeros &= (0 == yel_lmt_perc_);
    r += indent_string + "  " + std::string("yel_offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_offset_idx_) ) + "\n";
    all_zeros &= (0 == yel_offset_idx_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t red_lmt_perc_;
  uint8_t red_offset_idx_;
  uint8_t yel_lmt_perc_;
  uint8_t yel_offset_idx_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_color_limit_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_qac_queue_color_limit
    assert(index_qac_queue_color_limit_entry < 1152);
    offset += index_qac_queue_color_limit_entry * 0x1; // qac_queue_color_limit_entry[]
    return offset;
  }

};










class QacQueueColorLimitEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueColorLimitEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacQueueColorLimitEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &red_lmt_perc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].red_lmt_perc();
  }
  uint8_t &red_offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].red_offset_idx();
  }
  uint8_t &yel_lmt_perc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_lmt_perc();
  }
  uint8_t &yel_offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_offset_idx();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueColorLimitEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueColorLimitEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueColorLimitEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_qac_queue_color_limit
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class QacQueueColorLimitEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueColorLimitEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacQueueColorLimitEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t red_lmt_perc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].red_lmt_perc();
  }
  void red_lmt_perc(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].red_lmt_perc(v);
  }
  uint8_t red_offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].red_offset_idx();
  }
  void red_offset_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].red_offset_idx(v);
  }
  uint8_t yel_lmt_perc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_lmt_perc();
  }
  void yel_lmt_perc(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].yel_lmt_perc(v);
  }
  uint8_t yel_offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_offset_idx();
  }
  void yel_offset_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].yel_offset_idx(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueColorLimitEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueColorLimitEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueColorLimitEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_qac_queue_color_limit
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueApConfigEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueApConfigEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_ap_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_ap_config_entry), 1, false, write_callback, read_callback, std::string("QacQueueApConfigEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_ap_config_entry))
    {
    }
  QacQueueApConfigEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueApConfigEntry")
    {
    }
public:
  uint8_t &ap_id() { return ap_id_; }
  uint8_t &q_color_drop_en() { return q_color_drop_en_; }
  uint8_t &q_drop_en() { return q_drop_en_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ap_id_) & 0x3);
    *data0 |= ((static_cast<uint64_t>(q_color_drop_en_) & 0x1) << 2);
    *data0 |= ((static_cast<uint64_t>(q_drop_en_) & 0x1) << 3);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ap_id_ = (data0 & 0x3);
    q_color_drop_en_ = ((data0 >> 2) & 0x1);
    q_drop_en_ = ((data0 >> 3) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ap_id_ = 0;
    q_color_drop_en_ = 0;
    q_drop_en_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueApConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("ap_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ap_id_) ) + "\n";
    all_zeros &= (0 == ap_id_);
    r += indent_string + "  " + std::string("q_color_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_color_drop_en_) ) + "\n";
    all_zeros &= (0 == q_color_drop_en_);
    r += indent_string + "  " + std::string("q_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_drop_en_) ) + "\n";
    all_zeros &= (0 == q_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueApConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("ap_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ap_id_) ) + "\n";
    all_zeros &= (0 == ap_id_);
    r += indent_string + "  " + std::string("q_color_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_color_drop_en_) ) + "\n";
    all_zeros &= (0 == q_color_drop_en_);
    r += indent_string + "  " + std::string("q_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_drop_en_) ) + "\n";
    all_zeros &= (0 == q_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t ap_id_;
  uint8_t q_color_drop_en_;
  uint8_t q_drop_en_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_ap_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_qac_queue_ap_config
    assert(index_qac_queue_ap_config_entry < 1152);
    offset += index_qac_queue_ap_config_entry * 0x1; // qac_queue_ap_config_entry[]
    return offset;
  }

};









class QacQueueApConfigEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueApConfigEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_ap_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_ap_config_entry), 1, true, write_callback, read_callback, std::string("QacQueueApConfigEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_ap_config_entry))
    {
    }
  QacQueueApConfigEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueApConfigEntryMutable")
    {
    }
public:
  uint8_t ap_id() { return ap_id_; }
  void ap_id(const uint8_t &v) { ap_id_=v; }
  uint8_t q_color_drop_en() { return q_color_drop_en_; }
  void q_color_drop_en(const uint8_t &v) { q_color_drop_en_=v; }
  uint8_t q_drop_en() { return q_drop_en_; }
  void q_drop_en(const uint8_t &v) { q_drop_en_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ap_id_) & 0x3);
    *data0 |= ((static_cast<uint64_t>(q_color_drop_en_) & 0x1) << 2);
    *data0 |= ((static_cast<uint64_t>(q_drop_en_) & 0x1) << 3);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ap_id_ = (data0 & 0x3);
    q_color_drop_en_ = ((data0 >> 2) & 0x1);
    q_drop_en_ = ((data0 >> 3) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ap_id_ = 0;
    q_color_drop_en_ = 0;
    q_drop_en_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueApConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ap_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ap_id_) ) + "\n";
    all_zeros &= (0 == ap_id_);
    r += indent_string + "  " + std::string("q_color_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_color_drop_en_) ) + "\n";
    all_zeros &= (0 == q_color_drop_en_);
    r += indent_string + "  " + std::string("q_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_drop_en_) ) + "\n";
    all_zeros &= (0 == q_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueApConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ap_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ap_id_) ) + "\n";
    all_zeros &= (0 == ap_id_);
    r += indent_string + "  " + std::string("q_color_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_color_drop_en_) ) + "\n";
    all_zeros &= (0 == q_color_drop_en_);
    r += indent_string + "  " + std::string("q_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(q_drop_en_) ) + "\n";
    all_zeros &= (0 == q_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t ap_id_;
  uint8_t q_color_drop_en_;
  uint8_t q_drop_en_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_ap_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_qac_queue_ap_config
    assert(index_qac_queue_ap_config_entry < 1152);
    offset += index_qac_queue_ap_config_entry * 0x1; // qac_queue_ap_config_entry[]
    return offset;
  }

};









class QacQueueApConfigEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueApConfigEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacQueueApConfigEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &ap_id(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ap_id();
  }
  uint8_t &q_color_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_color_drop_en();
  }
  uint8_t &q_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_drop_en();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueApConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueApConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueApConfigEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_qac_queue_ap_config
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueApConfigEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueApConfigEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacQueueApConfigEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t ap_id(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ap_id();
  }
  void ap_id(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ap_id(v);
  }
  uint8_t q_color_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_color_drop_en();
  }
  void q_color_drop_en(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].q_color_drop_en(v);
  }
  uint8_t q_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_drop_en();
  }
  void q_drop_en(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].q_drop_en(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueApConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueApConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueApConfigEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_qac_queue_ap_config
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class QacQueueShrThrdConfigEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueShrThrdConfigEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_shr_thrd_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_shr_thrd_config_entry), 1, false, write_callback, read_callback, std::string("QacQueueShrThrdConfigEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_shr_thrd_config_entry))
    {
    }
  QacQueueShrThrdConfigEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueShrThrdConfigEntry")
    {
    }
public:
  uint32_t &shr_lmt() { return shr_lmt_; }
  uint8_t &offset_idx() { return offset_idx_; }
  uint8_t &dyn_en() { return dyn_en_; }
  uint8_t &fast_recover_mode() { return fast_recover_mode_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(shr_lmt_) & 0x7ffff);
    *data0 |= ((static_cast<uint64_t>(offset_idx_) & 0x1f) << 19);
    *data0 |= ((static_cast<uint64_t>(dyn_en_) & 0x1) << 24);
    *data0 |= ((static_cast<uint64_t>(fast_recover_mode_) & 0x1) << 25);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    shr_lmt_ = (data0 & 0x7ffff);
    offset_idx_ = ((data0 >> 19) & 0x1f);
    dyn_en_ = ((data0 >> 24) & 0x1);
    fast_recover_mode_ = ((data0 >> 25) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    shr_lmt_ = 0;
    offset_idx_ = 0;
    dyn_en_ = 0;
    fast_recover_mode_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueShrThrdConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    r += indent_string + "  " + std::string("dyn_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_en_) ) + "\n";
    all_zeros &= (0 == dyn_en_);
    r += indent_string + "  " + std::string("fast_recover_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(fast_recover_mode_) ) + "\n";
    all_zeros &= (0 == fast_recover_mode_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueShrThrdConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    r += indent_string + "  " + std::string("dyn_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_en_) ) + "\n";
    all_zeros &= (0 == dyn_en_);
    r += indent_string + "  " + std::string("fast_recover_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(fast_recover_mode_) ) + "\n";
    all_zeros &= (0 == fast_recover_mode_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t shr_lmt_;
  uint8_t offset_idx_;
  uint8_t dyn_en_;
  uint8_t fast_recover_mode_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_shr_thrd_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x800; // to get to csr_memory_qac_queue_shr_thrd_config
    assert(index_qac_queue_shr_thrd_config_entry < 1152);
    offset += index_qac_queue_shr_thrd_config_entry * 0x1; // qac_queue_shr_thrd_config_entry[]
    return offset;
  }

};










class QacQueueShrThrdConfigEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueShrThrdConfigEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_shr_thrd_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_shr_thrd_config_entry), 1, true, write_callback, read_callback, std::string("QacQueueShrThrdConfigEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_shr_thrd_config_entry))
    {
    }
  QacQueueShrThrdConfigEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueShrThrdConfigEntryMutable")
    {
    }
public:
  uint32_t shr_lmt() { return shr_lmt_; }
  void shr_lmt(const uint32_t &v) { shr_lmt_=v; }
  uint8_t offset_idx() { return offset_idx_; }
  void offset_idx(const uint8_t &v) { offset_idx_=v; }
  uint8_t dyn_en() { return dyn_en_; }
  void dyn_en(const uint8_t &v) { dyn_en_=v; }
  uint8_t fast_recover_mode() { return fast_recover_mode_; }
  void fast_recover_mode(const uint8_t &v) { fast_recover_mode_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(shr_lmt_) & 0x7ffff);
    *data0 |= ((static_cast<uint64_t>(offset_idx_) & 0x1f) << 19);
    *data0 |= ((static_cast<uint64_t>(dyn_en_) & 0x1) << 24);
    *data0 |= ((static_cast<uint64_t>(fast_recover_mode_) & 0x1) << 25);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    shr_lmt_ = (data0 & 0x7ffff);
    offset_idx_ = ((data0 >> 19) & 0x1f);
    dyn_en_ = ((data0 >> 24) & 0x1);
    fast_recover_mode_ = ((data0 >> 25) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    shr_lmt_ = 0;
    offset_idx_ = 0;
    dyn_en_ = 0;
    fast_recover_mode_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueShrThrdConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    r += indent_string + "  " + std::string("dyn_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_en_) ) + "\n";
    all_zeros &= (0 == dyn_en_);
    r += indent_string + "  " + std::string("fast_recover_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(fast_recover_mode_) ) + "\n";
    all_zeros &= (0 == fast_recover_mode_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueShrThrdConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("offset_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(offset_idx_) ) + "\n";
    all_zeros &= (0 == offset_idx_);
    r += indent_string + "  " + std::string("dyn_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_en_) ) + "\n";
    all_zeros &= (0 == dyn_en_);
    r += indent_string + "  " + std::string("fast_recover_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(fast_recover_mode_) ) + "\n";
    all_zeros &= (0 == fast_recover_mode_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t shr_lmt_;
  uint8_t offset_idx_;
  uint8_t dyn_en_;
  uint8_t fast_recover_mode_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_shr_thrd_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x800; // to get to csr_memory_qac_queue_shr_thrd_config
    assert(index_qac_queue_shr_thrd_config_entry < 1152);
    offset += index_qac_queue_shr_thrd_config_entry * 0x1; // qac_queue_shr_thrd_config_entry[]
    return offset;
  }

};










class QacQueueShrThrdConfigEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueShrThrdConfigEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacQueueShrThrdConfigEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &shr_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr_lmt();
  }
  uint8_t &offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].offset_idx();
  }
  uint8_t &dyn_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dyn_en();
  }
  uint8_t &fast_recover_mode(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].fast_recover_mode();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueShrThrdConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueShrThrdConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueShrThrdConfigEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x800; // to get to csr_memory_qac_queue_shr_thrd_config
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class QacQueueShrThrdConfigEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueShrThrdConfigEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacQueueShrThrdConfigEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t shr_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr_lmt();
  }
  void shr_lmt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].shr_lmt(v);
  }
  uint8_t offset_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].offset_idx();
  }
  void offset_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].offset_idx(v);
  }
  uint8_t dyn_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dyn_en();
  }
  void dyn_en(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dyn_en(v);
  }
  uint8_t fast_recover_mode(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].fast_recover_mode();
  }
  void fast_recover_mode(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].fast_recover_mode(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueShrThrdConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueShrThrdConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueShrThrdConfigEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x800; // to get to csr_memory_qac_queue_shr_thrd_config
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueMinThrdConfigEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueMinThrdConfigEntry(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_min_thrd_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_min_thrd_config_entry), 1, false, write_callback, read_callback, std::string("QacQueueMinThrdConfigEntry")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_min_thrd_config_entry))
    {
    }
  QacQueueMinThrdConfigEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueMinThrdConfigEntry")
    {
    }
public:
  uint32_t &min_lmt() { return min_lmt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(min_lmt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    min_lmt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    min_lmt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueMinThrdConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("min_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(min_lmt_) ) + "\n";
    all_zeros &= (0 == min_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueMinThrdConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("min_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(min_lmt_) ) + "\n";
    all_zeros &= (0 == min_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t min_lmt_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_min_thrd_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    assert(index_qac_queue_min_thrd_config_entry < 1152);
    offset += index_qac_queue_min_thrd_config_entry * 0x1; // qac_queue_min_thrd_config_entry[]
    return offset;
  }

};









class QacQueueMinThrdConfigEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueMinThrdConfigEntryMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, int index_qac_queue_min_thrd_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec, index_qac_queue_min_thrd_config_entry), 1, true, write_callback, read_callback, std::string("QacQueueMinThrdConfigEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_qac_queue_min_thrd_config_entry))
    {
    }
  QacQueueMinThrdConfigEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueMinThrdConfigEntryMutable")
    {
    }
public:
  uint32_t min_lmt() { return min_lmt_; }
  void min_lmt(const uint32_t &v) { min_lmt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(min_lmt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    min_lmt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    min_lmt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueMinThrdConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("min_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(min_lmt_) ) + "\n";
    all_zeros &= (0 == min_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("QacQueueMinThrdConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("min_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(min_lmt_) ) + "\n";
    all_zeros &= (0 == min_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t min_lmt_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec, int index_qac_queue_min_thrd_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    assert(index_qac_queue_min_thrd_config_entry < 1152);
    offset += index_qac_queue_min_thrd_config_entry * 0x1; // qac_queue_min_thrd_config_entry[]
    return offset;
  }

};









class QacQueueMinThrdConfigEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueMinThrdConfigEntryArray(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("QacQueueMinThrdConfigEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &min_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].min_lmt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueMinThrdConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueMinThrdConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueMinThrdConfigEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class QacQueueMinThrdConfigEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  QacQueueMinThrdConfigEntryArrayMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1 * ArraySize(index_tm_qac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("QacQueueMinThrdConfigEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_qac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_qac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_qac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t min_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].min_lmt();
  }
  void min_lmt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].min_lmt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("QacQueueMinThrdConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("QacQueueMinThrdConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<QacQueueMinThrdConfigEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_qac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQacPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacPipeMemRspec(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmQacPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  TmQacPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQacPipeMemRspec")
    {
    }
public:








  QacQueueMinThrdConfigEntry &csr_memory_qac_queue_min_thrd_config(int j0) { return csr_memory_qac_queue_min_thrd_config_[j0]; }









  QacQueueShrThrdConfigEntry &csr_memory_qac_queue_shr_thrd_config(int j0) { return csr_memory_qac_queue_shr_thrd_config_[j0]; }








  QacQueueApConfigEntry &csr_memory_qac_queue_ap_config(int j0) { return csr_memory_qac_queue_ap_config_[j0]; }









  QacQueueColorLimitEntry &csr_memory_qac_queue_color_limit(int j0) { return csr_memory_qac_queue_color_limit_[j0]; }








  QacQueueCellCountEntry &csr_memory_qac_queue_cell_count(int j0) { return csr_memory_qac_queue_cell_count_[j0]; }








  QacQueueWmCellCountEntry &csr_memory_qac_queue_wm_cell_count(int j0) { return csr_memory_qac_queue_wm_cell_count_[j0]; }








  QacPortWmCellCountEntry &csr_memory_qac_port_wm_cell_count(int j0) { return csr_memory_qac_port_wm_cell_count_[j0]; }








  QacPortConfigEntry &csr_memory_qac_port_config(int j0) { return csr_memory_qac_port_config_[j0]; }








  QacPortCellCountEntry &csr_memory_qac_port_cell_count(int j0) { return csr_memory_qac_port_cell_count_[j0]; }







  QacDropCountPortEntry &csr_memory_qac_drop_count_port(int j0) { return csr_memory_qac_drop_count_port_[j0]; }







  QacDropCountQueueEntry &csr_memory_qac_drop_count_queue(int j0) { return csr_memory_qac_drop_count_queue_[j0]; }









  QacQidMappingEntry &csr_memory_qac_qid_mapping(int j0) { return csr_memory_qac_qid_mapping_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x480) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_min_thrd_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_shr_thrd_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_ap_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_color_limit_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_wm_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_wm_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_port_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_queue_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_qid_mapping_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x480) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_min_thrd_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_shr_thrd_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_ap_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_color_limit_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_wm_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_port_wm_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_port_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_port_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_drop_count_port_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_drop_count_queue_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_qid_mapping_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_qac_queue_min_thrd_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_shr_thrd_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_ap_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_color_limit_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_wm_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_port_wm_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_port_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_port_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_drop_count_port_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_drop_count_queue_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_qid_mapping_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x480) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_min_thrd_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_shr_thrd_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_ap_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_color_limit_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_wm_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_port_wm_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_port_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_port_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_drop_count_port_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_drop_count_queue_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_qid_mapping_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_min_thrd_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_shr_thrd_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_ap_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_color_limit_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_wm_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_qac_port_wm_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_qac_port_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_qac_port_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<216;++a0) {
      r += csr_memory_qac_drop_count_port_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_drop_count_queue_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += csr_memory_qac_qid_mapping_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< QacQueueMinThrdConfigEntry, 1152 > csr_memory_qac_queue_min_thrd_config_;
  std::array< QacQueueShrThrdConfigEntry, 1152 > csr_memory_qac_queue_shr_thrd_config_;
  std::array< QacQueueApConfigEntry, 1152 > csr_memory_qac_queue_ap_config_;
  std::array< QacQueueColorLimitEntry, 1152 > csr_memory_qac_queue_color_limit_;
  std::array< QacQueueCellCountEntry, 1152 > csr_memory_qac_queue_cell_count_;
  std::array< QacQueueWmCellCountEntry, 1152 > csr_memory_qac_queue_wm_cell_count_;
  std::array< QacPortWmCellCountEntry, 72 > csr_memory_qac_port_wm_cell_count_;
  std::array< QacPortConfigEntry, 72 > csr_memory_qac_port_config_;
  std::array< QacPortCellCountEntry, 72 > csr_memory_qac_port_cell_count_;
  std::array< QacDropCountPortEntry, 216 > csr_memory_qac_drop_count_port_;
  std::array< QacDropCountQueueEntry, 1152 > csr_memory_qac_drop_count_queue_;
  std::array< QacQidMappingEntry, 288 > csr_memory_qac_qid_mapping_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

};








class TmQacPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacPipeMemRspecMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmQacPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  TmQacPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQacPipeMemRspecMutable")
    {
    }
public:








  QacQueueMinThrdConfigEntryMutable &csr_memory_qac_queue_min_thrd_config(int j0) { return csr_memory_qac_queue_min_thrd_config_[j0]; }









  QacQueueShrThrdConfigEntryMutable &csr_memory_qac_queue_shr_thrd_config(int j0) { return csr_memory_qac_queue_shr_thrd_config_[j0]; }








  QacQueueApConfigEntryMutable &csr_memory_qac_queue_ap_config(int j0) { return csr_memory_qac_queue_ap_config_[j0]; }









  QacQueueColorLimitEntryMutable &csr_memory_qac_queue_color_limit(int j0) { return csr_memory_qac_queue_color_limit_[j0]; }








  QacQueueCellCountEntryMutable &csr_memory_qac_queue_cell_count(int j0) { return csr_memory_qac_queue_cell_count_[j0]; }








  QacQueueWmCellCountEntryMutable &csr_memory_qac_queue_wm_cell_count(int j0) { return csr_memory_qac_queue_wm_cell_count_[j0]; }








  QacPortWmCellCountEntryMutable &csr_memory_qac_port_wm_cell_count(int j0) { return csr_memory_qac_port_wm_cell_count_[j0]; }








  QacPortConfigEntryMutable &csr_memory_qac_port_config(int j0) { return csr_memory_qac_port_config_[j0]; }








  QacPortCellCountEntryMutable &csr_memory_qac_port_cell_count(int j0) { return csr_memory_qac_port_cell_count_[j0]; }







  QacDropCountPortEntryMutable &csr_memory_qac_drop_count_port(int j0) { return csr_memory_qac_drop_count_port_[j0]; }







  QacDropCountQueueEntryMutable &csr_memory_qac_drop_count_queue(int j0) { return csr_memory_qac_drop_count_queue_[j0]; }









  QacQidMappingEntryMutable &csr_memory_qac_qid_mapping(int j0) { return csr_memory_qac_qid_mapping_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x480) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_min_thrd_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_shr_thrd_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_ap_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_color_limit_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_wm_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_wm_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_config_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_cell_count_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_port_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_queue_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_qac_qid_mapping_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x480) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_min_thrd_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_shr_thrd_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_ap_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_color_limit_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_queue_wm_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_port_wm_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_port_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_port_cell_count_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_drop_count_port_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_drop_count_queue_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_qac_qid_mapping_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_qac_queue_min_thrd_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_shr_thrd_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_ap_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_color_limit_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_queue_wm_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_port_wm_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_port_config_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_port_cell_count_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_drop_count_port_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_drop_count_queue_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_qac_qid_mapping_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x480) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_min_thrd_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_shr_thrd_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_ap_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_color_limit_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_queue_wm_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_port_wm_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_port_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_port_cell_count_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_drop_count_port_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_drop_count_queue_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_qac_qid_mapping_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_min_thrd_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_shr_thrd_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_ap_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_color_limit_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_queue_wm_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_qac_port_wm_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_qac_port_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_qac_port_cell_count_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<216;++a0) {
      r += csr_memory_qac_drop_count_port_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_qac_drop_count_queue_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += csr_memory_qac_qid_mapping_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< QacQueueMinThrdConfigEntryMutable, 1152 > csr_memory_qac_queue_min_thrd_config_;
  std::array< QacQueueShrThrdConfigEntryMutable, 1152 > csr_memory_qac_queue_shr_thrd_config_;
  std::array< QacQueueApConfigEntryMutable, 1152 > csr_memory_qac_queue_ap_config_;
  std::array< QacQueueColorLimitEntryMutable, 1152 > csr_memory_qac_queue_color_limit_;
  std::array< QacQueueCellCountEntryMutable, 1152 > csr_memory_qac_queue_cell_count_;
  std::array< QacQueueWmCellCountEntryMutable, 1152 > csr_memory_qac_queue_wm_cell_count_;
  std::array< QacPortWmCellCountEntryMutable, 72 > csr_memory_qac_port_wm_cell_count_;
  std::array< QacPortConfigEntryMutable, 72 > csr_memory_qac_port_config_;
  std::array< QacPortCellCountEntryMutable, 72 > csr_memory_qac_port_cell_count_;
  std::array< QacDropCountPortEntryMutable, 216 > csr_memory_qac_drop_count_port_;
  std::array< QacDropCountQueueEntryMutable, 1152 > csr_memory_qac_drop_count_queue_;
  std::array< QacQidMappingEntryMutable, 288 > csr_memory_qac_qid_mapping_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

};








class TmQacPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQacPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmQacPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:








  QacQueueMinThrdConfigEntry &csr_memory_qac_queue_min_thrd_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_min_thrd_config(j0);
  }









  QacQueueShrThrdConfigEntry &csr_memory_qac_queue_shr_thrd_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_shr_thrd_config(j0);
  }








  QacQueueApConfigEntry &csr_memory_qac_queue_ap_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_ap_config(j0);
  }









  QacQueueColorLimitEntry &csr_memory_qac_queue_color_limit(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_color_limit(j0);
  }








  QacQueueCellCountEntry &csr_memory_qac_queue_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_cell_count(j0);
  }








  QacQueueWmCellCountEntry &csr_memory_qac_queue_wm_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_wm_cell_count(j0);
  }








  QacPortWmCellCountEntry &csr_memory_qac_port_wm_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_wm_cell_count(j0);
  }








  QacPortConfigEntry &csr_memory_qac_port_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_config(j0);
  }








  QacPortCellCountEntry &csr_memory_qac_port_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_cell_count(j0);
  }







  QacDropCountPortEntry &csr_memory_qac_drop_count_port(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_port(j0);
  }







  QacDropCountQueueEntry &csr_memory_qac_drop_count_queue(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_queue(j0);
  }









  QacQidMappingEntry &csr_memory_qac_qid_mapping(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_qid_mapping(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQacPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQacPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQacPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmQacPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:








  QacQueueMinThrdConfigEntryMutable &csr_memory_qac_queue_min_thrd_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_min_thrd_config(j0);
  }









  QacQueueShrThrdConfigEntryMutable &csr_memory_qac_queue_shr_thrd_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_shr_thrd_config(j0);
  }








  QacQueueApConfigEntryMutable &csr_memory_qac_queue_ap_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_ap_config(j0);
  }









  QacQueueColorLimitEntryMutable &csr_memory_qac_queue_color_limit(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_color_limit(j0);
  }








  QacQueueCellCountEntryMutable &csr_memory_qac_queue_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_cell_count(j0);
  }








  QacQueueWmCellCountEntryMutable &csr_memory_qac_queue_wm_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_wm_cell_count(j0);
  }








  QacPortWmCellCountEntryMutable &csr_memory_qac_port_wm_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_wm_cell_count(j0);
  }








  QacPortConfigEntryMutable &csr_memory_qac_port_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_config(j0);
  }








  QacPortCellCountEntryMutable &csr_memory_qac_port_cell_count(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_cell_count(j0);
  }







  QacDropCountPortEntryMutable &csr_memory_qac_drop_count_port(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_port(j0);
  }







  QacDropCountQueueEntryMutable &csr_memory_qac_drop_count_queue(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_queue(j0);
  }









  QacQidMappingEntryMutable &csr_memory_qac_qid_mapping(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_qid_mapping(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQacPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQacMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmQacMemTopRspec"))
    {
    }
  TmQacMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQacMemTopRspec")
    {
    }
public:







  TmQacPipeMemRspec &qac_pipe_mem(int j0) { return qac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQacPipeMemRspec, 4 > qac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

};








class TmQacMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmQacMemTopRspecMutable"))
    {
    }
  TmQacMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQacMemTopRspecMutable")
    {
    }
public:







  TmQacPipeMemRspecMutable &qac_pipe_mem(int j0) { return qac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQacPipeMemRspecMutable, 4 > qac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

};









class CaaBlockFreePtrMemoryEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmCaaMemTopRspecEnum {
    kCaaBlockGrp0,
    kCaaBlockGrp1,
    kCaaBlockGrp2,
    kCaaBlockGrp3,
    kCaaBlockGrp4,
    kCaaBlockGrp5
  };
public:
  CaaBlockFreePtrMemoryEntry(
      int chipNumber, TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int index_caa_block_free_ptr_memory_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_caa_mem_top_rspec, index_caa_block_free_ptr_memory_entry), 1, false, write_callback, read_callback, std::string("CaaBlockFreePtrMemoryEntry")+":"+boost::lexical_cast<std::string>(selector_tm_caa_mem_top_rspec) + "," + boost::lexical_cast<std::string>(index_caa_block_free_ptr_memory_entry))
    {
    }
  CaaBlockFreePtrMemoryEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "CaaBlockFreePtrMemoryEntry")
    {
    }
public:
  uint16_t &ptr0() { return ptr0_; }
  uint16_t &ptr1() { return ptr1_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ptr0_) & 0x3ff);
    *data0 |= ((static_cast<uint64_t>(ptr1_) & 0x3ff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ptr0_ = (data0 & 0x3ff);
    ptr1_ = ((data0 >> 10) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ptr0_ = 0;
    ptr1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("CaaBlockFreePtrMemoryEntry") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("CaaBlockFreePtrMemoryEntry") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t ptr0_;
  uint16_t ptr1_;
private:
  static uint64_t StartOffset(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int index_caa_block_free_ptr_memory_entry
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp1:
        offset += 0x8000; // to get to caa_block_grp1
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp2:
        offset += 0x10000; // to get to caa_block_grp2
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp3:
        offset += 0x18000; // to get to caa_block_grp3
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp4:
        offset += 0x20000; // to get to caa_block_grp4
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp5:
        offset += 0x28000; // to get to caa_block_grp5
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class CaaBlockFreePtrMemoryEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmCaaMemTopRspecEnum {
    kCaaBlockGrp0,
    kCaaBlockGrp1,
    kCaaBlockGrp2,
    kCaaBlockGrp3,
    kCaaBlockGrp4,
    kCaaBlockGrp5
  };
public:
  CaaBlockFreePtrMemoryEntryMutable(
      int chipNumber, TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int index_caa_block_free_ptr_memory_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_caa_mem_top_rspec, index_caa_block_free_ptr_memory_entry), 1, true, write_callback, read_callback, std::string("CaaBlockFreePtrMemoryEntryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_caa_mem_top_rspec) + "," + boost::lexical_cast<std::string>(index_caa_block_free_ptr_memory_entry))
    {
    }
  CaaBlockFreePtrMemoryEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "CaaBlockFreePtrMemoryEntryMutable")
    {
    }
public:
  uint16_t ptr0() { return ptr0_; }
  void ptr0(const uint16_t &v) { ptr0_=v; }
  uint16_t ptr1() { return ptr1_; }
  void ptr1(const uint16_t &v) { ptr1_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(ptr0_) & 0x3ff);
    *data0 |= ((static_cast<uint64_t>(ptr1_) & 0x3ff) << 10);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ptr0_ = (data0 & 0x3ff);
    ptr1_ = ((data0 >> 10) & 0x3ff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ptr0_ = 0;
    ptr1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("CaaBlockFreePtrMemoryEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("CaaBlockFreePtrMemoryEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ptr0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr0_) ) + "\n";
    all_zeros &= (0 == ptr0_);
    r += indent_string + "  " + std::string("ptr1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ptr1_) ) + "\n";
    all_zeros &= (0 == ptr1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t ptr0_;
  uint16_t ptr1_;
private:
  static uint64_t StartOffset(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int index_caa_block_free_ptr_memory_entry
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp1:
        offset += 0x8000; // to get to caa_block_grp1
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp2:
        offset += 0x10000; // to get to caa_block_grp2
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp3:
        offset += 0x18000; // to get to caa_block_grp3
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp4:
        offset += 0x20000; // to get to caa_block_grp4
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      case kCaaBlockGrp5:
        offset += 0x28000; // to get to caa_block_grp5
        assert(index_caa_block_free_ptr_memory_entry < 32768);
        offset += index_caa_block_free_ptr_memory_entry * 0x1; // caa_block_free_ptr_memory_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class CaaBlockFreePtrMemoryEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmCaaMemTopRspecEnum {
    kCaaBlockGrp0,
    kCaaBlockGrp1,
    kCaaBlockGrp2,
    kCaaBlockGrp3,
    kCaaBlockGrp4,
    kCaaBlockGrp5
  };
public:
  CaaBlockFreePtrMemoryEntryArray(
      int chipNumber, TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_caa_mem_top_rspec), 1 * ArraySize(selector_tm_caa_mem_top_rspec, -1), false, write_callback, read_callback, std::string("CaaBlockFreePtrMemoryEntryArray")+":"+boost::lexical_cast<std::string>(selector_tm_caa_mem_top_rspec)),
    array(RealArraySize(selector_tm_caa_mem_top_rspec, -1)),
    size0_(ArraySize(selector_tm_caa_mem_top_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_caa_mem_top_rspec, 0))
    {
    }
public:
  uint16_t &ptr0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr0();
  }
  uint16_t &ptr1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr1();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("CaaBlockFreePtrMemoryEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("CaaBlockFreePtrMemoryEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<CaaBlockFreePtrMemoryEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        break;
      case kCaaBlockGrp1:
        offset += 0x8000; // to get to caa_block_grp1
        break;
      case kCaaBlockGrp2:
        offset += 0x10000; // to get to caa_block_grp2
        break;
      case kCaaBlockGrp3:
        offset += 0x18000; // to get to caa_block_grp3
        break;
      case kCaaBlockGrp4:
        offset += 0x20000; // to get to caa_block_grp4
        break;
      case kCaaBlockGrp5:
        offset += 0x28000; // to get to caa_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class CaaBlockFreePtrMemoryEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmCaaMemTopRspecEnum {
    kCaaBlockGrp0,
    kCaaBlockGrp1,
    kCaaBlockGrp2,
    kCaaBlockGrp3,
    kCaaBlockGrp4,
    kCaaBlockGrp5
  };
public:
  CaaBlockFreePtrMemoryEntryArrayMutable(
      int chipNumber, TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_caa_mem_top_rspec), 1 * ArraySize(selector_tm_caa_mem_top_rspec, -1), true, write_callback, read_callback, std::string("CaaBlockFreePtrMemoryEntryArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_caa_mem_top_rspec)),
    array(RealArraySize(selector_tm_caa_mem_top_rspec, -1)),
    size0_(ArraySize(selector_tm_caa_mem_top_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_caa_mem_top_rspec, 0))
    {
    }
public:
  uint16_t ptr0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr0();
  }
  void ptr0(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ptr0(v);
  }
  uint16_t ptr1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ptr1();
  }
  void ptr1(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ptr1(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("CaaBlockFreePtrMemoryEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("CaaBlockFreePtrMemoryEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<CaaBlockFreePtrMemoryEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        break;
      case kCaaBlockGrp1:
        offset += 0x8000; // to get to caa_block_grp1
        break;
      case kCaaBlockGrp2:
        offset += 0x10000; // to get to caa_block_grp2
        break;
      case kCaaBlockGrp3:
        offset += 0x18000; // to get to caa_block_grp3
        break;
      case kCaaBlockGrp4:
        offset += 0x20000; // to get to caa_block_grp4
        break;
      case kCaaBlockGrp5:
        offset += 0x28000; // to get to caa_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, int dimension
      ) {
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp1:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp2:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp3:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp4:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCaaBlockGrp5:
        switch (dimension) {
          case -1:
            return 32768;
            break;
          case 0:
            return 32768;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmCaaMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmCaaMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmCaaMemTopRspec"))
    {
    }
  TmCaaMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmCaaMemTopRspec")
    {
    }
public:








  CaaBlockFreePtrMemoryEntry &caa_block_grp0(int j0) { return caa_block_grp0_[j0]; }








  CaaBlockFreePtrMemoryEntry &caa_block_grp1(int j0) { return caa_block_grp1_[j0]; }








  CaaBlockFreePtrMemoryEntry &caa_block_grp2(int j0) { return caa_block_grp2_[j0]; }








  CaaBlockFreePtrMemoryEntry &caa_block_grp3(int j0) { return caa_block_grp3_[j0]; }








  CaaBlockFreePtrMemoryEntry &caa_block_grp4(int j0) { return caa_block_grp4_[j0]; }








  CaaBlockFreePtrMemoryEntry &caa_block_grp5(int j0) { return caa_block_grp5_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp4_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp5_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp4_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp5_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : caa_block_grp0_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp1_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp2_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp3_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp4_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp5_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp4_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp5_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp4_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp5_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< CaaBlockFreePtrMemoryEntry, 32768 > caa_block_grp0_;
  std::array< CaaBlockFreePtrMemoryEntry, 32768 > caa_block_grp1_;
  std::array< CaaBlockFreePtrMemoryEntry, 32768 > caa_block_grp2_;
  std::array< CaaBlockFreePtrMemoryEntry, 32768 > caa_block_grp3_;
  std::array< CaaBlockFreePtrMemoryEntry, 32768 > caa_block_grp4_;
  std::array< CaaBlockFreePtrMemoryEntry, 32768 > caa_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    return offset;
  }

};








class TmCaaMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmCaaMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmCaaMemTopRspecMutable"))
    {
    }
  TmCaaMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmCaaMemTopRspecMutable")
    {
    }
public:








  CaaBlockFreePtrMemoryEntryMutable &caa_block_grp0(int j0) { return caa_block_grp0_[j0]; }








  CaaBlockFreePtrMemoryEntryMutable &caa_block_grp1(int j0) { return caa_block_grp1_[j0]; }








  CaaBlockFreePtrMemoryEntryMutable &caa_block_grp2(int j0) { return caa_block_grp2_[j0]; }








  CaaBlockFreePtrMemoryEntryMutable &caa_block_grp3(int j0) { return caa_block_grp3_[j0]; }








  CaaBlockFreePtrMemoryEntryMutable &caa_block_grp4(int j0) { return caa_block_grp4_[j0]; }








  CaaBlockFreePtrMemoryEntryMutable &caa_block_grp5(int j0) { return caa_block_grp5_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp0_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp1_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp2_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp3_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp4_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      caa_block_grp5_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp0_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp1_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp2_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp3_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp4_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      caa_block_grp5_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : caa_block_grp0_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp1_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp2_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp3_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp4_) {
      f0.reset();
    }
    for (auto &f0 : caa_block_grp5_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp2_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp3_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp4_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += caa_block_grp5_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp1_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp2_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp3_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp4_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32768;++a0) {
      r += caa_block_grp5_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< CaaBlockFreePtrMemoryEntryMutable, 32768 > caa_block_grp0_;
  std::array< CaaBlockFreePtrMemoryEntryMutable, 32768 > caa_block_grp1_;
  std::array< CaaBlockFreePtrMemoryEntryMutable, 32768 > caa_block_grp2_;
  std::array< CaaBlockFreePtrMemoryEntryMutable, 32768 > caa_block_grp3_;
  std::array< CaaBlockFreePtrMemoryEntryMutable, 32768 > caa_block_grp4_;
  std::array< CaaBlockFreePtrMemoryEntryMutable, 32768 > caa_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    return offset;
  }

};









class WacQacqApConfigEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqApConfigEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_ap_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_qacq_ap_config_entry), 1, false, write_callback, read_callback, std::string("WacQacqApConfigEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_qacq_ap_config_entry))
    {
    }
  WacQacqApConfigEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacQacqApConfigEntry")
    {
    }
public:
  uint8_t &sp_id() { return sp_id_; }
  uint8_t &yel_red_drop_en() { return yel_red_drop_en_; }
  uint8_t &gre_drop_en() { return gre_drop_en_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(sp_id_) & 0x3);
    *data0 |= ((static_cast<uint64_t>(yel_red_drop_en_) & 0x1) << 2);
    *data0 |= ((static_cast<uint64_t>(gre_drop_en_) & 0x1) << 3);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    sp_id_ = (data0 & 0x3);
    yel_red_drop_en_ = ((data0 >> 2) & 0x1);
    gre_drop_en_ = ((data0 >> 3) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    sp_id_ = 0;
    yel_red_drop_en_ = 0;
    gre_drop_en_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqApConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("sp_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sp_id_) ) + "\n";
    all_zeros &= (0 == sp_id_);
    r += indent_string + "  " + std::string("yel_red_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_red_drop_en_) ) + "\n";
    all_zeros &= (0 == yel_red_drop_en_);
    r += indent_string + "  " + std::string("gre_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_drop_en_) ) + "\n";
    all_zeros &= (0 == gre_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqApConfigEntry") + ":\n";
    r += indent_string + "  " + std::string("sp_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sp_id_) ) + "\n";
    all_zeros &= (0 == sp_id_);
    r += indent_string + "  " + std::string("yel_red_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_red_drop_en_) ) + "\n";
    all_zeros &= (0 == yel_red_drop_en_);
    r += indent_string + "  " + std::string("gre_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_drop_en_) ) + "\n";
    all_zeros &= (0 == gre_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t sp_id_;
  uint8_t yel_red_drop_en_;
  uint8_t gre_drop_en_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_ap_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_wac_qacq_ap_config
    assert(index_wac_qacq_ap_config_entry < 1152);
    offset += index_wac_qacq_ap_config_entry * 0x1; // wac_qacq_ap_config_entry[]
    return offset;
  }

};









class WacQacqApConfigEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqApConfigEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_ap_config_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_qacq_ap_config_entry), 1, true, write_callback, read_callback, std::string("WacQacqApConfigEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_qacq_ap_config_entry))
    {
    }
  WacQacqApConfigEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacQacqApConfigEntryMutable")
    {
    }
public:
  uint8_t sp_id() { return sp_id_; }
  void sp_id(const uint8_t &v) { sp_id_=v; }
  uint8_t yel_red_drop_en() { return yel_red_drop_en_; }
  void yel_red_drop_en(const uint8_t &v) { yel_red_drop_en_=v; }
  uint8_t gre_drop_en() { return gre_drop_en_; }
  void gre_drop_en(const uint8_t &v) { gre_drop_en_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(sp_id_) & 0x3);
    *data0 |= ((static_cast<uint64_t>(yel_red_drop_en_) & 0x1) << 2);
    *data0 |= ((static_cast<uint64_t>(gre_drop_en_) & 0x1) << 3);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    sp_id_ = (data0 & 0x3);
    yel_red_drop_en_ = ((data0 >> 2) & 0x1);
    gre_drop_en_ = ((data0 >> 3) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    sp_id_ = 0;
    yel_red_drop_en_ = 0;
    gre_drop_en_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqApConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("sp_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sp_id_) ) + "\n";
    all_zeros &= (0 == sp_id_);
    r += indent_string + "  " + std::string("yel_red_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_red_drop_en_) ) + "\n";
    all_zeros &= (0 == yel_red_drop_en_);
    r += indent_string + "  " + std::string("gre_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_drop_en_) ) + "\n";
    all_zeros &= (0 == gre_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqApConfigEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("sp_id") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sp_id_) ) + "\n";
    all_zeros &= (0 == sp_id_);
    r += indent_string + "  " + std::string("yel_red_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_red_drop_en_) ) + "\n";
    all_zeros &= (0 == yel_red_drop_en_);
    r += indent_string + "  " + std::string("gre_drop_en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_drop_en_) ) + "\n";
    all_zeros &= (0 == gre_drop_en_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t sp_id_;
  uint8_t yel_red_drop_en_;
  uint8_t gre_drop_en_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_ap_config_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_wac_qacq_ap_config
    assert(index_wac_qacq_ap_config_entry < 1152);
    offset += index_wac_qacq_ap_config_entry * 0x1; // wac_qacq_ap_config_entry[]
    return offset;
  }

};









class WacQacqApConfigEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacQacqApConfigEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacQacqApConfigEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &sp_id(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].sp_id();
  }
  uint8_t &yel_red_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_red_drop_en();
  }
  uint8_t &gre_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].gre_drop_en();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacQacqApConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacQacqApConfigEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacQacqApConfigEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_wac_qacq_ap_config
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacQacqApConfigEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacQacqApConfigEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacQacqApConfigEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t sp_id(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].sp_id();
  }
  void sp_id(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].sp_id(v);
  }
  uint8_t yel_red_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_red_drop_en();
  }
  void yel_red_drop_en(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].yel_red_drop_en(v);
  }
  uint8_t gre_drop_en(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].gre_drop_en();
  }
  void gre_drop_en(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].gre_drop_en(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacQacqApConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacQacqApConfigEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacQacqApConfigEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_wac_qacq_ap_config
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacQacqStateEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqStateEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_state_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_qacq_state_entry), 1, false, write_callback, read_callback, std::string("WacQacqStateEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_qacq_state_entry))
    {
    }
  WacQacqStateEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacQacqStateEntry")
    {
    }
public:
  uint8_t &nomin() { return nomin_; }
  uint8_t &red_off() { return red_off_; }
  uint8_t &yel_off() { return yel_off_; }
  uint8_t &gre_off() { return gre_off_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(nomin_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(red_off_) & 0x1) << 1);
    *data0 |= ((static_cast<uint64_t>(yel_off_) & 0x1) << 2);
    *data0 |= ((static_cast<uint64_t>(gre_off_) & 0x1) << 3);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    nomin_ = (data0 & 0x1);
    red_off_ = ((data0 >> 1) & 0x1);
    yel_off_ = ((data0 >> 2) & 0x1);
    gre_off_ = ((data0 >> 3) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    nomin_ = 0;
    red_off_ = 0;
    yel_off_ = 0;
    gre_off_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqStateEntry") + ":\n";
    r += indent_string + "  " + std::string("nomin") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nomin_) ) + "\n";
    all_zeros &= (0 == nomin_);
    r += indent_string + "  " + std::string("red_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_off_) ) + "\n";
    all_zeros &= (0 == red_off_);
    r += indent_string + "  " + std::string("yel_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_off_) ) + "\n";
    all_zeros &= (0 == yel_off_);
    r += indent_string + "  " + std::string("gre_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_off_) ) + "\n";
    all_zeros &= (0 == gre_off_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqStateEntry") + ":\n";
    r += indent_string + "  " + std::string("nomin") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nomin_) ) + "\n";
    all_zeros &= (0 == nomin_);
    r += indent_string + "  " + std::string("red_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_off_) ) + "\n";
    all_zeros &= (0 == red_off_);
    r += indent_string + "  " + std::string("yel_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_off_) ) + "\n";
    all_zeros &= (0 == yel_off_);
    r += indent_string + "  " + std::string("gre_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_off_) ) + "\n";
    all_zeros &= (0 == gre_off_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t nomin_;
  uint8_t red_off_;
  uint8_t yel_off_;
  uint8_t gre_off_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_state_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_wac_qacq_state
    assert(index_wac_qacq_state_entry < 1152);
    offset += index_wac_qacq_state_entry * 0x1; // wac_qacq_state_entry[]
    return offset;
  }

};









class WacQacqStateEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqStateEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_state_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_qacq_state_entry), 1, true, write_callback, read_callback, std::string("WacQacqStateEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_qacq_state_entry))
    {
    }
  WacQacqStateEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacQacqStateEntryMutable")
    {
    }
public:
  uint8_t nomin() { return nomin_; }
  void nomin(const uint8_t &v) { nomin_=v; }
  uint8_t red_off() { return red_off_; }
  void red_off(const uint8_t &v) { red_off_=v; }
  uint8_t yel_off() { return yel_off_; }
  void yel_off(const uint8_t &v) { yel_off_=v; }
  uint8_t gre_off() { return gre_off_; }
  void gre_off(const uint8_t &v) { gre_off_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(nomin_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(red_off_) & 0x1) << 1);
    *data0 |= ((static_cast<uint64_t>(yel_off_) & 0x1) << 2);
    *data0 |= ((static_cast<uint64_t>(gre_off_) & 0x1) << 3);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    nomin_ = (data0 & 0x1);
    red_off_ = ((data0 >> 1) & 0x1);
    yel_off_ = ((data0 >> 2) & 0x1);
    gre_off_ = ((data0 >> 3) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    nomin_ = 0;
    red_off_ = 0;
    yel_off_ = 0;
    gre_off_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqStateEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("nomin") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nomin_) ) + "\n";
    all_zeros &= (0 == nomin_);
    r += indent_string + "  " + std::string("red_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_off_) ) + "\n";
    all_zeros &= (0 == red_off_);
    r += indent_string + "  " + std::string("yel_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_off_) ) + "\n";
    all_zeros &= (0 == yel_off_);
    r += indent_string + "  " + std::string("gre_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_off_) ) + "\n";
    all_zeros &= (0 == gre_off_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQacqStateEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("nomin") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nomin_) ) + "\n";
    all_zeros &= (0 == nomin_);
    r += indent_string + "  " + std::string("red_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(red_off_) ) + "\n";
    all_zeros &= (0 == red_off_);
    r += indent_string + "  " + std::string("yel_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(yel_off_) ) + "\n";
    all_zeros &= (0 == yel_off_);
    r += indent_string + "  " + std::string("gre_off") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(gre_off_) ) + "\n";
    all_zeros &= (0 == gre_off_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t nomin_;
  uint8_t red_off_;
  uint8_t yel_off_;
  uint8_t gre_off_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_qacq_state_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_wac_qacq_state
    assert(index_wac_qacq_state_entry < 1152);
    offset += index_wac_qacq_state_entry * 0x1; // wac_qacq_state_entry[]
    return offset;
  }

};









class WacQacqStateEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacQacqStateEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacQacqStateEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &nomin(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nomin();
  }
  uint8_t &red_off(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].red_off();
  }
  uint8_t &yel_off(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_off();
  }
  uint8_t &gre_off(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].gre_off();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacQacqStateEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacQacqStateEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacQacqStateEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_wac_qacq_state
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacQacqStateEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacQacqStateEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacQacqStateEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t nomin(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nomin();
  }
  void nomin(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].nomin(v);
  }
  uint8_t red_off(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].red_off();
  }
  void red_off(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].red_off(v);
  }
  uint8_t yel_off(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].yel_off();
  }
  void yel_off(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].yel_off(v);
  }
  uint8_t gre_off(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].gre_off();
  }
  void gre_off(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].gre_off(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacQacqStateEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacQacqStateEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacQacqStateEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_wac_qacq_state
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1152;
        break;
      case 0:
        return 1152;
        break;
      default:
        assert(0);
        break;
    }
  }

};











class WacQidMapEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQidMapEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_qid_map_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_qid_map_entry), 1, false, write_callback, read_callback, std::string("WacQidMapEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_qid_map_entry))
    {
    }
  WacQidMapEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacQidMapEntry")
    {
    }
public:
  uint8_t &qid_mid0() { return qid_mid0_; }
  uint8_t &qid_mid1() { return qid_mid1_; }
  uint8_t &qid_mid2() { return qid_mid2_; }
  uint8_t &qid_mid3() { return qid_mid3_; }
  uint8_t &qid_mid4() { return qid_mid4_; }
  uint8_t &qid_mid5() { return qid_mid5_; }
  uint8_t &qid_mid6() { return qid_mid6_; }
  uint8_t &qid_mid7() { return qid_mid7_; }
  uint8_t &qid_mid8() { return qid_mid8_; }
  uint8_t &qid_mid9() { return qid_mid9_; }
  uint8_t &qid_mid10() { return qid_mid10_; }
  uint8_t &qid_mid11() { return qid_mid11_; }
  uint8_t &qid_mid12() { return qid_mid12_; }
  uint8_t &qid_mid13() { return qid_mid13_; }
  uint8_t &qid_mid14() { return qid_mid14_; }
  uint8_t &qid_mid15() { return qid_mid15_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(qid_mid0_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(qid_mid1_) & 0x1f) << 5);
    *data0 |= ((static_cast<uint64_t>(qid_mid2_) & 0x1f) << 10);
    *data0 |= ((static_cast<uint64_t>(qid_mid3_) & 0x1f) << 15);
    *data0 |= ((static_cast<uint64_t>(qid_mid4_) & 0x1f) << 20);
    *data0 |= ((static_cast<uint64_t>(qid_mid5_) & 0x1f) << 25);
    *data0 |= ((static_cast<uint64_t>(qid_mid6_) & 0x1f) << 30);
    *data0 |= ((static_cast<uint64_t>(qid_mid7_) & 0x1f) << 35);
    *data0 |= ((static_cast<uint64_t>(qid_mid8_) & 0x1f) << 40);
    *data0 |= ((static_cast<uint64_t>(qid_mid9_) & 0x1f) << 45);
    *data0 |= ((static_cast<uint64_t>(qid_mid10_) & 0x1f) << 50);
    *data0 |= ((static_cast<uint64_t>(qid_mid11_) & 0x1f) << 55);
    *data0 |= ((static_cast<uint64_t>(qid_mid12_) & 0xf) << 60);
    *data1 = ((static_cast<uint64_t>(qid_mid12_) & 0x10) >> 4);
    *data1 |= ((static_cast<uint64_t>(qid_mid13_) & 0x1f) << 1);
    *data1 |= ((static_cast<uint64_t>(qid_mid14_) & 0x1f) << 6);
    *data1 |= ((static_cast<uint64_t>(qid_mid15_) & 0x1f) << 11);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    qid_mid0_ = (data0 & 0x1f);
    qid_mid1_ = ((data0 >> 5) & 0x1f);
    qid_mid2_ = ((data0 >> 10) & 0x1f);
    qid_mid3_ = ((data0 >> 15) & 0x1f);
    qid_mid4_ = ((data0 >> 20) & 0x1f);
    qid_mid5_ = ((data0 >> 25) & 0x1f);
    qid_mid6_ = ((data0 >> 30) & 0x1f);
    qid_mid7_ = ((data0 >> 35) & 0x1f);
    qid_mid8_ = ((data0 >> 40) & 0x1f);
    qid_mid9_ = ((data0 >> 45) & 0x1f);
    qid_mid10_ = ((data0 >> 50) & 0x1f);
    qid_mid11_ = ((data0 >> 55) & 0x1f);
    qid_mid12_ = (((data0 >> 60) & 0xf) | (qid_mid12_ & 0x10));
    qid_mid12_ = (((data1 << 4) & 0x10) | (qid_mid12_ & 0xf));
    qid_mid13_ = ((data1 >> 1) & 0x1f);
    qid_mid14_ = ((data1 >> 6) & 0x1f);
    qid_mid15_ = ((data1 >> 11) & 0x1f);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    qid_mid0_ = 0;
    qid_mid1_ = 0;
    qid_mid2_ = 0;
    qid_mid3_ = 0;
    qid_mid4_ = 0;
    qid_mid5_ = 0;
    qid_mid6_ = 0;
    qid_mid7_ = 0;
    qid_mid8_ = 0;
    qid_mid9_ = 0;
    qid_mid10_ = 0;
    qid_mid11_ = 0;
    qid_mid12_ = 0;
    qid_mid13_ = 0;
    qid_mid14_ = 0;
    qid_mid15_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQidMapEntry") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    r += indent_string + "  " + std::string("qid_mid8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid8_) ) + "\n";
    all_zeros &= (0 == qid_mid8_);
    r += indent_string + "  " + std::string("qid_mid9") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid9_) ) + "\n";
    all_zeros &= (0 == qid_mid9_);
    r += indent_string + "  " + std::string("qid_mid10") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid10_) ) + "\n";
    all_zeros &= (0 == qid_mid10_);
    r += indent_string + "  " + std::string("qid_mid11") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid11_) ) + "\n";
    all_zeros &= (0 == qid_mid11_);
    r += indent_string + "  " + std::string("qid_mid12") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid12_) ) + "\n";
    all_zeros &= (0 == qid_mid12_);
    r += indent_string + "  " + std::string("qid_mid13") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid13_) ) + "\n";
    all_zeros &= (0 == qid_mid13_);
    r += indent_string + "  " + std::string("qid_mid14") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid14_) ) + "\n";
    all_zeros &= (0 == qid_mid14_);
    r += indent_string + "  " + std::string("qid_mid15") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid15_) ) + "\n";
    all_zeros &= (0 == qid_mid15_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQidMapEntry") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    r += indent_string + "  " + std::string("qid_mid8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid8_) ) + "\n";
    all_zeros &= (0 == qid_mid8_);
    r += indent_string + "  " + std::string("qid_mid9") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid9_) ) + "\n";
    all_zeros &= (0 == qid_mid9_);
    r += indent_string + "  " + std::string("qid_mid10") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid10_) ) + "\n";
    all_zeros &= (0 == qid_mid10_);
    r += indent_string + "  " + std::string("qid_mid11") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid11_) ) + "\n";
    all_zeros &= (0 == qid_mid11_);
    r += indent_string + "  " + std::string("qid_mid12") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid12_) ) + "\n";
    all_zeros &= (0 == qid_mid12_);
    r += indent_string + "  " + std::string("qid_mid13") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid13_) ) + "\n";
    all_zeros &= (0 == qid_mid13_);
    r += indent_string + "  " + std::string("qid_mid14") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid14_) ) + "\n";
    all_zeros &= (0 == qid_mid14_);
    r += indent_string + "  " + std::string("qid_mid15") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid15_) ) + "\n";
    all_zeros &= (0 == qid_mid15_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t qid_mid0_;
  uint8_t qid_mid1_;
  uint8_t qid_mid2_;
  uint8_t qid_mid3_;
  uint8_t qid_mid4_;
  uint8_t qid_mid5_;
  uint8_t qid_mid6_;
  uint8_t qid_mid7_;
  uint8_t qid_mid8_;
  uint8_t qid_mid9_;
  uint8_t qid_mid10_;
  uint8_t qid_mid11_;
  uint8_t qid_mid12_;
  uint8_t qid_mid13_;
  uint8_t qid_mid14_;
  uint8_t qid_mid15_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_qid_map_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_wac_qid_map
    assert(index_wac_qid_map_entry < 576);
    offset += index_wac_qid_map_entry * 0x1; // wac_qid_map_entry[]
    return offset;
  }

};











class WacQidMapEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQidMapEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_qid_map_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_qid_map_entry), 1, true, write_callback, read_callback, std::string("WacQidMapEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_qid_map_entry))
    {
    }
  WacQidMapEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacQidMapEntryMutable")
    {
    }
public:
  uint8_t qid_mid0() { return qid_mid0_; }
  void qid_mid0(const uint8_t &v) { qid_mid0_=v; }
  uint8_t qid_mid1() { return qid_mid1_; }
  void qid_mid1(const uint8_t &v) { qid_mid1_=v; }
  uint8_t qid_mid2() { return qid_mid2_; }
  void qid_mid2(const uint8_t &v) { qid_mid2_=v; }
  uint8_t qid_mid3() { return qid_mid3_; }
  void qid_mid3(const uint8_t &v) { qid_mid3_=v; }
  uint8_t qid_mid4() { return qid_mid4_; }
  void qid_mid4(const uint8_t &v) { qid_mid4_=v; }
  uint8_t qid_mid5() { return qid_mid5_; }
  void qid_mid5(const uint8_t &v) { qid_mid5_=v; }
  uint8_t qid_mid6() { return qid_mid6_; }
  void qid_mid6(const uint8_t &v) { qid_mid6_=v; }
  uint8_t qid_mid7() { return qid_mid7_; }
  void qid_mid7(const uint8_t &v) { qid_mid7_=v; }
  uint8_t qid_mid8() { return qid_mid8_; }
  void qid_mid8(const uint8_t &v) { qid_mid8_=v; }
  uint8_t qid_mid9() { return qid_mid9_; }
  void qid_mid9(const uint8_t &v) { qid_mid9_=v; }
  uint8_t qid_mid10() { return qid_mid10_; }
  void qid_mid10(const uint8_t &v) { qid_mid10_=v; }
  uint8_t qid_mid11() { return qid_mid11_; }
  void qid_mid11(const uint8_t &v) { qid_mid11_=v; }
  uint8_t qid_mid12() { return qid_mid12_; }
  void qid_mid12(const uint8_t &v) { qid_mid12_=v; }
  uint8_t qid_mid13() { return qid_mid13_; }
  void qid_mid13(const uint8_t &v) { qid_mid13_=v; }
  uint8_t qid_mid14() { return qid_mid14_; }
  void qid_mid14(const uint8_t &v) { qid_mid14_=v; }
  uint8_t qid_mid15() { return qid_mid15_; }
  void qid_mid15(const uint8_t &v) { qid_mid15_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(qid_mid0_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(qid_mid1_) & 0x1f) << 5);
    *data0 |= ((static_cast<uint64_t>(qid_mid2_) & 0x1f) << 10);
    *data0 |= ((static_cast<uint64_t>(qid_mid3_) & 0x1f) << 15);
    *data0 |= ((static_cast<uint64_t>(qid_mid4_) & 0x1f) << 20);
    *data0 |= ((static_cast<uint64_t>(qid_mid5_) & 0x1f) << 25);
    *data0 |= ((static_cast<uint64_t>(qid_mid6_) & 0x1f) << 30);
    *data0 |= ((static_cast<uint64_t>(qid_mid7_) & 0x1f) << 35);
    *data0 |= ((static_cast<uint64_t>(qid_mid8_) & 0x1f) << 40);
    *data0 |= ((static_cast<uint64_t>(qid_mid9_) & 0x1f) << 45);
    *data0 |= ((static_cast<uint64_t>(qid_mid10_) & 0x1f) << 50);
    *data0 |= ((static_cast<uint64_t>(qid_mid11_) & 0x1f) << 55);
    *data0 |= ((static_cast<uint64_t>(qid_mid12_) & 0xf) << 60);
    *data1 = ((static_cast<uint64_t>(qid_mid12_) & 0x10) >> 4);
    *data1 |= ((static_cast<uint64_t>(qid_mid13_) & 0x1f) << 1);
    *data1 |= ((static_cast<uint64_t>(qid_mid14_) & 0x1f) << 6);
    *data1 |= ((static_cast<uint64_t>(qid_mid15_) & 0x1f) << 11);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    qid_mid0_ = (data0 & 0x1f);
    qid_mid1_ = ((data0 >> 5) & 0x1f);
    qid_mid2_ = ((data0 >> 10) & 0x1f);
    qid_mid3_ = ((data0 >> 15) & 0x1f);
    qid_mid4_ = ((data0 >> 20) & 0x1f);
    qid_mid5_ = ((data0 >> 25) & 0x1f);
    qid_mid6_ = ((data0 >> 30) & 0x1f);
    qid_mid7_ = ((data0 >> 35) & 0x1f);
    qid_mid8_ = ((data0 >> 40) & 0x1f);
    qid_mid9_ = ((data0 >> 45) & 0x1f);
    qid_mid10_ = ((data0 >> 50) & 0x1f);
    qid_mid11_ = ((data0 >> 55) & 0x1f);
    qid_mid12_ = (((data0 >> 60) & 0xf) | (qid_mid12_ & 0x10));
    qid_mid12_ = (((data1 << 4) & 0x10) | (qid_mid12_ & 0xf));
    qid_mid13_ = ((data1 >> 1) & 0x1f);
    qid_mid14_ = ((data1 >> 6) & 0x1f);
    qid_mid15_ = ((data1 >> 11) & 0x1f);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    qid_mid0_ = 0;
    qid_mid1_ = 0;
    qid_mid2_ = 0;
    qid_mid3_ = 0;
    qid_mid4_ = 0;
    qid_mid5_ = 0;
    qid_mid6_ = 0;
    qid_mid7_ = 0;
    qid_mid8_ = 0;
    qid_mid9_ = 0;
    qid_mid10_ = 0;
    qid_mid11_ = 0;
    qid_mid12_ = 0;
    qid_mid13_ = 0;
    qid_mid14_ = 0;
    qid_mid15_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQidMapEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    r += indent_string + "  " + std::string("qid_mid8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid8_) ) + "\n";
    all_zeros &= (0 == qid_mid8_);
    r += indent_string + "  " + std::string("qid_mid9") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid9_) ) + "\n";
    all_zeros &= (0 == qid_mid9_);
    r += indent_string + "  " + std::string("qid_mid10") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid10_) ) + "\n";
    all_zeros &= (0 == qid_mid10_);
    r += indent_string + "  " + std::string("qid_mid11") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid11_) ) + "\n";
    all_zeros &= (0 == qid_mid11_);
    r += indent_string + "  " + std::string("qid_mid12") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid12_) ) + "\n";
    all_zeros &= (0 == qid_mid12_);
    r += indent_string + "  " + std::string("qid_mid13") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid13_) ) + "\n";
    all_zeros &= (0 == qid_mid13_);
    r += indent_string + "  " + std::string("qid_mid14") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid14_) ) + "\n";
    all_zeros &= (0 == qid_mid14_);
    r += indent_string + "  " + std::string("qid_mid15") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid15_) ) + "\n";
    all_zeros &= (0 == qid_mid15_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacQidMapEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("qid_mid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid0_) ) + "\n";
    all_zeros &= (0 == qid_mid0_);
    r += indent_string + "  " + std::string("qid_mid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid1_) ) + "\n";
    all_zeros &= (0 == qid_mid1_);
    r += indent_string + "  " + std::string("qid_mid2") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid2_) ) + "\n";
    all_zeros &= (0 == qid_mid2_);
    r += indent_string + "  " + std::string("qid_mid3") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid3_) ) + "\n";
    all_zeros &= (0 == qid_mid3_);
    r += indent_string + "  " + std::string("qid_mid4") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid4_) ) + "\n";
    all_zeros &= (0 == qid_mid4_);
    r += indent_string + "  " + std::string("qid_mid5") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid5_) ) + "\n";
    all_zeros &= (0 == qid_mid5_);
    r += indent_string + "  " + std::string("qid_mid6") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid6_) ) + "\n";
    all_zeros &= (0 == qid_mid6_);
    r += indent_string + "  " + std::string("qid_mid7") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid7_) ) + "\n";
    all_zeros &= (0 == qid_mid7_);
    r += indent_string + "  " + std::string("qid_mid8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid8_) ) + "\n";
    all_zeros &= (0 == qid_mid8_);
    r += indent_string + "  " + std::string("qid_mid9") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid9_) ) + "\n";
    all_zeros &= (0 == qid_mid9_);
    r += indent_string + "  " + std::string("qid_mid10") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid10_) ) + "\n";
    all_zeros &= (0 == qid_mid10_);
    r += indent_string + "  " + std::string("qid_mid11") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid11_) ) + "\n";
    all_zeros &= (0 == qid_mid11_);
    r += indent_string + "  " + std::string("qid_mid12") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid12_) ) + "\n";
    all_zeros &= (0 == qid_mid12_);
    r += indent_string + "  " + std::string("qid_mid13") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid13_) ) + "\n";
    all_zeros &= (0 == qid_mid13_);
    r += indent_string + "  " + std::string("qid_mid14") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid14_) ) + "\n";
    all_zeros &= (0 == qid_mid14_);
    r += indent_string + "  " + std::string("qid_mid15") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(qid_mid15_) ) + "\n";
    all_zeros &= (0 == qid_mid15_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t qid_mid0_;
  uint8_t qid_mid1_;
  uint8_t qid_mid2_;
  uint8_t qid_mid3_;
  uint8_t qid_mid4_;
  uint8_t qid_mid5_;
  uint8_t qid_mid6_;
  uint8_t qid_mid7_;
  uint8_t qid_mid8_;
  uint8_t qid_mid9_;
  uint8_t qid_mid10_;
  uint8_t qid_mid11_;
  uint8_t qid_mid12_;
  uint8_t qid_mid13_;
  uint8_t qid_mid14_;
  uint8_t qid_mid15_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_qid_map_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_wac_qid_map
    assert(index_wac_qid_map_entry < 576);
    offset += index_wac_qid_map_entry * 0x1; // wac_qid_map_entry[]
    return offset;
  }

};











class WacQidMapEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacQidMapEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacQidMapEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &qid_mid0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid0();
  }
  uint8_t &qid_mid1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid1();
  }
  uint8_t &qid_mid2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid2();
  }
  uint8_t &qid_mid3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid3();
  }
  uint8_t &qid_mid4(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid4();
  }
  uint8_t &qid_mid5(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid5();
  }
  uint8_t &qid_mid6(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid6();
  }
  uint8_t &qid_mid7(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid7();
  }
  uint8_t &qid_mid8(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid8();
  }
  uint8_t &qid_mid9(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid9();
  }
  uint8_t &qid_mid10(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid10();
  }
  uint8_t &qid_mid11(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid11();
  }
  uint8_t &qid_mid12(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid12();
  }
  uint8_t &qid_mid13(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid13();
  }
  uint8_t &qid_mid14(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid14();
  }
  uint8_t &qid_mid15(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid15();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacQidMapEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacQidMapEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacQidMapEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_wac_qid_map
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 576;
        break;
      case 0:
        return 576;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 576;
        break;
      case 0:
        return 576;
        break;
      default:
        assert(0);
        break;
    }
  }

};











class WacQidMapEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacQidMapEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacQidMapEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t qid_mid0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid0();
  }
  void qid_mid0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid0(v);
  }
  uint8_t qid_mid1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid1();
  }
  void qid_mid1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid1(v);
  }
  uint8_t qid_mid2(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid2();
  }
  void qid_mid2(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid2(v);
  }
  uint8_t qid_mid3(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid3();
  }
  void qid_mid3(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid3(v);
  }
  uint8_t qid_mid4(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid4();
  }
  void qid_mid4(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid4(v);
  }
  uint8_t qid_mid5(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid5();
  }
  void qid_mid5(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid5(v);
  }
  uint8_t qid_mid6(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid6();
  }
  void qid_mid6(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid6(v);
  }
  uint8_t qid_mid7(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid7();
  }
  void qid_mid7(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid7(v);
  }
  uint8_t qid_mid8(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid8();
  }
  void qid_mid8(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid8(v);
  }
  uint8_t qid_mid9(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid9();
  }
  void qid_mid9(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid9(v);
  }
  uint8_t qid_mid10(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid10();
  }
  void qid_mid10(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid10(v);
  }
  uint8_t qid_mid11(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid11();
  }
  void qid_mid11(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid11(v);
  }
  uint8_t qid_mid12(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid12();
  }
  void qid_mid12(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid12(v);
  }
  uint8_t qid_mid13(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid13();
  }
  void qid_mid13(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid13(v);
  }
  uint8_t qid_mid14(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid14();
  }
  void qid_mid14(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid14(v);
  }
  uint8_t qid_mid15(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].qid_mid15();
  }
  void qid_mid15(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].qid_mid15(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacQidMapEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacQidMapEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacQidMapEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_wac_qid_map
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 576;
        break;
      case 0:
        return 576;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 576;
        break;
      case 0:
        return 576;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class WacPfcStatePfcState : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPfcStatePfcState(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pfc_state_pfc_state, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pfc_state_pfc_state), 1, false, write_callback, read_callback, std::string("WacPfcStatePfcState")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pfc_state_pfc_state))
    {
    }
  WacPfcStatePfcState(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPfcStatePfcState")
    {
    }
public:
  uint8_t &port_ppg_state() { return port_ppg_state_; }
  uint8_t &rm_pfc_state() { return rm_pfc_state_; }
  uint8_t &mac_pfc_out() { return mac_pfc_out_; }
  uint8_t &mac_pause_out() { return mac_pause_out_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(port_ppg_state_);
    *data0 |= (static_cast<uint64_t>(rm_pfc_state_) << 8);
    *data0 |= (static_cast<uint64_t>(mac_pfc_out_) << 16);
    *data0 |= ((static_cast<uint64_t>(mac_pause_out_) & 0x1) << 24);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    port_ppg_state_ = data0;
    rm_pfc_state_ = (data0 >> 8);
    mac_pfc_out_ = (data0 >> 16);
    mac_pause_out_ = ((data0 >> 24) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    port_ppg_state_ = 0;
    rm_pfc_state_ = 0;
    mac_pfc_out_ = 0;
    mac_pause_out_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPfcStatePfcState") + ":\n";
    r += indent_string + "  " + std::string("port_ppg_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_ppg_state_) ) + "\n";
    all_zeros &= (0 == port_ppg_state_);
    r += indent_string + "  " + std::string("rm_pfc_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rm_pfc_state_) ) + "\n";
    all_zeros &= (0 == rm_pfc_state_);
    r += indent_string + "  " + std::string("mac_pfc_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pfc_out_) ) + "\n";
    all_zeros &= (0 == mac_pfc_out_);
    r += indent_string + "  " + std::string("mac_pause_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pause_out_) ) + "\n";
    all_zeros &= (0 == mac_pause_out_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPfcStatePfcState") + ":\n";
    r += indent_string + "  " + std::string("port_ppg_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_ppg_state_) ) + "\n";
    all_zeros &= (0 == port_ppg_state_);
    r += indent_string + "  " + std::string("rm_pfc_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rm_pfc_state_) ) + "\n";
    all_zeros &= (0 == rm_pfc_state_);
    r += indent_string + "  " + std::string("mac_pfc_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pfc_out_) ) + "\n";
    all_zeros &= (0 == mac_pfc_out_);
    r += indent_string + "  " + std::string("mac_pause_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pause_out_) ) + "\n";
    all_zeros &= (0 == mac_pause_out_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t port_ppg_state_;
  uint8_t rm_pfc_state_;
  uint8_t mac_pfc_out_;
  uint8_t mac_pause_out_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pfc_state_pfc_state
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf80; // to get to csr_memory_wac_pfc_state
    assert(index_wac_pfc_state_pfc_state < 72);
    offset += index_wac_pfc_state_pfc_state * 0x1; // wac_pfc_state_pfc_state[]
    return offset;
  }

};










class WacPfcStatePfcStateMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPfcStatePfcStateMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pfc_state_pfc_state, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pfc_state_pfc_state), 1, true, write_callback, read_callback, std::string("WacPfcStatePfcStateMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pfc_state_pfc_state))
    {
    }
  WacPfcStatePfcStateMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPfcStatePfcStateMutable")
    {
    }
public:
  uint8_t port_ppg_state() { return port_ppg_state_; }
  void port_ppg_state(const uint8_t &v) { port_ppg_state_=v; }
  uint8_t rm_pfc_state() { return rm_pfc_state_; }
  void rm_pfc_state(const uint8_t &v) { rm_pfc_state_=v; }
  uint8_t mac_pfc_out() { return mac_pfc_out_; }
  void mac_pfc_out(const uint8_t &v) { mac_pfc_out_=v; }
  uint8_t mac_pause_out() { return mac_pause_out_; }
  void mac_pause_out(const uint8_t &v) { mac_pause_out_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(port_ppg_state_);
    *data0 |= (static_cast<uint64_t>(rm_pfc_state_) << 8);
    *data0 |= (static_cast<uint64_t>(mac_pfc_out_) << 16);
    *data0 |= ((static_cast<uint64_t>(mac_pause_out_) & 0x1) << 24);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    port_ppg_state_ = data0;
    rm_pfc_state_ = (data0 >> 8);
    mac_pfc_out_ = (data0 >> 16);
    mac_pause_out_ = ((data0 >> 24) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    port_ppg_state_ = 0;
    rm_pfc_state_ = 0;
    mac_pfc_out_ = 0;
    mac_pause_out_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPfcStatePfcStateMutable") + ":\n";
    r += indent_string + "  " + std::string("port_ppg_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_ppg_state_) ) + "\n";
    all_zeros &= (0 == port_ppg_state_);
    r += indent_string + "  " + std::string("rm_pfc_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rm_pfc_state_) ) + "\n";
    all_zeros &= (0 == rm_pfc_state_);
    r += indent_string + "  " + std::string("mac_pfc_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pfc_out_) ) + "\n";
    all_zeros &= (0 == mac_pfc_out_);
    r += indent_string + "  " + std::string("mac_pause_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pause_out_) ) + "\n";
    all_zeros &= (0 == mac_pause_out_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPfcStatePfcStateMutable") + ":\n";
    r += indent_string + "  " + std::string("port_ppg_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(port_ppg_state_) ) + "\n";
    all_zeros &= (0 == port_ppg_state_);
    r += indent_string + "  " + std::string("rm_pfc_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rm_pfc_state_) ) + "\n";
    all_zeros &= (0 == rm_pfc_state_);
    r += indent_string + "  " + std::string("mac_pfc_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pfc_out_) ) + "\n";
    all_zeros &= (0 == mac_pfc_out_);
    r += indent_string + "  " + std::string("mac_pause_out") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mac_pause_out_) ) + "\n";
    all_zeros &= (0 == mac_pause_out_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t port_ppg_state_;
  uint8_t rm_pfc_state_;
  uint8_t mac_pfc_out_;
  uint8_t mac_pause_out_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pfc_state_pfc_state
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf80; // to get to csr_memory_wac_pfc_state
    assert(index_wac_pfc_state_pfc_state < 72);
    offset += index_wac_pfc_state_pfc_state * 0x1; // wac_pfc_state_pfc_state[]
    return offset;
  }

};










class WacPfcStatePfcStateArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPfcStatePfcStateArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPfcStatePfcStateArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &port_ppg_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_ppg_state();
  }
  uint8_t &rm_pfc_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rm_pfc_state();
  }
  uint8_t &mac_pfc_out(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mac_pfc_out();
  }
  uint8_t &mac_pause_out(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mac_pause_out();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPfcStatePfcStateArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPfcStatePfcStateArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPfcStatePfcState> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf80; // to get to csr_memory_wac_pfc_state
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class WacPfcStatePfcStateArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPfcStatePfcStateArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPfcStatePfcStateArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t port_ppg_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_ppg_state();
  }
  void port_ppg_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].port_ppg_state(v);
  }
  uint8_t rm_pfc_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rm_pfc_state();
  }
  void rm_pfc_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rm_pfc_state(v);
  }
  uint8_t mac_pfc_out(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mac_pfc_out();
  }
  void mac_pfc_out(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mac_pfc_out(v);
  }
  uint8_t mac_pause_out(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mac_pause_out();
  }
  void mac_pause_out(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mac_pause_out(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPfcStatePfcStateArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPfcStatePfcStateArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPfcStatePfcStateMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf80; // to get to csr_memory_wac_pfc_state
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class WacDropCountPortDropCnt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPortDropCnt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_port_drop_cnt, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_drop_count_port_drop_cnt), 1, false, write_callback, read_callback, std::string("WacDropCountPortDropCnt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_drop_count_port_drop_cnt))
    {
    }
  WacDropCountPortDropCnt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacDropCountPortDropCnt")
    {
    }
public:
  uint64_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPortDropCnt") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPortDropCnt") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_port_drop_cnt
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf00; // to get to csr_memory_wac_drop_count_port
    assert(index_wac_drop_count_port_drop_cnt < 73);
    offset += index_wac_drop_count_port_drop_cnt * 0x1; // wac_drop_count_port_drop_cnt[]
    return offset;
  }

};










class WacDropCountPortDropCntMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPortDropCntMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_port_drop_cnt, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_drop_count_port_drop_cnt), 1, true, write_callback, read_callback, std::string("WacDropCountPortDropCntMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_drop_count_port_drop_cnt))
    {
    }
  WacDropCountPortDropCntMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacDropCountPortDropCntMutable")
    {
    }
public:
  uint64_t cnt() { return cnt_; }
  void cnt(const uint64_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPortDropCntMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPortDropCntMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_port_drop_cnt
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf00; // to get to csr_memory_wac_drop_count_port
    assert(index_wac_drop_count_port_drop_cnt < 73);
    offset += index_wac_drop_count_port_drop_cnt * 0x1; // wac_drop_count_port_drop_cnt[]
    return offset;
  }

};










class WacDropCountPortDropCntArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacDropCountPortDropCntArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacDropCountPortDropCntArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacDropCountPortDropCntArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacDropCountPortDropCntArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacDropCountPortDropCnt> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf00; // to get to csr_memory_wac_drop_count_port
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};










class WacDropCountPortDropCntArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacDropCountPortDropCntArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacDropCountPortDropCntArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint64_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacDropCountPortDropCntArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacDropCountPortDropCntArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacDropCountPortDropCntMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf00; // to get to csr_memory_wac_drop_count_port
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};















class WacDropCountPpgDropCnt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPpgDropCnt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_ppg_drop_cnt, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_drop_count_ppg_drop_cnt), 1, false, write_callback, read_callback, std::string("WacDropCountPpgDropCnt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_drop_count_ppg_drop_cnt))
    {
    }
  WacDropCountPpgDropCnt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacDropCountPpgDropCnt")
    {
    }
public:
  uint64_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPpgDropCnt") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPpgDropCnt") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_ppg_drop_cnt
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xe00; // to get to csr_memory_wac_drop_count_ppg
    assert(index_wac_drop_count_ppg_drop_cnt < 201);
    offset += index_wac_drop_count_ppg_drop_cnt * 0x1; // wac_drop_count_ppg_drop_cnt[]
    return offset;
  }

};















class WacDropCountPpgDropCntMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPpgDropCntMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_ppg_drop_cnt, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_drop_count_ppg_drop_cnt), 1, true, write_callback, read_callback, std::string("WacDropCountPpgDropCntMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_drop_count_ppg_drop_cnt))
    {
    }
  WacDropCountPpgDropCntMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacDropCountPpgDropCntMutable")
    {
    }
public:
  uint64_t cnt() { return cnt_; }
  void cnt(const uint64_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & UINT64_C(0xffffffffff));
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & UINT64_C(0xffffffffff));
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPpgDropCntMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacDropCountPpgDropCntMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_drop_count_ppg_drop_cnt
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xe00; // to get to csr_memory_wac_drop_count_ppg
    assert(index_wac_drop_count_ppg_drop_cnt < 201);
    offset += index_wac_drop_count_ppg_drop_cnt * 0x1; // wac_drop_count_ppg_drop_cnt[]
    return offset;
  }

};















class WacDropCountPpgDropCntArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacDropCountPpgDropCntArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacDropCountPpgDropCntArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacDropCountPpgDropCntArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacDropCountPpgDropCntArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacDropCountPpgDropCnt> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xe00; // to get to csr_memory_wac_drop_count_ppg
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

};















class WacDropCountPpgDropCntArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacDropCountPpgDropCntArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacDropCountPpgDropCntArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint64_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint64_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacDropCountPpgDropCntArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacDropCountPpgDropCntArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacDropCountPpgDropCntMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xe00; // to get to csr_memory_wac_drop_count_ppg
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgWmCntWmCnt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgWmCntWmCnt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pg_wm_cnt_wm_cnt, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pg_wm_cnt_wm_cnt), 1, false, write_callback, read_callback, std::string("WacPgWmCntWmCnt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_wm_cnt_wm_cnt))
    {
    }
  WacPgWmCntWmCnt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgWmCntWmCnt")
    {
    }
public:
  uint32_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgWmCntWmCnt") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgWmCntWmCnt") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pg_wm_cnt_wm_cnt
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xd00; // to get to csr_memory_wac_pg_wm_cnt
    assert(index_wac_pg_wm_cnt_wm_cnt < 201);
    offset += index_wac_pg_wm_cnt_wm_cnt * 0x1; // wac_pg_wm_cnt_wm_cnt[]
    return offset;
  }

};









class WacPgWmCntWmCntMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgWmCntWmCntMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pg_wm_cnt_wm_cnt, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pg_wm_cnt_wm_cnt), 1, true, write_callback, read_callback, std::string("WacPgWmCntWmCntMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_wm_cnt_wm_cnt))
    {
    }
  WacPgWmCntWmCntMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgWmCntWmCntMutable")
    {
    }
public:
  uint32_t cnt() { return cnt_; }
  void cnt(const uint32_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgWmCntWmCntMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgWmCntWmCntMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pg_wm_cnt_wm_cnt
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xd00; // to get to csr_memory_wac_pg_wm_cnt
    assert(index_wac_pg_wm_cnt_wm_cnt < 201);
    offset += index_wac_pg_wm_cnt_wm_cnt * 0x1; // wac_pg_wm_cnt_wm_cnt[]
    return offset;
  }

};









class WacPgWmCntWmCntArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPgWmCntWmCntArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPgWmCntWmCntArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgWmCntWmCntArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgWmCntWmCntArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgWmCntWmCnt> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xd00; // to get to csr_memory_wac_pg_wm_cnt
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgWmCntWmCntArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPgWmCntWmCntArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPgWmCntWmCntArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgWmCntWmCntArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgWmCntWmCntArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgWmCntWmCntMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xd00; // to get to csr_memory_wac_pg_wm_cnt
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 201;
        break;
      case 0:
        return 201;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPortStEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortStEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_port_st_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_port_st_entry), 1, false, write_callback, read_callback, std::string("WacPortStEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_st_entry))
    {
    }
  WacPortStEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortStEntry")
    {
    }
public:
  uint8_t &shr_lmt() { return shr_lmt_; }
  uint8_t &hdr_lmt() { return hdr_lmt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(shr_lmt_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(hdr_lmt_) & 0x1) << 1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    shr_lmt_ = (data0 & 0x1);
    hdr_lmt_ = ((data0 >> 1) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    shr_lmt_ = 0;
    hdr_lmt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortStEntry") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("hdr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_lmt_) ) + "\n";
    all_zeros &= (0 == hdr_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortStEntry") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("hdr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_lmt_) ) + "\n";
    all_zeros &= (0 == hdr_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t shr_lmt_;
  uint8_t hdr_lmt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_port_st_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xc80; // to get to csr_memory_wac_port_st
    assert(index_wac_port_st_entry < 73);
    offset += index_wac_port_st_entry * 0x1; // wac_port_st_entry[]
    return offset;
  }

};








class WacPortStEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortStEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_port_st_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_port_st_entry), 1, true, write_callback, read_callback, std::string("WacPortStEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_st_entry))
    {
    }
  WacPortStEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortStEntryMutable")
    {
    }
public:
  uint8_t shr_lmt() { return shr_lmt_; }
  void shr_lmt(const uint8_t &v) { shr_lmt_=v; }
  uint8_t hdr_lmt() { return hdr_lmt_; }
  void hdr_lmt(const uint8_t &v) { hdr_lmt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(shr_lmt_) & 0x1);
    *data0 |= ((static_cast<uint64_t>(hdr_lmt_) & 0x1) << 1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    shr_lmt_ = (data0 & 0x1);
    hdr_lmt_ = ((data0 >> 1) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    shr_lmt_ = 0;
    hdr_lmt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortStEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("hdr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_lmt_) ) + "\n";
    all_zeros &= (0 == hdr_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortStEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("shr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_lmt_) ) + "\n";
    all_zeros &= (0 == shr_lmt_);
    r += indent_string + "  " + std::string("hdr_lmt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_lmt_) ) + "\n";
    all_zeros &= (0 == hdr_lmt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t shr_lmt_;
  uint8_t hdr_lmt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_port_st_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xc80; // to get to csr_memory_wac_port_st
    assert(index_wac_port_st_entry < 73);
    offset += index_wac_port_st_entry * 0x1; // wac_port_st_entry[]
    return offset;
  }

};








class WacPortStEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPortStEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPortStEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &shr_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr_lmt();
  }
  uint8_t &hdr_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_lmt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortStEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortStEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortStEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xc80; // to get to csr_memory_wac_port_st
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPortStEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPortStEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPortStEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t shr_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr_lmt();
  }
  void shr_lmt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].shr_lmt(v);
  }
  uint8_t hdr_lmt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_lmt();
  }
  void hdr_lmt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].hdr_lmt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortStEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortStEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortStEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xc80; // to get to csr_memory_wac_port_st
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};











class WacPortCntEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrCnt,
    kCsrMemoryWacPortMinCnt,
    kCsrMemoryWacPortShrCnt,
    kCsrMemoryWacPortWm
  };
public:
  WacPortCntEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_cnt_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_port_cnt_entry), 1, false, write_callback, read_callback, std::string("WacPortCntEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_cnt_entry))
    {
    }
  WacPortCntEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortCntEntry")
    {
    }
public:
  uint32_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortCntEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortCntEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_cnt_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        offset += 0xb80; // to get to csr_memory_wac_port_hdr_cnt
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      case kCsrMemoryWacPortMinCnt:
        offset += 0xb00; // to get to csr_memory_wac_port_min_cnt
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      case kCsrMemoryWacPortShrCnt:
        offset += 0xc00; // to get to csr_memory_wac_port_shr_cnt
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      case kCsrMemoryWacPortWm:
        offset += 0xa80; // to get to csr_memory_wac_port_wm
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class WacPortCntEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrCnt,
    kCsrMemoryWacPortMinCnt,
    kCsrMemoryWacPortShrCnt,
    kCsrMemoryWacPortWm
  };
public:
  WacPortCntEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_cnt_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_port_cnt_entry), 1, true, write_callback, read_callback, std::string("WacPortCntEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_cnt_entry))
    {
    }
  WacPortCntEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortCntEntryMutable")
    {
    }
public:
  uint32_t cnt() { return cnt_; }
  void cnt(const uint32_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortCntEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortCntEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_cnt_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        offset += 0xb80; // to get to csr_memory_wac_port_hdr_cnt
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      case kCsrMemoryWacPortMinCnt:
        offset += 0xb00; // to get to csr_memory_wac_port_min_cnt
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      case kCsrMemoryWacPortShrCnt:
        offset += 0xc00; // to get to csr_memory_wac_port_shr_cnt
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      case kCsrMemoryWacPortWm:
        offset += 0xa80; // to get to csr_memory_wac_port_wm
        assert(index_wac_port_cnt_entry < 73);
        offset += index_wac_port_cnt_entry * 0x1; // wac_port_cnt_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class WacPortCntEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrCnt,
    kCsrMemoryWacPortMinCnt,
    kCsrMemoryWacPortShrCnt,
    kCsrMemoryWacPortWm
  };
public:
  WacPortCntEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPortCntEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortCntEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortCntEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortCntEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        offset += 0xb80; // to get to csr_memory_wac_port_hdr_cnt
        break;
      case kCsrMemoryWacPortMinCnt:
        offset += 0xb00; // to get to csr_memory_wac_port_min_cnt
        break;
      case kCsrMemoryWacPortShrCnt:
        offset += 0xc00; // to get to csr_memory_wac_port_shr_cnt
        break;
      case kCsrMemoryWacPortWm:
        offset += 0xa80; // to get to csr_memory_wac_port_wm
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortWm:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortWm:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class WacPortCntEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrCnt,
    kCsrMemoryWacPortMinCnt,
    kCsrMemoryWacPortShrCnt,
    kCsrMemoryWacPortWm
  };
public:
  WacPortCntEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPortCntEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortCntEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortCntEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortCntEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        offset += 0xb80; // to get to csr_memory_wac_port_hdr_cnt
        break;
      case kCsrMemoryWacPortMinCnt:
        offset += 0xb00; // to get to csr_memory_wac_port_min_cnt
        break;
      case kCsrMemoryWacPortShrCnt:
        offset += 0xc00; // to get to csr_memory_wac_port_shr_cnt
        break;
      case kCsrMemoryWacPortWm:
        offset += 0xa80; // to get to csr_memory_wac_port_wm
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortWm:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortWm:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class WacPortThEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrTh,
    kCsrMemoryWacPortShrTh
  };
public:
  WacPortThEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_th_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_port_th_entry), 1, false, write_callback, read_callback, std::string("WacPortThEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_th_entry))
    {
    }
  WacPortThEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortThEntry")
    {
    }
public:
  uint32_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortThEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortThEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_th_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        offset += 0xa00; // to get to csr_memory_wac_port_hdr_th
        assert(index_wac_port_th_entry < 73);
        offset += index_wac_port_th_entry * 0x1; // wac_port_th_entry[]
        break;
      case kCsrMemoryWacPortShrTh:
        offset += 0x980; // to get to csr_memory_wac_port_shr_th
        assert(index_wac_port_th_entry < 73);
        offset += index_wac_port_th_entry * 0x1; // wac_port_th_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class WacPortThEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrTh,
    kCsrMemoryWacPortShrTh
  };
public:
  WacPortThEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_th_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_port_th_entry), 1, true, write_callback, read_callback, std::string("WacPortThEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_th_entry))
    {
    }
  WacPortThEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortThEntryMutable")
    {
    }
public:
  uint32_t cnt() { return cnt_; }
  void cnt(const uint32_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortThEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortThEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_port_th_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        offset += 0xa00; // to get to csr_memory_wac_port_hdr_th
        assert(index_wac_port_th_entry < 73);
        offset += index_wac_port_th_entry * 0x1; // wac_port_th_entry[]
        break;
      case kCsrMemoryWacPortShrTh:
        offset += 0x980; // to get to csr_memory_wac_port_shr_th
        assert(index_wac_port_th_entry < 73);
        offset += index_wac_port_th_entry * 0x1; // wac_port_th_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class WacPortThEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrTh,
    kCsrMemoryWacPortShrTh
  };
public:
  WacPortThEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPortThEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortThEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortThEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortThEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        offset += 0xa00; // to get to csr_memory_wac_port_hdr_th
        break;
      case kCsrMemoryWacPortShrTh:
        offset += 0x980; // to get to csr_memory_wac_port_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};











class WacPortThEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrTh,
    kCsrMemoryWacPortShrTh
  };
public:
  WacPortThEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPortThEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortThEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortThEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortThEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        offset += 0xa00; // to get to csr_memory_wac_port_hdr_th
        break;
      case kCsrMemoryWacPortShrTh:
        offset += 0x980; // to get to csr_memory_wac_port_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPortShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgThEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinTh,
    kCsrMemoryWacPgShrTh
  };
public:
  WacPgThEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_th_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_pg_th_entry), 1, false, write_callback, read_callback, std::string("WacPgThEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_th_entry))
    {
    }
  WacPgThEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgThEntry")
    {
    }
public:
  uint32_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgThEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgThEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_th_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        offset += 0x880; // to get to csr_memory_wac_pg_min_th
        assert(index_wac_pg_th_entry < 73);
        offset += index_wac_pg_th_entry * 0x1; // wac_pg_th_entry[]
        break;
      case kCsrMemoryWacPgShrTh:
        offset += 0x900; // to get to csr_memory_wac_pg_shr_th
        assert(index_wac_pg_th_entry < 73);
        offset += index_wac_pg_th_entry * 0x1; // wac_pg_th_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgThEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinTh,
    kCsrMemoryWacPgShrTh
  };
public:
  WacPgThEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_th_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_pg_th_entry), 1, true, write_callback, read_callback, std::string("WacPgThEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_th_entry))
    {
    }
  WacPgThEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgThEntryMutable")
    {
    }
public:
  uint32_t cnt() { return cnt_; }
  void cnt(const uint32_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgThEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgThEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_th_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        offset += 0x880; // to get to csr_memory_wac_pg_min_th
        assert(index_wac_pg_th_entry < 73);
        offset += index_wac_pg_th_entry * 0x1; // wac_pg_th_entry[]
        break;
      case kCsrMemoryWacPgShrTh:
        offset += 0x900; // to get to csr_memory_wac_pg_shr_th
        assert(index_wac_pg_th_entry < 73);
        offset += index_wac_pg_th_entry * 0x1; // wac_pg_th_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgThEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinTh,
    kCsrMemoryWacPgShrTh
  };
public:
  WacPgThEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPgThEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgThEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgThEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgThEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        offset += 0x880; // to get to csr_memory_wac_pg_min_th
        break;
      case kCsrMemoryWacPgShrTh:
        offset += 0x900; // to get to csr_memory_wac_pg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgThEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinTh,
    kCsrMemoryWacPgShrTh
  };
public:
  WacPgThEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPgThEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgThEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgThEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgThEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        offset += 0x880; // to get to csr_memory_wac_pg_min_th
        break;
      case kCsrMemoryWacPgShrTh:
        offset += 0x900; // to get to csr_memory_wac_pg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrTh:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgCntEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinCnt,
    kCsrMemoryWacPgShrCnt
  };
public:
  WacPgCntEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_cnt_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_pg_cnt_entry), 1, false, write_callback, read_callback, std::string("WacPgCntEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_cnt_entry))
    {
    }
  WacPgCntEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgCntEntry")
    {
    }
public:
  uint32_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgCntEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgCntEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_cnt_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        offset += 0x780; // to get to csr_memory_wac_pg_min_cnt
        assert(index_wac_pg_cnt_entry < 73);
        offset += index_wac_pg_cnt_entry * 0x1; // wac_pg_cnt_entry[]
        break;
      case kCsrMemoryWacPgShrCnt:
        offset += 0x800; // to get to csr_memory_wac_pg_shr_cnt
        assert(index_wac_pg_cnt_entry < 73);
        offset += index_wac_pg_cnt_entry * 0x1; // wac_pg_cnt_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgCntEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinCnt,
    kCsrMemoryWacPgShrCnt
  };
public:
  WacPgCntEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_cnt_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_pg_cnt_entry), 1, true, write_callback, read_callback, std::string("WacPgCntEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_cnt_entry))
    {
    }
  WacPgCntEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgCntEntryMutable")
    {
    }
public:
  uint32_t cnt() { return cnt_; }
  void cnt(const uint32_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgCntEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgCntEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_pg_cnt_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        offset += 0x780; // to get to csr_memory_wac_pg_min_cnt
        assert(index_wac_pg_cnt_entry < 73);
        offset += index_wac_pg_cnt_entry * 0x1; // wac_pg_cnt_entry[]
        break;
      case kCsrMemoryWacPgShrCnt:
        offset += 0x800; // to get to csr_memory_wac_pg_shr_cnt
        assert(index_wac_pg_cnt_entry < 73);
        offset += index_wac_pg_cnt_entry * 0x1; // wac_pg_cnt_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgCntEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinCnt,
    kCsrMemoryWacPgShrCnt
  };
public:
  WacPgCntEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPgCntEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgCntEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgCntEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgCntEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        offset += 0x780; // to get to csr_memory_wac_pg_min_cnt
        break;
      case kCsrMemoryWacPgShrCnt:
        offset += 0x800; // to get to csr_memory_wac_pg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgCntEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinCnt,
    kCsrMemoryWacPgShrCnt
  };
public:
  WacPgCntEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPgCntEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgCntEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgCntEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgCntEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        offset += 0x780; // to get to csr_memory_wac_pg_min_cnt
        break;
      case kCsrMemoryWacPgShrCnt:
        offset += 0x800; // to get to csr_memory_wac_pg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPgShrCnt:
        switch (dimension) {
          case -1:
            return 73;
            break;
          case 0:
            return 73;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgOffIdxEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgOffIdxEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pg_off_idx_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pg_off_idx_entry), 1, false, write_callback, read_callback, std::string("WacPgOffIdxEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_off_idx_entry))
    {
    }
  WacPgOffIdxEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgOffIdxEntry")
    {
    }
public:
  uint8_t &off_idx() { return off_idx_; }
  uint8_t &dyn() { return dyn_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(off_idx_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(dyn_) & 0x1) << 5);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    off_idx_ = (data0 & 0x1f);
    dyn_ = ((data0 >> 5) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    off_idx_ = 0;
    dyn_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgOffIdxEntry") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgOffIdxEntry") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t off_idx_;
  uint8_t dyn_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pg_off_idx_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x700; // to get to csr_memory_wac_pg_off_idx
    assert(index_wac_pg_off_idx_entry < 73);
    offset += index_wac_pg_off_idx_entry * 0x1; // wac_pg_off_idx_entry[]
    return offset;
  }

};









class WacPgOffIdxEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgOffIdxEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pg_off_idx_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pg_off_idx_entry), 1, true, write_callback, read_callback, std::string("WacPgOffIdxEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_off_idx_entry))
    {
    }
  WacPgOffIdxEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgOffIdxEntryMutable")
    {
    }
public:
  uint8_t off_idx() { return off_idx_; }
  void off_idx(const uint8_t &v) { off_idx_=v; }
  uint8_t dyn() { return dyn_; }
  void dyn(const uint8_t &v) { dyn_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(off_idx_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(dyn_) & 0x1) << 5);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    off_idx_ = (data0 & 0x1f);
    dyn_ = ((data0 >> 5) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    off_idx_ = 0;
    dyn_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgOffIdxEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgOffIdxEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t off_idx_;
  uint8_t dyn_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pg_off_idx_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x700; // to get to csr_memory_wac_pg_off_idx
    assert(index_wac_pg_off_idx_entry < 73);
    offset += index_wac_pg_off_idx_entry * 0x1; // wac_pg_off_idx_entry[]
    return offset;
  }

};









class WacPgOffIdxEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPgOffIdxEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPgOffIdxEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].off_idx();
  }
  uint8_t &dyn(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dyn();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgOffIdxEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgOffIdxEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgOffIdxEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x700; // to get to csr_memory_wac_pg_off_idx
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgOffIdxEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPgOffIdxEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPgOffIdxEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].off_idx();
  }
  void off_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].off_idx(v);
  }
  uint8_t dyn(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dyn();
  }
  void dyn(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dyn(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgOffIdxEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgOffIdxEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgOffIdxEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x700; // to get to csr_memory_wac_pg_off_idx
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgOffIdxEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgOffIdxEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_off_idx_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_off_idx_entry), 1, false, write_callback, read_callback, std::string("WacPpgOffIdxEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_off_idx_entry))
    {
    }
  WacPpgOffIdxEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgOffIdxEntry")
    {
    }
public:
  uint8_t &off_idx() { return off_idx_; }
  uint8_t &dyn() { return dyn_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(off_idx_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(dyn_) & 0x1) << 5);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    off_idx_ = (data0 & 0x1f);
    dyn_ = ((data0 >> 5) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    off_idx_ = 0;
    dyn_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgOffIdxEntry") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgOffIdxEntry") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t off_idx_;
  uint8_t dyn_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_off_idx_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x680; // to get to csr_memory_wac_ppg_off_idx
    assert(index_wac_ppg_off_idx_entry < 128);
    offset += index_wac_ppg_off_idx_entry * 0x1; // wac_ppg_off_idx_entry[]
    return offset;
  }

};








class WacPpgOffIdxEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgOffIdxEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_off_idx_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_off_idx_entry), 1, true, write_callback, read_callback, std::string("WacPpgOffIdxEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_off_idx_entry))
    {
    }
  WacPpgOffIdxEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgOffIdxEntryMutable")
    {
    }
public:
  uint8_t off_idx() { return off_idx_; }
  void off_idx(const uint8_t &v) { off_idx_=v; }
  uint8_t dyn() { return dyn_; }
  void dyn(const uint8_t &v) { dyn_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(off_idx_) & 0x1f);
    *data0 |= ((static_cast<uint64_t>(dyn_) & 0x1) << 5);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    off_idx_ = (data0 & 0x1f);
    dyn_ = ((data0 >> 5) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    off_idx_ = 0;
    dyn_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgOffIdxEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgOffIdxEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("off_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(off_idx_) ) + "\n";
    all_zeros &= (0 == off_idx_);
    r += indent_string + "  " + std::string("dyn") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dyn_) ) + "\n";
    all_zeros &= (0 == dyn_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t off_idx_;
  uint8_t dyn_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_off_idx_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x680; // to get to csr_memory_wac_ppg_off_idx
    assert(index_wac_ppg_off_idx_entry < 128);
    offset += index_wac_ppg_off_idx_entry * 0x1; // wac_ppg_off_idx_entry[]
    return offset;
  }

};








class WacPpgOffIdxEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgOffIdxEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPpgOffIdxEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].off_idx();
  }
  uint8_t &dyn(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dyn();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgOffIdxEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgOffIdxEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgOffIdxEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x680; // to get to csr_memory_wac_ppg_off_idx
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgOffIdxEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgOffIdxEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPpgOffIdxEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].off_idx();
  }
  void off_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].off_idx(v);
  }
  uint8_t dyn(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dyn();
  }
  void dyn(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dyn(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgOffIdxEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgOffIdxEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgOffIdxEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x680; // to get to csr_memory_wac_ppg_off_idx
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgDropStEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgDropStEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pg_drop_st_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pg_drop_st_entry), 1, false, write_callback, read_callback, std::string("WacPgDropStEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_drop_st_entry))
    {
    }
  WacPgDropStEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgDropStEntry")
    {
    }
public:
  uint8_t &drop_st() { return drop_st_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(drop_st_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    drop_st_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    drop_st_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgDropStEntry") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgDropStEntry") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t drop_st_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pg_drop_st_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x600; // to get to csr_memory_wac_pg_drop_st
    assert(index_wac_pg_drop_st_entry < 73);
    offset += index_wac_pg_drop_st_entry * 0x1; // wac_pg_drop_st_entry[]
    return offset;
  }

};









class WacPgDropStEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgDropStEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_pg_drop_st_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_pg_drop_st_entry), 1, true, write_callback, read_callback, std::string("WacPgDropStEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_pg_drop_st_entry))
    {
    }
  WacPgDropStEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgDropStEntryMutable")
    {
    }
public:
  uint8_t drop_st() { return drop_st_; }
  void drop_st(const uint8_t &v) { drop_st_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(drop_st_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    drop_st_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    drop_st_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgDropStEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPgDropStEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t drop_st_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_pg_drop_st_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x600; // to get to csr_memory_wac_pg_drop_st
    assert(index_wac_pg_drop_st_entry < 73);
    offset += index_wac_pg_drop_st_entry * 0x1; // wac_pg_drop_st_entry[]
    return offset;
  }

};









class WacPgDropStEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPgDropStEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPgDropStEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].drop_st();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgDropStEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgDropStEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgDropStEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x600; // to get to csr_memory_wac_pg_drop_st
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPgDropStEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPgDropStEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPgDropStEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].drop_st();
  }
  void drop_st(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].drop_st(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPgDropStEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPgDropStEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPgDropStEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x600; // to get to csr_memory_wac_pg_drop_st
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 73;
        break;
      case 0:
        return 73;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgDropStEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgDropStEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_drop_st_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_drop_st_entry), 1, false, write_callback, read_callback, std::string("WacPpgDropStEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_drop_st_entry))
    {
    }
  WacPpgDropStEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgDropStEntry")
    {
    }
public:
  uint8_t &drop_st() { return drop_st_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(drop_st_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    drop_st_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    drop_st_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgDropStEntry") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgDropStEntry") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t drop_st_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_drop_st_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x580; // to get to csr_memory_wac_ppg_drop_st
    assert(index_wac_ppg_drop_st_entry < 128);
    offset += index_wac_ppg_drop_st_entry * 0x1; // wac_ppg_drop_st_entry[]
    return offset;
  }

};








class WacPpgDropStEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgDropStEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_drop_st_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_drop_st_entry), 1, true, write_callback, read_callback, std::string("WacPpgDropStEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_drop_st_entry))
    {
    }
  WacPpgDropStEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgDropStEntryMutable")
    {
    }
public:
  uint8_t drop_st() { return drop_st_; }
  void drop_st(const uint8_t &v) { drop_st_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(drop_st_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    drop_st_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    drop_st_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgDropStEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgDropStEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("drop_st") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(drop_st_) ) + "\n";
    all_zeros &= (0 == drop_st_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t drop_st_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_drop_st_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x580; // to get to csr_memory_wac_ppg_drop_st
    assert(index_wac_ppg_drop_st_entry < 128);
    offset += index_wac_ppg_drop_st_entry * 0x1; // wac_ppg_drop_st_entry[]
    return offset;
  }

};








class WacPpgDropStEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgDropStEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPpgDropStEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].drop_st();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgDropStEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgDropStEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgDropStEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x580; // to get to csr_memory_wac_ppg_drop_st
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgDropStEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgDropStEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPpgDropStEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].drop_st();
  }
  void drop_st(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].drop_st(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgDropStEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgDropStEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgDropStEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x580; // to get to csr_memory_wac_ppg_drop_st
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgIcosEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgIcosEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_icos_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_icos_entry), 1, false, write_callback, read_callback, std::string("WacPpgIcosEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_icos_entry))
    {
    }
  WacPpgIcosEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgIcosEntry")
    {
    }
public:
  uint8_t &icos() { return icos_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(icos_);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    icos_ = data0;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    icos_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgIcosEntry") + ":\n";
    r += indent_string + "  " + std::string("icos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(icos_) ) + "\n";
    all_zeros &= (0 == icos_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgIcosEntry") + ":\n";
    r += indent_string + "  " + std::string("icos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(icos_) ) + "\n";
    all_zeros &= (0 == icos_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t icos_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_icos_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x500; // to get to csr_memory_wac_ppg_icos
    assert(index_wac_ppg_icos_entry < 128);
    offset += index_wac_ppg_icos_entry * 0x1; // wac_ppg_icos_entry[]
    return offset;
  }

};








class WacPpgIcosEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgIcosEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_icos_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_icos_entry), 1, true, write_callback, read_callback, std::string("WacPpgIcosEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_icos_entry))
    {
    }
  WacPpgIcosEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgIcosEntryMutable")
    {
    }
public:
  uint8_t icos() { return icos_; }
  void icos(const uint8_t &v) { icos_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(icos_);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    icos_ = data0;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    icos_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgIcosEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("icos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(icos_) ) + "\n";
    all_zeros &= (0 == icos_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgIcosEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("icos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(icos_) ) + "\n";
    all_zeros &= (0 == icos_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t icos_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_icos_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x500; // to get to csr_memory_wac_ppg_icos
    assert(index_wac_ppg_icos_entry < 128);
    offset += index_wac_ppg_icos_entry * 0x1; // wac_ppg_icos_entry[]
    return offset;
  }

};








class WacPpgIcosEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgIcosEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPpgIcosEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &icos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].icos();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgIcosEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgIcosEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgIcosEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x500; // to get to csr_memory_wac_ppg_icos
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgIcosEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgIcosEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPpgIcosEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t icos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].icos();
  }
  void icos(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].icos(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgIcosEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgIcosEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgIcosEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x500; // to get to csr_memory_wac_ppg_icos
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgPfcEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgPfcEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_pfc_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_pfc_entry), 1, false, write_callback, read_callback, std::string("WacPpgPfcEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_pfc_entry))
    {
    }
  WacPpgPfcEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgPfcEntry")
    {
    }
public:
  uint8_t &pfc() { return pfc_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pfc_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pfc_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pfc_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgPfcEntry") + ":\n";
    r += indent_string + "  " + std::string("pfc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_) ) + "\n";
    all_zeros &= (0 == pfc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgPfcEntry") + ":\n";
    r += indent_string + "  " + std::string("pfc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_) ) + "\n";
    all_zeros &= (0 == pfc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pfc_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_pfc_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x480; // to get to csr_memory_wac_ppg_pfc
    assert(index_wac_ppg_pfc_entry < 128);
    offset += index_wac_ppg_pfc_entry * 0x1; // wac_ppg_pfc_entry[]
    return offset;
  }

};








class WacPpgPfcEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgPfcEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_pfc_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_ppg_pfc_entry), 1, true, write_callback, read_callback, std::string("WacPpgPfcEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_pfc_entry))
    {
    }
  WacPpgPfcEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgPfcEntryMutable")
    {
    }
public:
  uint8_t pfc() { return pfc_; }
  void pfc(const uint8_t &v) { pfc_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(pfc_) & 0x1);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    pfc_ = (data0 & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    pfc_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgPfcEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pfc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_) ) + "\n";
    all_zeros &= (0 == pfc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgPfcEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("pfc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pfc_) ) + "\n";
    all_zeros &= (0 == pfc_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t pfc_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_ppg_pfc_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x480; // to get to csr_memory_wac_ppg_pfc
    assert(index_wac_ppg_pfc_entry < 128);
    offset += index_wac_ppg_pfc_entry * 0x1; // wac_ppg_pfc_entry[]
    return offset;
  }

};








class WacPpgPfcEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgPfcEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPpgPfcEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &pfc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pfc();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgPfcEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgPfcEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgPfcEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x480; // to get to csr_memory_wac_ppg_pfc
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgPfcEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPpgPfcEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPpgPfcEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t pfc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pfc();
  }
  void pfc(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pfc(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgPfcEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgPfcEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgPfcEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x480; // to get to csr_memory_wac_ppg_pfc
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 128;
        break;
      case 0:
        return 128;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgThEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrTh,
    kCsrMemoryWacPpgMinTh,
    kCsrMemoryWacPpgShrTh
  };
public:
  WacPpgThEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_th_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_ppg_th_entry), 1, false, write_callback, read_callback, std::string("WacPpgThEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_th_entry))
    {
    }
  WacPpgThEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgThEntry")
    {
    }
public:
  uint32_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgThEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgThEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_th_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        offset += 0x400; // to get to csr_memory_wac_ppg_hdr_th
        assert(index_wac_ppg_th_entry < 128);
        offset += index_wac_ppg_th_entry * 0x1; // wac_ppg_th_entry[]
        break;
      case kCsrMemoryWacPpgMinTh:
        offset += 0x300; // to get to csr_memory_wac_ppg_min_th
        assert(index_wac_ppg_th_entry < 128);
        offset += index_wac_ppg_th_entry * 0x1; // wac_ppg_th_entry[]
        break;
      case kCsrMemoryWacPpgShrTh:
        offset += 0x380; // to get to csr_memory_wac_ppg_shr_th
        assert(index_wac_ppg_th_entry < 128);
        offset += index_wac_ppg_th_entry * 0x1; // wac_ppg_th_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class WacPpgThEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrTh,
    kCsrMemoryWacPpgMinTh,
    kCsrMemoryWacPpgShrTh
  };
public:
  WacPpgThEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_th_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_ppg_th_entry), 1, true, write_callback, read_callback, std::string("WacPpgThEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_th_entry))
    {
    }
  WacPpgThEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgThEntryMutable")
    {
    }
public:
  uint32_t cnt() { return cnt_; }
  void cnt(const uint32_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgThEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgThEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_th_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        offset += 0x400; // to get to csr_memory_wac_ppg_hdr_th
        assert(index_wac_ppg_th_entry < 128);
        offset += index_wac_ppg_th_entry * 0x1; // wac_ppg_th_entry[]
        break;
      case kCsrMemoryWacPpgMinTh:
        offset += 0x300; // to get to csr_memory_wac_ppg_min_th
        assert(index_wac_ppg_th_entry < 128);
        offset += index_wac_ppg_th_entry * 0x1; // wac_ppg_th_entry[]
        break;
      case kCsrMemoryWacPpgShrTh:
        offset += 0x380; // to get to csr_memory_wac_ppg_shr_th
        assert(index_wac_ppg_th_entry < 128);
        offset += index_wac_ppg_th_entry * 0x1; // wac_ppg_th_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class WacPpgThEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrTh,
    kCsrMemoryWacPpgMinTh,
    kCsrMemoryWacPpgShrTh
  };
public:
  WacPpgThEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPpgThEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgThEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgThEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgThEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        offset += 0x400; // to get to csr_memory_wac_ppg_hdr_th
        break;
      case kCsrMemoryWacPpgMinTh:
        offset += 0x300; // to get to csr_memory_wac_ppg_min_th
        break;
      case kCsrMemoryWacPpgShrTh:
        offset += 0x380; // to get to csr_memory_wac_ppg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgThEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrTh,
    kCsrMemoryWacPpgMinTh,
    kCsrMemoryWacPpgShrTh
  };
public:
  WacPpgThEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPpgThEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgThEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgThEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgThEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        offset += 0x400; // to get to csr_memory_wac_ppg_hdr_th
        break;
      case kCsrMemoryWacPpgMinTh:
        offset += 0x300; // to get to csr_memory_wac_ppg_min_th
        break;
      case kCsrMemoryWacPpgShrTh:
        offset += 0x380; // to get to csr_memory_wac_ppg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrTh:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgCntEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrCnt,
    kCsrMemoryWacPpgMinCnt,
    kCsrMemoryWacPpgShrCnt
  };
public:
  WacPpgCntEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_cnt_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_ppg_cnt_entry), 1, false, write_callback, read_callback, std::string("WacPpgCntEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_cnt_entry))
    {
    }
  WacPpgCntEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgCntEntry")
    {
    }
public:
  uint32_t &cnt() { return cnt_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgCntEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgCntEntry") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_cnt_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        offset += 0x280; // to get to csr_memory_wac_ppg_hdr_cnt
        assert(index_wac_ppg_cnt_entry < 128);
        offset += index_wac_ppg_cnt_entry * 0x1; // wac_ppg_cnt_entry[]
        break;
      case kCsrMemoryWacPpgMinCnt:
        offset += 0x180; // to get to csr_memory_wac_ppg_min_cnt
        assert(index_wac_ppg_cnt_entry < 128);
        offset += index_wac_ppg_cnt_entry * 0x1; // wac_ppg_cnt_entry[]
        break;
      case kCsrMemoryWacPpgShrCnt:
        offset += 0x200; // to get to csr_memory_wac_ppg_shr_cnt
        assert(index_wac_ppg_cnt_entry < 128);
        offset += index_wac_ppg_cnt_entry * 0x1; // wac_ppg_cnt_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class WacPpgCntEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrCnt,
    kCsrMemoryWacPpgMinCnt,
    kCsrMemoryWacPpgShrCnt
  };
public:
  WacPpgCntEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_cnt_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, index_wac_ppg_cnt_entry), 1, true, write_callback, read_callback, std::string("WacPpgCntEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_ppg_cnt_entry))
    {
    }
  WacPpgCntEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgCntEntryMutable")
    {
    }
public:
  uint32_t cnt() { return cnt_; }
  void cnt(const uint32_t &v) { cnt_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = (static_cast<uint64_t>(cnt_) & 0x7ffff);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    cnt_ = (data0 & 0x7ffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    cnt_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgCntEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPpgCntEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("cnt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(cnt_) ) + "\n";
    all_zeros &= (0 == cnt_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint32_t cnt_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int index_wac_ppg_cnt_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        offset += 0x280; // to get to csr_memory_wac_ppg_hdr_cnt
        assert(index_wac_ppg_cnt_entry < 128);
        offset += index_wac_ppg_cnt_entry * 0x1; // wac_ppg_cnt_entry[]
        break;
      case kCsrMemoryWacPpgMinCnt:
        offset += 0x180; // to get to csr_memory_wac_ppg_min_cnt
        assert(index_wac_ppg_cnt_entry < 128);
        offset += index_wac_ppg_cnt_entry * 0x1; // wac_ppg_cnt_entry[]
        break;
      case kCsrMemoryWacPpgShrCnt:
        offset += 0x200; // to get to csr_memory_wac_ppg_shr_cnt
        assert(index_wac_ppg_cnt_entry < 128);
        offset += index_wac_ppg_cnt_entry * 0x1; // wac_ppg_cnt_entry[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class WacPpgCntEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrCnt,
    kCsrMemoryWacPpgMinCnt,
    kCsrMemoryWacPpgShrCnt
  };
public:
  WacPpgCntEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPpgCntEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t &cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgCntEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgCntEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgCntEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        offset += 0x280; // to get to csr_memory_wac_ppg_hdr_cnt
        break;
      case kCsrMemoryWacPpgMinCnt:
        offset += 0x180; // to get to csr_memory_wac_ppg_min_cnt
        break;
      case kCsrMemoryWacPpgShrCnt:
        offset += 0x200; // to get to csr_memory_wac_ppg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class WacPpgCntEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrCnt,
    kCsrMemoryWacPpgMinCnt,
    kCsrMemoryWacPpgShrCnt
  };
public:
  WacPpgCntEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPpgCntEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint32_t cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].cnt();
  }
  void cnt(uint32_t a0,const uint32_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].cnt(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPpgCntEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPpgCntEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPpgCntEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        offset += 0x280; // to get to csr_memory_wac_ppg_hdr_cnt
        break;
      case kCsrMemoryWacPpgMinCnt:
        offset += 0x180; // to get to csr_memory_wac_ppg_min_cnt
        break;
      case kCsrMemoryWacPpgShrCnt:
        offset += 0x200; // to get to csr_memory_wac_ppg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgMinCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kCsrMemoryWacPpgShrCnt:
        switch (dimension) {
          case -1:
            return 128;
            break;
          case 0:
            return 128;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPortPpgMappingEntry : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortPpgMappingEntry(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_port_ppg_mapping_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_port_ppg_mapping_entry), 1, false, write_callback, read_callback, std::string("WacPortPpgMappingEntry")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_ppg_mapping_entry))
    {
    }
  WacPortPpgMappingEntry(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortPpgMappingEntry")
    {
    }
public:
  uint8_t &ppg0() { return ppg0_; }
  uint8_t &apid0() { return apid0_; }
  uint8_t &enb0() { return enb0_; }
  uint8_t &ppg1() { return ppg1_; }
  uint8_t &apid1() { return apid1_; }
  uint8_t &enb1() { return enb1_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(ppg0_);
    *data0 |= ((static_cast<uint64_t>(apid0_) & 0x3) << 8);
    *data0 |= ((static_cast<uint64_t>(enb0_) & 0x1) << 10);
    *data0 |= (static_cast<uint64_t>(ppg1_) << 11);
    *data0 |= ((static_cast<uint64_t>(apid1_) & 0x3) << 19);
    *data0 |= ((static_cast<uint64_t>(enb1_) & 0x1) << 21);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ppg0_ = data0;
    apid0_ = ((data0 >> 8) & 0x3);
    enb0_ = ((data0 >> 10) & 0x1);
    ppg1_ = (data0 >> 11);
    apid1_ = ((data0 >> 19) & 0x3);
    enb1_ = ((data0 >> 21) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ppg0_ = 0;
    apid0_ = 0;
    enb0_ = 0;
    ppg1_ = 0;
    apid1_ = 0;
    enb1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortPpgMappingEntry") + ":\n";
    r += indent_string + "  " + std::string("ppg0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg0_) ) + "\n";
    all_zeros &= (0 == ppg0_);
    r += indent_string + "  " + std::string("apid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid0_) ) + "\n";
    all_zeros &= (0 == apid0_);
    r += indent_string + "  " + std::string("enb0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb0_) ) + "\n";
    all_zeros &= (0 == enb0_);
    r += indent_string + "  " + std::string("ppg1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg1_) ) + "\n";
    all_zeros &= (0 == ppg1_);
    r += indent_string + "  " + std::string("apid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid1_) ) + "\n";
    all_zeros &= (0 == apid1_);
    r += indent_string + "  " + std::string("enb1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb1_) ) + "\n";
    all_zeros &= (0 == enb1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortPpgMappingEntry") + ":\n";
    r += indent_string + "  " + std::string("ppg0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg0_) ) + "\n";
    all_zeros &= (0 == ppg0_);
    r += indent_string + "  " + std::string("apid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid0_) ) + "\n";
    all_zeros &= (0 == apid0_);
    r += indent_string + "  " + std::string("enb0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb0_) ) + "\n";
    all_zeros &= (0 == enb0_);
    r += indent_string + "  " + std::string("ppg1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg1_) ) + "\n";
    all_zeros &= (0 == ppg1_);
    r += indent_string + "  " + std::string("apid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid1_) ) + "\n";
    all_zeros &= (0 == apid1_);
    r += indent_string + "  " + std::string("enb1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb1_) ) + "\n";
    all_zeros &= (0 == enb1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t ppg0_;
  uint8_t apid0_;
  uint8_t enb0_;
  uint8_t ppg1_;
  uint8_t apid1_;
  uint8_t enb1_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_port_ppg_mapping_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    assert(index_wac_port_ppg_mapping_entry < 292);
    offset += index_wac_port_ppg_mapping_entry * 0x1; // wac_port_ppg_mapping_entry[]
    return offset;
  }

};









class WacPortPpgMappingEntryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortPpgMappingEntryMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, int index_wac_port_ppg_mapping_entry, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, index_wac_port_ppg_mapping_entry), 1, true, write_callback, read_callback, std::string("WacPortPpgMappingEntryMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(index_wac_port_ppg_mapping_entry))
    {
    }
  WacPortPpgMappingEntryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortPpgMappingEntryMutable")
    {
    }
public:
  uint8_t ppg0() { return ppg0_; }
  void ppg0(const uint8_t &v) { ppg0_=v; }
  uint8_t apid0() { return apid0_; }
  void apid0(const uint8_t &v) { apid0_=v; }
  uint8_t enb0() { return enb0_; }
  void enb0(const uint8_t &v) { enb0_=v; }
  uint8_t ppg1() { return ppg1_; }
  void ppg1(const uint8_t &v) { ppg1_=v; }
  uint8_t apid1() { return apid1_; }
  void apid1(const uint8_t &v) { apid1_=v; }
  uint8_t enb1() { return enb1_; }
  void enb1(const uint8_t &v) { enb1_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(ppg0_);
    *data0 |= ((static_cast<uint64_t>(apid0_) & 0x3) << 8);
    *data0 |= ((static_cast<uint64_t>(enb0_) & 0x1) << 10);
    *data0 |= (static_cast<uint64_t>(ppg1_) << 11);
    *data0 |= ((static_cast<uint64_t>(apid1_) & 0x3) << 19);
    *data0 |= ((static_cast<uint64_t>(enb1_) & 0x1) << 21);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    ppg0_ = data0;
    apid0_ = ((data0 >> 8) & 0x3);
    enb0_ = ((data0 >> 10) & 0x1);
    ppg1_ = (data0 >> 11);
    apid1_ = ((data0 >> 19) & 0x3);
    enb1_ = ((data0 >> 21) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    ppg0_ = 0;
    apid0_ = 0;
    enb0_ = 0;
    ppg1_ = 0;
    apid1_ = 0;
    enb1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortPpgMappingEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ppg0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg0_) ) + "\n";
    all_zeros &= (0 == ppg0_);
    r += indent_string + "  " + std::string("apid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid0_) ) + "\n";
    all_zeros &= (0 == apid0_);
    r += indent_string + "  " + std::string("enb0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb0_) ) + "\n";
    all_zeros &= (0 == enb0_);
    r += indent_string + "  " + std::string("ppg1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg1_) ) + "\n";
    all_zeros &= (0 == ppg1_);
    r += indent_string + "  " + std::string("apid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid1_) ) + "\n";
    all_zeros &= (0 == apid1_);
    r += indent_string + "  " + std::string("enb1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb1_) ) + "\n";
    all_zeros &= (0 == enb1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("WacPortPpgMappingEntryMutable") + ":\n";
    r += indent_string + "  " + std::string("ppg0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg0_) ) + "\n";
    all_zeros &= (0 == ppg0_);
    r += indent_string + "  " + std::string("apid0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid0_) ) + "\n";
    all_zeros &= (0 == apid0_);
    r += indent_string + "  " + std::string("enb0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb0_) ) + "\n";
    all_zeros &= (0 == enb0_);
    r += indent_string + "  " + std::string("ppg1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ppg1_) ) + "\n";
    all_zeros &= (0 == ppg1_);
    r += indent_string + "  " + std::string("apid1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(apid1_) ) + "\n";
    all_zeros &= (0 == apid1_);
    r += indent_string + "  " + std::string("enb1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(enb1_) ) + "\n";
    all_zeros &= (0 == enb1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t ppg0_;
  uint8_t apid0_;
  uint8_t enb0_;
  uint8_t ppg1_;
  uint8_t apid1_;
  uint8_t enb1_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, int index_wac_port_ppg_mapping_entry
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    assert(index_wac_port_ppg_mapping_entry < 292);
    offset += index_wac_port_ppg_mapping_entry * 0x1; // wac_port_ppg_mapping_entry[]
    return offset;
  }

};









class WacPortPpgMappingEntryArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPortPpgMappingEntryArray(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), false, write_callback, read_callback, std::string("WacPortPpgMappingEntryArray")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t &ppg0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ppg0();
  }
  uint8_t &apid0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].apid0();
  }
  uint8_t &enb0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].enb0();
  }
  uint8_t &ppg1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ppg1();
  }
  uint8_t &apid1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].apid1();
  }
  uint8_t &enb1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].enb1();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortPpgMappingEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortPpgMappingEntryArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortPpgMappingEntry> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 292;
        break;
      case 0:
        return 292;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 292;
        break;
      case 0:
        return 292;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class WacPortPpgMappingEntryArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  WacPortPpgMappingEntryArrayMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1 * ArraySize(index_tm_wac_pipe_mem_rspec, -1), true, write_callback, read_callback, std::string("WacPortPpgMappingEntryArrayMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec)),
    array(RealArraySize(index_tm_wac_pipe_mem_rspec, -1)),
    size0_(ArraySize(index_tm_wac_pipe_mem_rspec, 0)),
    real_size0_(RealArraySize(index_tm_wac_pipe_mem_rspec, 0))
    {
    }
public:
  uint8_t ppg0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ppg0();
  }
  void ppg0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ppg0(v);
  }
  uint8_t apid0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].apid0();
  }
  void apid0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].apid0(v);
  }
  uint8_t enb0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].enb0();
  }
  void enb0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].enb0(v);
  }
  uint8_t ppg1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ppg1();
  }
  void ppg1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ppg1(v);
  }
  uint8_t apid1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].apid1();
  }
  void apid1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].apid1(v);
  }
  uint8_t enb1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].enb1();
  }
  void enb1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].enb1(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("WacPortPpgMappingEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("WacPortPpgMappingEntryArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<WacPortPpgMappingEntryMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

  static int ArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 292;
        break;
      case 0:
        return 292;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_tm_wac_pipe_mem_rspec, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 292;
        break;
      case 0:
        return 292;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmWacPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacPipeMemRspec(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmWacPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  TmWacPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmWacPipeMemRspec")
    {
    }
public:








  WacPortPpgMappingEntry &csr_memory_wac_port_ppg_mapping(int j0) { return csr_memory_wac_port_ppg_mapping_[j0]; }







  WacPpgCntEntry &csr_memory_wac_ppg_min_cnt(int j0) { return csr_memory_wac_ppg_min_cnt_[j0]; }







  WacPpgCntEntry &csr_memory_wac_ppg_shr_cnt(int j0) { return csr_memory_wac_ppg_shr_cnt_[j0]; }







  WacPpgCntEntry &csr_memory_wac_ppg_hdr_cnt(int j0) { return csr_memory_wac_ppg_hdr_cnt_[j0]; }







  WacPpgThEntry &csr_memory_wac_ppg_min_th(int j0) { return csr_memory_wac_ppg_min_th_[j0]; }







  WacPpgThEntry &csr_memory_wac_ppg_shr_th(int j0) { return csr_memory_wac_ppg_shr_th_[j0]; }







  WacPpgThEntry &csr_memory_wac_ppg_hdr_th(int j0) { return csr_memory_wac_ppg_hdr_th_[j0]; }







  WacPpgPfcEntry &csr_memory_wac_ppg_pfc(int j0) { return csr_memory_wac_ppg_pfc_[j0]; }







  WacPpgIcosEntry &csr_memory_wac_ppg_icos(int j0) { return csr_memory_wac_ppg_icos_[j0]; }







  WacPpgDropStEntry &csr_memory_wac_ppg_drop_st(int j0) { return csr_memory_wac_ppg_drop_st_[j0]; }








  WacPgDropStEntry &csr_memory_wac_pg_drop_st(int j0) { return csr_memory_wac_pg_drop_st_[j0]; }







  WacPpgOffIdxEntry &csr_memory_wac_ppg_off_idx(int j0) { return csr_memory_wac_ppg_off_idx_[j0]; }








  WacPgOffIdxEntry &csr_memory_wac_pg_off_idx(int j0) { return csr_memory_wac_pg_off_idx_[j0]; }








  WacPgCntEntry &csr_memory_wac_pg_min_cnt(int j0) { return csr_memory_wac_pg_min_cnt_[j0]; }








  WacPgCntEntry &csr_memory_wac_pg_shr_cnt(int j0) { return csr_memory_wac_pg_shr_cnt_[j0]; }








  WacPgThEntry &csr_memory_wac_pg_min_th(int j0) { return csr_memory_wac_pg_min_th_[j0]; }








  WacPgThEntry &csr_memory_wac_pg_shr_th(int j0) { return csr_memory_wac_pg_shr_th_[j0]; }










  WacPortThEntry &csr_memory_wac_port_shr_th(int j0) { return csr_memory_wac_port_shr_th_[j0]; }










  WacPortThEntry &csr_memory_wac_port_hdr_th(int j0) { return csr_memory_wac_port_hdr_th_[j0]; }










  WacPortCntEntry &csr_memory_wac_port_wm(int j0) { return csr_memory_wac_port_wm_[j0]; }










  WacPortCntEntry &csr_memory_wac_port_min_cnt(int j0) { return csr_memory_wac_port_min_cnt_[j0]; }










  WacPortCntEntry &csr_memory_wac_port_hdr_cnt(int j0) { return csr_memory_wac_port_hdr_cnt_[j0]; }










  WacPortCntEntry &csr_memory_wac_port_shr_cnt(int j0) { return csr_memory_wac_port_shr_cnt_[j0]; }







  WacPortStEntry &csr_memory_wac_port_st(int j0) { return csr_memory_wac_port_st_[j0]; }








  WacPgWmCntWmCnt &csr_memory_wac_pg_wm_cnt(int j0) { return csr_memory_wac_pg_wm_cnt_[j0]; }














  WacDropCountPpgDropCnt &csr_memory_wac_drop_count_ppg(int j0) { return csr_memory_wac_drop_count_ppg_[j0]; }









  WacDropCountPortDropCnt &csr_memory_wac_drop_count_port(int j0) { return csr_memory_wac_drop_count_port_[j0]; }









  WacPfcStatePfcState &csr_memory_wac_pfc_state(int j0) { return csr_memory_wac_pfc_state_[j0]; }










  WacQidMapEntry &csr_memory_wac_qid_map(int j0) { return csr_memory_wac_qid_map_[j0]; }








  WacQacqStateEntry &csr_memory_wac_qacq_state(int j0) { return csr_memory_wac_qacq_state_[j0]; }








  WacQacqApConfigEntry &csr_memory_wac_qacq_ap_config(int j0) { return csr_memory_wac_qacq_ap_config_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x124) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_ppg_mapping_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_pfc_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_icos_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_drop_st_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_drop_st_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_off_idx_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_off_idx_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_wm_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_min_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_st_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_wm_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_ppg_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_port_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pfc_state_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_qid_map_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_state_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_ap_config_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x124) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_ppg_mapping_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_min_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_shr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_hdr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_min_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_shr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_hdr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_pfc_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_icos_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_drop_st_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_drop_st_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_off_idx_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_off_idx_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_min_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_shr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_min_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_shr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_shr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_hdr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_wm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_min_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_hdr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_shr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_st_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_wm_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_drop_count_ppg_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_drop_count_port_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pfc_state_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_qid_map_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_qacq_state_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_qacq_ap_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_wac_port_ppg_mapping_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_min_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_shr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_hdr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_min_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_shr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_hdr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_pfc_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_icos_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_drop_st_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_drop_st_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_off_idx_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_off_idx_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_min_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_shr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_min_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_shr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_shr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_hdr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_wm_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_min_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_hdr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_shr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_st_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_wm_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_drop_count_ppg_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_drop_count_port_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pfc_state_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_qid_map_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_qacq_state_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_qacq_ap_config_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x124) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_ppg_mapping_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_min_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_shr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_hdr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_min_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_shr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_hdr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_pfc_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_icos_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_drop_st_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_drop_st_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_off_idx_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_off_idx_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_min_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_shr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_min_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_shr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_shr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_hdr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_wm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_min_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_hdr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_shr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_st_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_wm_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_drop_count_ppg_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_drop_count_port_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pfc_state_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_qid_map_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_qacq_state_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_qacq_ap_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<292;++a0) {
      r += csr_memory_wac_port_ppg_mapping_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_min_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_shr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_hdr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_min_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_shr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_hdr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_pfc_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_icos_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_drop_st_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_drop_st_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_off_idx_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_off_idx_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_min_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_shr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_min_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_shr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_shr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_hdr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_wm_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_min_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_hdr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_shr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_st_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<201;++a0) {
      r += csr_memory_wac_pg_wm_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<201;++a0) {
      r += csr_memory_wac_drop_count_ppg_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_drop_count_port_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_wac_pfc_state_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += csr_memory_wac_qid_map_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_wac_qacq_state_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_wac_qacq_ap_config_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< WacPortPpgMappingEntry, 292 > csr_memory_wac_port_ppg_mapping_;
  std::array< WacPpgCntEntry, 128 > csr_memory_wac_ppg_min_cnt_;
  std::array< WacPpgCntEntry, 128 > csr_memory_wac_ppg_shr_cnt_;
  std::array< WacPpgCntEntry, 128 > csr_memory_wac_ppg_hdr_cnt_;
  std::array< WacPpgThEntry, 128 > csr_memory_wac_ppg_min_th_;
  std::array< WacPpgThEntry, 128 > csr_memory_wac_ppg_shr_th_;
  std::array< WacPpgThEntry, 128 > csr_memory_wac_ppg_hdr_th_;
  std::array< WacPpgPfcEntry, 128 > csr_memory_wac_ppg_pfc_;
  std::array< WacPpgIcosEntry, 128 > csr_memory_wac_ppg_icos_;
  std::array< WacPpgDropStEntry, 128 > csr_memory_wac_ppg_drop_st_;
  std::array< WacPgDropStEntry, 73 > csr_memory_wac_pg_drop_st_;
  std::array< WacPpgOffIdxEntry, 128 > csr_memory_wac_ppg_off_idx_;
  std::array< WacPgOffIdxEntry, 73 > csr_memory_wac_pg_off_idx_;
  std::array< WacPgCntEntry, 73 > csr_memory_wac_pg_min_cnt_;
  std::array< WacPgCntEntry, 73 > csr_memory_wac_pg_shr_cnt_;
  std::array< WacPgThEntry, 73 > csr_memory_wac_pg_min_th_;
  std::array< WacPgThEntry, 73 > csr_memory_wac_pg_shr_th_;
  std::array< WacPortThEntry, 73 > csr_memory_wac_port_shr_th_;
  std::array< WacPortThEntry, 73 > csr_memory_wac_port_hdr_th_;
  std::array< WacPortCntEntry, 73 > csr_memory_wac_port_wm_;
  std::array< WacPortCntEntry, 73 > csr_memory_wac_port_min_cnt_;
  std::array< WacPortCntEntry, 73 > csr_memory_wac_port_hdr_cnt_;
  std::array< WacPortCntEntry, 73 > csr_memory_wac_port_shr_cnt_;
  std::array< WacPortStEntry, 73 > csr_memory_wac_port_st_;
  std::array< WacPgWmCntWmCnt, 201 > csr_memory_wac_pg_wm_cnt_;
  std::array< WacDropCountPpgDropCnt, 201 > csr_memory_wac_drop_count_ppg_;
  std::array< WacDropCountPortDropCnt, 73 > csr_memory_wac_drop_count_port_;
  std::array< WacPfcStatePfcState, 72 > csr_memory_wac_pfc_state_;
  std::array< WacQidMapEntry, 576 > csr_memory_wac_qid_map_;
  std::array< WacQacqStateEntry, 1152 > csr_memory_wac_qacq_state_;
  std::array< WacQacqApConfigEntry, 1152 > csr_memory_wac_qacq_ap_config_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

};








class TmWacPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacPipeMemRspecMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmWacPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  TmWacPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmWacPipeMemRspecMutable")
    {
    }
public:








  WacPortPpgMappingEntryMutable &csr_memory_wac_port_ppg_mapping(int j0) { return csr_memory_wac_port_ppg_mapping_[j0]; }







  WacPpgCntEntryMutable &csr_memory_wac_ppg_min_cnt(int j0) { return csr_memory_wac_ppg_min_cnt_[j0]; }







  WacPpgCntEntryMutable &csr_memory_wac_ppg_shr_cnt(int j0) { return csr_memory_wac_ppg_shr_cnt_[j0]; }







  WacPpgCntEntryMutable &csr_memory_wac_ppg_hdr_cnt(int j0) { return csr_memory_wac_ppg_hdr_cnt_[j0]; }







  WacPpgThEntryMutable &csr_memory_wac_ppg_min_th(int j0) { return csr_memory_wac_ppg_min_th_[j0]; }







  WacPpgThEntryMutable &csr_memory_wac_ppg_shr_th(int j0) { return csr_memory_wac_ppg_shr_th_[j0]; }







  WacPpgThEntryMutable &csr_memory_wac_ppg_hdr_th(int j0) { return csr_memory_wac_ppg_hdr_th_[j0]; }







  WacPpgPfcEntryMutable &csr_memory_wac_ppg_pfc(int j0) { return csr_memory_wac_ppg_pfc_[j0]; }







  WacPpgIcosEntryMutable &csr_memory_wac_ppg_icos(int j0) { return csr_memory_wac_ppg_icos_[j0]; }







  WacPpgDropStEntryMutable &csr_memory_wac_ppg_drop_st(int j0) { return csr_memory_wac_ppg_drop_st_[j0]; }








  WacPgDropStEntryMutable &csr_memory_wac_pg_drop_st(int j0) { return csr_memory_wac_pg_drop_st_[j0]; }







  WacPpgOffIdxEntryMutable &csr_memory_wac_ppg_off_idx(int j0) { return csr_memory_wac_ppg_off_idx_[j0]; }








  WacPgOffIdxEntryMutable &csr_memory_wac_pg_off_idx(int j0) { return csr_memory_wac_pg_off_idx_[j0]; }








  WacPgCntEntryMutable &csr_memory_wac_pg_min_cnt(int j0) { return csr_memory_wac_pg_min_cnt_[j0]; }








  WacPgCntEntryMutable &csr_memory_wac_pg_shr_cnt(int j0) { return csr_memory_wac_pg_shr_cnt_[j0]; }








  WacPgThEntryMutable &csr_memory_wac_pg_min_th(int j0) { return csr_memory_wac_pg_min_th_[j0]; }








  WacPgThEntryMutable &csr_memory_wac_pg_shr_th(int j0) { return csr_memory_wac_pg_shr_th_[j0]; }










  WacPortThEntryMutable &csr_memory_wac_port_shr_th(int j0) { return csr_memory_wac_port_shr_th_[j0]; }










  WacPortThEntryMutable &csr_memory_wac_port_hdr_th(int j0) { return csr_memory_wac_port_hdr_th_[j0]; }










  WacPortCntEntryMutable &csr_memory_wac_port_wm(int j0) { return csr_memory_wac_port_wm_[j0]; }










  WacPortCntEntryMutable &csr_memory_wac_port_min_cnt(int j0) { return csr_memory_wac_port_min_cnt_[j0]; }










  WacPortCntEntryMutable &csr_memory_wac_port_hdr_cnt(int j0) { return csr_memory_wac_port_hdr_cnt_[j0]; }










  WacPortCntEntryMutable &csr_memory_wac_port_shr_cnt(int j0) { return csr_memory_wac_port_shr_cnt_[j0]; }







  WacPortStEntryMutable &csr_memory_wac_port_st(int j0) { return csr_memory_wac_port_st_[j0]; }








  WacPgWmCntWmCntMutable &csr_memory_wac_pg_wm_cnt(int j0) { return csr_memory_wac_pg_wm_cnt_[j0]; }














  WacDropCountPpgDropCntMutable &csr_memory_wac_drop_count_ppg(int j0) { return csr_memory_wac_drop_count_ppg_[j0]; }









  WacDropCountPortDropCntMutable &csr_memory_wac_drop_count_port(int j0) { return csr_memory_wac_drop_count_port_[j0]; }









  WacPfcStatePfcStateMutable &csr_memory_wac_pfc_state(int j0) { return csr_memory_wac_pfc_state_[j0]; }










  WacQidMapEntryMutable &csr_memory_wac_qid_map(int j0) { return csr_memory_wac_qid_map_[j0]; }








  WacQacqStateEntryMutable &csr_memory_wac_qacq_state(int j0) { return csr_memory_wac_qacq_state_[j0]; }








  WacQacqApConfigEntryMutable &csr_memory_wac_qacq_ap_config(int j0) { return csr_memory_wac_qacq_ap_config_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x124) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_ppg_mapping_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_pfc_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_icos_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_drop_st_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_drop_st_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_off_idx_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_off_idx_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_th_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_wm_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_min_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_st_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_wm_cnt_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_ppg_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_port_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_pfc_state_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_qid_map_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_state_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_ap_config_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x124) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_ppg_mapping_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_min_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_shr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_hdr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_min_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_shr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_hdr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_pfc_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_icos_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_drop_st_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_drop_st_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_ppg_off_idx_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_off_idx_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_min_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_shr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_min_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_shr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_shr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_hdr_th_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_wm_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_min_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_hdr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_shr_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_port_st_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pg_wm_cnt_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_drop_count_ppg_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_drop_count_port_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_pfc_state_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_qid_map_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_qacq_state_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      csr_memory_wac_qacq_ap_config_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : csr_memory_wac_port_ppg_mapping_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_min_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_shr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_hdr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_min_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_shr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_hdr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_pfc_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_icos_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_drop_st_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_drop_st_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_ppg_off_idx_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_off_idx_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_min_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_shr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_min_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_shr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_shr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_hdr_th_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_wm_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_min_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_hdr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_shr_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_port_st_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pg_wm_cnt_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_drop_count_ppg_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_drop_count_port_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_pfc_state_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_qid_map_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_qacq_state_) {
      f0.reset();
    }
    for (auto &f0 : csr_memory_wac_qacq_ap_config_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x124) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_ppg_mapping_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_min_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_shr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_hdr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_min_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_shr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_hdr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_pfc_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_icos_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_drop_st_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_drop_st_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_ppg_off_idx_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_off_idx_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_min_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_shr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_min_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_shr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_shr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_hdr_th_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_wm_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_min_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_hdr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_shr_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_port_st_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pg_wm_cnt_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_drop_count_ppg_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_drop_count_port_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_pfc_state_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_qid_map_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_qacq_state_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += csr_memory_wac_qacq_ap_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<292;++a0) {
      r += csr_memory_wac_port_ppg_mapping_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_min_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_shr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_hdr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_min_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_shr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_hdr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_pfc_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_icos_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_drop_st_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_drop_st_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<128;++a0) {
      r += csr_memory_wac_ppg_off_idx_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_off_idx_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_min_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_shr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_min_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_pg_shr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_shr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_hdr_th_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_wm_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_min_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_hdr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_shr_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_port_st_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<201;++a0) {
      r += csr_memory_wac_pg_wm_cnt_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<201;++a0) {
      r += csr_memory_wac_drop_count_ppg_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += csr_memory_wac_drop_count_port_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += csr_memory_wac_pfc_state_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += csr_memory_wac_qid_map_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_wac_qacq_state_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += csr_memory_wac_qacq_ap_config_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< WacPortPpgMappingEntryMutable, 292 > csr_memory_wac_port_ppg_mapping_;
  std::array< WacPpgCntEntryMutable, 128 > csr_memory_wac_ppg_min_cnt_;
  std::array< WacPpgCntEntryMutable, 128 > csr_memory_wac_ppg_shr_cnt_;
  std::array< WacPpgCntEntryMutable, 128 > csr_memory_wac_ppg_hdr_cnt_;
  std::array< WacPpgThEntryMutable, 128 > csr_memory_wac_ppg_min_th_;
  std::array< WacPpgThEntryMutable, 128 > csr_memory_wac_ppg_shr_th_;
  std::array< WacPpgThEntryMutable, 128 > csr_memory_wac_ppg_hdr_th_;
  std::array< WacPpgPfcEntryMutable, 128 > csr_memory_wac_ppg_pfc_;
  std::array< WacPpgIcosEntryMutable, 128 > csr_memory_wac_ppg_icos_;
  std::array< WacPpgDropStEntryMutable, 128 > csr_memory_wac_ppg_drop_st_;
  std::array< WacPgDropStEntryMutable, 73 > csr_memory_wac_pg_drop_st_;
  std::array< WacPpgOffIdxEntryMutable, 128 > csr_memory_wac_ppg_off_idx_;
  std::array< WacPgOffIdxEntryMutable, 73 > csr_memory_wac_pg_off_idx_;
  std::array< WacPgCntEntryMutable, 73 > csr_memory_wac_pg_min_cnt_;
  std::array< WacPgCntEntryMutable, 73 > csr_memory_wac_pg_shr_cnt_;
  std::array< WacPgThEntryMutable, 73 > csr_memory_wac_pg_min_th_;
  std::array< WacPgThEntryMutable, 73 > csr_memory_wac_pg_shr_th_;
  std::array< WacPortThEntryMutable, 73 > csr_memory_wac_port_shr_th_;
  std::array< WacPortThEntryMutable, 73 > csr_memory_wac_port_hdr_th_;
  std::array< WacPortCntEntryMutable, 73 > csr_memory_wac_port_wm_;
  std::array< WacPortCntEntryMutable, 73 > csr_memory_wac_port_min_cnt_;
  std::array< WacPortCntEntryMutable, 73 > csr_memory_wac_port_hdr_cnt_;
  std::array< WacPortCntEntryMutable, 73 > csr_memory_wac_port_shr_cnt_;
  std::array< WacPortStEntryMutable, 73 > csr_memory_wac_port_st_;
  std::array< WacPgWmCntWmCntMutable, 201 > csr_memory_wac_pg_wm_cnt_;
  std::array< WacDropCountPpgDropCntMutable, 201 > csr_memory_wac_drop_count_ppg_;
  std::array< WacDropCountPortDropCntMutable, 73 > csr_memory_wac_drop_count_port_;
  std::array< WacPfcStatePfcStateMutable, 72 > csr_memory_wac_pfc_state_;
  std::array< WacQidMapEntryMutable, 576 > csr_memory_wac_qid_map_;
  std::array< WacQacqStateEntryMutable, 1152 > csr_memory_wac_qacq_state_;
  std::array< WacQacqApConfigEntryMutable, 1152 > csr_memory_wac_qacq_ap_config_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

};








class TmWacPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmWacPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmWacPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:








  WacPortPpgMappingEntry &csr_memory_wac_port_ppg_mapping(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_ppg_mapping(j0);
  }







  WacPpgCntEntry &csr_memory_wac_ppg_min_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_cnt(j0);
  }







  WacPpgCntEntry &csr_memory_wac_ppg_shr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_cnt(j0);
  }







  WacPpgCntEntry &csr_memory_wac_ppg_hdr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_cnt(j0);
  }







  WacPpgThEntry &csr_memory_wac_ppg_min_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_th(j0);
  }







  WacPpgThEntry &csr_memory_wac_ppg_shr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_th(j0);
  }







  WacPpgThEntry &csr_memory_wac_ppg_hdr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_th(j0);
  }







  WacPpgPfcEntry &csr_memory_wac_ppg_pfc(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_pfc(j0);
  }







  WacPpgIcosEntry &csr_memory_wac_ppg_icos(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_icos(j0);
  }







  WacPpgDropStEntry &csr_memory_wac_ppg_drop_st(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_drop_st(j0);
  }








  WacPgDropStEntry &csr_memory_wac_pg_drop_st(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_drop_st(j0);
  }







  WacPpgOffIdxEntry &csr_memory_wac_ppg_off_idx(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_off_idx(j0);
  }








  WacPgOffIdxEntry &csr_memory_wac_pg_off_idx(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_off_idx(j0);
  }








  WacPgCntEntry &csr_memory_wac_pg_min_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_cnt(j0);
  }








  WacPgCntEntry &csr_memory_wac_pg_shr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_cnt(j0);
  }








  WacPgThEntry &csr_memory_wac_pg_min_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_th(j0);
  }








  WacPgThEntry &csr_memory_wac_pg_shr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_th(j0);
  }










  WacPortThEntry &csr_memory_wac_port_shr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_th(j0);
  }










  WacPortThEntry &csr_memory_wac_port_hdr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_th(j0);
  }










  WacPortCntEntry &csr_memory_wac_port_wm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_wm(j0);
  }










  WacPortCntEntry &csr_memory_wac_port_min_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_min_cnt(j0);
  }










  WacPortCntEntry &csr_memory_wac_port_hdr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_cnt(j0);
  }










  WacPortCntEntry &csr_memory_wac_port_shr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_cnt(j0);
  }







  WacPortStEntry &csr_memory_wac_port_st(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_st(j0);
  }








  WacPgWmCntWmCnt &csr_memory_wac_pg_wm_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_wm_cnt(j0);
  }














  WacDropCountPpgDropCnt &csr_memory_wac_drop_count_ppg(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_ppg(j0);
  }









  WacDropCountPortDropCnt &csr_memory_wac_drop_count_port(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_port(j0);
  }









  WacPfcStatePfcState &csr_memory_wac_pfc_state(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pfc_state(j0);
  }










  WacQidMapEntry &csr_memory_wac_qid_map(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qid_map(j0);
  }








  WacQacqStateEntry &csr_memory_wac_qacq_state(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_state(j0);
  }








  WacQacqApConfigEntry &csr_memory_wac_qacq_ap_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_ap_config(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmWacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmWacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmWacPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmWacPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmWacPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmWacPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:








  WacPortPpgMappingEntryMutable &csr_memory_wac_port_ppg_mapping(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_ppg_mapping(j0);
  }







  WacPpgCntEntryMutable &csr_memory_wac_ppg_min_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_cnt(j0);
  }







  WacPpgCntEntryMutable &csr_memory_wac_ppg_shr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_cnt(j0);
  }







  WacPpgCntEntryMutable &csr_memory_wac_ppg_hdr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_cnt(j0);
  }







  WacPpgThEntryMutable &csr_memory_wac_ppg_min_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_th(j0);
  }







  WacPpgThEntryMutable &csr_memory_wac_ppg_shr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_th(j0);
  }







  WacPpgThEntryMutable &csr_memory_wac_ppg_hdr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_th(j0);
  }







  WacPpgPfcEntryMutable &csr_memory_wac_ppg_pfc(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_pfc(j0);
  }







  WacPpgIcosEntryMutable &csr_memory_wac_ppg_icos(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_icos(j0);
  }







  WacPpgDropStEntryMutable &csr_memory_wac_ppg_drop_st(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_drop_st(j0);
  }








  WacPgDropStEntryMutable &csr_memory_wac_pg_drop_st(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_drop_st(j0);
  }







  WacPpgOffIdxEntryMutable &csr_memory_wac_ppg_off_idx(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_off_idx(j0);
  }








  WacPgOffIdxEntryMutable &csr_memory_wac_pg_off_idx(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_off_idx(j0);
  }








  WacPgCntEntryMutable &csr_memory_wac_pg_min_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_cnt(j0);
  }








  WacPgCntEntryMutable &csr_memory_wac_pg_shr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_cnt(j0);
  }








  WacPgThEntryMutable &csr_memory_wac_pg_min_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_th(j0);
  }








  WacPgThEntryMutable &csr_memory_wac_pg_shr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_th(j0);
  }










  WacPortThEntryMutable &csr_memory_wac_port_shr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_th(j0);
  }










  WacPortThEntryMutable &csr_memory_wac_port_hdr_th(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_th(j0);
  }










  WacPortCntEntryMutable &csr_memory_wac_port_wm(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_wm(j0);
  }










  WacPortCntEntryMutable &csr_memory_wac_port_min_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_min_cnt(j0);
  }










  WacPortCntEntryMutable &csr_memory_wac_port_hdr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_cnt(j0);
  }










  WacPortCntEntryMutable &csr_memory_wac_port_shr_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_cnt(j0);
  }







  WacPortStEntryMutable &csr_memory_wac_port_st(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_st(j0);
  }








  WacPgWmCntWmCntMutable &csr_memory_wac_pg_wm_cnt(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_wm_cnt(j0);
  }














  WacDropCountPpgDropCntMutable &csr_memory_wac_drop_count_ppg(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_ppg(j0);
  }









  WacDropCountPortDropCntMutable &csr_memory_wac_drop_count_port(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_port(j0);
  }









  WacPfcStatePfcStateMutable &csr_memory_wac_pfc_state(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pfc_state(j0);
  }










  WacQidMapEntryMutable &csr_memory_wac_qid_map(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qid_map(j0);
  }








  WacQacqStateEntryMutable &csr_memory_wac_qacq_state(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_state(j0);
  }








  WacQacqApConfigEntryMutable &csr_memory_wac_qacq_ap_config(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_ap_config(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmWacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmWacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmWacPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmWacMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmWacMemTopRspec"))
    {
    }
  TmWacMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmWacMemTopRspec")
    {
    }
public:







  TmWacPipeMemRspec &wac_pipe_mem(int j0) { return wac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      wac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      wac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : wac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += wac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += wac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmWacPipeMemRspec, 4 > wac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

};








class TmWacMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmWacMemTopRspecMutable"))
    {
    }
  TmWacMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmWacMemTopRspecMutable")
    {
    }
public:







  TmWacPipeMemRspecMutable &wac_pipe_mem(int j0) { return wac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      wac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      wac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : wac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += wac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += wac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmWacPipeMemRspecMutable, 4 > wac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

};








class TmTopMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmTopMemRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 463856467968, false, write_callback, read_callback, std::string("TmTopMemRspec"))
    {
    }
  TmTopMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmTopMemRspec")
    {
    }
public:





  TmWacMemTopRspec &tm_wac() { return tm_wac_; }





  TmCaaMemTopRspec &tm_caa() { return tm_caa_; }





  TmQacMemTopRspec &tm_qac() { return tm_qac_; }





  TmSchMemTopRspec &tm_scha() { return tm_scha_; }





  TmSchMemTopRspec &tm_schb() { return tm_schb_; }





  TmClcMemTopRspec &tm_clc() { return tm_clc_; }





  TmPexMemTopRspec &tm_pex() { return tm_pex_; }





  TmQlcMemTopRspec &tm_qlc() { return tm_qlc_; }





  TmPrcMemTopRspec &tm_prc() { return tm_prc_; }





  TmPreMemTopRspec &tm_pre() { return tm_pre_; }





  TmPscMemTopRspec &tm_psc() { return tm_psc_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      if (read_callback_) read_callback_();
      tm_wac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      if (read_callback_) read_callback_();
      tm_caa_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      if (read_callback_) read_callback_();
      tm_qac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      if (read_callback_) read_callback_();
      tm_scha_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      if (read_callback_) read_callback_();
      tm_schb_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      if (read_callback_) read_callback_();
      tm_clc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      if (read_callback_) read_callback_();
      tm_pex_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      if (read_callback_) read_callback_();
      tm_qlc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      if (read_callback_) read_callback_();
      tm_prc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      if (read_callback_) read_callback_();
      tm_pre_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      if (read_callback_) read_callback_();
      tm_psc_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      tm_wac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      tm_caa_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      tm_qac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      tm_scha_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      tm_schb_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      tm_clc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      tm_pex_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      tm_qlc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      tm_prc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      tm_pre_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      tm_psc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_wac_.reset();
    tm_caa_.reset();
    tm_qac_.reset();
    tm_scha_.reset();
    tm_schb_.reset();
    tm_clc_.reset();
    tm_pex_.reset();
    tm_qlc_.reset();
    tm_prc_.reset();
    tm_pre_.reset();
    tm_psc_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      r += tm_wac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      r += tm_caa_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      r += tm_qac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      r += tm_scha_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      r += tm_schb_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      r += tm_clc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      r += tm_pex_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      r += tm_qlc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      r += tm_prc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      r += tm_pre_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      r += tm_psc_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_wac_.to_string(print_zeros,indent_string) ;
    r += tm_caa_.to_string(print_zeros,indent_string) ;
    r += tm_qac_.to_string(print_zeros,indent_string) ;
    r += tm_scha_.to_string(print_zeros,indent_string) ;
    r += tm_schb_.to_string(print_zeros,indent_string) ;
    r += tm_clc_.to_string(print_zeros,indent_string) ;
    r += tm_pex_.to_string(print_zeros,indent_string) ;
    r += tm_qlc_.to_string(print_zeros,indent_string) ;
    r += tm_prc_.to_string(print_zeros,indent_string) ;
    r += tm_pre_.to_string(print_zeros,indent_string) ;
    r += tm_psc_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmWacMemTopRspec tm_wac_;
  TmCaaMemTopRspec tm_caa_;
  TmQacMemTopRspec tm_qac_;
  TmSchMemTopRspec tm_scha_;
  TmSchMemTopRspec tm_schb_;
  TmClcMemTopRspec tm_clc_;
  TmPexMemTopRspec tm_pex_;
  TmQlcMemTopRspec tm_qlc_;
  TmPrcMemTopRspec tm_prc_;
  TmPreMemTopRspec tm_pre_;
  TmPscMemTopRspec tm_psc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};








class TmTopMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmTopMemRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 463856467968, true, write_callback, read_callback, std::string("TmTopMemRspecMutable"))
    {
    }
  TmTopMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmTopMemRspecMutable")
    {
    }
public:





  TmWacMemTopRspecMutable &tm_wac() { return tm_wac_; }





  TmCaaMemTopRspecMutable &tm_caa() { return tm_caa_; }





  TmQacMemTopRspecMutable &tm_qac() { return tm_qac_; }





  TmSchMemTopRspecMutable &tm_scha() { return tm_scha_; }





  TmSchMemTopRspecMutable &tm_schb() { return tm_schb_; }





  TmClcMemTopRspecMutable &tm_clc() { return tm_clc_; }





  TmPexMemTopRspecMutable &tm_pex() { return tm_pex_; }





  TmQlcMemTopRspecMutable &tm_qlc() { return tm_qlc_; }





  TmPrcMemTopRspecMutable &tm_prc() { return tm_prc_; }





  TmPreMemTopRspecMutable &tm_pre() { return tm_pre_; }





  TmPscMemTopRspecMutable &tm_psc() { return tm_psc_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      if (read_callback_) read_callback_();
      tm_wac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      if (read_callback_) read_callback_();
      tm_caa_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      if (read_callback_) read_callback_();
      tm_qac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      if (read_callback_) read_callback_();
      tm_scha_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      if (read_callback_) read_callback_();
      tm_schb_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      if (read_callback_) read_callback_();
      tm_clc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      if (read_callback_) read_callback_();
      tm_pex_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      if (read_callback_) read_callback_();
      tm_qlc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      if (read_callback_) read_callback_();
      tm_prc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      if (read_callback_) read_callback_();
      tm_pre_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      if (read_callback_) read_callback_();
      tm_psc_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      tm_wac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      tm_caa_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      tm_qac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      tm_scha_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      tm_schb_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      tm_clc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      tm_pex_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      tm_qlc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      tm_prc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      tm_pre_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      tm_psc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_wac_.reset();
    tm_caa_.reset();
    tm_qac_.reset();
    tm_scha_.reset();
    tm_schb_.reset();
    tm_clc_.reset();
    tm_pex_.reset();
    tm_qlc_.reset();
    tm_prc_.reset();
    tm_pre_.reset();
    tm_psc_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      r += tm_wac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      r += tm_caa_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      r += tm_qac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      r += tm_scha_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      r += tm_schb_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      r += tm_clc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      r += tm_pex_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      r += tm_qlc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      r += tm_prc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      r += tm_pre_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      r += tm_psc_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_wac_.to_string(print_zeros,indent_string) ;
    r += tm_caa_.to_string(print_zeros,indent_string) ;
    r += tm_qac_.to_string(print_zeros,indent_string) ;
    r += tm_scha_.to_string(print_zeros,indent_string) ;
    r += tm_schb_.to_string(print_zeros,indent_string) ;
    r += tm_clc_.to_string(print_zeros,indent_string) ;
    r += tm_pex_.to_string(print_zeros,indent_string) ;
    r += tm_qlc_.to_string(print_zeros,indent_string) ;
    r += tm_prc_.to_string(print_zeros,indent_string) ;
    r += tm_pre_.to_string(print_zeros,indent_string) ;
    r += tm_psc_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmWacMemTopRspecMutable tm_wac_;
  TmCaaMemTopRspecMutable tm_caa_;
  TmQacMemTopRspecMutable tm_qac_;
  TmSchMemTopRspecMutable tm_scha_;
  TmSchMemTopRspecMutable tm_schb_;
  TmClcMemTopRspecMutable tm_clc_;
  TmPexMemTopRspecMutable tm_pex_;
  TmQlcMemTopRspecMutable tm_qlc_;
  TmPrcMemTopRspecMutable tm_prc_;
  TmPreMemTopRspecMutable tm_pre_;
  TmPscMemTopRspecMutable tm_psc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};








class Chip : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  Chip(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4398046511104, false, write_callback, read_callback, std::string("Chip"))
    {
    }
  Chip(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "Chip")
    {
    }
public:





  TmTopMemRspec &tm() { return tm_; }







  PipeAddrmap &pipes(int j0) { return pipes_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      tm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      if (read_callback_) read_callback_();
      pipes_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      tm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      pipes_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_.reset();
    for (auto &f0 : pipes_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      r += tm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      r += pipes_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pipes_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmTopMemRspec tm_;
  std::array< PipeAddrmap, 4 > pipes_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};








class ChipMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  ChipMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4398046511104, true, write_callback, read_callback, std::string("ChipMutable"))
    {
    }
  ChipMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "ChipMutable")
    {
    }
public:





  TmTopMemRspecMutable &tm() { return tm_; }







  PipeAddrmapMutable &pipes(int j0) { return pipes_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      tm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      if (read_callback_) read_callback_();
      pipes_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      tm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      pipes_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_.reset();
    for (auto &f0 : pipes_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      r += tm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      r += pipes_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pipes_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmTopMemRspecMutable tm_;
  std::array< PipeAddrmapMutable, 4 > pipes_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};
  }; // namespace memory_classes
}; // namespace jbay
#endif // #ifndef ___JBAY_REGISTER_INCLUDES_MODEL_MEM_H__
