/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_PARB_RIGHT_REG_H__
#define __REGISTER_INCLUDES_PARB_RIGHT_REG_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>









#include "parb_bubble_count.h"
#include "parb_chnl_ctrl.h"
#include "parb_dpr_slot_ctrl.h"
#include "parb_dpr_slot_status.h"
#include "parb_dprs_input_fifo_count.h"
#include "parb_phv_count.h"
#include "parb_port_debug.h"
#include "parb_port_debug_en.h"
#include "parb_priority_inc_r.h"
#include "parb_right_reg_debug_ctrl.h"
#include "parb_right_reg_e_afifo_oflow_err_log.h"
#include "parb_right_reg_e_arb_cred_oflow_err_log.h"
#include "parb_right_reg_e_arb_cred_uflow_err_log.h"
#include "parb_right_reg_e_avail_oflow_err_log.h"
#include "parb_right_reg_e_bcnt_oflow_err_log.h"
#include "parb_right_reg_e_phv_rate_ctrl.h"
#include "parb_right_reg_g_phv_rate_ctrl.h"
#include "parb_right_reg_gbl_rate_ctrl.h"
#include "parb_right_reg_intr.h"
#include "parb_right_reg_port_rate_cfg.h"
#include "parb_tdm_last_entry.h"
#include "parb_tdm_table_entry.h"
#include "parb_wb_ctrl.h"

namespace jbay {
  namespace register_classes {

class ParbRightReg : public model_core::RegisterBlock<RegisterCallback> {
public:
  ParbRightReg(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap), 1908, false, write_callback, read_callback, std::string("ParbRightReg")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  ParbRightReg(
      
  )
    : RegisterBlock(0, 0, 0, false, 0, 0, "ParbRightReg")
    {
    }
public:









  ParbRightRegPortRateCfg &port_rate_cfg(int j0) { return port_rate_cfg_[j0]; }






  ParbRightRegEPhvRateCtrl &e_phv_rate_ctrl() { return e_phv_rate_ctrl_; }






  ParbRightRegGPhvRateCtrl &g_phv_rate_ctrl() { return g_phv_rate_ctrl_; }






  ParbRightRegGblRateCtrl &gbl_rate_ctrl() { return gbl_rate_ctrl_; }







  ParbChnlCtrl &e_chnl_ctrl(int j0) { return e_chnl_ctrl_[j0]; }







  ParbDprsInputFifoCount &e_dprsr_cred_status(int j0) { return e_dprsr_cred_status_[j0]; }





  ParbBubbleCount &e_bubble_count() { return e_bubble_count_; }





  ParbPhvCount &e_phv_count() { return e_phv_count_; }





  ParbPhvCount &e_eop_count() { return e_eop_count_; }







  ParbPortDebug &e_port_dbg(int j0) { return e_port_dbg_[j0]; }





  ParbTdmLastEntry &e_tdm_last_entry() { return e_tdm_last_entry_; }






  ParbTdmTableEntry &e_tdm_table(int j0) { return e_tdm_table_[j0]; }





  ParbDprSlotCtrl &e_slot_ctrl() { return e_slot_ctrl_; }





  ParbDprSlotStatus &e_slot_status() { return e_slot_status_; }







  ParbPriorityIncR &e_pri_inc_ctrl_400g() { return e_pri_inc_ctrl_400g_; }







  ParbPriorityIncR &e_pri_inc_ctrl_200g() { return e_pri_inc_ctrl_200g_; }







  ParbPriorityIncR &e_pri_inc_ctrl_100g() { return e_pri_inc_ctrl_100g_; }







  ParbPriorityIncR &e_pri_inc_ctrl_50g() { return e_pri_inc_ctrl_50g_; }







  ParbPriorityIncR &e_pri_inc_ctrl_40g() { return e_pri_inc_ctrl_40g_; }







  ParbPriorityIncR &e_pri_inc_ctrl_25g() { return e_pri_inc_ctrl_25g_; }







  ParbPriorityIncR &e_pri_inc_ctrl_10g() { return e_pri_inc_ctrl_10g_; }





  ParbRightRegEAvailOflowErrLog &e_avail_oflow_err_log() { return e_avail_oflow_err_log_; }





  ParbRightRegEBcntOflowErrLog &e_bcnt_oflow_err_log() { return e_bcnt_oflow_err_log_; }





  ParbRightRegEAfifoOflowErrLog &e_afifo_oflow_err_log() { return e_afifo_oflow_err_log_; }





  ParbRightRegEArbCredUflowErrLog &e_arb_cred_uflow_err_log() { return e_arb_cred_uflow_err_log_; }





  ParbRightRegEArbCredOflowErrLog &e_arb_cred_oflow_err_log() { return e_arb_cred_oflow_err_log_; }





  ParbRightRegDebugCtrl &debug_ctrl() { return debug_ctrl_; }





  ParbPortDebugEn &e_port_dbg_en() { return e_port_dbg_en_; }





  ParbWbCtrl &e_wb_ctrl() { return e_wb_ctrl_; }
  ParbRightRegIntr &intr() { return intr_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x40 && offset < 0x64) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_rate_cfg_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      if (read_callback_) read_callback_();
      e_phv_rate_ctrl_.read( offset, data );
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      if (read_callback_) read_callback_();
      g_phv_rate_ctrl_.read( offset, data );
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      if (read_callback_) read_callback_();
      gbl_rate_ctrl_.read( offset, data );
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      e_chnl_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      e_dprsr_cred_status_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x520 && offset < 0x528) {
      offset -= 0x520;
      if (read_callback_) read_callback_();
      e_bubble_count_.read( offset, data );
    }
    else if (offset >= 0x528 && offset < 0x530) {
      offset -= 0x528;
      if (read_callback_) read_callback_();
      e_phv_count_.read( offset, data );
    }
    else if (offset >= 0x530 && offset < 0x538) {
      offset -= 0x530;
      if (read_callback_) read_callback_();
      e_eop_count_.read( offset, data );
    }
    else if (offset >= 0x580 && offset < 0x5c8) {
      offset -= 0x580;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      e_port_dbg_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x5c8 && offset < 0x5cc) {
      offset -= 0x5c8;
      if (read_callback_) read_callback_();
      e_tdm_last_entry_.read( offset, data );
    }
    else if (offset >= 0x600 && offset < 0x700) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      e_tdm_table_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x700 && offset < 0x704) {
      offset -= 0x700;
      if (read_callback_) read_callback_();
      e_slot_ctrl_.read( offset, data );
    }
    else if (offset >= 0x704 && offset < 0x708) {
      offset -= 0x704;
      if (read_callback_) read_callback_();
      e_slot_status_.read( offset, data );
    }
    else if (offset >= 0x708 && offset < 0x70c) {
      offset -= 0x708;
      if (read_callback_) read_callback_();
      e_pri_inc_ctrl_400g_.read( offset, data );
    }
    else if (offset >= 0x70c && offset < 0x710) {
      offset -= 0x70c;
      if (read_callback_) read_callback_();
      e_pri_inc_ctrl_200g_.read( offset, data );
    }
    else if (offset >= 0x710 && offset < 0x714) {
      offset -= 0x710;
      if (read_callback_) read_callback_();
      e_pri_inc_ctrl_100g_.read( offset, data );
    }
    else if (offset >= 0x714 && offset < 0x718) {
      offset -= 0x714;
      if (read_callback_) read_callback_();
      e_pri_inc_ctrl_50g_.read( offset, data );
    }
    else if (offset >= 0x718 && offset < 0x71c) {
      offset -= 0x718;
      if (read_callback_) read_callback_();
      e_pri_inc_ctrl_40g_.read( offset, data );
    }
    else if (offset >= 0x71c && offset < 0x720) {
      offset -= 0x71c;
      if (read_callback_) read_callback_();
      e_pri_inc_ctrl_25g_.read( offset, data );
    }
    else if (offset >= 0x720 && offset < 0x724) {
      offset -= 0x720;
      if (read_callback_) read_callback_();
      e_pri_inc_ctrl_10g_.read( offset, data );
    }
    else if (offset >= 0x754 && offset < 0x758) {
      offset -= 0x754;
      if (read_callback_) read_callback_();
      e_avail_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x758 && offset < 0x75c) {
      offset -= 0x758;
      if (read_callback_) read_callback_();
      e_bcnt_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x75c && offset < 0x760) {
      offset -= 0x75c;
      if (read_callback_) read_callback_();
      e_afifo_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x760 && offset < 0x764) {
      offset -= 0x760;
      if (read_callback_) read_callback_();
      e_arb_cred_uflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x764 && offset < 0x768) {
      offset -= 0x764;
      if (read_callback_) read_callback_();
      e_arb_cred_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x768 && offset < 0x76c) {
      offset -= 0x768;
      if (read_callback_) read_callback_();
      debug_ctrl_.read( offset, data );
    }
    else if (offset >= 0x76c && offset < 0x770) {
      offset -= 0x76c;
      if (read_callback_) read_callback_();
      e_port_dbg_en_.read( offset, data );
    }
    else if (offset >= 0x770 && offset < 0x774) {
      offset -= 0x770;
      if (read_callback_) read_callback_();
      e_wb_ctrl_.read( offset, data );
    }
    else if (offset >= 0x740 && offset < 0x754) {
      offset -= 0x740;
      if (read_callback_) read_callback_();
      intr_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x40 && offset < 0x64) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_rate_cfg_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      e_phv_rate_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      g_phv_rate_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      gbl_rate_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      e_chnl_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      e_dprsr_cred_status_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x520 && offset < 0x528) {
      offset -= 0x520;
      e_bubble_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x528 && offset < 0x530) {
      offset -= 0x528;
      e_phv_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x530 && offset < 0x538) {
      offset -= 0x530;
      e_eop_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x580 && offset < 0x5c8) {
      offset -= 0x580;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      e_port_dbg_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5c8 && offset < 0x5cc) {
      offset -= 0x5c8;
      e_tdm_last_entry_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x700) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      e_tdm_table_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x700 && offset < 0x704) {
      offset -= 0x700;
      e_slot_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x704 && offset < 0x708) {
      offset -= 0x704;
      e_slot_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x708 && offset < 0x70c) {
      offset -= 0x708;
      e_pri_inc_ctrl_400g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x70c && offset < 0x710) {
      offset -= 0x70c;
      e_pri_inc_ctrl_200g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x710 && offset < 0x714) {
      offset -= 0x710;
      e_pri_inc_ctrl_100g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x714 && offset < 0x718) {
      offset -= 0x714;
      e_pri_inc_ctrl_50g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x718 && offset < 0x71c) {
      offset -= 0x718;
      e_pri_inc_ctrl_40g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x71c && offset < 0x720) {
      offset -= 0x71c;
      e_pri_inc_ctrl_25g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x720 && offset < 0x724) {
      offset -= 0x720;
      e_pri_inc_ctrl_10g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x754 && offset < 0x758) {
      offset -= 0x754;
      e_avail_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x758 && offset < 0x75c) {
      offset -= 0x758;
      e_bcnt_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x75c && offset < 0x760) {
      offset -= 0x75c;
      e_afifo_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x760 && offset < 0x764) {
      offset -= 0x760;
      e_arb_cred_uflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x764 && offset < 0x768) {
      offset -= 0x764;
      e_arb_cred_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x768 && offset < 0x76c) {
      offset -= 0x768;
      debug_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x76c && offset < 0x770) {
      offset -= 0x76c;
      e_port_dbg_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x770 && offset < 0x774) {
      offset -= 0x770;
      e_wb_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x740 && offset < 0x754) {
      offset -= 0x740;
      intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : port_rate_cfg_) {
      f0.reset();
    }
    e_phv_rate_ctrl_.reset();
    g_phv_rate_ctrl_.reset();
    gbl_rate_ctrl_.reset();
    for (auto &f0 : e_chnl_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : e_dprsr_cred_status_) {
      f0.reset();
    }
    e_bubble_count_.reset();
    e_phv_count_.reset();
    e_eop_count_.reset();
    for (auto &f0 : e_port_dbg_) {
      f0.reset();
    }
    e_tdm_last_entry_.reset();
    for (auto &f0 : e_tdm_table_) {
      f0.reset();
    }
    e_slot_ctrl_.reset();
    e_slot_status_.reset();
    e_pri_inc_ctrl_400g_.reset();
    e_pri_inc_ctrl_200g_.reset();
    e_pri_inc_ctrl_100g_.reset();
    e_pri_inc_ctrl_50g_.reset();
    e_pri_inc_ctrl_40g_.reset();
    e_pri_inc_ctrl_25g_.reset();
    e_pri_inc_ctrl_10g_.reset();
    e_avail_oflow_err_log_.reset();
    e_bcnt_oflow_err_log_.reset();
    e_afifo_oflow_err_log_.reset();
    e_arb_cred_uflow_err_log_.reset();
    e_arb_cred_oflow_err_log_.reset();
    debug_ctrl_.reset();
    e_port_dbg_en_.reset();
    e_wb_ctrl_.reset();
    intr_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x40 && offset < 0x64) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_rate_cfg_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      r += e_phv_rate_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      r += g_phv_rate_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      r += gbl_rate_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += e_chnl_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += e_dprsr_cred_status_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x520 && offset < 0x528) {
      offset -= 0x520;
      r += e_bubble_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x528 && offset < 0x530) {
      offset -= 0x528;
      r += e_phv_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x530 && offset < 0x538) {
      offset -= 0x530;
      r += e_eop_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x580 && offset < 0x5c8) {
      offset -= 0x580;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += e_port_dbg_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5c8 && offset < 0x5cc) {
      offset -= 0x5c8;
      r += e_tdm_last_entry_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x700) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += e_tdm_table_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x700 && offset < 0x704) {
      offset -= 0x700;
      r += e_slot_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x704 && offset < 0x708) {
      offset -= 0x704;
      r += e_slot_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x708 && offset < 0x70c) {
      offset -= 0x708;
      r += e_pri_inc_ctrl_400g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x70c && offset < 0x710) {
      offset -= 0x70c;
      r += e_pri_inc_ctrl_200g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x710 && offset < 0x714) {
      offset -= 0x710;
      r += e_pri_inc_ctrl_100g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x714 && offset < 0x718) {
      offset -= 0x714;
      r += e_pri_inc_ctrl_50g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x718 && offset < 0x71c) {
      offset -= 0x718;
      r += e_pri_inc_ctrl_40g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x71c && offset < 0x720) {
      offset -= 0x71c;
      r += e_pri_inc_ctrl_25g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x720 && offset < 0x724) {
      offset -= 0x720;
      r += e_pri_inc_ctrl_10g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x754 && offset < 0x758) {
      offset -= 0x754;
      r += e_avail_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x758 && offset < 0x75c) {
      offset -= 0x758;
      r += e_bcnt_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x75c && offset < 0x760) {
      offset -= 0x75c;
      r += e_afifo_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x760 && offset < 0x764) {
      offset -= 0x760;
      r += e_arb_cred_uflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x764 && offset < 0x768) {
      offset -= 0x764;
      r += e_arb_cred_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x768 && offset < 0x76c) {
      offset -= 0x768;
      r += debug_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x76c && offset < 0x770) {
      offset -= 0x76c;
      r += e_port_dbg_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x770 && offset < 0x774) {
      offset -= 0x770;
      r += e_wb_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x740 && offset < 0x754) {
      offset -= 0x740;
      r += intr_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<9;++a0) {
      r += port_rate_cfg_[a0].to_string(print_zeros,indent_string) ;
    }
    r += e_phv_rate_ctrl_.to_string(print_zeros,indent_string) ;
    r += g_phv_rate_ctrl_.to_string(print_zeros,indent_string) ;
    r += gbl_rate_ctrl_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<72;++a0) {
      r += e_chnl_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += e_dprsr_cred_status_[a0].to_string(print_zeros,indent_string) ;
    }
    r += e_bubble_count_.to_string(print_zeros,indent_string) ;
    r += e_phv_count_.to_string(print_zeros,indent_string) ;
    r += e_eop_count_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<18;++a0) {
      r += e_port_dbg_[a0].to_string(print_zeros,indent_string) ;
    }
    r += e_tdm_last_entry_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<64;++a0) {
      r += e_tdm_table_[a0].to_string(print_zeros,indent_string) ;
    }
    r += e_slot_ctrl_.to_string(print_zeros,indent_string) ;
    r += e_slot_status_.to_string(print_zeros,indent_string) ;
    r += e_pri_inc_ctrl_400g_.to_string(print_zeros,indent_string) ;
    r += e_pri_inc_ctrl_200g_.to_string(print_zeros,indent_string) ;
    r += e_pri_inc_ctrl_100g_.to_string(print_zeros,indent_string) ;
    r += e_pri_inc_ctrl_50g_.to_string(print_zeros,indent_string) ;
    r += e_pri_inc_ctrl_40g_.to_string(print_zeros,indent_string) ;
    r += e_pri_inc_ctrl_25g_.to_string(print_zeros,indent_string) ;
    r += e_pri_inc_ctrl_10g_.to_string(print_zeros,indent_string) ;
    r += e_avail_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += e_bcnt_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += e_afifo_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += e_arb_cred_uflow_err_log_.to_string(print_zeros,indent_string) ;
    r += e_arb_cred_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += debug_ctrl_.to_string(print_zeros,indent_string) ;
    r += e_port_dbg_en_.to_string(print_zeros,indent_string) ;
    r += e_wb_ctrl_.to_string(print_zeros,indent_string) ;
    r += intr_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< ParbRightRegPortRateCfg, 9 > port_rate_cfg_;
  ParbRightRegEPhvRateCtrl e_phv_rate_ctrl_;
  ParbRightRegGPhvRateCtrl g_phv_rate_ctrl_;
  ParbRightRegGblRateCtrl gbl_rate_ctrl_;
  std::array< ParbChnlCtrl, 72 > e_chnl_ctrl_;
  std::array< ParbDprsInputFifoCount, 72 > e_dprsr_cred_status_;
  ParbBubbleCount e_bubble_count_;
  ParbPhvCount e_phv_count_;
  ParbPhvCount e_eop_count_;
  std::array< ParbPortDebug, 18 > e_port_dbg_;
  ParbTdmLastEntry e_tdm_last_entry_;
  std::array< ParbTdmTableEntry, 64 > e_tdm_table_;
  ParbDprSlotCtrl e_slot_ctrl_;
  ParbDprSlotStatus e_slot_status_;
  ParbPriorityIncR e_pri_inc_ctrl_400g_;
  ParbPriorityIncR e_pri_inc_ctrl_200g_;
  ParbPriorityIncR e_pri_inc_ctrl_100g_;
  ParbPriorityIncR e_pri_inc_ctrl_50g_;
  ParbPriorityIncR e_pri_inc_ctrl_40g_;
  ParbPriorityIncR e_pri_inc_ctrl_25g_;
  ParbPriorityIncR e_pri_inc_ctrl_10g_;
  ParbRightRegEAvailOflowErrLog e_avail_oflow_err_log_;
  ParbRightRegEBcntOflowErrLog e_bcnt_oflow_err_log_;
  ParbRightRegEAfifoOflowErrLog e_afifo_oflow_err_log_;
  ParbRightRegEArbCredUflowErrLog e_arb_cred_uflow_err_log_;
  ParbRightRegEArbCredOflowErrLog e_arb_cred_oflow_err_log_;
  ParbRightRegDebugCtrl debug_ctrl_;
  ParbPortDebugEn e_port_dbg_en_;
  ParbWbCtrl e_wb_ctrl_;
  ParbRightRegIntr intr_;
private:
  static int StartOffset(
      int index_pipe_addrmap
      ) {
    int offset=0;
    offset += 0x4000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x1000000; // pipe_addrmap[]
    offset += 0xc00000; // to get to pardereg
    offset += 0x14000; // to get to parbreg
    offset += 0x800; // to get to right
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace jbay

#endif // __REGISTER_INCLUDES_PARB_RIGHT_REG_H__
