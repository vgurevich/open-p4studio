/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_TM_SCH_PIPE_RSPEC_MUTABLE_H__
#define __REGISTER_INCLUDES_TM_SCH_PIPE_RSPEC_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>









#include "sch_adv_cntr_r_mutable.h"
#include "sch_advfc_config_r_mutable.h"
#include "sch_advfc_status_r_mutable.h"
#include "sch_byte_count_adjust_r_mutable.h"
#include "sch_ctrl_r_mutable.h"
#include "sch_l1_config_r_mutable.h"
#include "sch_mac_pex_status_r_mutable.h"
#include "sch_pex_credit_ctrl_r_mutable.h"
#include "sch_port_arb_ctrl_r_mutable.h"
#include "sch_port_config_r_mutable.h"
#include "sch_port_pex_status_r_mutable.h"
#include "sch_port_pfc_status_r_mutable.h"
#include "sch_pq_ctrl_r_mutable.h"
#include "sch_pq_port_en_r_mutable.h"
#include "sch_pq_port_profile_sel_r_mutable.h"
#include "sch_queue_config_r_mutable.h"
#include "sch_queue_flush_ctrl_r_mutable.h"
#include "sch_queue_flush_mask_r_mutable.h"
#include "sch_ready_r_mutable.h"
#include "sch_tdm_config_r_mutable.h"
#include "sch_tdm_table_entry_r_mutable.h"
#include "sch_watchdog_config_r_mutable.h"
#include "sch_watchdog_status_r_mutable.h"
#include "sch_watchdog_timer_r_mutable.h"
#include "tm_sch_pipe_rspec_debug_bus_ctrl_mutable.h"
#include "tm_sch_pipe_rspec_ecc_mutable.h"
#include "tm_sch_pipe_rspec_intr_mutable.h"
#include "tm_sch_pipe_rspec_l1_excrate_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_l1_excrate_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_l1_maxrate_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_l1_maxrate_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_l1_minrate_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_l1_minrate_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_p_maxrate_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_p_maxrate_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_pex_credit_err_log_mutable.h"
#include "tm_sch_pipe_rspec_pex_mac_credit_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_excrate_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_excrate_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_maxrate_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_maxrate_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_minrate_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_minrate_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_watchdog_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_q_watchdog_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_tdm_table_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_tdm_table_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_edprsr_advfc_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_edprsr_advfc_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_edprsr_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_edprsr_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex0_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex0_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex1_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex1_sbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_wac_mbe_err_log_mutable.h"
#include "tm_sch_pipe_rspec_upd_wac_sbe_err_log_mutable.h"

namespace jbay {
  namespace register_classes {

class TmSchPipeRspecMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  enum TmTopRspecEnum {
    kTmSchaTop,
    kTmSchbTop
  };
public:
  TmSchPipeRspecMutable(
      int chipNumber, TmTopRspecEnum selector_tm_top_rspec, int index_tm_sch_pipe_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_tm_top_rspec, index_tm_sch_pipe_rspec), 32768, true, write_callback, read_callback, std::string("TmSchPipeRspecMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_rspec))
    {
    }
  TmSchPipeRspecMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "TmSchPipeRspecMutable")
    {
    }
public:








  TmSchPipeRspecEccMutable &ecc() { return ecc_; }





  TmSchPipeRspecTdmTableSbeErrLogMutable &tdm_table_sbe_err_log() { return tdm_table_sbe_err_log_; }





  TmSchPipeRspecTdmTableMbeErrLogMutable &tdm_table_mbe_err_log() { return tdm_table_mbe_err_log_; }





  TmSchPipeRspecUpdWacSbeErrLogMutable &upd_wac_sbe_err_log() { return upd_wac_sbe_err_log_; }





  TmSchPipeRspecUpdWacMbeErrLogMutable &upd_wac_mbe_err_log() { return upd_wac_mbe_err_log_; }





  TmSchPipeRspecUpdEdprsrAdvfcSbeErrLogMutable &upd_edprsr_advfc_sbe_err_log() { return upd_edprsr_advfc_sbe_err_log_; }





  TmSchPipeRspecUpdEdprsrAdvfcMbeErrLogMutable &upd_edprsr_advfc_mbe_err_log() { return upd_edprsr_advfc_mbe_err_log_; }





  TmSchPipeRspecQMinrateSbeErrLogMutable &q_minrate_sbe_err_log() { return q_minrate_sbe_err_log_; }





  TmSchPipeRspecQMinrateMbeErrLogMutable &q_minrate_mbe_err_log() { return q_minrate_mbe_err_log_; }





  TmSchPipeRspecQExcrateSbeErrLogMutable &q_excrate_sbe_err_log() { return q_excrate_sbe_err_log_; }





  TmSchPipeRspecQExcrateMbeErrLogMutable &q_excrate_mbe_err_log() { return q_excrate_mbe_err_log_; }





  TmSchPipeRspecQMaxrateSbeErrLogMutable &q_maxrate_sbe_err_log() { return q_maxrate_sbe_err_log_; }





  TmSchPipeRspecQMaxrateMbeErrLogMutable &q_maxrate_mbe_err_log() { return q_maxrate_mbe_err_log_; }





  TmSchPipeRspecL1MinrateSbeErrLogMutable &l1_minrate_sbe_err_log() { return l1_minrate_sbe_err_log_; }





  TmSchPipeRspecL1MinrateMbeErrLogMutable &l1_minrate_mbe_err_log() { return l1_minrate_mbe_err_log_; }





  TmSchPipeRspecL1ExcrateSbeErrLogMutable &l1_excrate_sbe_err_log() { return l1_excrate_sbe_err_log_; }





  TmSchPipeRspecL1ExcrateMbeErrLogMutable &l1_excrate_mbe_err_log() { return l1_excrate_mbe_err_log_; }





  TmSchPipeRspecL1MaxrateSbeErrLogMutable &l1_maxrate_sbe_err_log() { return l1_maxrate_sbe_err_log_; }





  TmSchPipeRspecL1MaxrateMbeErrLogMutable &l1_maxrate_mbe_err_log() { return l1_maxrate_mbe_err_log_; }





  TmSchPipeRspecPMaxrateSbeErrLogMutable &p_maxrate_sbe_err_log() { return p_maxrate_sbe_err_log_; }





  TmSchPipeRspecPMaxrateMbeErrLogMutable &p_maxrate_mbe_err_log() { return p_maxrate_mbe_err_log_; }












  TmSchPipeRspecUpdPex0SbeErrLogMutable &upd_pex0_sbe_err_log() { return upd_pex0_sbe_err_log_; }












  TmSchPipeRspecUpdPex0MbeErrLogMutable &upd_pex0_mbe_err_log() { return upd_pex0_mbe_err_log_; }












  TmSchPipeRspecUpdPex1SbeErrLogMutable &upd_pex1_sbe_err_log() { return upd_pex1_sbe_err_log_; }












  TmSchPipeRspecUpdPex1MbeErrLogMutable &upd_pex1_mbe_err_log() { return upd_pex1_mbe_err_log_; }












  TmSchPipeRspecUpdEdprsrSbeErrLogMutable &upd_edprsr_sbe_err_log() { return upd_edprsr_sbe_err_log_; }












  TmSchPipeRspecUpdEdprsrMbeErrLogMutable &upd_edprsr_mbe_err_log() { return upd_edprsr_mbe_err_log_; }





  TmSchPipeRspecPexCreditErrLogMutable &pex_credit_err_log() { return pex_credit_err_log_; }





  TmSchPipeRspecPexMacCreditErrLogMutable &pex_mac_credit_err_log() { return pex_mac_credit_err_log_; }





  TmSchPipeRspecQWatchdogSbeErrLogMutable &q_watchdog_sbe_err_log() { return q_watchdog_sbe_err_log_; }





  TmSchPipeRspecQWatchdogMbeErrLogMutable &q_watchdog_mbe_err_log() { return q_watchdog_mbe_err_log_; }






  SchCtrlRMutable &ctrl() { return ctrl_; }






  SchReadyRMutable &ready() { return ready_; }






  SchByteCountAdjustRMutable &global_bytecnt_adj() { return global_bytecnt_adj_; }





  SchTdmConfigRMutable &tdm_config() { return tdm_config_; }












  SchTdmTableEntryRMutable &tdm_table(int j0) { return tdm_table_[j0]; }





  SchPortArbCtrlRMutable &port_arb_ctrl() { return port_arb_ctrl_; }





  SchPexCreditCtrlRMutable &pex_credit_ctrl() { return pex_credit_ctrl_; }








  SchPortConfigRMutable &port_config(int j0) { return port_config_[j0]; }






  SchPortPfcStatusRMutable &port_pfc_status_mem(int j0) { return port_pfc_status_mem_[j0]; }












  SchPortPexStatusRMutable &port_pex_status_mem(int j0) { return port_pex_status_mem_[j0]; }









  SchMacPexStatusRMutable &mac_pex_status_mem(int j0) { return mac_pex_status_mem_[j0]; }








  SchL1ConfigRMutable &l1_config(int j0) { return l1_config_[j0]; }









  SchQueueConfigRMutable &queue_config(int j0) { return queue_config_[j0]; }




  SchQueueFlushCtrlRMutable &queue_flush_ctrl() { return queue_flush_ctrl_; }




  SchQueueFlushMaskRMutable &queue_flush_mask() { return queue_flush_mask_; }





  SchWatchdogConfigRMutable &watchdog_config() { return watchdog_config_; }







  SchWatchdogStatusRMutable &watchdog_status(int j0) { return watchdog_status_[j0]; }





  SchWatchdogTimerRMutable &watchdog_timer() { return watchdog_timer_; }





  SchAdvfcConfigRMutable &iadvfc_config() { return iadvfc_config_; }





  SchAdvfcStatusRMutable &iadvfc_status() { return iadvfc_status_; }





  SchAdvCntrRMutable &iadvfc_ctr() { return iadvfc_ctr_; }





  SchAdvfcConfigRMutable &eadvfc_config() { return eadvfc_config_; }





  SchAdvfcStatusRMutable &eadvfc_status() { return eadvfc_status_; }





  SchAdvCntrRMutable &eadvfc_ctr() { return eadvfc_ctr_; }










  SchPqCtrlRMutable &pq_ctrl() { return pq_ctrl_; }






  SchPqPortEnRMutable &pq_port_en() { return pq_port_en_; }






  SchPqPortProfileSelRMutable &pq_port_profile_sel() { return pq_port_profile_sel_; }





  TmSchPipeRspecDebugBusCtrlMutable &debug_bus_ctrl() { return debug_bus_ctrl_; }
  TmSchPipeRspecIntrMutable &intr() { return intr_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x20 && offset < 0x34) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      ecc_.read( offset, data );
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      if (read_callback_) read_callback_();
      tdm_table_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x58 && offset < 0x5c) {
      offset -= 0x58;
      if (read_callback_) read_callback_();
      tdm_table_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x5c && offset < 0x60) {
      offset -= 0x5c;
      if (read_callback_) read_callback_();
      upd_wac_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x60 && offset < 0x64) {
      offset -= 0x60;
      if (read_callback_) read_callback_();
      upd_wac_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      if (read_callback_) read_callback_();
      upd_edprsr_advfc_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      if (read_callback_) read_callback_();
      upd_edprsr_advfc_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      if (read_callback_) read_callback_();
      q_minrate_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x70 && offset < 0x74) {
      offset -= 0x70;
      if (read_callback_) read_callback_();
      q_minrate_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x74 && offset < 0x78) {
      offset -= 0x74;
      if (read_callback_) read_callback_();
      q_excrate_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x78 && offset < 0x7c) {
      offset -= 0x78;
      if (read_callback_) read_callback_();
      q_excrate_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x7c && offset < 0x80) {
      offset -= 0x7c;
      if (read_callback_) read_callback_();
      q_maxrate_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x80 && offset < 0x84) {
      offset -= 0x80;
      if (read_callback_) read_callback_();
      q_maxrate_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x84 && offset < 0x88) {
      offset -= 0x84;
      if (read_callback_) read_callback_();
      l1_minrate_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x88 && offset < 0x8c) {
      offset -= 0x88;
      if (read_callback_) read_callback_();
      l1_minrate_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x8c && offset < 0x90) {
      offset -= 0x8c;
      if (read_callback_) read_callback_();
      l1_excrate_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x90 && offset < 0x94) {
      offset -= 0x90;
      if (read_callback_) read_callback_();
      l1_excrate_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x94 && offset < 0x98) {
      offset -= 0x94;
      if (read_callback_) read_callback_();
      l1_maxrate_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x98 && offset < 0x9c) {
      offset -= 0x98;
      if (read_callback_) read_callback_();
      l1_maxrate_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x9c && offset < 0xa0) {
      offset -= 0x9c;
      if (read_callback_) read_callback_();
      p_maxrate_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xa0 && offset < 0xa4) {
      offset -= 0xa0;
      if (read_callback_) read_callback_();
      p_maxrate_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xa4 && offset < 0xa8) {
      offset -= 0xa4;
      if (read_callback_) read_callback_();
      upd_pex0_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xa8 && offset < 0xac) {
      offset -= 0xa8;
      if (read_callback_) read_callback_();
      upd_pex0_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xac && offset < 0xb0) {
      offset -= 0xac;
      if (read_callback_) read_callback_();
      upd_pex1_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xb0 && offset < 0xb4) {
      offset -= 0xb0;
      if (read_callback_) read_callback_();
      upd_pex1_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xb4 && offset < 0xb8) {
      offset -= 0xb4;
      if (read_callback_) read_callback_();
      upd_edprsr_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xb8 && offset < 0xbc) {
      offset -= 0xb8;
      if (read_callback_) read_callback_();
      upd_edprsr_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xbc && offset < 0xc0) {
      offset -= 0xbc;
      if (read_callback_) read_callback_();
      pex_credit_err_log_.read( offset, data );
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      if (read_callback_) read_callback_();
      pex_mac_credit_err_log_.read( offset, data );
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      if (read_callback_) read_callback_();
      q_watchdog_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      if (read_callback_) read_callback_();
      q_watchdog_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x100 && offset < 0x104) {
      offset -= 0x100;
      if (read_callback_) read_callback_();
      ctrl_.read( offset, data );
    }
    else if (offset >= 0x104 && offset < 0x108) {
      offset -= 0x104;
      if (read_callback_) read_callback_();
      ready_.read( offset, data );
    }
    else if (offset >= 0x108 && offset < 0x10c) {
      offset -= 0x108;
      if (read_callback_) read_callback_();
      global_bytecnt_adj_.read( offset, data );
    }
    else if (offset >= 0x10c && offset < 0x110) {
      offset -= 0x10c;
      if (read_callback_) read_callback_();
      tdm_config_.read( offset, data );
    }
    else if (offset >= 0x200 && offset < 0x400) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tdm_table_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x400 && offset < 0x404) {
      offset -= 0x400;
      if (read_callback_) read_callback_();
      port_arb_ctrl_.read( offset, data );
    }
    else if (offset >= 0x404 && offset < 0x408) {
      offset -= 0x404;
      if (read_callback_) read_callback_();
      pex_credit_ctrl_.read( offset, data );
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_config_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_pfc_status_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1000 && offset < 0x1900) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_pex_status_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1900 && offset < 0x1914) {
      offset -= 0x1900;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mac_pex_status_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      l1_config_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x4000 && offset < 0x5200) {
      offset -= 0x4000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      queue_config_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x5200 && offset < 0x5204) {
      offset -= 0x5200;
      if (read_callback_) read_callback_();
      queue_flush_ctrl_.read( offset, data );
    }
    else if (offset >= 0x5210 && offset < 0x5220) {
      offset -= 0x5210;
      if (read_callback_) read_callback_();
      queue_flush_mask_.read( offset, data );
    }
    else if (offset >= 0x5220 && offset < 0x5224) {
      offset -= 0x5220;
      if (read_callback_) read_callback_();
      watchdog_config_.read( offset, data );
    }
    else if (offset >= 0x6000 && offset < 0x7200) {
      offset -= 0x6000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      watchdog_status_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x7200 && offset < 0x7208) {
      offset -= 0x7200;
      if (read_callback_) read_callback_();
      watchdog_timer_.read( offset, data );
    }
    else if (offset >= 0x7208 && offset < 0x720c) {
      offset -= 0x7208;
      if (read_callback_) read_callback_();
      iadvfc_config_.read( offset, data );
    }
    else if (offset >= 0x720c && offset < 0x7210) {
      offset -= 0x720c;
      if (read_callback_) read_callback_();
      iadvfc_status_.read( offset, data );
    }
    else if (offset >= 0x7210 && offset < 0x7214) {
      offset -= 0x7210;
      if (read_callback_) read_callback_();
      iadvfc_ctr_.read( offset, data );
    }
    else if (offset >= 0x7214 && offset < 0x7218) {
      offset -= 0x7214;
      if (read_callback_) read_callback_();
      eadvfc_config_.read( offset, data );
    }
    else if (offset >= 0x7218 && offset < 0x721c) {
      offset -= 0x7218;
      if (read_callback_) read_callback_();
      eadvfc_status_.read( offset, data );
    }
    else if (offset >= 0x721c && offset < 0x7220) {
      offset -= 0x721c;
      if (read_callback_) read_callback_();
      eadvfc_ctr_.read( offset, data );
    }
    else if (offset >= 0x7220 && offset < 0x7224) {
      offset -= 0x7220;
      if (read_callback_) read_callback_();
      pq_ctrl_.read( offset, data );
    }
    else if (offset >= 0x7230 && offset < 0x723c) {
      offset -= 0x7230;
      if (read_callback_) read_callback_();
      pq_port_en_.read( offset, data );
    }
    else if (offset >= 0x7240 && offset < 0x724c) {
      offset -= 0x7240;
      if (read_callback_) read_callback_();
      pq_port_profile_sel_.read( offset, data );
    }
    else if (offset >= 0x724c && offset < 0x7250) {
      offset -= 0x724c;
      if (read_callback_) read_callback_();
      debug_bus_ctrl_.read( offset, data );
    }
    else if (offset >= 0x40 && offset < 0x54) {
      offset -= 0x40;
      if (read_callback_) read_callback_();
      intr_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x20 && offset < 0x34) {
      offset -= 0x20;
      ecc_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      tdm_table_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x58 && offset < 0x5c) {
      offset -= 0x58;
      tdm_table_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5c && offset < 0x60) {
      offset -= 0x5c;
      upd_wac_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x60 && offset < 0x64) {
      offset -= 0x60;
      upd_wac_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      upd_edprsr_advfc_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      upd_edprsr_advfc_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      q_minrate_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x70 && offset < 0x74) {
      offset -= 0x70;
      q_minrate_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x74 && offset < 0x78) {
      offset -= 0x74;
      q_excrate_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x78 && offset < 0x7c) {
      offset -= 0x78;
      q_excrate_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7c && offset < 0x80) {
      offset -= 0x7c;
      q_maxrate_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0x84) {
      offset -= 0x80;
      q_maxrate_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x84 && offset < 0x88) {
      offset -= 0x84;
      l1_minrate_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x88 && offset < 0x8c) {
      offset -= 0x88;
      l1_minrate_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8c && offset < 0x90) {
      offset -= 0x8c;
      l1_excrate_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x90 && offset < 0x94) {
      offset -= 0x90;
      l1_excrate_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x94 && offset < 0x98) {
      offset -= 0x94;
      l1_maxrate_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x98 && offset < 0x9c) {
      offset -= 0x98;
      l1_maxrate_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x9c && offset < 0xa0) {
      offset -= 0x9c;
      p_maxrate_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa0 && offset < 0xa4) {
      offset -= 0xa0;
      p_maxrate_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa4 && offset < 0xa8) {
      offset -= 0xa4;
      upd_pex0_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa8 && offset < 0xac) {
      offset -= 0xa8;
      upd_pex0_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xac && offset < 0xb0) {
      offset -= 0xac;
      upd_pex1_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb0 && offset < 0xb4) {
      offset -= 0xb0;
      upd_pex1_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb4 && offset < 0xb8) {
      offset -= 0xb4;
      upd_edprsr_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb8 && offset < 0xbc) {
      offset -= 0xb8;
      upd_edprsr_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xbc && offset < 0xc0) {
      offset -= 0xbc;
      pex_credit_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      pex_mac_credit_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      q_watchdog_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      q_watchdog_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100 && offset < 0x104) {
      offset -= 0x100;
      ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104 && offset < 0x108) {
      offset -= 0x104;
      ready_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x108 && offset < 0x10c) {
      offset -= 0x108;
      global_bytecnt_adj_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10c && offset < 0x110) {
      offset -= 0x10c;
      tdm_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x400) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tdm_table_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x404) {
      offset -= 0x400;
      port_arb_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x404 && offset < 0x408) {
      offset -= 0x404;
      pex_credit_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_config_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_pfc_status_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1900) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_pex_status_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1900 && offset < 0x1914) {
      offset -= 0x1900;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mac_pex_status_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      l1_config_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4000 && offset < 0x5200) {
      offset -= 0x4000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      queue_config_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5200 && offset < 0x5204) {
      offset -= 0x5200;
      queue_flush_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5210 && offset < 0x5220) {
      offset -= 0x5210;
      queue_flush_mask_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5220 && offset < 0x5224) {
      offset -= 0x5220;
      watchdog_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6000 && offset < 0x7200) {
      offset -= 0x6000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      watchdog_status_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7200 && offset < 0x7208) {
      offset -= 0x7200;
      watchdog_timer_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7208 && offset < 0x720c) {
      offset -= 0x7208;
      iadvfc_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x720c && offset < 0x7210) {
      offset -= 0x720c;
      iadvfc_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7210 && offset < 0x7214) {
      offset -= 0x7210;
      iadvfc_ctr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7214 && offset < 0x7218) {
      offset -= 0x7214;
      eadvfc_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7218 && offset < 0x721c) {
      offset -= 0x7218;
      eadvfc_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x721c && offset < 0x7220) {
      offset -= 0x721c;
      eadvfc_ctr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7220 && offset < 0x7224) {
      offset -= 0x7220;
      pq_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7230 && offset < 0x723c) {
      offset -= 0x7230;
      pq_port_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7240 && offset < 0x724c) {
      offset -= 0x7240;
      pq_port_profile_sel_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x724c && offset < 0x7250) {
      offset -= 0x724c;
      debug_bus_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40 && offset < 0x54) {
      offset -= 0x40;
      intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    ecc_.reset();
    tdm_table_sbe_err_log_.reset();
    tdm_table_mbe_err_log_.reset();
    upd_wac_sbe_err_log_.reset();
    upd_wac_mbe_err_log_.reset();
    upd_edprsr_advfc_sbe_err_log_.reset();
    upd_edprsr_advfc_mbe_err_log_.reset();
    q_minrate_sbe_err_log_.reset();
    q_minrate_mbe_err_log_.reset();
    q_excrate_sbe_err_log_.reset();
    q_excrate_mbe_err_log_.reset();
    q_maxrate_sbe_err_log_.reset();
    q_maxrate_mbe_err_log_.reset();
    l1_minrate_sbe_err_log_.reset();
    l1_minrate_mbe_err_log_.reset();
    l1_excrate_sbe_err_log_.reset();
    l1_excrate_mbe_err_log_.reset();
    l1_maxrate_sbe_err_log_.reset();
    l1_maxrate_mbe_err_log_.reset();
    p_maxrate_sbe_err_log_.reset();
    p_maxrate_mbe_err_log_.reset();
    upd_pex0_sbe_err_log_.reset();
    upd_pex0_mbe_err_log_.reset();
    upd_pex1_sbe_err_log_.reset();
    upd_pex1_mbe_err_log_.reset();
    upd_edprsr_sbe_err_log_.reset();
    upd_edprsr_mbe_err_log_.reset();
    pex_credit_err_log_.reset();
    pex_mac_credit_err_log_.reset();
    q_watchdog_sbe_err_log_.reset();
    q_watchdog_mbe_err_log_.reset();
    ctrl_.reset();
    ready_.reset();
    global_bytecnt_adj_.reset();
    tdm_config_.reset();
    for (auto &f0 : tdm_table_) {
      f0.reset();
    }
    port_arb_ctrl_.reset();
    pex_credit_ctrl_.reset();
    for (auto &f0 : port_config_) {
      f0.reset();
    }
    for (auto &f0 : port_pfc_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : port_pex_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : mac_pex_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : l1_config_) {
      f0.reset();
    }
    for (auto &f0 : queue_config_) {
      f0.reset();
    }
    queue_flush_ctrl_.reset();
    queue_flush_mask_.reset();
    watchdog_config_.reset();
    for (auto &f0 : watchdog_status_) {
      f0.reset();
    }
    watchdog_timer_.reset();
    iadvfc_config_.reset();
    iadvfc_status_.reset();
    iadvfc_ctr_.reset();
    eadvfc_config_.reset();
    eadvfc_status_.reset();
    eadvfc_ctr_.reset();
    pq_ctrl_.reset();
    pq_port_en_.reset();
    pq_port_profile_sel_.reset();
    debug_bus_ctrl_.reset();
    intr_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x20 && offset < 0x34) {
      offset -= 0x20;
      r += ecc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      r += tdm_table_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x58 && offset < 0x5c) {
      offset -= 0x58;
      r += tdm_table_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5c && offset < 0x60) {
      offset -= 0x5c;
      r += upd_wac_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x60 && offset < 0x64) {
      offset -= 0x60;
      r += upd_wac_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      r += upd_edprsr_advfc_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      r += upd_edprsr_advfc_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      r += q_minrate_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x70 && offset < 0x74) {
      offset -= 0x70;
      r += q_minrate_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x74 && offset < 0x78) {
      offset -= 0x74;
      r += q_excrate_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x78 && offset < 0x7c) {
      offset -= 0x78;
      r += q_excrate_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7c && offset < 0x80) {
      offset -= 0x7c;
      r += q_maxrate_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0x84) {
      offset -= 0x80;
      r += q_maxrate_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x84 && offset < 0x88) {
      offset -= 0x84;
      r += l1_minrate_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x88 && offset < 0x8c) {
      offset -= 0x88;
      r += l1_minrate_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8c && offset < 0x90) {
      offset -= 0x8c;
      r += l1_excrate_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x90 && offset < 0x94) {
      offset -= 0x90;
      r += l1_excrate_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x94 && offset < 0x98) {
      offset -= 0x94;
      r += l1_maxrate_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x98 && offset < 0x9c) {
      offset -= 0x98;
      r += l1_maxrate_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x9c && offset < 0xa0) {
      offset -= 0x9c;
      r += p_maxrate_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa0 && offset < 0xa4) {
      offset -= 0xa0;
      r += p_maxrate_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa4 && offset < 0xa8) {
      offset -= 0xa4;
      r += upd_pex0_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa8 && offset < 0xac) {
      offset -= 0xa8;
      r += upd_pex0_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xac && offset < 0xb0) {
      offset -= 0xac;
      r += upd_pex1_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb0 && offset < 0xb4) {
      offset -= 0xb0;
      r += upd_pex1_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb4 && offset < 0xb8) {
      offset -= 0xb4;
      r += upd_edprsr_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb8 && offset < 0xbc) {
      offset -= 0xb8;
      r += upd_edprsr_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xbc && offset < 0xc0) {
      offset -= 0xbc;
      r += pex_credit_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      r += pex_mac_credit_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      r += q_watchdog_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      r += q_watchdog_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100 && offset < 0x104) {
      offset -= 0x100;
      r += ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104 && offset < 0x108) {
      offset -= 0x104;
      r += ready_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x108 && offset < 0x10c) {
      offset -= 0x108;
      r += global_bytecnt_adj_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10c && offset < 0x110) {
      offset -= 0x10c;
      r += tdm_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x400) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tdm_table_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x404) {
      offset -= 0x400;
      r += port_arb_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x404 && offset < 0x408) {
      offset -= 0x404;
      r += pex_credit_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_pfc_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1900) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_pex_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1900 && offset < 0x1914) {
      offset -= 0x1900;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mac_pex_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += l1_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4000 && offset < 0x5200) {
      offset -= 0x4000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += queue_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5200 && offset < 0x5204) {
      offset -= 0x5200;
      r += queue_flush_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5210 && offset < 0x5220) {
      offset -= 0x5210;
      r += queue_flush_mask_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5220 && offset < 0x5224) {
      offset -= 0x5220;
      r += watchdog_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6000 && offset < 0x7200) {
      offset -= 0x6000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += watchdog_status_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7200 && offset < 0x7208) {
      offset -= 0x7200;
      r += watchdog_timer_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7208 && offset < 0x720c) {
      offset -= 0x7208;
      r += iadvfc_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x720c && offset < 0x7210) {
      offset -= 0x720c;
      r += iadvfc_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7210 && offset < 0x7214) {
      offset -= 0x7210;
      r += iadvfc_ctr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7214 && offset < 0x7218) {
      offset -= 0x7214;
      r += eadvfc_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7218 && offset < 0x721c) {
      offset -= 0x7218;
      r += eadvfc_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x721c && offset < 0x7220) {
      offset -= 0x721c;
      r += eadvfc_ctr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7220 && offset < 0x7224) {
      offset -= 0x7220;
      r += pq_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7230 && offset < 0x723c) {
      offset -= 0x7230;
      r += pq_port_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7240 && offset < 0x724c) {
      offset -= 0x7240;
      r += pq_port_profile_sel_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x724c && offset < 0x7250) {
      offset -= 0x724c;
      r += debug_bus_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40 && offset < 0x54) {
      offset -= 0x40;
      r += intr_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += ecc_.to_string(print_zeros,indent_string) ;
    r += tdm_table_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += tdm_table_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_wac_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_wac_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_edprsr_advfc_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_edprsr_advfc_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += q_minrate_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += q_minrate_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += q_excrate_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += q_excrate_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += q_maxrate_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += q_maxrate_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += l1_minrate_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += l1_minrate_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += l1_excrate_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += l1_excrate_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += l1_maxrate_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += l1_maxrate_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += p_maxrate_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += p_maxrate_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_pex0_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_pex0_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_pex1_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_pex1_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_edprsr_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += upd_edprsr_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += pex_credit_err_log_.to_string(print_zeros,indent_string) ;
    r += pex_mac_credit_err_log_.to_string(print_zeros,indent_string) ;
    r += q_watchdog_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += q_watchdog_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += ctrl_.to_string(print_zeros,indent_string) ;
    r += ready_.to_string(print_zeros,indent_string) ;
    r += global_bytecnt_adj_.to_string(print_zeros,indent_string) ;
    r += tdm_config_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<128;++a0) {
      r += tdm_table_[a0].to_string(print_zeros,indent_string) ;
    }
    r += port_arb_ctrl_.to_string(print_zeros,indent_string) ;
    r += pex_credit_ctrl_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_pfc_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += port_pex_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<5;++a0) {
      r += mac_pex_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<288;++a0) {
      r += l1_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<1152;++a0) {
      r += queue_config_[a0].to_string(print_zeros,indent_string) ;
    }
    r += queue_flush_ctrl_.to_string(print_zeros,indent_string) ;
    r += queue_flush_mask_.to_string(print_zeros,indent_string) ;
    r += watchdog_config_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<1152;++a0) {
      r += watchdog_status_[a0].to_string(print_zeros,indent_string) ;
    }
    r += watchdog_timer_.to_string(print_zeros,indent_string) ;
    r += iadvfc_config_.to_string(print_zeros,indent_string) ;
    r += iadvfc_status_.to_string(print_zeros,indent_string) ;
    r += iadvfc_ctr_.to_string(print_zeros,indent_string) ;
    r += eadvfc_config_.to_string(print_zeros,indent_string) ;
    r += eadvfc_status_.to_string(print_zeros,indent_string) ;
    r += eadvfc_ctr_.to_string(print_zeros,indent_string) ;
    r += pq_ctrl_.to_string(print_zeros,indent_string) ;
    r += pq_port_en_.to_string(print_zeros,indent_string) ;
    r += pq_port_profile_sel_.to_string(print_zeros,indent_string) ;
    r += debug_bus_ctrl_.to_string(print_zeros,indent_string) ;
    r += intr_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmSchPipeRspecEccMutable ecc_;
  TmSchPipeRspecTdmTableSbeErrLogMutable tdm_table_sbe_err_log_;
  TmSchPipeRspecTdmTableMbeErrLogMutable tdm_table_mbe_err_log_;
  TmSchPipeRspecUpdWacSbeErrLogMutable upd_wac_sbe_err_log_;
  TmSchPipeRspecUpdWacMbeErrLogMutable upd_wac_mbe_err_log_;
  TmSchPipeRspecUpdEdprsrAdvfcSbeErrLogMutable upd_edprsr_advfc_sbe_err_log_;
  TmSchPipeRspecUpdEdprsrAdvfcMbeErrLogMutable upd_edprsr_advfc_mbe_err_log_;
  TmSchPipeRspecQMinrateSbeErrLogMutable q_minrate_sbe_err_log_;
  TmSchPipeRspecQMinrateMbeErrLogMutable q_minrate_mbe_err_log_;
  TmSchPipeRspecQExcrateSbeErrLogMutable q_excrate_sbe_err_log_;
  TmSchPipeRspecQExcrateMbeErrLogMutable q_excrate_mbe_err_log_;
  TmSchPipeRspecQMaxrateSbeErrLogMutable q_maxrate_sbe_err_log_;
  TmSchPipeRspecQMaxrateMbeErrLogMutable q_maxrate_mbe_err_log_;
  TmSchPipeRspecL1MinrateSbeErrLogMutable l1_minrate_sbe_err_log_;
  TmSchPipeRspecL1MinrateMbeErrLogMutable l1_minrate_mbe_err_log_;
  TmSchPipeRspecL1ExcrateSbeErrLogMutable l1_excrate_sbe_err_log_;
  TmSchPipeRspecL1ExcrateMbeErrLogMutable l1_excrate_mbe_err_log_;
  TmSchPipeRspecL1MaxrateSbeErrLogMutable l1_maxrate_sbe_err_log_;
  TmSchPipeRspecL1MaxrateMbeErrLogMutable l1_maxrate_mbe_err_log_;
  TmSchPipeRspecPMaxrateSbeErrLogMutable p_maxrate_sbe_err_log_;
  TmSchPipeRspecPMaxrateMbeErrLogMutable p_maxrate_mbe_err_log_;
  TmSchPipeRspecUpdPex0SbeErrLogMutable upd_pex0_sbe_err_log_;
  TmSchPipeRspecUpdPex0MbeErrLogMutable upd_pex0_mbe_err_log_;
  TmSchPipeRspecUpdPex1SbeErrLogMutable upd_pex1_sbe_err_log_;
  TmSchPipeRspecUpdPex1MbeErrLogMutable upd_pex1_mbe_err_log_;
  TmSchPipeRspecUpdEdprsrSbeErrLogMutable upd_edprsr_sbe_err_log_;
  TmSchPipeRspecUpdEdprsrMbeErrLogMutable upd_edprsr_mbe_err_log_;
  TmSchPipeRspecPexCreditErrLogMutable pex_credit_err_log_;
  TmSchPipeRspecPexMacCreditErrLogMutable pex_mac_credit_err_log_;
  TmSchPipeRspecQWatchdogSbeErrLogMutable q_watchdog_sbe_err_log_;
  TmSchPipeRspecQWatchdogMbeErrLogMutable q_watchdog_mbe_err_log_;
  SchCtrlRMutable ctrl_;
  SchReadyRMutable ready_;
  SchByteCountAdjustRMutable global_bytecnt_adj_;
  SchTdmConfigRMutable tdm_config_;
  std::array< SchTdmTableEntryRMutable, 128 > tdm_table_;
  SchPortArbCtrlRMutable port_arb_ctrl_;
  SchPexCreditCtrlRMutable pex_credit_ctrl_;
  std::array< SchPortConfigRMutable, 72 > port_config_;
  std::array< SchPortPfcStatusRMutable, 72 > port_pfc_status_mem_;
  std::array< SchPortPexStatusRMutable, 576 > port_pex_status_mem_;
  std::array< SchMacPexStatusRMutable, 5 > mac_pex_status_mem_;
  std::array< SchL1ConfigRMutable, 288 > l1_config_;
  std::array< SchQueueConfigRMutable, 1152 > queue_config_;
  SchQueueFlushCtrlRMutable queue_flush_ctrl_;
  SchQueueFlushMaskRMutable queue_flush_mask_;
  SchWatchdogConfigRMutable watchdog_config_;
  std::array< SchWatchdogStatusRMutable, 1152 > watchdog_status_;
  SchWatchdogTimerRMutable watchdog_timer_;
  SchAdvfcConfigRMutable iadvfc_config_;
  SchAdvfcStatusRMutable iadvfc_status_;
  SchAdvCntrRMutable iadvfc_ctr_;
  SchAdvfcConfigRMutable eadvfc_config_;
  SchAdvfcStatusRMutable eadvfc_status_;
  SchAdvCntrRMutable eadvfc_ctr_;
  SchPqCtrlRMutable pq_ctrl_;
  SchPqPortEnRMutable pq_port_en_;
  SchPqPortProfileSelRMutable pq_port_profile_sel_;
  TmSchPipeRspecDebugBusCtrlMutable debug_bus_ctrl_;
  TmSchPipeRspecIntrMutable intr_;
private:
  static int StartOffset(
      TmTopRspecEnum selector_tm_top_rspec, int index_tm_sch_pipe_rspec
      ) {
    int offset=0;
    offset += 0x800000; // to get to tm_top
    switch (selector_tm_top_rspec) {
      case kTmSchaTop:
        offset += 0x180000; // to get to tm_scha_top
        assert(index_tm_sch_pipe_rspec < 2);
        offset += index_tm_sch_pipe_rspec * 0x8000; // tm_sch_pipe_rspec[]
        break;
      case kTmSchbTop:
        offset += 0x200000; // to get to tm_schb_top
        assert(index_tm_sch_pipe_rspec < 2);
        offset += index_tm_sch_pipe_rspec * 0x8000; // tm_sch_pipe_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace jbay

#endif // __REGISTER_INCLUDES_TM_SCH_PIPE_RSPEC_MUTABLE_H__
