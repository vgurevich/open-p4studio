/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_ETH100G_REG_RSPEC_H__
#define __REGISTER_INCLUDES_ETH100G_REG_RSPEC_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>









#include "eth100g_reg_rspec_chnl_intr.h"
#include "eth100g_reg_rspec_chnl_seq.h"
#include "eth100g_reg_rspec_crcerr_inj.h"
#include "eth100g_reg_rspec_eth_clkobs_ctrl.h"
#include "eth100g_reg_rspec_eth_mac_ts_offset_ctrl.h"
#include "eth100g_reg_rspec_eth_mdioci_addr.h"
#include "eth100g_reg_rspec_eth_mdioci_ctrl.h"
#include "eth100g_reg_rspec_eth_mdioci_poll_ctrl.h"
#include "eth100g_reg_rspec_eth_mdioci_poll_time.h"
#include "eth100g_reg_rspec_eth_onestep_ets_offset_ctrl.h"
#include "eth100g_reg_rspec_eth_ppm_ctrl.h"
#include "eth100g_reg_rspec_eth_ppm_sel.h"
#include "eth100g_reg_rspec_eth_ppm_stat.h"
#include "eth100g_reg_rspec_eth_ring_addr.h"
#include "eth100g_reg_rspec_eth_ring_ctrl.h"
#include "eth100g_reg_rspec_eth_ring_rdata.h"
#include "eth100g_reg_rspec_eth_ring_setup.h"
#include "eth100g_reg_rspec_eth_ring_wdata.h"
#include "eth100g_reg_rspec_eth_rxsigok_bitsel.h"
#include "eth100g_reg_rspec_eth_rxsigok_ctrl.h"
#include "eth100g_reg_rspec_eth_soft_reset.h"
#include "eth100g_reg_rspec_eth_status.h"
#include "eth100g_reg_rspec_global_intr_stat.h"
#include "eth100g_reg_rspec_mac_ctrl.h"
#include "eth100g_reg_rspec_mac_en0.h"
#include "eth100g_reg_rspec_mac_en1.h"
#include "eth100g_reg_rspec_mac_freeze_enable.h"
#include "eth100g_reg_rspec_mdioci_en0.h"
#include "eth100g_reg_rspec_mdioci_en1.h"
#include "eth100g_reg_rspec_mdioci_freeze_enable.h"
#include "eth100g_reg_rspec_mdioci_intr_stat.h"
#include "eth100g_reg_rspec_mem_ecc.h"
#include "eth100g_reg_rspec_mem_intr.h"
#include "eth100g_reg_rspec_port_alive_lut.h"
#include "eth100g_reg_rspec_rxff_ctrl.h"
#include "eth100g_reg_rspec_rxpkt_err_sts.h"
#include "eth100g_reg_rspec_serdes_config.h"
#include "eth100g_reg_rspec_soft_port_alive.h"
#include "eth100g_reg_rspec_statsmem_mbe_err_log.h"
#include "eth100g_reg_rspec_statsmem_sbe_err_log.h"
#include "eth100g_reg_rspec_tv80_debug_ctrl.h"
#include "eth100g_reg_rspec_tv80_debug_head_ptr.h"
#include "eth100g_reg_rspec_tv80_debug_tail_ptr.h"
#include "eth100g_reg_rspec_tv80_halted_status.h"
#include "eth100g_reg_rspec_tv80_intr.h"
#include "eth100g_reg_rspec_tv80_stall_on_error.h"
#include "eth100g_reg_rspec_tv80_watchdog_count.h"
#include "eth100g_reg_rspec_tv80_watchdog_ctrl.h"
#include "eth100g_reg_rspec_tv80mem_mbe_err_log.h"
#include "eth100g_reg_rspec_tv80mem_sbe_err_log.h"
#include "eth100g_reg_rspec_txcrc_trunc_ctrl.h"
#include "eth100g_reg_rspec_txff_ctrl.h"
#include "eth100g_reg_rspec_txff_pream0.h"
#include "eth100g_reg_rspec_txff_pream1.h"
#include "eth100g_reg_rspec_txff_status.h"
#include "eth100g_reg_rspec_txfifo_mbe_err_log.h"
#include "eth100g_reg_rspec_txfifo_sbe_err_log.h"
#include "eth100g_reg_rspec_uctrl_intr.h"

namespace jbayB0 {
  namespace register_classes {

class Eth100gRegRspec : public model_core::RegisterBlock<RegisterCallback> {
public:
  enum JbayRegEnum {
    kEth100gRegs,
    kEth100gRegsRot
  };
public:
  Eth100gRegRspec(
      int chipNumber, JbayRegEnum selector_jbay_reg, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_jbay_reg), 468, false, write_callback, read_callback, std::string("Eth100gRegRspec")+":"+boost::lexical_cast<std::string>(selector_jbay_reg))
    {
    }
  Eth100gRegRspec(
      
  )
    : RegisterBlock(0, 0, 0, false, 0, 0, "Eth100gRegRspec")
    {
    }
public:






  Eth100gRegRspecEthSoftReset &eth_soft_reset() { return eth_soft_reset_; }






  Eth100gRegRspecChnlSeq &chnl_seq() { return chnl_seq_; }








  Eth100gRegRspecPortAliveLut &port_alive_lut() { return port_alive_lut_; }





  Eth100gRegRspecEthClkobsCtrl &eth_clkobs_ctrl() { return eth_clkobs_ctrl_; }








  Eth100gRegRspecEthOnestepEtsOffsetCtrl &eth_onestep_ets_offset_ctrl(int j0) { return eth_onestep_ets_offset_ctrl_[j0]; }





  Eth100gRegRspecEthMacTsOffsetCtrl &eth_mac_ts_offset_ctrl() { return eth_mac_ts_offset_ctrl_; }





  Eth100gRegRspecEthStatus &eth_status() { return eth_status_; }






  Eth100gRegRspecGlobalIntrStat &global_intr_stat() { return global_intr_stat_; }







  Eth100gRegRspecTxffCtrl &txff_ctrl(int j0) { return txff_ctrl_[j0]; }







  Eth100gRegRspecTxffStatus &txff_status(int j0) { return txff_status_[j0]; }







  Eth100gRegRspecTxcrcTruncCtrl &txcrc_trunc_ctrl(int j0) { return txcrc_trunc_ctrl_[j0]; }







  Eth100gRegRspecRxffCtrl &rxff_ctrl(int j0) { return rxff_ctrl_[j0]; }







  Eth100gRegRspecRxpktErrSts &rxpkt_err_sts(int j0) { return rxpkt_err_sts_[j0]; }





  Eth100gRegRspecEthRingAddr &eth_ring_addr() { return eth_ring_addr_; }





  Eth100gRegRspecEthRingWdata &eth_ring_wdata() { return eth_ring_wdata_; }





  Eth100gRegRspecEthRingRdata &eth_ring_rdata() { return eth_ring_rdata_; }





  Eth100gRegRspecEthRingCtrl &eth_ring_ctrl() { return eth_ring_ctrl_; }





  Eth100gRegRspecEthRingSetup &eth_ring_setup() { return eth_ring_setup_; }





  Eth100gRegRspecSoftPortAlive &soft_port_alive() { return soft_port_alive_; }








  Eth100gRegRspecMemEcc &mem_ecc() { return mem_ecc_; }





  Eth100gRegRspecTxfifoSbeErrLog &txfifo_sbe_err_log() { return txfifo_sbe_err_log_; }





  Eth100gRegRspecTxfifoMbeErrLog &txfifo_mbe_err_log() { return txfifo_mbe_err_log_; }





  Eth100gRegRspecStatsmemSbeErrLog &statsmem_sbe_err_log() { return statsmem_sbe_err_log_; }





  Eth100gRegRspecStatsmemMbeErrLog &statsmem_mbe_err_log() { return statsmem_mbe_err_log_; }





  Eth100gRegRspecTv80memSbeErrLog &tv80mem_sbe_err_log() { return tv80mem_sbe_err_log_; }





  Eth100gRegRspecTv80memMbeErrLog &tv80mem_mbe_err_log() { return tv80mem_mbe_err_log_; }







  Eth100gRegRspecMacEn0 &mac_en0() { return mac_en0_; }







  Eth100gRegRspecMacEn1 &mac_en1() { return mac_en1_; }





  Eth100gRegRspecMacFreezeEnable &mac_freeze_enable() { return mac_freeze_enable_; }






  Eth100gRegRspecCrcerrInj &crcerr_inj() { return crcerr_inj_; }










  Eth100gRegRspecTv80DebugCtrl &tv80_debug_ctrl() { return tv80_debug_ctrl_; }






  Eth100gRegRspecTv80DebugHeadPtr &tv80_debug_head_ptr() { return tv80_debug_head_ptr_; }






  Eth100gRegRspecTv80DebugTailPtr &tv80_debug_tail_ptr() { return tv80_debug_tail_ptr_; }








  Eth100gRegRspecTv80StallOnError &tv80_stall_on_error() { return tv80_stall_on_error_; }





  Eth100gRegRspecTv80HaltedStatus &tv80_halted_status() { return tv80_halted_status_; }





  Eth100gRegRspecTv80WatchdogCtrl &tv80_watchdog_ctrl() { return tv80_watchdog_ctrl_; }






  Eth100gRegRspecTv80WatchdogCount &tv80_watchdog_count() { return tv80_watchdog_count_; }







  Eth100gRegRspecEthRxsigokCtrl &eth_rxsigok_ctrl() { return eth_rxsigok_ctrl_; }






  Eth100gRegRspecEthMdiociCtrl &eth_mdioci_ctrl() { return eth_mdioci_ctrl_; }






  Eth100gRegRspecEthMdiociPollCtrl &eth_mdioci_poll_ctrl() { return eth_mdioci_poll_ctrl_; }





  Eth100gRegRspecEthMdiociPollTime &eth_mdioci_poll_time() { return eth_mdioci_poll_time_; }





  Eth100gRegRspecEthRxsigokBitsel &eth_rxsigok_bitsel() { return eth_rxsigok_bitsel_; }





  Eth100gRegRspecMdiociIntrStat &mdioci_intr_stat() { return mdioci_intr_stat_; }







  Eth100gRegRspecMdiociEn0 &mdioci_en0() { return mdioci_en0_; }







  Eth100gRegRspecMdiociEn1 &mdioci_en1() { return mdioci_en1_; }





  Eth100gRegRspecMdiociFreezeEnable &mdioci_freeze_enable() { return mdioci_freeze_enable_; }





  Eth100gRegRspecMacCtrl &mac_ctrl() { return mac_ctrl_; }





  Eth100gRegRspecTxffPream0 &txff_pream0() { return txff_pream0_; }





  Eth100gRegRspecTxffPream1 &txff_pream1() { return txff_pream1_; }






  Eth100gRegRspecSerdesConfig &serdes_config() { return serdes_config_; }





  Eth100gRegRspecEthPpmSel &eth_ppm_sel() { return eth_ppm_sel_; }





  Eth100gRegRspecEthPpmCtrl &eth_ppm_ctrl() { return eth_ppm_ctrl_; }





  Eth100gRegRspecEthPpmStat &eth_ppm_stat() { return eth_ppm_stat_; }






  Eth100gRegRspecEthMdiociAddr &eth_mdioci_addr() { return eth_mdioci_addr_; }
  Eth100gRegRspecChnlIntr &chnl_intr() { return chnl_intr_; }
  Eth100gRegRspecMemIntr &mem_intr() { return mem_intr_; }
  Eth100gRegRspecUctrlIntr &uctrl_intr() { return uctrl_intr_; }
  Eth100gRegRspecTv80Intr &tv80_intr() { return tv80_intr_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      if (read_callback_) read_callback_();
      eth_soft_reset_.read( offset, data );
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      if (read_callback_) read_callback_();
      chnl_seq_.read( offset, data );
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      if (read_callback_) read_callback_();
      port_alive_lut_.read( offset, data );
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      eth_clkobs_ctrl_.read( offset, data );
    }
    else if (offset >= 0x40 && offset < 0x60) {
      offset -= 0x40;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      if (read_callback_) read_callback_();
      eth_onestep_ets_offset_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x60 && offset < 0x68) {
      offset -= 0x60;
      if (read_callback_) read_callback_();
      eth_mac_ts_offset_ctrl_.read( offset, data );
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      if (read_callback_) read_callback_();
      eth_status_.read( offset, data );
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      if (read_callback_) read_callback_();
      global_intr_stat_.read( offset, data );
    }
    else if (offset >= 0x70 && offset < 0x80) {
      offset -= 0x70;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      txff_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x80 && offset < 0x90) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      txff_status_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x90 && offset < 0xa0) {
      offset -= 0x90;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      txcrc_trunc_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0xa0 && offset < 0xb0) {
      offset -= 0xa0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      rxff_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0xb0 && offset < 0xc0) {
      offset -= 0xb0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      rxpkt_err_sts_[ i0 ].read( offset, data );
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      if (read_callback_) read_callback_();
      eth_ring_addr_.read( offset, data );
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      if (read_callback_) read_callback_();
      eth_ring_wdata_.read( offset, data );
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      if (read_callback_) read_callback_();
      eth_ring_rdata_.read( offset, data );
    }
    else if (offset >= 0xcc && offset < 0xd0) {
      offset -= 0xcc;
      if (read_callback_) read_callback_();
      eth_ring_ctrl_.read( offset, data );
    }
    else if (offset >= 0xd0 && offset < 0xd4) {
      offset -= 0xd0;
      if (read_callback_) read_callback_();
      eth_ring_setup_.read( offset, data );
    }
    else if (offset >= 0xd4 && offset < 0xd8) {
      offset -= 0xd4;
      if (read_callback_) read_callback_();
      soft_port_alive_.read( offset, data );
    }
    else if (offset >= 0x134 && offset < 0x138) {
      offset -= 0x134;
      if (read_callback_) read_callback_();
      mem_ecc_.read( offset, data );
    }
    else if (offset >= 0x138 && offset < 0x13c) {
      offset -= 0x138;
      if (read_callback_) read_callback_();
      txfifo_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x13c && offset < 0x140) {
      offset -= 0x13c;
      if (read_callback_) read_callback_();
      txfifo_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x140 && offset < 0x144) {
      offset -= 0x140;
      if (read_callback_) read_callback_();
      statsmem_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x144 && offset < 0x148) {
      offset -= 0x144;
      if (read_callback_) read_callback_();
      statsmem_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x148 && offset < 0x14c) {
      offset -= 0x148;
      if (read_callback_) read_callback_();
      tv80mem_sbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x14c && offset < 0x150) {
      offset -= 0x14c;
      if (read_callback_) read_callback_();
      tv80mem_mbe_err_log_.read( offset, data );
    }
    else if (offset >= 0x150 && offset < 0x154) {
      offset -= 0x150;
      if (read_callback_) read_callback_();
      mac_en0_.read( offset, data );
    }
    else if (offset >= 0x154 && offset < 0x158) {
      offset -= 0x154;
      if (read_callback_) read_callback_();
      mac_en1_.read( offset, data );
    }
    else if (offset >= 0x158 && offset < 0x15c) {
      offset -= 0x158;
      if (read_callback_) read_callback_();
      mac_freeze_enable_.read( offset, data );
    }
    else if (offset >= 0x15c && offset < 0x160) {
      offset -= 0x15c;
      if (read_callback_) read_callback_();
      crcerr_inj_.read( offset, data );
    }
    else if (offset >= 0x174 && offset < 0x178) {
      offset -= 0x174;
      if (read_callback_) read_callback_();
      tv80_debug_ctrl_.read( offset, data );
    }
    else if (offset >= 0x178 && offset < 0x17c) {
      offset -= 0x178;
      if (read_callback_) read_callback_();
      tv80_debug_head_ptr_.read( offset, data );
    }
    else if (offset >= 0x17c && offset < 0x180) {
      offset -= 0x17c;
      if (read_callback_) read_callback_();
      tv80_debug_tail_ptr_.read( offset, data );
    }
    else if (offset >= 0x180 && offset < 0x184) {
      offset -= 0x180;
      if (read_callback_) read_callback_();
      tv80_stall_on_error_.read( offset, data );
    }
    else if (offset >= 0x184 && offset < 0x188) {
      offset -= 0x184;
      if (read_callback_) read_callback_();
      tv80_halted_status_.read( offset, data );
    }
    else if (offset >= 0x188 && offset < 0x18c) {
      offset -= 0x188;
      if (read_callback_) read_callback_();
      tv80_watchdog_ctrl_.read( offset, data );
    }
    else if (offset >= 0x18c && offset < 0x190) {
      offset -= 0x18c;
      if (read_callback_) read_callback_();
      tv80_watchdog_count_.read( offset, data );
    }
    else if (offset >= 0x190 && offset < 0x194) {
      offset -= 0x190;
      if (read_callback_) read_callback_();
      eth_rxsigok_ctrl_.read( offset, data );
    }
    else if (offset >= 0x194 && offset < 0x198) {
      offset -= 0x194;
      if (read_callback_) read_callback_();
      eth_mdioci_ctrl_.read( offset, data );
    }
    else if (offset >= 0x198 && offset < 0x19c) {
      offset -= 0x198;
      if (read_callback_) read_callback_();
      eth_mdioci_poll_ctrl_.read( offset, data );
    }
    else if (offset >= 0x19c && offset < 0x1a0) {
      offset -= 0x19c;
      if (read_callback_) read_callback_();
      eth_mdioci_poll_time_.read( offset, data );
    }
    else if (offset >= 0x1a0 && offset < 0x1a4) {
      offset -= 0x1a0;
      if (read_callback_) read_callback_();
      eth_rxsigok_bitsel_.read( offset, data );
    }
    else if (offset >= 0x1a4 && offset < 0x1a8) {
      offset -= 0x1a4;
      if (read_callback_) read_callback_();
      mdioci_intr_stat_.read( offset, data );
    }
    else if (offset >= 0x1a8 && offset < 0x1ac) {
      offset -= 0x1a8;
      if (read_callback_) read_callback_();
      mdioci_en0_.read( offset, data );
    }
    else if (offset >= 0x1ac && offset < 0x1b0) {
      offset -= 0x1ac;
      if (read_callback_) read_callback_();
      mdioci_en1_.read( offset, data );
    }
    else if (offset >= 0x1b0 && offset < 0x1b4) {
      offset -= 0x1b0;
      if (read_callback_) read_callback_();
      mdioci_freeze_enable_.read( offset, data );
    }
    else if (offset >= 0x1b4 && offset < 0x1b8) {
      offset -= 0x1b4;
      if (read_callback_) read_callback_();
      mac_ctrl_.read( offset, data );
    }
    else if (offset >= 0x1b8 && offset < 0x1bc) {
      offset -= 0x1b8;
      if (read_callback_) read_callback_();
      txff_pream0_.read( offset, data );
    }
    else if (offset >= 0x1bc && offset < 0x1c0) {
      offset -= 0x1bc;
      if (read_callback_) read_callback_();
      txff_pream1_.read( offset, data );
    }
    else if (offset >= 0x1c0 && offset < 0x1c4) {
      offset -= 0x1c0;
      if (read_callback_) read_callback_();
      serdes_config_.read( offset, data );
    }
    else if (offset >= 0x1c4 && offset < 0x1c8) {
      offset -= 0x1c4;
      if (read_callback_) read_callback_();
      eth_ppm_sel_.read( offset, data );
    }
    else if (offset >= 0x1c8 && offset < 0x1cc) {
      offset -= 0x1c8;
      if (read_callback_) read_callback_();
      eth_ppm_ctrl_.read( offset, data );
    }
    else if (offset >= 0x1cc && offset < 0x1d0) {
      offset -= 0x1cc;
      if (read_callback_) read_callback_();
      eth_ppm_stat_.read( offset, data );
    }
    else if (offset >= 0x1d0 && offset < 0x1d4) {
      offset -= 0x1d0;
      if (read_callback_) read_callback_();
      eth_mdioci_addr_.read( offset, data );
    }
    else if (offset >= 0xe0 && offset < 0xf4) {
      offset -= 0xe0;
      if (read_callback_) read_callback_();
      chnl_intr_.read( offset, data );
    }
    else if (offset >= 0x100 && offset < 0x114) {
      offset -= 0x100;
      if (read_callback_) read_callback_();
      mem_intr_.read( offset, data );
    }
    else if (offset >= 0x120 && offset < 0x134) {
      offset -= 0x120;
      if (read_callback_) read_callback_();
      uctrl_intr_.read( offset, data );
    }
    else if (offset >= 0x160 && offset < 0x174) {
      offset -= 0x160;
      if (read_callback_) read_callback_();
      tv80_intr_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      eth_soft_reset_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      chnl_seq_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      port_alive_lut_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      eth_clkobs_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40 && offset < 0x60) {
      offset -= 0x40;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      eth_onestep_ets_offset_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x60 && offset < 0x68) {
      offset -= 0x60;
      eth_mac_ts_offset_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      eth_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      global_intr_stat_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x70 && offset < 0x80) {
      offset -= 0x70;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      txff_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0x90) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      txff_status_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x90 && offset < 0xa0) {
      offset -= 0x90;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      txcrc_trunc_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa0 && offset < 0xb0) {
      offset -= 0xa0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      rxff_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb0 && offset < 0xc0) {
      offset -= 0xb0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      rxpkt_err_sts_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      eth_ring_addr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      eth_ring_wdata_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      eth_ring_rdata_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xcc && offset < 0xd0) {
      offset -= 0xcc;
      eth_ring_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd0 && offset < 0xd4) {
      offset -= 0xd0;
      eth_ring_setup_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd4 && offset < 0xd8) {
      offset -= 0xd4;
      soft_port_alive_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x134 && offset < 0x138) {
      offset -= 0x134;
      mem_ecc_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x138 && offset < 0x13c) {
      offset -= 0x138;
      txfifo_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x13c && offset < 0x140) {
      offset -= 0x13c;
      txfifo_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x140 && offset < 0x144) {
      offset -= 0x140;
      statsmem_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x144 && offset < 0x148) {
      offset -= 0x144;
      statsmem_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x148 && offset < 0x14c) {
      offset -= 0x148;
      tv80mem_sbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14c && offset < 0x150) {
      offset -= 0x14c;
      tv80mem_mbe_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x150 && offset < 0x154) {
      offset -= 0x150;
      mac_en0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x154 && offset < 0x158) {
      offset -= 0x154;
      mac_en1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x158 && offset < 0x15c) {
      offset -= 0x158;
      mac_freeze_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x15c && offset < 0x160) {
      offset -= 0x15c;
      crcerr_inj_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x174 && offset < 0x178) {
      offset -= 0x174;
      tv80_debug_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x178 && offset < 0x17c) {
      offset -= 0x178;
      tv80_debug_head_ptr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x17c && offset < 0x180) {
      offset -= 0x17c;
      tv80_debug_tail_ptr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x180 && offset < 0x184) {
      offset -= 0x180;
      tv80_stall_on_error_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x184 && offset < 0x188) {
      offset -= 0x184;
      tv80_halted_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x188 && offset < 0x18c) {
      offset -= 0x188;
      tv80_watchdog_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18c && offset < 0x190) {
      offset -= 0x18c;
      tv80_watchdog_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x190 && offset < 0x194) {
      offset -= 0x190;
      eth_rxsigok_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x194 && offset < 0x198) {
      offset -= 0x194;
      eth_mdioci_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x198 && offset < 0x19c) {
      offset -= 0x198;
      eth_mdioci_poll_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x19c && offset < 0x1a0) {
      offset -= 0x19c;
      eth_mdioci_poll_time_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1a0 && offset < 0x1a4) {
      offset -= 0x1a0;
      eth_rxsigok_bitsel_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1a4 && offset < 0x1a8) {
      offset -= 0x1a4;
      mdioci_intr_stat_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1a8 && offset < 0x1ac) {
      offset -= 0x1a8;
      mdioci_en0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1ac && offset < 0x1b0) {
      offset -= 0x1ac;
      mdioci_en1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1b0 && offset < 0x1b4) {
      offset -= 0x1b0;
      mdioci_freeze_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1b4 && offset < 0x1b8) {
      offset -= 0x1b4;
      mac_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1b8 && offset < 0x1bc) {
      offset -= 0x1b8;
      txff_pream0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1bc && offset < 0x1c0) {
      offset -= 0x1bc;
      txff_pream1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c0 && offset < 0x1c4) {
      offset -= 0x1c0;
      serdes_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c4 && offset < 0x1c8) {
      offset -= 0x1c4;
      eth_ppm_sel_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c8 && offset < 0x1cc) {
      offset -= 0x1c8;
      eth_ppm_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1cc && offset < 0x1d0) {
      offset -= 0x1cc;
      eth_ppm_stat_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1d0 && offset < 0x1d4) {
      offset -= 0x1d0;
      eth_mdioci_addr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe0 && offset < 0xf4) {
      offset -= 0xe0;
      chnl_intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100 && offset < 0x114) {
      offset -= 0x100;
      mem_intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x120 && offset < 0x134) {
      offset -= 0x120;
      uctrl_intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x160 && offset < 0x174) {
      offset -= 0x160;
      tv80_intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    eth_soft_reset_.reset();
    chnl_seq_.reset();
    port_alive_lut_.reset();
    eth_clkobs_ctrl_.reset();
    for (auto &f0 : eth_onestep_ets_offset_ctrl_) {
      f0.reset();
    }
    eth_mac_ts_offset_ctrl_.reset();
    eth_status_.reset();
    global_intr_stat_.reset();
    for (auto &f0 : txff_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : txff_status_) {
      f0.reset();
    }
    for (auto &f0 : txcrc_trunc_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : rxff_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : rxpkt_err_sts_) {
      f0.reset();
    }
    eth_ring_addr_.reset();
    eth_ring_wdata_.reset();
    eth_ring_rdata_.reset();
    eth_ring_ctrl_.reset();
    eth_ring_setup_.reset();
    soft_port_alive_.reset();
    mem_ecc_.reset();
    txfifo_sbe_err_log_.reset();
    txfifo_mbe_err_log_.reset();
    statsmem_sbe_err_log_.reset();
    statsmem_mbe_err_log_.reset();
    tv80mem_sbe_err_log_.reset();
    tv80mem_mbe_err_log_.reset();
    mac_en0_.reset();
    mac_en1_.reset();
    mac_freeze_enable_.reset();
    crcerr_inj_.reset();
    tv80_debug_ctrl_.reset();
    tv80_debug_head_ptr_.reset();
    tv80_debug_tail_ptr_.reset();
    tv80_stall_on_error_.reset();
    tv80_halted_status_.reset();
    tv80_watchdog_ctrl_.reset();
    tv80_watchdog_count_.reset();
    eth_rxsigok_ctrl_.reset();
    eth_mdioci_ctrl_.reset();
    eth_mdioci_poll_ctrl_.reset();
    eth_mdioci_poll_time_.reset();
    eth_rxsigok_bitsel_.reset();
    mdioci_intr_stat_.reset();
    mdioci_en0_.reset();
    mdioci_en1_.reset();
    mdioci_freeze_enable_.reset();
    mac_ctrl_.reset();
    txff_pream0_.reset();
    txff_pream1_.reset();
    serdes_config_.reset();
    eth_ppm_sel_.reset();
    eth_ppm_ctrl_.reset();
    eth_ppm_stat_.reset();
    eth_mdioci_addr_.reset();
    chnl_intr_.reset();
    mem_intr_.reset();
    uctrl_intr_.reset();
    tv80_intr_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      r += eth_soft_reset_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      r += chnl_seq_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      r += port_alive_lut_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      r += eth_clkobs_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40 && offset < 0x60) {
      offset -= 0x40;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      r += eth_onestep_ets_offset_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x60 && offset < 0x68) {
      offset -= 0x60;
      r += eth_mac_ts_offset_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      r += eth_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      r += global_intr_stat_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x70 && offset < 0x80) {
      offset -= 0x70;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += txff_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0x90) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += txff_status_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x90 && offset < 0xa0) {
      offset -= 0x90;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += txcrc_trunc_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa0 && offset < 0xb0) {
      offset -= 0xa0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += rxff_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb0 && offset < 0xc0) {
      offset -= 0xb0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += rxpkt_err_sts_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      r += eth_ring_addr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      r += eth_ring_wdata_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      r += eth_ring_rdata_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xcc && offset < 0xd0) {
      offset -= 0xcc;
      r += eth_ring_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd0 && offset < 0xd4) {
      offset -= 0xd0;
      r += eth_ring_setup_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd4 && offset < 0xd8) {
      offset -= 0xd4;
      r += soft_port_alive_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x134 && offset < 0x138) {
      offset -= 0x134;
      r += mem_ecc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x138 && offset < 0x13c) {
      offset -= 0x138;
      r += txfifo_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x13c && offset < 0x140) {
      offset -= 0x13c;
      r += txfifo_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x140 && offset < 0x144) {
      offset -= 0x140;
      r += statsmem_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x144 && offset < 0x148) {
      offset -= 0x144;
      r += statsmem_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x148 && offset < 0x14c) {
      offset -= 0x148;
      r += tv80mem_sbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14c && offset < 0x150) {
      offset -= 0x14c;
      r += tv80mem_mbe_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x150 && offset < 0x154) {
      offset -= 0x150;
      r += mac_en0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x154 && offset < 0x158) {
      offset -= 0x154;
      r += mac_en1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x158 && offset < 0x15c) {
      offset -= 0x158;
      r += mac_freeze_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x15c && offset < 0x160) {
      offset -= 0x15c;
      r += crcerr_inj_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x174 && offset < 0x178) {
      offset -= 0x174;
      r += tv80_debug_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x178 && offset < 0x17c) {
      offset -= 0x178;
      r += tv80_debug_head_ptr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x17c && offset < 0x180) {
      offset -= 0x17c;
      r += tv80_debug_tail_ptr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x180 && offset < 0x184) {
      offset -= 0x180;
      r += tv80_stall_on_error_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x184 && offset < 0x188) {
      offset -= 0x184;
      r += tv80_halted_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x188 && offset < 0x18c) {
      offset -= 0x188;
      r += tv80_watchdog_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18c && offset < 0x190) {
      offset -= 0x18c;
      r += tv80_watchdog_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x190 && offset < 0x194) {
      offset -= 0x190;
      r += eth_rxsigok_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x194 && offset < 0x198) {
      offset -= 0x194;
      r += eth_mdioci_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x198 && offset < 0x19c) {
      offset -= 0x198;
      r += eth_mdioci_poll_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x19c && offset < 0x1a0) {
      offset -= 0x19c;
      r += eth_mdioci_poll_time_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1a0 && offset < 0x1a4) {
      offset -= 0x1a0;
      r += eth_rxsigok_bitsel_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1a4 && offset < 0x1a8) {
      offset -= 0x1a4;
      r += mdioci_intr_stat_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1a8 && offset < 0x1ac) {
      offset -= 0x1a8;
      r += mdioci_en0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1ac && offset < 0x1b0) {
      offset -= 0x1ac;
      r += mdioci_en1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1b0 && offset < 0x1b4) {
      offset -= 0x1b0;
      r += mdioci_freeze_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1b4 && offset < 0x1b8) {
      offset -= 0x1b4;
      r += mac_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1b8 && offset < 0x1bc) {
      offset -= 0x1b8;
      r += txff_pream0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1bc && offset < 0x1c0) {
      offset -= 0x1bc;
      r += txff_pream1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c0 && offset < 0x1c4) {
      offset -= 0x1c0;
      r += serdes_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c4 && offset < 0x1c8) {
      offset -= 0x1c4;
      r += eth_ppm_sel_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c8 && offset < 0x1cc) {
      offset -= 0x1c8;
      r += eth_ppm_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1cc && offset < 0x1d0) {
      offset -= 0x1cc;
      r += eth_ppm_stat_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1d0 && offset < 0x1d4) {
      offset -= 0x1d0;
      r += eth_mdioci_addr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe0 && offset < 0xf4) {
      offset -= 0xe0;
      r += chnl_intr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100 && offset < 0x114) {
      offset -= 0x100;
      r += mem_intr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x120 && offset < 0x134) {
      offset -= 0x120;
      r += uctrl_intr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x160 && offset < 0x174) {
      offset -= 0x160;
      r += tv80_intr_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += eth_soft_reset_.to_string(print_zeros,indent_string) ;
    r += chnl_seq_.to_string(print_zeros,indent_string) ;
    r += port_alive_lut_.to_string(print_zeros,indent_string) ;
    r += eth_clkobs_ctrl_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += eth_onestep_ets_offset_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    r += eth_mac_ts_offset_ctrl_.to_string(print_zeros,indent_string) ;
    r += eth_status_.to_string(print_zeros,indent_string) ;
    r += global_intr_stat_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += txff_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += txff_status_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += txcrc_trunc_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += rxff_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += rxpkt_err_sts_[a0].to_string(print_zeros,indent_string) ;
    }
    r += eth_ring_addr_.to_string(print_zeros,indent_string) ;
    r += eth_ring_wdata_.to_string(print_zeros,indent_string) ;
    r += eth_ring_rdata_.to_string(print_zeros,indent_string) ;
    r += eth_ring_ctrl_.to_string(print_zeros,indent_string) ;
    r += eth_ring_setup_.to_string(print_zeros,indent_string) ;
    r += soft_port_alive_.to_string(print_zeros,indent_string) ;
    r += mem_ecc_.to_string(print_zeros,indent_string) ;
    r += txfifo_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += txfifo_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += statsmem_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += statsmem_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += tv80mem_sbe_err_log_.to_string(print_zeros,indent_string) ;
    r += tv80mem_mbe_err_log_.to_string(print_zeros,indent_string) ;
    r += mac_en0_.to_string(print_zeros,indent_string) ;
    r += mac_en1_.to_string(print_zeros,indent_string) ;
    r += mac_freeze_enable_.to_string(print_zeros,indent_string) ;
    r += crcerr_inj_.to_string(print_zeros,indent_string) ;
    r += tv80_debug_ctrl_.to_string(print_zeros,indent_string) ;
    r += tv80_debug_head_ptr_.to_string(print_zeros,indent_string) ;
    r += tv80_debug_tail_ptr_.to_string(print_zeros,indent_string) ;
    r += tv80_stall_on_error_.to_string(print_zeros,indent_string) ;
    r += tv80_halted_status_.to_string(print_zeros,indent_string) ;
    r += tv80_watchdog_ctrl_.to_string(print_zeros,indent_string) ;
    r += tv80_watchdog_count_.to_string(print_zeros,indent_string) ;
    r += eth_rxsigok_ctrl_.to_string(print_zeros,indent_string) ;
    r += eth_mdioci_ctrl_.to_string(print_zeros,indent_string) ;
    r += eth_mdioci_poll_ctrl_.to_string(print_zeros,indent_string) ;
    r += eth_mdioci_poll_time_.to_string(print_zeros,indent_string) ;
    r += eth_rxsigok_bitsel_.to_string(print_zeros,indent_string) ;
    r += mdioci_intr_stat_.to_string(print_zeros,indent_string) ;
    r += mdioci_en0_.to_string(print_zeros,indent_string) ;
    r += mdioci_en1_.to_string(print_zeros,indent_string) ;
    r += mdioci_freeze_enable_.to_string(print_zeros,indent_string) ;
    r += mac_ctrl_.to_string(print_zeros,indent_string) ;
    r += txff_pream0_.to_string(print_zeros,indent_string) ;
    r += txff_pream1_.to_string(print_zeros,indent_string) ;
    r += serdes_config_.to_string(print_zeros,indent_string) ;
    r += eth_ppm_sel_.to_string(print_zeros,indent_string) ;
    r += eth_ppm_ctrl_.to_string(print_zeros,indent_string) ;
    r += eth_ppm_stat_.to_string(print_zeros,indent_string) ;
    r += eth_mdioci_addr_.to_string(print_zeros,indent_string) ;
    r += chnl_intr_.to_string(print_zeros,indent_string) ;
    r += mem_intr_.to_string(print_zeros,indent_string) ;
    r += uctrl_intr_.to_string(print_zeros,indent_string) ;
    r += tv80_intr_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  Eth100gRegRspecEthSoftReset eth_soft_reset_;
  Eth100gRegRspecChnlSeq chnl_seq_;
  Eth100gRegRspecPortAliveLut port_alive_lut_;
  Eth100gRegRspecEthClkobsCtrl eth_clkobs_ctrl_;
  std::array< Eth100gRegRspecEthOnestepEtsOffsetCtrl, 4 > eth_onestep_ets_offset_ctrl_;
  Eth100gRegRspecEthMacTsOffsetCtrl eth_mac_ts_offset_ctrl_;
  Eth100gRegRspecEthStatus eth_status_;
  Eth100gRegRspecGlobalIntrStat global_intr_stat_;
  std::array< Eth100gRegRspecTxffCtrl, 4 > txff_ctrl_;
  std::array< Eth100gRegRspecTxffStatus, 4 > txff_status_;
  std::array< Eth100gRegRspecTxcrcTruncCtrl, 4 > txcrc_trunc_ctrl_;
  std::array< Eth100gRegRspecRxffCtrl, 4 > rxff_ctrl_;
  std::array< Eth100gRegRspecRxpktErrSts, 4 > rxpkt_err_sts_;
  Eth100gRegRspecEthRingAddr eth_ring_addr_;
  Eth100gRegRspecEthRingWdata eth_ring_wdata_;
  Eth100gRegRspecEthRingRdata eth_ring_rdata_;
  Eth100gRegRspecEthRingCtrl eth_ring_ctrl_;
  Eth100gRegRspecEthRingSetup eth_ring_setup_;
  Eth100gRegRspecSoftPortAlive soft_port_alive_;
  Eth100gRegRspecMemEcc mem_ecc_;
  Eth100gRegRspecTxfifoSbeErrLog txfifo_sbe_err_log_;
  Eth100gRegRspecTxfifoMbeErrLog txfifo_mbe_err_log_;
  Eth100gRegRspecStatsmemSbeErrLog statsmem_sbe_err_log_;
  Eth100gRegRspecStatsmemMbeErrLog statsmem_mbe_err_log_;
  Eth100gRegRspecTv80memSbeErrLog tv80mem_sbe_err_log_;
  Eth100gRegRspecTv80memMbeErrLog tv80mem_mbe_err_log_;
  Eth100gRegRspecMacEn0 mac_en0_;
  Eth100gRegRspecMacEn1 mac_en1_;
  Eth100gRegRspecMacFreezeEnable mac_freeze_enable_;
  Eth100gRegRspecCrcerrInj crcerr_inj_;
  Eth100gRegRspecTv80DebugCtrl tv80_debug_ctrl_;
  Eth100gRegRspecTv80DebugHeadPtr tv80_debug_head_ptr_;
  Eth100gRegRspecTv80DebugTailPtr tv80_debug_tail_ptr_;
  Eth100gRegRspecTv80StallOnError tv80_stall_on_error_;
  Eth100gRegRspecTv80HaltedStatus tv80_halted_status_;
  Eth100gRegRspecTv80WatchdogCtrl tv80_watchdog_ctrl_;
  Eth100gRegRspecTv80WatchdogCount tv80_watchdog_count_;
  Eth100gRegRspecEthRxsigokCtrl eth_rxsigok_ctrl_;
  Eth100gRegRspecEthMdiociCtrl eth_mdioci_ctrl_;
  Eth100gRegRspecEthMdiociPollCtrl eth_mdioci_poll_ctrl_;
  Eth100gRegRspecEthMdiociPollTime eth_mdioci_poll_time_;
  Eth100gRegRspecEthRxsigokBitsel eth_rxsigok_bitsel_;
  Eth100gRegRspecMdiociIntrStat mdioci_intr_stat_;
  Eth100gRegRspecMdiociEn0 mdioci_en0_;
  Eth100gRegRspecMdiociEn1 mdioci_en1_;
  Eth100gRegRspecMdiociFreezeEnable mdioci_freeze_enable_;
  Eth100gRegRspecMacCtrl mac_ctrl_;
  Eth100gRegRspecTxffPream0 txff_pream0_;
  Eth100gRegRspecTxffPream1 txff_pream1_;
  Eth100gRegRspecSerdesConfig serdes_config_;
  Eth100gRegRspecEthPpmSel eth_ppm_sel_;
  Eth100gRegRspecEthPpmCtrl eth_ppm_ctrl_;
  Eth100gRegRspecEthPpmStat eth_ppm_stat_;
  Eth100gRegRspecEthMdiociAddr eth_mdioci_addr_;
  Eth100gRegRspecChnlIntr chnl_intr_;
  Eth100gRegRspecMemIntr mem_intr_;
  Eth100gRegRspecUctrlIntr uctrl_intr_;
  Eth100gRegRspecTv80Intr tv80_intr_;
private:
  static int StartOffset(
      JbayRegEnum selector_jbay_reg
      ) {
    int offset=0;
    switch (selector_jbay_reg) {
      case kEth100gRegs:
        offset += 0x2000000; // to get to eth100g_regs
        offset += 0x1fc00; // to get to eth100g_reg
        break;
      case kEth100gRegsRot:
        offset += 0x29c0000; // to get to eth100g_regs_rot
        offset += 0x1fc00; // to get to eth100g_reg
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace jbayB0

#endif // __REGISTER_INCLUDES_ETH100G_REG_RSPEC_H__
