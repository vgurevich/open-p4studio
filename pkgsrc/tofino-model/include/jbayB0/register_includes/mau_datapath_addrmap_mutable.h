/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_MAU_DATAPATH_ADDRMAP_MUTABLE_H__
#define __REGISTER_INCLUDES_MAU_DATAPATH_ADDRMAP_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>









#include "action_output_delay_mutable.h"
#include "actionmux_din_power_ctl_mutable.h"
#include "cur_stage_dependency_on_prev_mutable.h"
#include "hashout_ctl_mutable.h"
#include "imem_parity_ctl_mutable.h"
#include "imem_sbe_errlog_mutable.h"
#include "imem_table_addr_egress_mutable.h"
#include "imem_table_addr_format_mutable.h"
#include "imem_table_selector_fallback_addr_mutable.h"
#include "imem_table_selector_fallback_icxbar_ctl_mutable.h"
#include "imem_word_read_override_mutable.h"
#include "intr_enable0_mau_gfm_hash_mutable.h"
#include "intr_enable0_mau_imem_mutable.h"
#include "intr_enable0_mau_snapshot_mutable.h"
#include "intr_enable1_mau_gfm_hash_mutable.h"
#include "intr_enable1_mau_imem_mutable.h"
#include "intr_enable1_mau_snapshot_mutable.h"
#include "intr_freeze_enable_mau_gfm_hash_mutable.h"
#include "intr_freeze_enable_mau_imem_mutable.h"
#include "intr_freeze_enable_mau_snapshot_mutable.h"
#include "intr_inject_mau_gfm_hash_mutable.h"
#include "intr_inject_mau_imem_mutable.h"
#include "intr_inject_mau_snapshot_mutable.h"
#include "intr_status_mau_gfm_hash_mutable.h"
#include "intr_status_mau_imem_mutable.h"
#include "intr_status_mau_snapshot_mutable.h"
#include "match_ie_input_mux_sel_mutable.h"
#include "match_input_xbar_din_power_ctl_mutable.h"
#include "mau_diag_adb_ctl_mutable.h"
#include "mau_imem_addrmap_mutable.h"
#include "mau_match_input_xbar_exact_match_enable_mutable.h"
#include "mau_match_input_xbar_hash_addrmap_mutable.h"
#include "mau_scratch_mutable.h"
#include "mau_snapshot_control_addrmap_mutable.h"
#include "mau_snapshot_datapath_addrmap_mutable.h"
#include "mau_snapshot_imem_logical_read_adr_mutable.h"
#include "mau_snapshot_imem_logical_selector_fallback_mutable.h"
#include "next_stage_dependency_on_cur_mutable.h"
#include "phv_egress_thread_imem_mutable.h"
#include "phv_egress_thread_mutable.h"
#include "phv_fifo_enable_mutable.h"
#include "phv_ingress_thread_imem_mutable.h"
#include "phv_ingress_thread_mutable.h"
#include "pipelength_added_stages_mutable.h"
#include "stage_concurrent_with_prev_mutable.h"

namespace jbayB0 {
  namespace register_classes {

class MauDatapathAddrmapMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  MauDatapathAddrmapMutable(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 262144, true, write_callback, read_callback, std::string("MauDatapathAddrmapMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauDatapathAddrmapMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "MauDatapathAddrmapMutable")
    {
    }
public:











  PhvEgressThreadImemMutable &phv_egress_thread_imem(int j1,int j0) { return phv_egress_thread_imem_[j1][j0]; }



















  ActionmuxDinPowerCtlMutable &actionmux_din_power_ctl(int j1,int j0) { return actionmux_din_power_ctl_[j1][j0]; }






















  MatchInputXbarDinPowerCtlMutable &match_input_xbar_din_power_ctl(int j1,int j0) { return match_input_xbar_din_power_ctl_[j1][j0]; }







  ImemTableAddrFormatMutable &imem_table_addr_format(int j0) { return imem_table_addr_format_[j0]; }








  ImemTableSelectorFallbackAddrMutable &imem_table_selector_fallback_addr(int j0) { return imem_table_selector_fallback_addr_[j0]; }








  MauSnapshotImemLogicalReadAdrMutable &mau_snapshot_imem_logical_read_adr(int j0) { return mau_snapshot_imem_logical_read_adr_[j0]; }






  IntrEnable0MauGfmHashMutable &intr_enable0_mau_gfm_hash() { return intr_enable0_mau_gfm_hash_; }






  IntrEnable1MauGfmHashMutable &intr_enable1_mau_gfm_hash() { return intr_enable1_mau_gfm_hash_; }







  IntrInjectMauGfmHashMutable &intr_inject_mau_gfm_hash() { return intr_inject_mau_gfm_hash_; }





  IntrFreezeEnableMauGfmHashMutable &intr_freeze_enable_mau_gfm_hash() { return intr_freeze_enable_mau_gfm_hash_; }







  ImemWordReadOverrideMutable &imem_word_read_override() { return imem_word_read_override_; }





  MauSnapshotImemLogicalSelectorFallbackMutable &mau_snapshot_imem_logical_selector_fallback() { return mau_snapshot_imem_logical_selector_fallback_; }











  ImemTableSelectorFallbackIcxbarCtlMutable &imem_table_selector_fallback_icxbar_ctl(int j0) { return imem_table_selector_fallback_icxbar_ctl_[j0]; }














  ActionOutputDelayMutable &action_output_delay(int j0) { return action_output_delay_[j0]; }













  CurStageDependencyOnPrevMutable &cur_stage_dependency_on_prev(int j0) { return cur_stage_dependency_on_prev_[j0]; }













  NextStageDependencyOnCurMutable &next_stage_dependency_on_cur(int j0) { return next_stage_dependency_on_cur_[j0]; }










  PipelengthAddedStagesMutable &pipelength_added_stages(int j0) { return pipelength_added_stages_[j0]; }










  MauMatchInputXbarExactMatchEnableMutable &mau_match_input_xbar_exact_match_enable(int j0) { return mau_match_input_xbar_exact_match_enable_[j0]; }










  MatchIeInputMuxSelMutable &match_ie_input_mux_sel() { return match_ie_input_mux_sel_; }








  ImemParityCtlMutable &imem_parity_ctl() { return imem_parity_ctl_; }












  PhvFifoEnableMutable &phv_fifo_enable() { return phv_fifo_enable_; }





  StageConcurrentWithPrevMutable &stage_concurrent_with_prev() { return stage_concurrent_with_prev_; }








  ImemTableAddrEgressMutable &imem_table_addr_egress() { return imem_table_addr_egress_; }





  MauDiagAdbCtlMutable &mau_diag_adb_ctl() { return mau_diag_adb_ctl_; }






  IntrStatusMauImemMutable &intr_status_mau_imem() { return intr_status_mau_imem_; }






  IntrEnable0MauImemMutable &intr_enable0_mau_imem() { return intr_enable0_mau_imem_; }






  IntrEnable1MauImemMutable &intr_enable1_mau_imem() { return intr_enable1_mau_imem_; }







  IntrInjectMauImemMutable &intr_inject_mau_imem() { return intr_inject_mau_imem_; }





  IntrFreezeEnableMauImemMutable &intr_freeze_enable_mau_imem() { return intr_freeze_enable_mau_imem_; }






  IntrStatusMauSnapshotMutable &intr_status_mau_snapshot() { return intr_status_mau_snapshot_; }






  IntrEnable0MauSnapshotMutable &intr_enable0_mau_snapshot() { return intr_enable0_mau_snapshot_; }






  IntrEnable1MauSnapshotMutable &intr_enable1_mau_snapshot() { return intr_enable1_mau_snapshot_; }







  IntrInjectMauSnapshotMutable &intr_inject_mau_snapshot() { return intr_inject_mau_snapshot_; }





  IntrFreezeEnableMauSnapshotMutable &intr_freeze_enable_mau_snapshot() { return intr_freeze_enable_mau_snapshot_; }





  MauScratchMutable &mau_scratch() { return mau_scratch_; }






  ImemSbeErrlogMutable &imem_sbe_errlog() { return imem_sbe_errlog_; }



















  HashoutCtlMutable &hashout_ctl() { return hashout_ctl_; }






  IntrStatusMauGfmHashMutable &intr_status_mau_gfm_hash() { return intr_status_mau_gfm_hash_; }


















  PhvIngressThreadMutable &phv_ingress_thread(int j1,int j0) { return phv_ingress_thread_[j1][j0]; }









  PhvEgressThreadMutable &phv_egress_thread(int j1,int j0) { return phv_egress_thread_[j1][j0]; }











  PhvIngressThreadImemMutable &phv_ingress_thread_imem(int j1,int j0) { return phv_ingress_thread_imem_[j1][j0]; }





  MauImemAddrmapMutable &imem() { return imem_; }





  MauSnapshotControlAddrmapMutable &snapshot_ctl() { return snapshot_ctl_; }





  MauSnapshotDatapathAddrmapMutable &snapshot_dp() { return snapshot_dp_; }





  MauMatchInputXbarHashAddrmapMutable &xbar_hash() { return xbar_hash_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x20000 && offset < 0x20080) {
      offset -= 0x20000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_egress_thread_imem_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x20080 && offset < 0x20100) {
      offset -= 0x20080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      actionmux_din_power_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x20100 && offset < 0x20180) {
      offset -= 0x20100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      match_input_xbar_din_power_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x201c0 && offset < 0x20200) {
      offset -= 0x201c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      imem_table_addr_format_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x20400 && offset < 0x20440) {
      offset -= 0x20400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      imem_table_selector_fallback_addr_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x20440 && offset < 0x20480) {
      offset -= 0x20440;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_imem_logical_read_adr_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x20480 && offset < 0x20484) {
      offset -= 0x20480;
      if (read_callback_) read_callback_();
      intr_enable0_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x20484 && offset < 0x20488) {
      offset -= 0x20484;
      if (read_callback_) read_callback_();
      intr_enable1_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x20488 && offset < 0x2048c) {
      offset -= 0x20488;
      if (read_callback_) read_callback_();
      intr_inject_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x2048c && offset < 0x20490) {
      offset -= 0x2048c;
      if (read_callback_) read_callback_();
      intr_freeze_enable_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x204a0 && offset < 0x204a4) {
      offset -= 0x204a0;
      if (read_callback_) read_callback_();
      imem_word_read_override_.read( offset, data );
    }
    else if (offset >= 0x204a4 && offset < 0x204a8) {
      offset -= 0x204a4;
      if (read_callback_) read_callback_();
      mau_snapshot_imem_logical_selector_fallback_.read( offset, data );
    }
    else if (offset >= 0x204b0 && offset < 0x204c0) {
      offset -= 0x204b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      imem_table_selector_fallback_icxbar_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x204c8 && offset < 0x204d0) {
      offset -= 0x204c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      action_output_delay_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x204d0 && offset < 0x204d8) {
      offset -= 0x204d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      cur_stage_dependency_on_prev_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x204d8 && offset < 0x204e0) {
      offset -= 0x204d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      next_stage_dependency_on_cur_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x204e0 && offset < 0x204e8) {
      offset -= 0x204e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pipelength_added_stages_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x204e8 && offset < 0x204f0) {
      offset -= 0x204e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_match_input_xbar_exact_match_enable_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x204f0 && offset < 0x204f4) {
      offset -= 0x204f0;
      if (read_callback_) read_callback_();
      match_ie_input_mux_sel_.read( offset, data );
    }
    else if (offset >= 0x204f4 && offset < 0x204f8) {
      offset -= 0x204f4;
      if (read_callback_) read_callback_();
      imem_parity_ctl_.read( offset, data );
    }
    else if (offset >= 0x204f8 && offset < 0x204fc) {
      offset -= 0x204f8;
      if (read_callback_) read_callback_();
      phv_fifo_enable_.read( offset, data );
    }
    else if (offset >= 0x204fc && offset < 0x20500) {
      offset -= 0x204fc;
      if (read_callback_) read_callback_();
      stage_concurrent_with_prev_.read( offset, data );
    }
    else if (offset >= 0x20600 && offset < 0x20604) {
      offset -= 0x20600;
      if (read_callback_) read_callback_();
      imem_table_addr_egress_.read( offset, data );
    }
    else if (offset >= 0x20604 && offset < 0x20608) {
      offset -= 0x20604;
      if (read_callback_) read_callback_();
      mau_diag_adb_ctl_.read( offset, data );
    }
    else if (offset >= 0x20608 && offset < 0x2060c) {
      offset -= 0x20608;
      if (read_callback_) read_callback_();
      intr_status_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x2060c && offset < 0x20610) {
      offset -= 0x2060c;
      if (read_callback_) read_callback_();
      intr_enable0_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x20610 && offset < 0x20614) {
      offset -= 0x20610;
      if (read_callback_) read_callback_();
      intr_enable1_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x20614 && offset < 0x20618) {
      offset -= 0x20614;
      if (read_callback_) read_callback_();
      intr_inject_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x20618 && offset < 0x2061c) {
      offset -= 0x20618;
      if (read_callback_) read_callback_();
      intr_freeze_enable_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x2061c && offset < 0x20620) {
      offset -= 0x2061c;
      if (read_callback_) read_callback_();
      intr_status_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x20620 && offset < 0x20624) {
      offset -= 0x20620;
      if (read_callback_) read_callback_();
      intr_enable0_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x20624 && offset < 0x20628) {
      offset -= 0x20624;
      if (read_callback_) read_callback_();
      intr_enable1_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x20628 && offset < 0x2062c) {
      offset -= 0x20628;
      if (read_callback_) read_callback_();
      intr_inject_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x2062c && offset < 0x20630) {
      offset -= 0x2062c;
      if (read_callback_) read_callback_();
      intr_freeze_enable_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x20630 && offset < 0x20634) {
      offset -= 0x20630;
      if (read_callback_) read_callback_();
      mau_scratch_.read( offset, data );
    }
    else if (offset >= 0x20634 && offset < 0x20638) {
      offset -= 0x20634;
      if (read_callback_) read_callback_();
      imem_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x20638 && offset < 0x2063c) {
      offset -= 0x20638;
      if (read_callback_) read_callback_();
      hashout_ctl_.read( offset, data );
    }
    else if (offset >= 0x2063c && offset < 0x20640) {
      offset -= 0x2063c;
      if (read_callback_) read_callback_();
      intr_status_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x20680 && offset < 0x20700) {
      offset -= 0x20680;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_ingress_thread_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x20700 && offset < 0x20780) {
      offset -= 0x20700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_egress_thread_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x20780 && offset < 0x20800) {
      offset -= 0x20780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_ingress_thread_imem_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset < 0x10000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      imem_.read( offset, data );
    }
    else if (offset >= 0x20180 && offset < 0x201c0) {
      offset -= 0x20180;
      if (read_callback_) read_callback_();
      snapshot_ctl_.read( offset, data );
    }
    else if (offset >= 0x22000 && offset < 0x24000) {
      offset -= 0x22000;
      if (read_callback_) read_callback_();
      snapshot_dp_.read( offset, data );
    }
    else if (offset >= 0x30000 && offset < 0x40000) {
      offset -= 0x30000;
      if (read_callback_) read_callback_();
      xbar_hash_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x20000 && offset < 0x20080) {
      offset -= 0x20000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_egress_thread_imem_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20080 && offset < 0x20100) {
      offset -= 0x20080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      actionmux_din_power_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20100 && offset < 0x20180) {
      offset -= 0x20100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      match_input_xbar_din_power_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x201c0 && offset < 0x20200) {
      offset -= 0x201c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      imem_table_addr_format_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20400 && offset < 0x20440) {
      offset -= 0x20400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      imem_table_selector_fallback_addr_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20440 && offset < 0x20480) {
      offset -= 0x20440;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_imem_logical_read_adr_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20480 && offset < 0x20484) {
      offset -= 0x20480;
      intr_enable0_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20484 && offset < 0x20488) {
      offset -= 0x20484;
      intr_enable1_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20488 && offset < 0x2048c) {
      offset -= 0x20488;
      intr_inject_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2048c && offset < 0x20490) {
      offset -= 0x2048c;
      intr_freeze_enable_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204a0 && offset < 0x204a4) {
      offset -= 0x204a0;
      imem_word_read_override_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204a4 && offset < 0x204a8) {
      offset -= 0x204a4;
      mau_snapshot_imem_logical_selector_fallback_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204b0 && offset < 0x204c0) {
      offset -= 0x204b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      imem_table_selector_fallback_icxbar_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204c8 && offset < 0x204d0) {
      offset -= 0x204c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      action_output_delay_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204d0 && offset < 0x204d8) {
      offset -= 0x204d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      cur_stage_dependency_on_prev_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204d8 && offset < 0x204e0) {
      offset -= 0x204d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      next_stage_dependency_on_cur_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204e0 && offset < 0x204e8) {
      offset -= 0x204e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pipelength_added_stages_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204e8 && offset < 0x204f0) {
      offset -= 0x204e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_match_input_xbar_exact_match_enable_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204f0 && offset < 0x204f4) {
      offset -= 0x204f0;
      match_ie_input_mux_sel_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204f4 && offset < 0x204f8) {
      offset -= 0x204f4;
      imem_parity_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204f8 && offset < 0x204fc) {
      offset -= 0x204f8;
      phv_fifo_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x204fc && offset < 0x20500) {
      offset -= 0x204fc;
      stage_concurrent_with_prev_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20600 && offset < 0x20604) {
      offset -= 0x20600;
      imem_table_addr_egress_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20604 && offset < 0x20608) {
      offset -= 0x20604;
      mau_diag_adb_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20608 && offset < 0x2060c) {
      offset -= 0x20608;
      intr_status_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2060c && offset < 0x20610) {
      offset -= 0x2060c;
      intr_enable0_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20610 && offset < 0x20614) {
      offset -= 0x20610;
      intr_enable1_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20614 && offset < 0x20618) {
      offset -= 0x20614;
      intr_inject_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20618 && offset < 0x2061c) {
      offset -= 0x20618;
      intr_freeze_enable_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2061c && offset < 0x20620) {
      offset -= 0x2061c;
      intr_status_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20620 && offset < 0x20624) {
      offset -= 0x20620;
      intr_enable0_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20624 && offset < 0x20628) {
      offset -= 0x20624;
      intr_enable1_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20628 && offset < 0x2062c) {
      offset -= 0x20628;
      intr_inject_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2062c && offset < 0x20630) {
      offset -= 0x2062c;
      intr_freeze_enable_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20630 && offset < 0x20634) {
      offset -= 0x20630;
      mau_scratch_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20634 && offset < 0x20638) {
      offset -= 0x20634;
      imem_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20638 && offset < 0x2063c) {
      offset -= 0x20638;
      hashout_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2063c && offset < 0x20640) {
      offset -= 0x2063c;
      intr_status_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20680 && offset < 0x20700) {
      offset -= 0x20680;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_ingress_thread_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20700 && offset < 0x20780) {
      offset -= 0x20700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_egress_thread_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20780 && offset < 0x20800) {
      offset -= 0x20780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_ingress_thread_imem_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset < 0x10000) {
      offset -= 0x0;
      imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20180 && offset < 0x201c0) {
      offset -= 0x20180;
      snapshot_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22000 && offset < 0x24000) {
      offset -= 0x22000;
      snapshot_dp_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x30000 && offset < 0x40000) {
      offset -= 0x30000;
      xbar_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : phv_egress_thread_imem_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : actionmux_din_power_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : match_input_xbar_din_power_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : imem_table_addr_format_) {
      f0.reset();
    }
    for (auto &f0 : imem_table_selector_fallback_addr_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_imem_logical_read_adr_) {
      f0.reset();
    }
    intr_enable0_mau_gfm_hash_.reset();
    intr_enable1_mau_gfm_hash_.reset();
    intr_inject_mau_gfm_hash_.reset();
    intr_freeze_enable_mau_gfm_hash_.reset();
    imem_word_read_override_.reset();
    mau_snapshot_imem_logical_selector_fallback_.reset();
    for (auto &f0 : imem_table_selector_fallback_icxbar_ctl_) {
      f0.reset();
    }
    for (auto &f0 : action_output_delay_) {
      f0.reset();
    }
    for (auto &f0 : cur_stage_dependency_on_prev_) {
      f0.reset();
    }
    for (auto &f0 : next_stage_dependency_on_cur_) {
      f0.reset();
    }
    for (auto &f0 : pipelength_added_stages_) {
      f0.reset();
    }
    for (auto &f0 : mau_match_input_xbar_exact_match_enable_) {
      f0.reset();
    }
    match_ie_input_mux_sel_.reset();
    imem_parity_ctl_.reset();
    phv_fifo_enable_.reset();
    stage_concurrent_with_prev_.reset();
    imem_table_addr_egress_.reset();
    mau_diag_adb_ctl_.reset();
    intr_status_mau_imem_.reset();
    intr_enable0_mau_imem_.reset();
    intr_enable1_mau_imem_.reset();
    intr_inject_mau_imem_.reset();
    intr_freeze_enable_mau_imem_.reset();
    intr_status_mau_snapshot_.reset();
    intr_enable0_mau_snapshot_.reset();
    intr_enable1_mau_snapshot_.reset();
    intr_inject_mau_snapshot_.reset();
    intr_freeze_enable_mau_snapshot_.reset();
    mau_scratch_.reset();
    imem_sbe_errlog_.reset();
    hashout_ctl_.reset();
    intr_status_mau_gfm_hash_.reset();
    for (auto &f0 : phv_ingress_thread_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : phv_egress_thread_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : phv_ingress_thread_imem_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    imem_.reset();
    snapshot_ctl_.reset();
    snapshot_dp_.reset();
    xbar_hash_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x20000 && offset < 0x20080) {
      offset -= 0x20000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_egress_thread_imem_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20080 && offset < 0x20100) {
      offset -= 0x20080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += actionmux_din_power_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20100 && offset < 0x20180) {
      offset -= 0x20100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += match_input_xbar_din_power_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x201c0 && offset < 0x20200) {
      offset -= 0x201c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += imem_table_addr_format_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20400 && offset < 0x20440) {
      offset -= 0x20400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += imem_table_selector_fallback_addr_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20440 && offset < 0x20480) {
      offset -= 0x20440;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_imem_logical_read_adr_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20480 && offset < 0x20484) {
      offset -= 0x20480;
      r += intr_enable0_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20484 && offset < 0x20488) {
      offset -= 0x20484;
      r += intr_enable1_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20488 && offset < 0x2048c) {
      offset -= 0x20488;
      r += intr_inject_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2048c && offset < 0x20490) {
      offset -= 0x2048c;
      r += intr_freeze_enable_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204a0 && offset < 0x204a4) {
      offset -= 0x204a0;
      r += imem_word_read_override_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204a4 && offset < 0x204a8) {
      offset -= 0x204a4;
      r += mau_snapshot_imem_logical_selector_fallback_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204b0 && offset < 0x204c0) {
      offset -= 0x204b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += imem_table_selector_fallback_icxbar_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204c8 && offset < 0x204d0) {
      offset -= 0x204c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += action_output_delay_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204d0 && offset < 0x204d8) {
      offset -= 0x204d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += cur_stage_dependency_on_prev_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204d8 && offset < 0x204e0) {
      offset -= 0x204d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += next_stage_dependency_on_cur_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204e0 && offset < 0x204e8) {
      offset -= 0x204e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pipelength_added_stages_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204e8 && offset < 0x204f0) {
      offset -= 0x204e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_match_input_xbar_exact_match_enable_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204f0 && offset < 0x204f4) {
      offset -= 0x204f0;
      r += match_ie_input_mux_sel_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204f4 && offset < 0x204f8) {
      offset -= 0x204f4;
      r += imem_parity_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204f8 && offset < 0x204fc) {
      offset -= 0x204f8;
      r += phv_fifo_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x204fc && offset < 0x20500) {
      offset -= 0x204fc;
      r += stage_concurrent_with_prev_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20600 && offset < 0x20604) {
      offset -= 0x20600;
      r += imem_table_addr_egress_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20604 && offset < 0x20608) {
      offset -= 0x20604;
      r += mau_diag_adb_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20608 && offset < 0x2060c) {
      offset -= 0x20608;
      r += intr_status_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2060c && offset < 0x20610) {
      offset -= 0x2060c;
      r += intr_enable0_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20610 && offset < 0x20614) {
      offset -= 0x20610;
      r += intr_enable1_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20614 && offset < 0x20618) {
      offset -= 0x20614;
      r += intr_inject_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20618 && offset < 0x2061c) {
      offset -= 0x20618;
      r += intr_freeze_enable_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2061c && offset < 0x20620) {
      offset -= 0x2061c;
      r += intr_status_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20620 && offset < 0x20624) {
      offset -= 0x20620;
      r += intr_enable0_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20624 && offset < 0x20628) {
      offset -= 0x20624;
      r += intr_enable1_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20628 && offset < 0x2062c) {
      offset -= 0x20628;
      r += intr_inject_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2062c && offset < 0x20630) {
      offset -= 0x2062c;
      r += intr_freeze_enable_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20630 && offset < 0x20634) {
      offset -= 0x20630;
      r += mau_scratch_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20634 && offset < 0x20638) {
      offset -= 0x20634;
      r += imem_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20638 && offset < 0x2063c) {
      offset -= 0x20638;
      r += hashout_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2063c && offset < 0x20640) {
      offset -= 0x2063c;
      r += intr_status_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20680 && offset < 0x20700) {
      offset -= 0x20680;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_ingress_thread_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20700 && offset < 0x20780) {
      offset -= 0x20700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_egress_thread_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20780 && offset < 0x20800) {
      offset -= 0x20780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_ingress_thread_imem_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset < 0x10000) {
      offset -= 0x0;
      r += imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20180 && offset < 0x201c0) {
      offset -= 0x20180;
      r += snapshot_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22000 && offset < 0x24000) {
      offset -= 0x22000;
      r += snapshot_dp_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x30000 && offset < 0x40000) {
      offset -= 0x30000;
      r += xbar_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_egress_thread_imem_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += actionmux_din_power_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += match_input_xbar_din_power_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += imem_table_addr_format_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += imem_table_selector_fallback_addr_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_snapshot_imem_logical_read_adr_[a0].to_string(print_zeros,indent_string) ;
    }
    r += intr_enable0_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += intr_enable1_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += intr_inject_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += intr_freeze_enable_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += imem_word_read_override_.to_string(print_zeros,indent_string) ;
    r += mau_snapshot_imem_logical_selector_fallback_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += imem_table_selector_fallback_icxbar_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += action_output_delay_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += cur_stage_dependency_on_prev_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += next_stage_dependency_on_cur_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += pipelength_added_stages_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_match_input_xbar_exact_match_enable_[a0].to_string(print_zeros,indent_string) ;
    }
    r += match_ie_input_mux_sel_.to_string(print_zeros,indent_string) ;
    r += imem_parity_ctl_.to_string(print_zeros,indent_string) ;
    r += phv_fifo_enable_.to_string(print_zeros,indent_string) ;
    r += stage_concurrent_with_prev_.to_string(print_zeros,indent_string) ;
    r += imem_table_addr_egress_.to_string(print_zeros,indent_string) ;
    r += mau_diag_adb_ctl_.to_string(print_zeros,indent_string) ;
    r += intr_status_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_enable0_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_enable1_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_inject_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_freeze_enable_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_status_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_enable0_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_enable1_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_inject_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_freeze_enable_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += mau_scratch_.to_string(print_zeros,indent_string) ;
    r += imem_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += hashout_ctl_.to_string(print_zeros,indent_string) ;
    r += intr_status_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_ingress_thread_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_egress_thread_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_ingress_thread_imem_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    r += imem_.to_string(print_zeros,indent_string) ;
    r += snapshot_ctl_.to_string(print_zeros,indent_string) ;
    r += snapshot_dp_.to_string(print_zeros,indent_string) ;
    r += xbar_hash_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< std::array< PhvEgressThreadImemMutable, 14 >, 2 > phv_egress_thread_imem_;
  std::array< std::array< ActionmuxDinPowerCtlMutable, 14 >, 2 > actionmux_din_power_ctl_;
  std::array< std::array< MatchInputXbarDinPowerCtlMutable, 14 >, 2 > match_input_xbar_din_power_ctl_;
  std::array< ImemTableAddrFormatMutable, 16 > imem_table_addr_format_;
  std::array< ImemTableSelectorFallbackAddrMutable, 16 > imem_table_selector_fallback_addr_;
  std::array< MauSnapshotImemLogicalReadAdrMutable, 16 > mau_snapshot_imem_logical_read_adr_;
  IntrEnable0MauGfmHashMutable intr_enable0_mau_gfm_hash_;
  IntrEnable1MauGfmHashMutable intr_enable1_mau_gfm_hash_;
  IntrInjectMauGfmHashMutable intr_inject_mau_gfm_hash_;
  IntrFreezeEnableMauGfmHashMutable intr_freeze_enable_mau_gfm_hash_;
  ImemWordReadOverrideMutable imem_word_read_override_;
  MauSnapshotImemLogicalSelectorFallbackMutable mau_snapshot_imem_logical_selector_fallback_;
  std::array< ImemTableSelectorFallbackIcxbarCtlMutable, 4 > imem_table_selector_fallback_icxbar_ctl_;
  std::array< ActionOutputDelayMutable, 2 > action_output_delay_;
  std::array< CurStageDependencyOnPrevMutable, 2 > cur_stage_dependency_on_prev_;
  std::array< NextStageDependencyOnCurMutable, 2 > next_stage_dependency_on_cur_;
  std::array< PipelengthAddedStagesMutable, 2 > pipelength_added_stages_;
  std::array< MauMatchInputXbarExactMatchEnableMutable, 2 > mau_match_input_xbar_exact_match_enable_;
  MatchIeInputMuxSelMutable match_ie_input_mux_sel_;
  ImemParityCtlMutable imem_parity_ctl_;
  PhvFifoEnableMutable phv_fifo_enable_;
  StageConcurrentWithPrevMutable stage_concurrent_with_prev_;
  ImemTableAddrEgressMutable imem_table_addr_egress_;
  MauDiagAdbCtlMutable mau_diag_adb_ctl_;
  IntrStatusMauImemMutable intr_status_mau_imem_;
  IntrEnable0MauImemMutable intr_enable0_mau_imem_;
  IntrEnable1MauImemMutable intr_enable1_mau_imem_;
  IntrInjectMauImemMutable intr_inject_mau_imem_;
  IntrFreezeEnableMauImemMutable intr_freeze_enable_mau_imem_;
  IntrStatusMauSnapshotMutable intr_status_mau_snapshot_;
  IntrEnable0MauSnapshotMutable intr_enable0_mau_snapshot_;
  IntrEnable1MauSnapshotMutable intr_enable1_mau_snapshot_;
  IntrInjectMauSnapshotMutable intr_inject_mau_snapshot_;
  IntrFreezeEnableMauSnapshotMutable intr_freeze_enable_mau_snapshot_;
  MauScratchMutable mau_scratch_;
  ImemSbeErrlogMutable imem_sbe_errlog_;
  HashoutCtlMutable hashout_ctl_;
  IntrStatusMauGfmHashMutable intr_status_mau_gfm_hash_;
  std::array< std::array< PhvIngressThreadMutable, 14 >, 2 > phv_ingress_thread_;
  std::array< std::array< PhvEgressThreadMutable, 14 >, 2 > phv_egress_thread_;
  std::array< std::array< PhvIngressThreadImemMutable, 14 >, 2 > phv_ingress_thread_imem_;
  MauImemAddrmapMutable imem_;
  MauSnapshotControlAddrmapMutable snapshot_ctl_;
  MauSnapshotDatapathAddrmapMutable snapshot_dp_;
  MauMatchInputXbarHashAddrmapMutable xbar_hash_;
private:
  static int StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    int offset=0;
    offset += 0x4000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x1000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x80000; // mau_addrmap[]
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace jbayB0

#endif // __REGISTER_INCLUDES_MAU_DATAPATH_ADDRMAP_MUTABLE_H__
