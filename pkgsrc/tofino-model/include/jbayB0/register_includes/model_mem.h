/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/



#ifndef ___JBAYB0_REGISTER_INCLUDES_MODEL_MEM_H__
#define ___JBAYB0_REGISTER_INCLUDES_MODEL_MEM_H__
#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>
namespace jbayB0 {
  namespace memory_classes {









class PgrPhase0Meta : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPhase0Meta(
      int chipNumber, int index_pipe_addrmap, int index_pgr_phase0_meta, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_phase0_meta), 1, false, write_callback, read_callback, std::string("PgrPhase0Meta")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_phase0_meta))
    {
    }
  PgrPhase0Meta(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrPhase0Meta")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0Meta") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0Meta") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_phase0_meta
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    assert(index_pgr_phase0_meta < 72);
    offset += index_pgr_phase0_meta * 0x1; // pgr_phase0_meta[]
    return offset;
  }

};









class PgrPhase0MetaMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPhase0MetaMutable(
      int chipNumber, int index_pipe_addrmap, int index_pgr_phase0_meta, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_phase0_meta), 1, true, write_callback, read_callback, std::string("PgrPhase0MetaMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_phase0_meta))
    {
    }
  PgrPhase0MetaMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrPhase0MetaMutable")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0MetaMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrPhase0MetaMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_phase0_meta
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    assert(index_pgr_phase0_meta < 72);
    offset += index_pgr_phase0_meta * 0x1; // pgr_phase0_meta[]
    return offset;
  }

};









class PgrPhase0MetaArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrPhase0MetaArray(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), false, write_callback, read_callback, std::string("PgrPhase0MetaArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrPhase0MetaArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrPhase0MetaArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrPhase0Meta> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PgrPhase0MetaArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrPhase0MetaArrayMutable(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), true, write_callback, read_callback, std::string("PgrPhase0MetaArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrPhase0MetaArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrPhase0MetaArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrPhase0MetaMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 72;
        break;
      case 0:
        return 72;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PgrPh0Rspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPh0Rspec(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 256, false, write_callback, read_callback, std::string("PgrPh0Rspec")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrPh0Rspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrPh0Rspec")
    {
    }
public:








  PgrPhase0Meta &phase0_mem_word(int j0) { return phase0_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      phase0_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      phase0_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : phase0_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += phase0_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<72;++a0) {
      r += phase0_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrPhase0Meta, 72 > phase0_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

};








class PgrPh0RspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrPh0RspecMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 256, true, write_callback, read_callback, std::string("PgrPh0RspecMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrPh0RspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrPh0RspecMutable")
    {
    }
public:








  PgrPhase0MetaMutable &phase0_mem_word(int j0) { return phase0_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      phase0_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      phase0_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : phase0_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += phase0_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<72;++a0) {
      r += phase0_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrPhase0MetaMutable, 72 > phase0_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x36000; // to get to pgr_ph0_rspec
    return offset;
  }

};









class PgrBufferMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrBufferMemWord(
      int chipNumber, int index_pipe_addrmap, int index_pgr_buffer_mem_word, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_buffer_mem_word), 1, false, write_callback, read_callback, std::string("PgrBufferMemWord")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_buffer_mem_word))
    {
    }
  PgrBufferMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrBufferMemWord")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWord") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWord") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_buffer_mem_word
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    assert(index_pgr_buffer_mem_word < 1024);
    offset += index_pgr_buffer_mem_word * 0x1; // pgr_buffer_mem_word[]
    return offset;
  }

};









class PgrBufferMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrBufferMemWordMutable(
      int chipNumber, int index_pipe_addrmap, int index_pgr_buffer_mem_word, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_pgr_buffer_mem_word), 1, true, write_callback, read_callback, std::string("PgrBufferMemWordMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_pgr_buffer_mem_word))
    {
    }
  PgrBufferMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrBufferMemWordMutable")
    {
    }
public:




  BitVector<128> &mem_word() { return mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = mem_word_.get_word(0);
    *data1 = mem_word_.get_word(64);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    mem_word_.set_word(data0, 0,64);
    mem_word_.set_word(data1, 64,64);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    mem_word_.fill_all_zeros();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWordMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PgrBufferMemWordMutable") + ":\n";
    r += indent_string + "  " + std::string("mem_word") +  ": 0x" + mem_word_.to_string() + "\n";
    all_zeros &= 0;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  BitVector<128> mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_pgr_buffer_mem_word
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    assert(index_pgr_buffer_mem_word < 1024);
    offset += index_pgr_buffer_mem_word * 0x1; // pgr_buffer_mem_word[]
    return offset;
  }

};









class PgrBufferMemWordArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrBufferMemWordArray(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), false, write_callback, read_callback, std::string("PgrBufferMemWordArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrBufferMemWordArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrBufferMemWordArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrBufferMemWord> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PgrBufferMemWordArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PgrBufferMemWordArrayMutable(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 1 * ArraySize(index_pipe_addrmap, -1), true, write_callback, read_callback, std::string("PgrBufferMemWordArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:




  BitVector<128> &mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PgrBufferMemWordArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PgrBufferMemWordArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PgrBufferMemWordMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 1024;
        break;
      case 0:
        return 1024;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PgrMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrMemRspec(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 8192, false, write_callback, read_callback, std::string("PgrMemRspec")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PgrMemRspec")
    {
    }
public:








  PgrBufferMemWord &buffer_mem_word(int j0) { return buffer_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      buffer_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      buffer_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : buffer_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += buffer_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<1024;++a0) {
      r += buffer_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrBufferMemWord, 1024 > buffer_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

};








class PgrMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PgrMemRspecMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 8192, true, write_callback, read_callback, std::string("PgrMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PgrMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PgrMemRspecMutable")
    {
    }
public:








  PgrBufferMemWordMutable &buffer_mem_word(int j0) { return buffer_mem_word_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      buffer_mem_word_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      buffer_mem_word_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : buffer_mem_word_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += buffer_mem_word_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<1024;++a0) {
      r += buffer_mem_word_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PgrBufferMemWordMutable, 1024 > buffer_mem_word_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    offset += 0x34000; // to get to pgr_mem_rspec
    return offset;
  }

};







class PrsrPoCsumCtrlRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, index_prsr_po_csum_ctrl_row), 1, false, write_callback, read_callback, std::string("PrsrPoCsumCtrlRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_csum_ctrl_row))
    {
    }
  PrsrPoCsumCtrlRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrPoCsumCtrlRow")
    {
    }
public:





  uint16_t &add() { return add_; }







  uint8_t &swap(int j0) { return swap_[j0]; }






  uint8_t &shr() { return shr_; }







  uint8_t &mask(int j0) { return mask_[j0]; }






  uint8_t &dst_bit_hdr_end_pos() { return dst_bit_hdr_end_pos_; }






  uint8_t &dst() { return dst_; }







  uint8_t &hdr_end() { return hdr_end_; }







  uint8_t &type() { return type_; }





  uint8_t &start() { return start_; }







  uint8_t &zeros_as_ones() { return zeros_as_ones_; }






  uint8_t &zeros_as_ones_pos() { return zeros_as_ones_pos_; }







  uint8_t &mul_2(int j0) { return mul_2_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= ((static_cast<uint64_t>(swap_[0]) & 0x1) << 16);
    *data0 |= ((static_cast<uint64_t>(swap_[1]) & 0x1) << 17);
    *data0 |= ((static_cast<uint64_t>(swap_[2]) & 0x1) << 18);
    *data0 |= ((static_cast<uint64_t>(swap_[3]) & 0x1) << 19);
    *data0 |= ((static_cast<uint64_t>(swap_[4]) & 0x1) << 20);
    *data0 |= ((static_cast<uint64_t>(swap_[5]) & 0x1) << 21);
    *data0 |= ((static_cast<uint64_t>(swap_[6]) & 0x1) << 22);
    *data0 |= ((static_cast<uint64_t>(swap_[7]) & 0x1) << 23);
    *data0 |= ((static_cast<uint64_t>(swap_[8]) & 0x1) << 24);
    *data0 |= ((static_cast<uint64_t>(swap_[9]) & 0x1) << 25);
    *data0 |= ((static_cast<uint64_t>(swap_[10]) & 0x1) << 26);
    *data0 |= ((static_cast<uint64_t>(swap_[11]) & 0x1) << 27);
    *data0 |= ((static_cast<uint64_t>(swap_[12]) & 0x1) << 28);
    *data0 |= ((static_cast<uint64_t>(swap_[13]) & 0x1) << 29);
    *data0 |= ((static_cast<uint64_t>(swap_[14]) & 0x1) << 30);
    *data0 |= ((static_cast<uint64_t>(swap_[15]) & 0x1) << 31);
    *data0 |= ((static_cast<uint64_t>(swap_[16]) & 0x1) << 32);
    *data0 |= ((static_cast<uint64_t>(shr_) & 0x1) << 33);
    *data0 |= ((static_cast<uint64_t>(mask_[0]) & 0x1) << 34);
    *data0 |= ((static_cast<uint64_t>(mask_[1]) & 0x1) << 35);
    *data0 |= ((static_cast<uint64_t>(mask_[2]) & 0x1) << 36);
    *data0 |= ((static_cast<uint64_t>(mask_[3]) & 0x1) << 37);
    *data0 |= ((static_cast<uint64_t>(mask_[4]) & 0x1) << 38);
    *data0 |= ((static_cast<uint64_t>(mask_[5]) & 0x1) << 39);
    *data0 |= ((static_cast<uint64_t>(mask_[6]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(mask_[7]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(mask_[8]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(mask_[9]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(mask_[10]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(mask_[11]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(mask_[12]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(mask_[13]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(mask_[14]) & 0x1) << 48);
    *data0 |= ((static_cast<uint64_t>(mask_[15]) & 0x1) << 49);
    *data0 |= ((static_cast<uint64_t>(mask_[16]) & 0x1) << 50);
    *data0 |= ((static_cast<uint64_t>(mask_[17]) & 0x1) << 51);
    *data0 |= ((static_cast<uint64_t>(mask_[18]) & 0x1) << 52);
    *data0 |= ((static_cast<uint64_t>(mask_[19]) & 0x1) << 53);
    *data0 |= ((static_cast<uint64_t>(mask_[20]) & 0x1) << 54);
    *data0 |= ((static_cast<uint64_t>(mask_[21]) & 0x1) << 55);
    *data0 |= ((static_cast<uint64_t>(mask_[22]) & 0x1) << 56);
    *data0 |= ((static_cast<uint64_t>(mask_[23]) & 0x1) << 57);
    *data0 |= ((static_cast<uint64_t>(mask_[24]) & 0x1) << 58);
    *data0 |= ((static_cast<uint64_t>(mask_[25]) & 0x1) << 59);
    *data0 |= ((static_cast<uint64_t>(mask_[26]) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(mask_[27]) & 0x1) << 61);
    *data0 |= ((static_cast<uint64_t>(mask_[28]) & 0x1) << 62);
    *data0 |= ((static_cast<uint64_t>(mask_[29]) & 0x1) << 63);
    *data1 = (static_cast<uint64_t>(mask_[30]) & 0x1);
    *data1 |= ((static_cast<uint64_t>(mask_[31]) & 0x1) << 1);
    *data1 |= ((static_cast<uint64_t>(dst_bit_hdr_end_pos_) & 0x1f) << 2);
    *data1 |= (static_cast<uint64_t>(dst_) << 7);
    *data1 |= ((static_cast<uint64_t>(hdr_end_) & 0x1) << 15);
    *data1 |= ((static_cast<uint64_t>(type_) & 0x3) << 16);
    *data1 |= ((static_cast<uint64_t>(start_) & 0x1) << 18);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_) & 0x1) << 19);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_pos_) & 0x1f) << 20);
    *data1 |= ((static_cast<uint64_t>(mul_2_[0]) & 0x1) << 25);
    *data1 |= ((static_cast<uint64_t>(mul_2_[1]) & 0x1) << 26);
    *data1 |= ((static_cast<uint64_t>(mul_2_[2]) & 0x1) << 27);
    *data1 |= ((static_cast<uint64_t>(mul_2_[3]) & 0x1) << 28);
    *data1 |= ((static_cast<uint64_t>(mul_2_[4]) & 0x1) << 29);
    *data1 |= ((static_cast<uint64_t>(mul_2_[5]) & 0x1) << 30);
    *data1 |= ((static_cast<uint64_t>(mul_2_[6]) & 0x1) << 31);
    *data1 |= ((static_cast<uint64_t>(mul_2_[7]) & 0x1) << 32);
    *data1 |= ((static_cast<uint64_t>(mul_2_[8]) & 0x1) << 33);
    *data1 |= ((static_cast<uint64_t>(mul_2_[9]) & 0x1) << 34);
    *data1 |= ((static_cast<uint64_t>(mul_2_[10]) & 0x1) << 35);
    *data1 |= ((static_cast<uint64_t>(mul_2_[11]) & 0x1) << 36);
    *data1 |= ((static_cast<uint64_t>(mul_2_[12]) & 0x1) << 37);
    *data1 |= ((static_cast<uint64_t>(mul_2_[13]) & 0x1) << 38);
    *data1 |= ((static_cast<uint64_t>(mul_2_[14]) & 0x1) << 39);
    *data1 |= ((static_cast<uint64_t>(mul_2_[15]) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(mul_2_[16]) & 0x1) << 41);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    swap_[0] = ((data0 >> 16) & 0x1);
    swap_[1] = ((data0 >> 17) & 0x1);
    swap_[2] = ((data0 >> 18) & 0x1);
    swap_[3] = ((data0 >> 19) & 0x1);
    swap_[4] = ((data0 >> 20) & 0x1);
    swap_[5] = ((data0 >> 21) & 0x1);
    swap_[6] = ((data0 >> 22) & 0x1);
    swap_[7] = ((data0 >> 23) & 0x1);
    swap_[8] = ((data0 >> 24) & 0x1);
    swap_[9] = ((data0 >> 25) & 0x1);
    swap_[10] = ((data0 >> 26) & 0x1);
    swap_[11] = ((data0 >> 27) & 0x1);
    swap_[12] = ((data0 >> 28) & 0x1);
    swap_[13] = ((data0 >> 29) & 0x1);
    swap_[14] = ((data0 >> 30) & 0x1);
    swap_[15] = ((data0 >> 31) & 0x1);
    swap_[16] = ((data0 >> 32) & 0x1);
    shr_ = ((data0 >> 33) & 0x1);
    mask_[0] = ((data0 >> 34) & 0x1);
    mask_[1] = ((data0 >> 35) & 0x1);
    mask_[2] = ((data0 >> 36) & 0x1);
    mask_[3] = ((data0 >> 37) & 0x1);
    mask_[4] = ((data0 >> 38) & 0x1);
    mask_[5] = ((data0 >> 39) & 0x1);
    mask_[6] = ((data0 >> 40) & 0x1);
    mask_[7] = ((data0 >> 41) & 0x1);
    mask_[8] = ((data0 >> 42) & 0x1);
    mask_[9] = ((data0 >> 43) & 0x1);
    mask_[10] = ((data0 >> 44) & 0x1);
    mask_[11] = ((data0 >> 45) & 0x1);
    mask_[12] = ((data0 >> 46) & 0x1);
    mask_[13] = ((data0 >> 47) & 0x1);
    mask_[14] = ((data0 >> 48) & 0x1);
    mask_[15] = ((data0 >> 49) & 0x1);
    mask_[16] = ((data0 >> 50) & 0x1);
    mask_[17] = ((data0 >> 51) & 0x1);
    mask_[18] = ((data0 >> 52) & 0x1);
    mask_[19] = ((data0 >> 53) & 0x1);
    mask_[20] = ((data0 >> 54) & 0x1);
    mask_[21] = ((data0 >> 55) & 0x1);
    mask_[22] = ((data0 >> 56) & 0x1);
    mask_[23] = ((data0 >> 57) & 0x1);
    mask_[24] = ((data0 >> 58) & 0x1);
    mask_[25] = ((data0 >> 59) & 0x1);
    mask_[26] = ((data0 >> 60) & 0x1);
    mask_[27] = ((data0 >> 61) & 0x1);
    mask_[28] = ((data0 >> 62) & 0x1);
    mask_[29] = ((data0 >> 63) & 0x1);
    mask_[30] = (data1 & 0x1);
    mask_[31] = ((data1 >> 1) & 0x1);
    dst_bit_hdr_end_pos_ = ((data1 >> 2) & 0x1f);
    dst_ = (data1 >> 7);
    hdr_end_ = ((data1 >> 15) & 0x1);
    type_ = ((data1 >> 16) & 0x3);
    start_ = ((data1 >> 18) & 0x1);
    zeros_as_ones_ = ((data1 >> 19) & 0x1);
    zeros_as_ones_pos_ = ((data1 >> 20) & 0x1f);
    mul_2_[0] = ((data1 >> 25) & 0x1);
    mul_2_[1] = ((data1 >> 26) & 0x1);
    mul_2_[2] = ((data1 >> 27) & 0x1);
    mul_2_[3] = ((data1 >> 28) & 0x1);
    mul_2_[4] = ((data1 >> 29) & 0x1);
    mul_2_[5] = ((data1 >> 30) & 0x1);
    mul_2_[6] = ((data1 >> 31) & 0x1);
    mul_2_[7] = ((data1 >> 32) & 0x1);
    mul_2_[8] = ((data1 >> 33) & 0x1);
    mul_2_[9] = ((data1 >> 34) & 0x1);
    mul_2_[10] = ((data1 >> 35) & 0x1);
    mul_2_[11] = ((data1 >> 36) & 0x1);
    mul_2_[12] = ((data1 >> 37) & 0x1);
    mul_2_[13] = ((data1 >> 38) & 0x1);
    mul_2_[14] = ((data1 >> 39) & 0x1);
    mul_2_[15] = ((data1 >> 40) & 0x1);
    mul_2_[16] = ((data1 >> 41) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    swap_[0] = 0;
    swap_[1] = 0;
    swap_[2] = 0;
    swap_[3] = 0;
    swap_[4] = 0;
    swap_[5] = 0;
    swap_[6] = 0;
    swap_[7] = 0;
    swap_[8] = 0;
    swap_[9] = 0;
    swap_[10] = 0;
    swap_[11] = 0;
    swap_[12] = 0;
    swap_[13] = 0;
    swap_[14] = 0;
    swap_[15] = 0;
    swap_[16] = 0;
    shr_ = 0;
    mask_[0] = 0;
    mask_[1] = 0;
    mask_[2] = 0;
    mask_[3] = 0;
    mask_[4] = 0;
    mask_[5] = 0;
    mask_[6] = 0;
    mask_[7] = 0;
    mask_[8] = 0;
    mask_[9] = 0;
    mask_[10] = 0;
    mask_[11] = 0;
    mask_[12] = 0;
    mask_[13] = 0;
    mask_[14] = 0;
    mask_[15] = 0;
    mask_[16] = 0;
    mask_[17] = 0;
    mask_[18] = 0;
    mask_[19] = 0;
    mask_[20] = 0;
    mask_[21] = 0;
    mask_[22] = 0;
    mask_[23] = 0;
    mask_[24] = 0;
    mask_[25] = 0;
    mask_[26] = 0;
    mask_[27] = 0;
    mask_[28] = 0;
    mask_[29] = 0;
    mask_[30] = 0;
    mask_[31] = 0;
    dst_bit_hdr_end_pos_ = 0;
    dst_ = 0;
    hdr_end_ = 0;
    type_ = 0;
    start_ = 0;
    zeros_as_ones_ = 0;
    zeros_as_ones_pos_ = 0;
    mul_2_[0] = 0;
    mul_2_[1] = 0;
    mul_2_[2] = 0;
    mul_2_[3] = 0;
    mul_2_[4] = 0;
    mul_2_[5] = 0;
    mul_2_[6] = 0;
    mul_2_[7] = 0;
    mul_2_[8] = 0;
    mul_2_[9] = 0;
    mul_2_[10] = 0;
    mul_2_[11] = 0;
    mul_2_[12] = 0;
    mul_2_[13] = 0;
    mul_2_[14] = 0;
    mul_2_[15] = 0;
    mul_2_[16] = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRow") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRow") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t add_;
  std::array< uint8_t, 17 > swap_;
  uint8_t shr_;
  std::array< uint8_t, 32 > mask_;
  uint8_t dst_bit_hdr_end_pos_;
  uint8_t dst_;
  uint8_t hdr_end_;
  uint8_t type_;
  uint8_t start_;
  uint8_t zeros_as_ones_;
  uint8_t zeros_as_ones_pos_;
  std::array< uint8_t, 17 > mul_2_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class PrsrPoCsumCtrlRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, index_prsr_po_csum_ctrl_row), 1, true, write_callback, read_callback, std::string("PrsrPoCsumCtrlRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_csum_ctrl_row))
    {
    }
  PrsrPoCsumCtrlRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrPoCsumCtrlRowMutable")
    {
    }
public:





  uint16_t add() { return add_; }
  void add(const uint16_t &v) { add_=v; }







  uint8_t swap(int j0) { return swap_[j0]; }
  void swap(int j0,const uint8_t &v) { swap_[j0]=v; }






  uint8_t shr() { return shr_; }
  void shr(const uint8_t &v) { shr_=v; }







  uint8_t mask(int j0) { return mask_[j0]; }
  void mask(int j0,const uint8_t &v) { mask_[j0]=v; }






  uint8_t dst_bit_hdr_end_pos() { return dst_bit_hdr_end_pos_; }
  void dst_bit_hdr_end_pos(const uint8_t &v) { dst_bit_hdr_end_pos_=v; }






  uint8_t dst() { return dst_; }
  void dst(const uint8_t &v) { dst_=v; }







  uint8_t hdr_end() { return hdr_end_; }
  void hdr_end(const uint8_t &v) { hdr_end_=v; }







  uint8_t type() { return type_; }
  void type(const uint8_t &v) { type_=v; }





  uint8_t start() { return start_; }
  void start(const uint8_t &v) { start_=v; }







  uint8_t zeros_as_ones() { return zeros_as_ones_; }
  void zeros_as_ones(const uint8_t &v) { zeros_as_ones_=v; }






  uint8_t zeros_as_ones_pos() { return zeros_as_ones_pos_; }
  void zeros_as_ones_pos(const uint8_t &v) { zeros_as_ones_pos_=v; }







  uint8_t mul_2(int j0) { return mul_2_[j0]; }
  void mul_2(int j0,const uint8_t &v) { mul_2_[j0]=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= ((static_cast<uint64_t>(swap_[0]) & 0x1) << 16);
    *data0 |= ((static_cast<uint64_t>(swap_[1]) & 0x1) << 17);
    *data0 |= ((static_cast<uint64_t>(swap_[2]) & 0x1) << 18);
    *data0 |= ((static_cast<uint64_t>(swap_[3]) & 0x1) << 19);
    *data0 |= ((static_cast<uint64_t>(swap_[4]) & 0x1) << 20);
    *data0 |= ((static_cast<uint64_t>(swap_[5]) & 0x1) << 21);
    *data0 |= ((static_cast<uint64_t>(swap_[6]) & 0x1) << 22);
    *data0 |= ((static_cast<uint64_t>(swap_[7]) & 0x1) << 23);
    *data0 |= ((static_cast<uint64_t>(swap_[8]) & 0x1) << 24);
    *data0 |= ((static_cast<uint64_t>(swap_[9]) & 0x1) << 25);
    *data0 |= ((static_cast<uint64_t>(swap_[10]) & 0x1) << 26);
    *data0 |= ((static_cast<uint64_t>(swap_[11]) & 0x1) << 27);
    *data0 |= ((static_cast<uint64_t>(swap_[12]) & 0x1) << 28);
    *data0 |= ((static_cast<uint64_t>(swap_[13]) & 0x1) << 29);
    *data0 |= ((static_cast<uint64_t>(swap_[14]) & 0x1) << 30);
    *data0 |= ((static_cast<uint64_t>(swap_[15]) & 0x1) << 31);
    *data0 |= ((static_cast<uint64_t>(swap_[16]) & 0x1) << 32);
    *data0 |= ((static_cast<uint64_t>(shr_) & 0x1) << 33);
    *data0 |= ((static_cast<uint64_t>(mask_[0]) & 0x1) << 34);
    *data0 |= ((static_cast<uint64_t>(mask_[1]) & 0x1) << 35);
    *data0 |= ((static_cast<uint64_t>(mask_[2]) & 0x1) << 36);
    *data0 |= ((static_cast<uint64_t>(mask_[3]) & 0x1) << 37);
    *data0 |= ((static_cast<uint64_t>(mask_[4]) & 0x1) << 38);
    *data0 |= ((static_cast<uint64_t>(mask_[5]) & 0x1) << 39);
    *data0 |= ((static_cast<uint64_t>(mask_[6]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(mask_[7]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(mask_[8]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(mask_[9]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(mask_[10]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(mask_[11]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(mask_[12]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(mask_[13]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(mask_[14]) & 0x1) << 48);
    *data0 |= ((static_cast<uint64_t>(mask_[15]) & 0x1) << 49);
    *data0 |= ((static_cast<uint64_t>(mask_[16]) & 0x1) << 50);
    *data0 |= ((static_cast<uint64_t>(mask_[17]) & 0x1) << 51);
    *data0 |= ((static_cast<uint64_t>(mask_[18]) & 0x1) << 52);
    *data0 |= ((static_cast<uint64_t>(mask_[19]) & 0x1) << 53);
    *data0 |= ((static_cast<uint64_t>(mask_[20]) & 0x1) << 54);
    *data0 |= ((static_cast<uint64_t>(mask_[21]) & 0x1) << 55);
    *data0 |= ((static_cast<uint64_t>(mask_[22]) & 0x1) << 56);
    *data0 |= ((static_cast<uint64_t>(mask_[23]) & 0x1) << 57);
    *data0 |= ((static_cast<uint64_t>(mask_[24]) & 0x1) << 58);
    *data0 |= ((static_cast<uint64_t>(mask_[25]) & 0x1) << 59);
    *data0 |= ((static_cast<uint64_t>(mask_[26]) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(mask_[27]) & 0x1) << 61);
    *data0 |= ((static_cast<uint64_t>(mask_[28]) & 0x1) << 62);
    *data0 |= ((static_cast<uint64_t>(mask_[29]) & 0x1) << 63);
    *data1 = (static_cast<uint64_t>(mask_[30]) & 0x1);
    *data1 |= ((static_cast<uint64_t>(mask_[31]) & 0x1) << 1);
    *data1 |= ((static_cast<uint64_t>(dst_bit_hdr_end_pos_) & 0x1f) << 2);
    *data1 |= (static_cast<uint64_t>(dst_) << 7);
    *data1 |= ((static_cast<uint64_t>(hdr_end_) & 0x1) << 15);
    *data1 |= ((static_cast<uint64_t>(type_) & 0x3) << 16);
    *data1 |= ((static_cast<uint64_t>(start_) & 0x1) << 18);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_) & 0x1) << 19);
    *data1 |= ((static_cast<uint64_t>(zeros_as_ones_pos_) & 0x1f) << 20);
    *data1 |= ((static_cast<uint64_t>(mul_2_[0]) & 0x1) << 25);
    *data1 |= ((static_cast<uint64_t>(mul_2_[1]) & 0x1) << 26);
    *data1 |= ((static_cast<uint64_t>(mul_2_[2]) & 0x1) << 27);
    *data1 |= ((static_cast<uint64_t>(mul_2_[3]) & 0x1) << 28);
    *data1 |= ((static_cast<uint64_t>(mul_2_[4]) & 0x1) << 29);
    *data1 |= ((static_cast<uint64_t>(mul_2_[5]) & 0x1) << 30);
    *data1 |= ((static_cast<uint64_t>(mul_2_[6]) & 0x1) << 31);
    *data1 |= ((static_cast<uint64_t>(mul_2_[7]) & 0x1) << 32);
    *data1 |= ((static_cast<uint64_t>(mul_2_[8]) & 0x1) << 33);
    *data1 |= ((static_cast<uint64_t>(mul_2_[9]) & 0x1) << 34);
    *data1 |= ((static_cast<uint64_t>(mul_2_[10]) & 0x1) << 35);
    *data1 |= ((static_cast<uint64_t>(mul_2_[11]) & 0x1) << 36);
    *data1 |= ((static_cast<uint64_t>(mul_2_[12]) & 0x1) << 37);
    *data1 |= ((static_cast<uint64_t>(mul_2_[13]) & 0x1) << 38);
    *data1 |= ((static_cast<uint64_t>(mul_2_[14]) & 0x1) << 39);
    *data1 |= ((static_cast<uint64_t>(mul_2_[15]) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(mul_2_[16]) & 0x1) << 41);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    swap_[0] = ((data0 >> 16) & 0x1);
    swap_[1] = ((data0 >> 17) & 0x1);
    swap_[2] = ((data0 >> 18) & 0x1);
    swap_[3] = ((data0 >> 19) & 0x1);
    swap_[4] = ((data0 >> 20) & 0x1);
    swap_[5] = ((data0 >> 21) & 0x1);
    swap_[6] = ((data0 >> 22) & 0x1);
    swap_[7] = ((data0 >> 23) & 0x1);
    swap_[8] = ((data0 >> 24) & 0x1);
    swap_[9] = ((data0 >> 25) & 0x1);
    swap_[10] = ((data0 >> 26) & 0x1);
    swap_[11] = ((data0 >> 27) & 0x1);
    swap_[12] = ((data0 >> 28) & 0x1);
    swap_[13] = ((data0 >> 29) & 0x1);
    swap_[14] = ((data0 >> 30) & 0x1);
    swap_[15] = ((data0 >> 31) & 0x1);
    swap_[16] = ((data0 >> 32) & 0x1);
    shr_ = ((data0 >> 33) & 0x1);
    mask_[0] = ((data0 >> 34) & 0x1);
    mask_[1] = ((data0 >> 35) & 0x1);
    mask_[2] = ((data0 >> 36) & 0x1);
    mask_[3] = ((data0 >> 37) & 0x1);
    mask_[4] = ((data0 >> 38) & 0x1);
    mask_[5] = ((data0 >> 39) & 0x1);
    mask_[6] = ((data0 >> 40) & 0x1);
    mask_[7] = ((data0 >> 41) & 0x1);
    mask_[8] = ((data0 >> 42) & 0x1);
    mask_[9] = ((data0 >> 43) & 0x1);
    mask_[10] = ((data0 >> 44) & 0x1);
    mask_[11] = ((data0 >> 45) & 0x1);
    mask_[12] = ((data0 >> 46) & 0x1);
    mask_[13] = ((data0 >> 47) & 0x1);
    mask_[14] = ((data0 >> 48) & 0x1);
    mask_[15] = ((data0 >> 49) & 0x1);
    mask_[16] = ((data0 >> 50) & 0x1);
    mask_[17] = ((data0 >> 51) & 0x1);
    mask_[18] = ((data0 >> 52) & 0x1);
    mask_[19] = ((data0 >> 53) & 0x1);
    mask_[20] = ((data0 >> 54) & 0x1);
    mask_[21] = ((data0 >> 55) & 0x1);
    mask_[22] = ((data0 >> 56) & 0x1);
    mask_[23] = ((data0 >> 57) & 0x1);
    mask_[24] = ((data0 >> 58) & 0x1);
    mask_[25] = ((data0 >> 59) & 0x1);
    mask_[26] = ((data0 >> 60) & 0x1);
    mask_[27] = ((data0 >> 61) & 0x1);
    mask_[28] = ((data0 >> 62) & 0x1);
    mask_[29] = ((data0 >> 63) & 0x1);
    mask_[30] = (data1 & 0x1);
    mask_[31] = ((data1 >> 1) & 0x1);
    dst_bit_hdr_end_pos_ = ((data1 >> 2) & 0x1f);
    dst_ = (data1 >> 7);
    hdr_end_ = ((data1 >> 15) & 0x1);
    type_ = ((data1 >> 16) & 0x3);
    start_ = ((data1 >> 18) & 0x1);
    zeros_as_ones_ = ((data1 >> 19) & 0x1);
    zeros_as_ones_pos_ = ((data1 >> 20) & 0x1f);
    mul_2_[0] = ((data1 >> 25) & 0x1);
    mul_2_[1] = ((data1 >> 26) & 0x1);
    mul_2_[2] = ((data1 >> 27) & 0x1);
    mul_2_[3] = ((data1 >> 28) & 0x1);
    mul_2_[4] = ((data1 >> 29) & 0x1);
    mul_2_[5] = ((data1 >> 30) & 0x1);
    mul_2_[6] = ((data1 >> 31) & 0x1);
    mul_2_[7] = ((data1 >> 32) & 0x1);
    mul_2_[8] = ((data1 >> 33) & 0x1);
    mul_2_[9] = ((data1 >> 34) & 0x1);
    mul_2_[10] = ((data1 >> 35) & 0x1);
    mul_2_[11] = ((data1 >> 36) & 0x1);
    mul_2_[12] = ((data1 >> 37) & 0x1);
    mul_2_[13] = ((data1 >> 38) & 0x1);
    mul_2_[14] = ((data1 >> 39) & 0x1);
    mul_2_[15] = ((data1 >> 40) & 0x1);
    mul_2_[16] = ((data1 >> 41) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    swap_[0] = 0;
    swap_[1] = 0;
    swap_[2] = 0;
    swap_[3] = 0;
    swap_[4] = 0;
    swap_[5] = 0;
    swap_[6] = 0;
    swap_[7] = 0;
    swap_[8] = 0;
    swap_[9] = 0;
    swap_[10] = 0;
    swap_[11] = 0;
    swap_[12] = 0;
    swap_[13] = 0;
    swap_[14] = 0;
    swap_[15] = 0;
    swap_[16] = 0;
    shr_ = 0;
    mask_[0] = 0;
    mask_[1] = 0;
    mask_[2] = 0;
    mask_[3] = 0;
    mask_[4] = 0;
    mask_[5] = 0;
    mask_[6] = 0;
    mask_[7] = 0;
    mask_[8] = 0;
    mask_[9] = 0;
    mask_[10] = 0;
    mask_[11] = 0;
    mask_[12] = 0;
    mask_[13] = 0;
    mask_[14] = 0;
    mask_[15] = 0;
    mask_[16] = 0;
    mask_[17] = 0;
    mask_[18] = 0;
    mask_[19] = 0;
    mask_[20] = 0;
    mask_[21] = 0;
    mask_[22] = 0;
    mask_[23] = 0;
    mask_[24] = 0;
    mask_[25] = 0;
    mask_[26] = 0;
    mask_[27] = 0;
    mask_[28] = 0;
    mask_[29] = 0;
    mask_[30] = 0;
    mask_[31] = 0;
    dst_bit_hdr_end_pos_ = 0;
    dst_ = 0;
    hdr_end_ = 0;
    type_ = 0;
    start_ = 0;
    zeros_as_ones_ = 0;
    zeros_as_ones_pos_ = 0;
    mul_2_[0] = 0;
    mul_2_[1] = 0;
    mul_2_[2] = 0;
    mul_2_[3] = 0;
    mul_2_[4] = 0;
    mul_2_[5] = 0;
    mul_2_[6] = 0;
    mul_2_[7] = 0;
    mul_2_[8] = 0;
    mul_2_[9] = 0;
    mul_2_[10] = 0;
    mul_2_[11] = 0;
    mul_2_[12] = 0;
    mul_2_[13] = 0;
    mul_2_[14] = 0;
    mul_2_[15] = 0;
    mul_2_[16] = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRowMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoCsumCtrlRowMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("swap") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(swap_[f]) ) + "\n";
      all_zeros &= (0 == swap_[f]);
    }
    r += indent_string + "  " + std::string("shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shr_) ) + "\n";
    all_zeros &= (0 == shr_);
    for (uint32_t f=0;f<32;++f) {
      r += indent_string + "  " + std::string("mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_[f]) ) + "\n";
      all_zeros &= (0 == mask_[f]);
    }
    r += indent_string + "  " + std::string("dst_bit_hdr_end_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_bit_hdr_end_pos_) ) + "\n";
    all_zeros &= (0 == dst_bit_hdr_end_pos_);
    r += indent_string + "  " + std::string("dst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_) ) + "\n";
    all_zeros &= (0 == dst_);
    r += indent_string + "  " + std::string("hdr_end") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_end_) ) + "\n";
    all_zeros &= (0 == hdr_end_);
    r += indent_string + "  " + std::string("type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(type_) ) + "\n";
    all_zeros &= (0 == type_);
    r += indent_string + "  " + std::string("start") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(start_) ) + "\n";
    all_zeros &= (0 == start_);
    r += indent_string + "  " + std::string("zeros_as_ones") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_);
    r += indent_string + "  " + std::string("zeros_as_ones_pos") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(zeros_as_ones_pos_) ) + "\n";
    all_zeros &= (0 == zeros_as_ones_pos_);
    for (uint32_t f=0;f<17;++f) {
      r += indent_string + "  " + std::string("mul_2") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mul_2_[f]) ) + "\n";
      all_zeros &= (0 == mul_2_[f]);
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint16_t add_;
  std::array< uint8_t, 17 > swap_;
  uint8_t shr_;
  std::array< uint8_t, 32 > mask_;
  uint8_t dst_bit_hdr_end_pos_;
  uint8_t dst_;
  uint8_t hdr_end_;
  uint8_t type_;
  uint8_t start_;
  uint8_t zeros_as_ones_;
  uint8_t zeros_as_ones_pos_;
  std::array< uint8_t, 17 > mul_2_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int index_prsr_po_csum_ctrl_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            assert(index_prsr_po_csum_ctrl_row < 32);
            offset += index_prsr_po_csum_ctrl_row * 0x1; // prsr_po_csum_ctrl_row[]
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class PrsrPoCsumCtrlRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrPoCsumCtrlRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint16_t &add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }







  uint8_t &swap(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].swap(j0);
  }






  uint8_t &shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr();
  }







  uint8_t &mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask(j0);
  }






  uint8_t &dst_bit_hdr_end_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_bit_hdr_end_pos();
  }






  uint8_t &dst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst();
  }







  uint8_t &hdr_end(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_end();
  }







  uint8_t &type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].type();
  }





  uint8_t &start(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].start();
  }







  uint8_t &zeros_as_ones(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones();
  }






  uint8_t &zeros_as_ones_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones_pos();
  }







  uint8_t &mul_2(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mul_2(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoCsumCtrlRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoCsumCtrlRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoCsumCtrlRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};







class PrsrPoCsumCtrlRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
  enum PrsrMemMainRspecEnum {
    kPoCsumCtrl_0Row,
    kPoCsumCtrl_1Row,
    kPoCsumCtrl_2Row,
    kPoCsumCtrl_3Row,
    kPoCsumCtrl_4Row
  };
public:
  PrsrPoCsumCtrlRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrPoCsumCtrlRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(selector_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, selector_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint16_t add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }
  void add(uint32_t a0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].add(v);
  }







  uint8_t swap(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].swap(j0);
  }
  void swap(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].swap(j0,v);
  }






  uint8_t shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shr();
  }
  void shr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].shr(v);
  }







  uint8_t mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask(j0);
  }
  void mask(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mask(j0,v);
  }






  uint8_t dst_bit_hdr_end_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_bit_hdr_end_pos();
  }
  void dst_bit_hdr_end_pos(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst_bit_hdr_end_pos(v);
  }






  uint8_t dst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst();
  }
  void dst(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst(v);
  }







  uint8_t hdr_end(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_end();
  }
  void hdr_end(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].hdr_end(v);
  }







  uint8_t type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].type();
  }
  void type(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].type(v);
  }





  uint8_t start(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].start();
  }
  void start(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].start(v);
  }







  uint8_t zeros_as_ones(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones();
  }
  void zeros_as_ones(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].zeros_as_ones(v);
  }






  uint8_t zeros_as_ones_pos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].zeros_as_ones_pos();
  }
  void zeros_as_ones_pos(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].zeros_as_ones_pos(v);
  }







  uint8_t mul_2(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mul_2(j0);
  }
  void mul_2(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mul_2(j0,v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoCsumCtrlRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoCsumCtrlRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoCsumCtrlRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            offset += 0x620; // to get to po_csum_ctrl_0_row
            break;
          case kPoCsumCtrl_1Row:
            offset += 0x640; // to get to po_csum_ctrl_1_row
            break;
          case kPoCsumCtrl_2Row:
            offset += 0x660; // to get to po_csum_ctrl_2_row
            break;
          case kPoCsumCtrl_3Row:
            offset += 0x680; // to get to po_csum_ctrl_3_row
            break;
          case kPoCsumCtrl_4Row:
            offset += 0x6a0; // to get to po_csum_ctrl_4_row
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, PrsrMemMainRspecEnum selector_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (selector_prsr_mem_main_rspec) {
          case kPoCsumCtrl_0Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_1Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_2Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_3Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          case kPoCsumCtrl_4Row:
            switch (dimension) {
              case -1:
                return 32;
                break;
              case 0:
                return 32;
                break;
              default:
                assert(0);
                break;
            }
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlCtrInitRamM : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamM(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ctr_init_ram_m), 1, false, write_callback, read_callback, std::string("PrsrMlCtrInitRamM")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ctr_init_ram_m))
    {
    }
  PrsrMlCtrInitRamM(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMlCtrInitRamM")
    {
    }
public:





  uint8_t &add() { return add_; }





  uint8_t &mask_8() { return mask_8_; }





  uint8_t &rotate() { return rotate_; }





  uint8_t &max() { return max_; }





  uint8_t &src() { return src_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= (static_cast<uint64_t>(mask_8_) << 8);
    *data0 |= ((static_cast<uint64_t>(rotate_) & 0x7) << 16);
    *data0 |= (static_cast<uint64_t>(max_) << 19);
    *data0 |= ((static_cast<uint64_t>(src_) & 0x3) << 27);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    mask_8_ = (data0 >> 8);
    rotate_ = ((data0 >> 16) & 0x7);
    max_ = (data0 >> 19);
    src_ = ((data0 >> 27) & 0x3);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    mask_8_ = 0;
    rotate_ = 0;
    max_ = 0;
    src_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamM") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamM") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t add_;
  uint8_t mask_8_;
  uint8_t rotate_;
  uint8_t max_;
  uint8_t src_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlCtrInitRamMMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamMMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ctr_init_ram_m), 1, true, write_callback, read_callback, std::string("PrsrMlCtrInitRamMMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ctr_init_ram_m))
    {
    }
  PrsrMlCtrInitRamMMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMlCtrInitRamMMutable")
    {
    }
public:





  uint8_t add() { return add_; }
  void add(const uint8_t &v) { add_=v; }





  uint8_t mask_8() { return mask_8_; }
  void mask_8(const uint8_t &v) { mask_8_=v; }





  uint8_t rotate() { return rotate_; }
  void rotate(const uint8_t &v) { rotate_=v; }





  uint8_t max() { return max_; }
  void max(const uint8_t &v) { max_=v; }





  uint8_t src() { return src_; }
  void src(const uint8_t &v) { src_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(add_);
    *data0 |= (static_cast<uint64_t>(mask_8_) << 8);
    *data0 |= ((static_cast<uint64_t>(rotate_) & 0x7) << 16);
    *data0 |= (static_cast<uint64_t>(max_) << 19);
    *data0 |= ((static_cast<uint64_t>(src_) & 0x3) << 27);
    *data1 = 0;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    add_ = data0;
    mask_8_ = (data0 >> 8);
    rotate_ = ((data0 >> 16) & 0x7);
    max_ = (data0 >> 19);
    src_ = ((data0 >> 27) & 0x3);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    add_ = 0;
    mask_8_ = 0;
    rotate_ = 0;
    max_ = 0;
    src_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamMMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlCtrInitRamMMutable") + ":\n";
    r += indent_string + "  " + std::string("add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(add_) ) + "\n";
    all_zeros &= (0 == add_);
    r += indent_string + "  " + std::string("mask_8") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(mask_8_) ) + "\n";
    all_zeros &= (0 == mask_8_);
    r += indent_string + "  " + std::string("rotate") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rotate_) ) + "\n";
    all_zeros &= (0 == rotate_);
    r += indent_string + "  " + std::string("max") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(max_) ) + "\n";
    all_zeros &= (0 == max_);
    r += indent_string + "  " + std::string("src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(src_) ) + "\n";
    all_zeros &= (0 == src_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t add_;
  uint8_t mask_8_;
  uint8_t rotate_;
  uint8_t max_;
  uint8_t src_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ctr_init_ram_m
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        assert(index_prsr_ml_ctr_init_ram_m < 16);
        offset += index_prsr_ml_ctr_init_ram_m * 0x1; // prsr_ml_ctr_init_ram_m[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlCtrInitRamMArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamMArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrMlCtrInitRamMArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint8_t &add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }





  uint8_t &mask_8(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask_8();
  }





  uint8_t &rotate(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rotate();
  }





  uint8_t &max(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].max();
  }





  uint8_t &src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].src();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlCtrInitRamMArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlCtrInitRamMArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlCtrInitRamM> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlCtrInitRamMArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlCtrInitRamMArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrMlCtrInitRamMArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:





  uint8_t add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].add();
  }
  void add(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].add(v);
  }





  uint8_t mask_8(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mask_8();
  }
  void mask_8(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].mask_8(v);
  }





  uint8_t rotate(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].rotate();
  }
  void rotate(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].rotate(v);
  }





  uint8_t max(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].max();
  }
  void max(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].max(v);
  }





  uint8_t src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].src();
  }
  void src(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].src(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlCtrInitRamMArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlCtrInitRamMArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlCtrInitRamMMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x600; // to get to ml_ctr_init_ram
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 16;
            break;
          case 0:
            return 16;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlEaRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ea_row), 1, false, write_callback, read_callback, std::string("PrsrMlEaRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ea_row))
    {
    }
  PrsrMlEaRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMlEaRow")
    {
    }
public:




  uint8_t &nxt_state() { return nxt_state_; }





  uint8_t &nxt_state_mask() { return nxt_state_mask_; }








  uint8_t &lookup_offset_8(int j0) { return lookup_offset_8_[j0]; }






  uint8_t &ld_lookup_8(int j0) { return ld_lookup_8_[j0]; }






  uint8_t &sv_lookup_8(int j0) { return sv_lookup_8_[j0]; }





  uint8_t &shift_amt() { return shift_amt_; }






  uint8_t &buf_req() { return buf_req_; }






  uint8_t &done() { return done_; }





  uint8_t &ctr_op() { return ctr_op_; }





  uint8_t &ctr_amt_idx() { return ctr_amt_idx_; }






  uint8_t &ctr_stack_push() { return ctr_stack_push_; }






  uint8_t &ctr_stack_upd_w_top() { return ctr_stack_upd_w_top_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(nxt_state_);
    *data0 |= (static_cast<uint64_t>(nxt_state_mask_) << 8);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[0]) & 0x3f) << 16);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[1]) & 0x3f) << 22);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[2]) & 0x3f) << 28);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[3]) & 0x3f) << 34);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[0]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[1]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[2]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[3]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[0]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[1]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[2]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[3]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(shift_amt_) & 0x3f) << 48);
    *data0 |= ((static_cast<uint64_t>(buf_req_) & 0x3f) << 54);
    *data0 |= ((static_cast<uint64_t>(done_) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(ctr_op_) & 0x3) << 61);
    *data0 |= ((static_cast<uint64_t>(ctr_amt_idx_) & 0x1) << 63);
    *data1 = ((static_cast<uint64_t>(ctr_amt_idx_) & 0xfe) >> 1);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_push_) & 0x1) << 7);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_upd_w_top_) & 0x1) << 8);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    nxt_state_ = data0;
    nxt_state_mask_ = (data0 >> 8);
    lookup_offset_8_[0] = ((data0 >> 16) & 0x3f);
    lookup_offset_8_[1] = ((data0 >> 22) & 0x3f);
    lookup_offset_8_[2] = ((data0 >> 28) & 0x3f);
    lookup_offset_8_[3] = ((data0 >> 34) & 0x3f);
    ld_lookup_8_[0] = ((data0 >> 40) & 0x1);
    ld_lookup_8_[1] = ((data0 >> 41) & 0x1);
    ld_lookup_8_[2] = ((data0 >> 42) & 0x1);
    ld_lookup_8_[3] = ((data0 >> 43) & 0x1);
    sv_lookup_8_[0] = ((data0 >> 44) & 0x1);
    sv_lookup_8_[1] = ((data0 >> 45) & 0x1);
    sv_lookup_8_[2] = ((data0 >> 46) & 0x1);
    sv_lookup_8_[3] = ((data0 >> 47) & 0x1);
    shift_amt_ = ((data0 >> 48) & 0x3f);
    buf_req_ = ((data0 >> 54) & 0x3f);
    done_ = ((data0 >> 60) & 0x1);
    ctr_op_ = ((data0 >> 61) & 0x3);
    ctr_amt_idx_ = (((data0 >> 63) & 0x1) | (ctr_amt_idx_ & 0xfe));
    ctr_amt_idx_ = (((data1 << 1) & 0xfe) | (ctr_amt_idx_ & 0x1));
    ctr_stack_push_ = ((data1 >> 7) & 0x1);
    ctr_stack_upd_w_top_ = ((data1 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    nxt_state_ = 0;
    nxt_state_mask_ = 0;
    lookup_offset_8_[0] = 0x0;
    lookup_offset_8_[1] = 0x0;
    lookup_offset_8_[2] = 0x0;
    lookup_offset_8_[3] = 0x0;
    ld_lookup_8_[0] = 0;
    ld_lookup_8_[1] = 0;
    ld_lookup_8_[2] = 0;
    ld_lookup_8_[3] = 0;
    sv_lookup_8_[0] = 0;
    sv_lookup_8_[1] = 0;
    sv_lookup_8_[2] = 0;
    sv_lookup_8_[3] = 0;
    shift_amt_ = 0;
    buf_req_ = 0;
    done_ = 0;
    ctr_op_ = 0;
    ctr_amt_idx_ = 0;
    ctr_stack_push_ = 0;
    ctr_stack_upd_w_top_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRow") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRow") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t nxt_state_;
  uint8_t nxt_state_mask_;
  std::array< uint8_t, 4 > lookup_offset_8_;
  std::array< uint8_t, 4 > ld_lookup_8_;
  std::array< uint8_t, 4 > sv_lookup_8_;
  uint8_t shift_amt_;
  uint8_t buf_req_;
  uint8_t done_;
  uint8_t ctr_op_;
  uint8_t ctr_amt_idx_;
  uint8_t ctr_stack_push_;
  uint8_t ctr_stack_upd_w_top_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlEaRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_ea_row), 1, true, write_callback, read_callback, std::string("PrsrMlEaRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_ea_row))
    {
    }
  PrsrMlEaRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMlEaRowMutable")
    {
    }
public:




  uint8_t nxt_state() { return nxt_state_; }
  void nxt_state(const uint8_t &v) { nxt_state_=v; }





  uint8_t nxt_state_mask() { return nxt_state_mask_; }
  void nxt_state_mask(const uint8_t &v) { nxt_state_mask_=v; }








  uint8_t lookup_offset_8(int j0) { return lookup_offset_8_[j0]; }
  void lookup_offset_8(int j0,const uint8_t &v) { lookup_offset_8_[j0]=v; }






  uint8_t ld_lookup_8(int j0) { return ld_lookup_8_[j0]; }
  void ld_lookup_8(int j0,const uint8_t &v) { ld_lookup_8_[j0]=v; }






  uint8_t sv_lookup_8(int j0) { return sv_lookup_8_[j0]; }
  void sv_lookup_8(int j0,const uint8_t &v) { sv_lookup_8_[j0]=v; }





  uint8_t shift_amt() { return shift_amt_; }
  void shift_amt(const uint8_t &v) { shift_amt_=v; }






  uint8_t buf_req() { return buf_req_; }
  void buf_req(const uint8_t &v) { buf_req_=v; }






  uint8_t done() { return done_; }
  void done(const uint8_t &v) { done_=v; }





  uint8_t ctr_op() { return ctr_op_; }
  void ctr_op(const uint8_t &v) { ctr_op_=v; }





  uint8_t ctr_amt_idx() { return ctr_amt_idx_; }
  void ctr_amt_idx(const uint8_t &v) { ctr_amt_idx_=v; }






  uint8_t ctr_stack_push() { return ctr_stack_push_; }
  void ctr_stack_push(const uint8_t &v) { ctr_stack_push_=v; }






  uint8_t ctr_stack_upd_w_top() { return ctr_stack_upd_w_top_; }
  void ctr_stack_upd_w_top(const uint8_t &v) { ctr_stack_upd_w_top_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(nxt_state_);
    *data0 |= (static_cast<uint64_t>(nxt_state_mask_) << 8);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[0]) & 0x3f) << 16);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[1]) & 0x3f) << 22);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[2]) & 0x3f) << 28);
    *data0 |= ((static_cast<uint64_t>(lookup_offset_8_[3]) & 0x3f) << 34);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[0]) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[1]) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[2]) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(ld_lookup_8_[3]) & 0x1) << 43);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[0]) & 0x1) << 44);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[1]) & 0x1) << 45);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[2]) & 0x1) << 46);
    *data0 |= ((static_cast<uint64_t>(sv_lookup_8_[3]) & 0x1) << 47);
    *data0 |= ((static_cast<uint64_t>(shift_amt_) & 0x3f) << 48);
    *data0 |= ((static_cast<uint64_t>(buf_req_) & 0x3f) << 54);
    *data0 |= ((static_cast<uint64_t>(done_) & 0x1) << 60);
    *data0 |= ((static_cast<uint64_t>(ctr_op_) & 0x3) << 61);
    *data0 |= ((static_cast<uint64_t>(ctr_amt_idx_) & 0x1) << 63);
    *data1 = ((static_cast<uint64_t>(ctr_amt_idx_) & 0xfe) >> 1);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_push_) & 0x1) << 7);
    *data1 |= ((static_cast<uint64_t>(ctr_stack_upd_w_top_) & 0x1) << 8);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    nxt_state_ = data0;
    nxt_state_mask_ = (data0 >> 8);
    lookup_offset_8_[0] = ((data0 >> 16) & 0x3f);
    lookup_offset_8_[1] = ((data0 >> 22) & 0x3f);
    lookup_offset_8_[2] = ((data0 >> 28) & 0x3f);
    lookup_offset_8_[3] = ((data0 >> 34) & 0x3f);
    ld_lookup_8_[0] = ((data0 >> 40) & 0x1);
    ld_lookup_8_[1] = ((data0 >> 41) & 0x1);
    ld_lookup_8_[2] = ((data0 >> 42) & 0x1);
    ld_lookup_8_[3] = ((data0 >> 43) & 0x1);
    sv_lookup_8_[0] = ((data0 >> 44) & 0x1);
    sv_lookup_8_[1] = ((data0 >> 45) & 0x1);
    sv_lookup_8_[2] = ((data0 >> 46) & 0x1);
    sv_lookup_8_[3] = ((data0 >> 47) & 0x1);
    shift_amt_ = ((data0 >> 48) & 0x3f);
    buf_req_ = ((data0 >> 54) & 0x3f);
    done_ = ((data0 >> 60) & 0x1);
    ctr_op_ = ((data0 >> 61) & 0x3);
    ctr_amt_idx_ = (((data0 >> 63) & 0x1) | (ctr_amt_idx_ & 0xfe));
    ctr_amt_idx_ = (((data1 << 1) & 0xfe) | (ctr_amt_idx_ & 0x1));
    ctr_stack_push_ = ((data1 >> 7) & 0x1);
    ctr_stack_upd_w_top_ = ((data1 >> 8) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    nxt_state_ = 0;
    nxt_state_mask_ = 0;
    lookup_offset_8_[0] = 0x0;
    lookup_offset_8_[1] = 0x0;
    lookup_offset_8_[2] = 0x0;
    lookup_offset_8_[3] = 0x0;
    ld_lookup_8_[0] = 0;
    ld_lookup_8_[1] = 0;
    ld_lookup_8_[2] = 0;
    ld_lookup_8_[3] = 0;
    sv_lookup_8_[0] = 0;
    sv_lookup_8_[1] = 0;
    sv_lookup_8_[2] = 0;
    sv_lookup_8_[3] = 0;
    shift_amt_ = 0;
    buf_req_ = 0;
    done_ = 0;
    ctr_op_ = 0;
    ctr_amt_idx_ = 0;
    ctr_stack_push_ = 0;
    ctr_stack_upd_w_top_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRowMutable") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlEaRowMutable") + ":\n";
    r += indent_string + "  " + std::string("nxt_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_) ) + "\n";
    all_zeros &= (0 == nxt_state_);
    r += indent_string + "  " + std::string("nxt_state_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(nxt_state_mask_) ) + "\n";
    all_zeros &= (0 == nxt_state_mask_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("lookup_offset_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(lookup_offset_8_[f]) ) + "\n";
      all_zeros &= (0 == lookup_offset_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("ld_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ld_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == ld_lookup_8_[f]);
    }
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("sv_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(sv_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == sv_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("shift_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(shift_amt_) ) + "\n";
    all_zeros &= (0 == shift_amt_);
    r += indent_string + "  " + std::string("buf_req") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(buf_req_) ) + "\n";
    all_zeros &= (0 == buf_req_);
    r += indent_string + "  " + std::string("done") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(done_) ) + "\n";
    all_zeros &= (0 == done_);
    r += indent_string + "  " + std::string("ctr_op") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_op_) ) + "\n";
    all_zeros &= (0 == ctr_op_);
    r += indent_string + "  " + std::string("ctr_amt_idx") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_amt_idx_) ) + "\n";
    all_zeros &= (0 == ctr_amt_idx_);
    r += indent_string + "  " + std::string("ctr_stack_push") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_push_) ) + "\n";
    all_zeros &= (0 == ctr_stack_push_);
    r += indent_string + "  " + std::string("ctr_stack_upd_w_top") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ctr_stack_upd_w_top_) ) + "\n";
    all_zeros &= (0 == ctr_stack_upd_w_top_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t nxt_state_;
  uint8_t nxt_state_mask_;
  std::array< uint8_t, 4 > lookup_offset_8_;
  std::array< uint8_t, 4 > ld_lookup_8_;
  std::array< uint8_t, 4 > sv_lookup_8_;
  uint8_t shift_amt_;
  uint8_t buf_req_;
  uint8_t done_;
  uint8_t ctr_op_;
  uint8_t ctr_amt_idx_;
  uint8_t ctr_stack_push_;
  uint8_t ctr_stack_upd_w_top_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_ea_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        assert(index_prsr_ml_ea_row < 256);
        offset += index_prsr_ml_ea_row * 0x1; // prsr_ml_ea_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrMlEaRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrMlEaRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:




  uint8_t &nxt_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state();
  }





  uint8_t &nxt_state_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state_mask();
  }








  uint8_t &lookup_offset_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].lookup_offset_8(j0);
  }






  uint8_t &ld_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ld_lookup_8(j0);
  }






  uint8_t &sv_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].sv_lookup_8(j0);
  }





  uint8_t &shift_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shift_amt();
  }






  uint8_t &buf_req(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].buf_req();
  }






  uint8_t &done(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].done();
  }





  uint8_t &ctr_op(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_op();
  }





  uint8_t &ctr_amt_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_amt_idx();
  }






  uint8_t &ctr_stack_push(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_push();
  }






  uint8_t &ctr_stack_upd_w_top(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_upd_w_top();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlEaRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlEaRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlEaRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrMlEaRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlEaRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrMlEaRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:




  uint8_t nxt_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state();
  }
  void nxt_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].nxt_state(v);
  }





  uint8_t nxt_state_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].nxt_state_mask();
  }
  void nxt_state_mask(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].nxt_state_mask(v);
  }








  uint8_t lookup_offset_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].lookup_offset_8(j0);
  }
  void lookup_offset_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].lookup_offset_8(j0,v);
  }






  uint8_t ld_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ld_lookup_8(j0);
  }
  void ld_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ld_lookup_8(j0,v);
  }






  uint8_t sv_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].sv_lookup_8(j0);
  }
  void sv_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].sv_lookup_8(j0,v);
  }





  uint8_t shift_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].shift_amt();
  }
  void shift_amt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].shift_amt(v);
  }






  uint8_t buf_req(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].buf_req();
  }
  void buf_req(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].buf_req(v);
  }






  uint8_t done(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].done();
  }
  void done(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].done(v);
  }





  uint8_t ctr_op(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_op();
  }
  void ctr_op(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_op(v);
  }





  uint8_t ctr_amt_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_amt_idx();
  }
  void ctr_amt_idx(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_amt_idx(v);
  }






  uint8_t ctr_stack_push(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_push();
  }
  void ctr_stack_push(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_stack_push(v);
  }






  uint8_t ctr_stack_upd_w_top(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ctr_stack_upd_w_top();
  }
  void ctr_stack_upd_w_top(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ctr_stack_upd_w_top(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlEaRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlEaRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlEaRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x500; // to get to ml_ea_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PrsrMlTcamRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_tcam_row), 1, false, write_callback, read_callback, std::string("PrsrMlTcamRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_tcam_row))
    {
    }
  PrsrMlTcamRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMlTcamRow")
    {
    }
public:






  uint8_t &w0_lookup_8(int j0) { return w0_lookup_8_[j0]; }




  uint8_t &w0_curr_state() { return w0_curr_state_; }





  uint8_t &w0_ctr_zero() { return w0_ctr_zero_; }





  uint8_t &w0_ctr_neg() { return w0_ctr_neg_; }





  uint8_t &w0_ver_0() { return w0_ver_0_; }





  uint8_t &w0_ver_1() { return w0_ver_1_; }






  uint8_t &w1_lookup_8(int j0) { return w1_lookup_8_[j0]; }




  uint8_t &w1_curr_state() { return w1_curr_state_; }





  uint8_t &w1_ctr_zero() { return w1_ctr_zero_; }





  uint8_t &w1_ctr_neg() { return w1_ctr_neg_; }





  uint8_t &w1_ver_0() { return w1_ver_0_; }





  uint8_t &w1_ver_1() { return w1_ver_1_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(w0_lookup_8_[0]);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[1]) << 8);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[2]) << 16);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[3]) << 24);
    *data0 |= (static_cast<uint64_t>(w0_curr_state_) << 32);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_zero_) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_neg_) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(w0_ver_0_) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(w0_ver_1_) & 0x1) << 43);
    *data1 = static_cast<uint64_t>(w1_lookup_8_[0]);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[1]) << 8);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[2]) << 16);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[3]) << 24);
    *data1 |= (static_cast<uint64_t>(w1_curr_state_) << 32);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_zero_) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_neg_) & 0x1) << 41);
    *data1 |= ((static_cast<uint64_t>(w1_ver_0_) & 0x1) << 42);
    *data1 |= ((static_cast<uint64_t>(w1_ver_1_) & 0x1) << 43);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    w0_lookup_8_[0] = data0;
    w0_lookup_8_[1] = (data0 >> 8);
    w0_lookup_8_[2] = (data0 >> 16);
    w0_lookup_8_[3] = (data0 >> 24);
    w0_curr_state_ = (data0 >> 32);
    w0_ctr_zero_ = ((data0 >> 40) & 0x1);
    w0_ctr_neg_ = ((data0 >> 41) & 0x1);
    w0_ver_0_ = ((data0 >> 42) & 0x1);
    w0_ver_1_ = ((data0 >> 43) & 0x1);
    w1_lookup_8_[0] = data1;
    w1_lookup_8_[1] = (data1 >> 8);
    w1_lookup_8_[2] = (data1 >> 16);
    w1_lookup_8_[3] = (data1 >> 24);
    w1_curr_state_ = (data1 >> 32);
    w1_ctr_zero_ = ((data1 >> 40) & 0x1);
    w1_ctr_neg_ = ((data1 >> 41) & 0x1);
    w1_ver_0_ = ((data1 >> 42) & 0x1);
    w1_ver_1_ = ((data1 >> 43) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    w0_lookup_8_[0] = 0;
    w0_lookup_8_[1] = 0;
    w0_lookup_8_[2] = 0;
    w0_lookup_8_[3] = 0;
    w0_curr_state_ = 0;
    w0_ctr_zero_ = 0;
    w0_ctr_neg_ = 0;
    w0_ver_0_ = 0;
    w0_ver_1_ = 0;
    w1_lookup_8_[0] = 0;
    w1_lookup_8_[1] = 0;
    w1_lookup_8_[2] = 0;
    w1_lookup_8_[3] = 0;
    w1_curr_state_ = 0;
    w1_ctr_zero_ = 0;
    w1_ctr_neg_ = 0;
    w1_ver_0_ = 0;
    w1_ver_1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRow") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRow") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 4 > w0_lookup_8_;
  uint8_t w0_curr_state_;
  uint8_t w0_ctr_zero_;
  uint8_t w0_ctr_neg_;
  uint8_t w0_ver_0_;
  uint8_t w0_ver_1_;
  std::array< uint8_t, 4 > w1_lookup_8_;
  uint8_t w1_curr_state_;
  uint8_t w1_ctr_zero_;
  uint8_t w1_ctr_neg_;
  uint8_t w1_ver_0_;
  uint8_t w1_ver_1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class PrsrMlTcamRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_ml_tcam_row), 1, true, write_callback, read_callback, std::string("PrsrMlTcamRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_ml_tcam_row))
    {
    }
  PrsrMlTcamRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMlTcamRowMutable")
    {
    }
public:






  uint8_t w0_lookup_8(int j0) { return w0_lookup_8_[j0]; }
  void w0_lookup_8(int j0,const uint8_t &v) { w0_lookup_8_[j0]=v; }




  uint8_t w0_curr_state() { return w0_curr_state_; }
  void w0_curr_state(const uint8_t &v) { w0_curr_state_=v; }





  uint8_t w0_ctr_zero() { return w0_ctr_zero_; }
  void w0_ctr_zero(const uint8_t &v) { w0_ctr_zero_=v; }





  uint8_t w0_ctr_neg() { return w0_ctr_neg_; }
  void w0_ctr_neg(const uint8_t &v) { w0_ctr_neg_=v; }





  uint8_t w0_ver_0() { return w0_ver_0_; }
  void w0_ver_0(const uint8_t &v) { w0_ver_0_=v; }





  uint8_t w0_ver_1() { return w0_ver_1_; }
  void w0_ver_1(const uint8_t &v) { w0_ver_1_=v; }






  uint8_t w1_lookup_8(int j0) { return w1_lookup_8_[j0]; }
  void w1_lookup_8(int j0,const uint8_t &v) { w1_lookup_8_[j0]=v; }




  uint8_t w1_curr_state() { return w1_curr_state_; }
  void w1_curr_state(const uint8_t &v) { w1_curr_state_=v; }





  uint8_t w1_ctr_zero() { return w1_ctr_zero_; }
  void w1_ctr_zero(const uint8_t &v) { w1_ctr_zero_=v; }





  uint8_t w1_ctr_neg() { return w1_ctr_neg_; }
  void w1_ctr_neg(const uint8_t &v) { w1_ctr_neg_=v; }





  uint8_t w1_ver_0() { return w1_ver_0_; }
  void w1_ver_0(const uint8_t &v) { w1_ver_0_=v; }





  uint8_t w1_ver_1() { return w1_ver_1_; }
  void w1_ver_1(const uint8_t &v) { w1_ver_1_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = static_cast<uint64_t>(w0_lookup_8_[0]);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[1]) << 8);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[2]) << 16);
    *data0 |= (static_cast<uint64_t>(w0_lookup_8_[3]) << 24);
    *data0 |= (static_cast<uint64_t>(w0_curr_state_) << 32);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_zero_) & 0x1) << 40);
    *data0 |= ((static_cast<uint64_t>(w0_ctr_neg_) & 0x1) << 41);
    *data0 |= ((static_cast<uint64_t>(w0_ver_0_) & 0x1) << 42);
    *data0 |= ((static_cast<uint64_t>(w0_ver_1_) & 0x1) << 43);
    *data1 = static_cast<uint64_t>(w1_lookup_8_[0]);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[1]) << 8);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[2]) << 16);
    *data1 |= (static_cast<uint64_t>(w1_lookup_8_[3]) << 24);
    *data1 |= (static_cast<uint64_t>(w1_curr_state_) << 32);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_zero_) & 0x1) << 40);
    *data1 |= ((static_cast<uint64_t>(w1_ctr_neg_) & 0x1) << 41);
    *data1 |= ((static_cast<uint64_t>(w1_ver_0_) & 0x1) << 42);
    *data1 |= ((static_cast<uint64_t>(w1_ver_1_) & 0x1) << 43);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    w0_lookup_8_[0] = data0;
    w0_lookup_8_[1] = (data0 >> 8);
    w0_lookup_8_[2] = (data0 >> 16);
    w0_lookup_8_[3] = (data0 >> 24);
    w0_curr_state_ = (data0 >> 32);
    w0_ctr_zero_ = ((data0 >> 40) & 0x1);
    w0_ctr_neg_ = ((data0 >> 41) & 0x1);
    w0_ver_0_ = ((data0 >> 42) & 0x1);
    w0_ver_1_ = ((data0 >> 43) & 0x1);
    w1_lookup_8_[0] = data1;
    w1_lookup_8_[1] = (data1 >> 8);
    w1_lookup_8_[2] = (data1 >> 16);
    w1_lookup_8_[3] = (data1 >> 24);
    w1_curr_state_ = (data1 >> 32);
    w1_ctr_zero_ = ((data1 >> 40) & 0x1);
    w1_ctr_neg_ = ((data1 >> 41) & 0x1);
    w1_ver_0_ = ((data1 >> 42) & 0x1);
    w1_ver_1_ = ((data1 >> 43) & 0x1);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    w0_lookup_8_[0] = 0;
    w0_lookup_8_[1] = 0;
    w0_lookup_8_[2] = 0;
    w0_lookup_8_[3] = 0;
    w0_curr_state_ = 0;
    w0_ctr_zero_ = 0;
    w0_ctr_neg_ = 0;
    w0_ver_0_ = 0;
    w0_ver_1_ = 0;
    w1_lookup_8_[0] = 0;
    w1_lookup_8_[1] = 0;
    w1_lookup_8_[2] = 0;
    w1_lookup_8_[3] = 0;
    w1_curr_state_ = 0;
    w1_ctr_zero_ = 0;
    w1_ctr_neg_ = 0;
    w1_ver_0_ = 0;
    w1_ver_1_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRowMutable") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrMlTcamRowMutable") + ":\n";
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w0_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w0_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w0_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_curr_state_) ) + "\n";
    all_zeros &= (0 == w0_curr_state_);
    r += indent_string + "  " + std::string("w0_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w0_ctr_zero_);
    r += indent_string + "  " + std::string("w0_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w0_ctr_neg_);
    r += indent_string + "  " + std::string("w0_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_0_) ) + "\n";
    all_zeros &= (0 == w0_ver_0_);
    r += indent_string + "  " + std::string("w0_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w0_ver_1_) ) + "\n";
    all_zeros &= (0 == w0_ver_1_);
    for (uint32_t f=0;f<4;++f) {
      r += indent_string + "  " + std::string("w1_lookup_8") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_lookup_8_[f]) ) + "\n";
      all_zeros &= (0 == w1_lookup_8_[f]);
    }
    r += indent_string + "  " + std::string("w1_curr_state") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_curr_state_) ) + "\n";
    all_zeros &= (0 == w1_curr_state_);
    r += indent_string + "  " + std::string("w1_ctr_zero") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_zero_) ) + "\n";
    all_zeros &= (0 == w1_ctr_zero_);
    r += indent_string + "  " + std::string("w1_ctr_neg") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ctr_neg_) ) + "\n";
    all_zeros &= (0 == w1_ctr_neg_);
    r += indent_string + "  " + std::string("w1_ver_0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_0_) ) + "\n";
    all_zeros &= (0 == w1_ver_0_);
    r += indent_string + "  " + std::string("w1_ver_1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(w1_ver_1_) ) + "\n";
    all_zeros &= (0 == w1_ver_1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 4 > w0_lookup_8_;
  uint8_t w0_curr_state_;
  uint8_t w0_ctr_zero_;
  uint8_t w0_ctr_neg_;
  uint8_t w0_ver_0_;
  uint8_t w0_ver_1_;
  std::array< uint8_t, 4 > w1_lookup_8_;
  uint8_t w1_curr_state_;
  uint8_t w1_ctr_zero_;
  uint8_t w1_ctr_neg_;
  uint8_t w1_ver_0_;
  uint8_t w1_ver_1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_ml_tcam_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        assert(index_prsr_ml_tcam_row < 256);
        offset += index_prsr_ml_tcam_row * 0x1; // prsr_ml_tcam_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class PrsrMlTcamRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrMlTcamRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:






  uint8_t &w0_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_lookup_8(j0);
  }




  uint8_t &w0_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_curr_state();
  }





  uint8_t &w0_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_zero();
  }





  uint8_t &w0_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_neg();
  }





  uint8_t &w0_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_0();
  }





  uint8_t &w0_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_1();
  }






  uint8_t &w1_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_lookup_8(j0);
  }




  uint8_t &w1_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_curr_state();
  }





  uint8_t &w1_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_zero();
  }





  uint8_t &w1_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_neg();
  }





  uint8_t &w1_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_0();
  }





  uint8_t &w1_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_1();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlTcamRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlTcamRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlTcamRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};









class PrsrMlTcamRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMlTcamRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrMlTcamRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:






  uint8_t w0_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_lookup_8(j0);
  }
  void w0_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_lookup_8(j0,v);
  }




  uint8_t w0_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_curr_state();
  }
  void w0_curr_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_curr_state(v);
  }





  uint8_t w0_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_zero();
  }
  void w0_ctr_zero(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ctr_zero(v);
  }





  uint8_t w0_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ctr_neg();
  }
  void w0_ctr_neg(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ctr_neg(v);
  }





  uint8_t w0_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_0();
  }
  void w0_ver_0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ver_0(v);
  }





  uint8_t w0_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w0_ver_1();
  }
  void w0_ver_1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w0_ver_1(v);
  }






  uint8_t w1_lookup_8(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_lookup_8(j0);
  }
  void w1_lookup_8(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_lookup_8(j0,v);
  }




  uint8_t w1_curr_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_curr_state();
  }
  void w1_curr_state(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_curr_state(v);
  }





  uint8_t w1_ctr_zero(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_zero();
  }
  void w1_ctr_zero(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ctr_zero(v);
  }





  uint8_t w1_ctr_neg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ctr_neg();
  }
  void w1_ctr_neg(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ctr_neg(v);
  }





  uint8_t w1_ver_0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_0();
  }
  void w1_ver_0(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ver_0(v);
  }





  uint8_t w1_ver_1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].w1_ver_1();
  }
  void w1_ver_1(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].w1_ver_1(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1;
    (*offset) -= (i*1);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMlTcamRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMlTcamRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMlTcamRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        offset += 0x400; // to get to ml_tcam_row
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrPoActionRow : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRow(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_po_action_row), 4, false, write_callback, read_callback, std::string("PrsrPoActionRow")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_action_row))
    {
    }
  PrsrPoActionRow(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrPoActionRow")
    {
    }
public:








  uint8_t &phv_src(int j0) { return phv_src_[j0]; }







  uint8_t &phv_dst(int j0) { return phv_dst_[j0]; }








  uint8_t &phv_offset_add_dst(int j0) { return phv_offset_add_dst_[j0]; }







  uint8_t &extract_type(int j0) { return extract_type_[j0]; }






  uint8_t &csum_addr(int j0) { return csum_addr_[j0]; }






  uint8_t &csum_en(int j0) { return csum_en_[j0]; }






  uint8_t &dst_offset_inc() { return dst_offset_inc_; }






  uint8_t &dst_offset_rst() { return dst_offset_rst_; }






  uint8_t &pri_upd_type() { return pri_upd_type_; }






  uint8_t &pri_upd_src() { return pri_upd_src_; }







  uint8_t &pri_upd_en_shr() { return pri_upd_en_shr_; }






  uint8_t &pri_upd_val_mask() { return pri_upd_val_mask_; }






  uint8_t &ver_upd_type() { return ver_upd_type_; }






  uint8_t &ver_upd_src() { return ver_upd_src_; }







  uint8_t &ver_upd_en_shr() { return ver_upd_en_shr_; }






  uint8_t &ver_upd_val_mask() { return ver_upd_val_mask_; }







  uint16_t &val_const(int j0) { return val_const_[j0]; }







  uint8_t &val_const_rot(int j0) { return val_const_rot_[j0]; }





  uint8_t &val_const_32b_bond() { return val_const_32b_bond_; }








  uint8_t &clot_type(int j0) { return clot_type_[j0]; }









  uint8_t &clot_len_src(int j0) { return clot_len_src_[j0]; }









  uint8_t &clot_en_len_shr(int j0) { return clot_en_len_shr_[j0]; }







  uint8_t &clot_len_mask(int j0) { return clot_len_mask_[j0]; }









  uint8_t &clot_len_add() { return clot_len_add_; }







  uint8_t &clot_offset(int j0) { return clot_offset_[j0]; }







  uint8_t &clot_tag(int j0) { return clot_tag_[j0]; }







  uint8_t &clot_tag_offset_add(int j0) { return clot_tag_offset_add_[j0]; }







  uint8_t &clot_has_csum(int j0) { return clot_has_csum_[j0]; }






  uint8_t &hdr_len_inc_stop() { return hdr_len_inc_stop_; }





  uint8_t &hdr_len_inc_final_amt() { return hdr_len_inc_final_amt_; }





  uint8_t &disable_partial_hdr_err() { return disable_partial_hdr_err_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      if (read_callback_) read_callback_();
      *data0 = (static_cast<uint64_t>(phv_src_[0]) & 0x3f);
      *data0 |= ((static_cast<uint64_t>(phv_src_[1]) & 0x3f) << 6);
      *data0 |= ((static_cast<uint64_t>(phv_src_[2]) & 0x3f) << 12);
      *data0 |= ((static_cast<uint64_t>(phv_src_[3]) & 0x3f) << 18);
      *data0 |= ((static_cast<uint64_t>(phv_src_[4]) & 0x3f) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_src_[5]) & 0x3f) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_src_[6]) & 0x3f) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_src_[7]) & 0x3f) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_src_[8]) & 0x3f) << 48);
      *data0 |= ((static_cast<uint64_t>(phv_src_[9]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(phv_src_[10]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(phv_src_[10]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(phv_src_[11]) & 0x3f) << 2);
      *data1 |= ((static_cast<uint64_t>(phv_src_[12]) & 0x3f) << 8);
      *data1 |= ((static_cast<uint64_t>(phv_src_[13]) & 0x3f) << 14);
      *data1 |= ((static_cast<uint64_t>(phv_src_[14]) & 0x3f) << 20);
      *data1 |= ((static_cast<uint64_t>(phv_src_[15]) & 0x3f) << 26);
      *data1 |= ((static_cast<uint64_t>(phv_src_[16]) & 0x3f) << 32);
      *data1 |= ((static_cast<uint64_t>(phv_src_[17]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(phv_src_[18]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(phv_src_[19]) & 0x3f) << 50);
      *data1 |= (static_cast<uint64_t>(phv_dst_[0]) << 56);
    }
    else if (offset >= 0x1 && offset < 0x2) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[1]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[2]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[3]) << 16);
      *data0 |= (static_cast<uint64_t>(phv_dst_[4]) << 24);
      *data0 |= (static_cast<uint64_t>(phv_dst_[5]) << 32);
      *data0 |= (static_cast<uint64_t>(phv_dst_[6]) << 40);
      *data0 |= (static_cast<uint64_t>(phv_dst_[7]) << 48);
      *data0 |= (static_cast<uint64_t>(phv_dst_[8]) << 56);
      *data1 = static_cast<uint64_t>(phv_dst_[9]);
      *data1 |= (static_cast<uint64_t>(phv_dst_[10]) << 8);
      *data1 |= (static_cast<uint64_t>(phv_dst_[11]) << 16);
      *data1 |= (static_cast<uint64_t>(phv_dst_[12]) << 24);
      *data1 |= (static_cast<uint64_t>(phv_dst_[13]) << 32);
      *data1 |= (static_cast<uint64_t>(phv_dst_[14]) << 40);
      *data1 |= (static_cast<uint64_t>(phv_dst_[15]) << 48);
      *data1 |= (static_cast<uint64_t>(phv_dst_[16]) << 56);
    }
    else if (offset >= 0x2 && offset < 0x3) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[17]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[18]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[19]) << 16);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[0]) & 0x1) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[1]) & 0x1) << 25);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[2]) & 0x1) << 26);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[3]) & 0x1) << 27);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[4]) & 0x1) << 28);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[5]) & 0x1) << 29);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[6]) & 0x1) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[7]) & 0x1) << 31);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[8]) & 0x1) << 32);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[9]) & 0x1) << 33);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[10]) & 0x1) << 34);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[11]) & 0x1) << 35);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[12]) & 0x1) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[13]) & 0x1) << 37);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[14]) & 0x1) << 38);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[15]) & 0x1) << 39);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[16]) & 0x1) << 40);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[17]) & 0x1) << 41);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[18]) & 0x1) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[19]) & 0x1) << 43);
      *data0 |= ((static_cast<uint64_t>(extract_type_[0]) & 0x3) << 44);
      *data0 |= ((static_cast<uint64_t>(extract_type_[1]) & 0x3) << 46);
      *data0 |= ((static_cast<uint64_t>(extract_type_[2]) & 0x3) << 48);
      *data0 |= ((static_cast<uint64_t>(extract_type_[3]) & 0x3) << 50);
      *data0 |= ((static_cast<uint64_t>(extract_type_[4]) & 0x3) << 52);
      *data0 |= ((static_cast<uint64_t>(extract_type_[5]) & 0x3) << 54);
      *data0 |= ((static_cast<uint64_t>(extract_type_[6]) & 0x3) << 56);
      *data0 |= ((static_cast<uint64_t>(extract_type_[7]) & 0x3) << 58);
      *data0 |= ((static_cast<uint64_t>(extract_type_[8]) & 0x3) << 60);
      *data0 |= ((static_cast<uint64_t>(extract_type_[9]) & 0x3) << 62);
      *data1 = (static_cast<uint64_t>(extract_type_[10]) & 0x3);
      *data1 |= ((static_cast<uint64_t>(extract_type_[11]) & 0x3) << 2);
      *data1 |= ((static_cast<uint64_t>(extract_type_[12]) & 0x3) << 4);
      *data1 |= ((static_cast<uint64_t>(extract_type_[13]) & 0x3) << 6);
      *data1 |= ((static_cast<uint64_t>(extract_type_[14]) & 0x3) << 8);
      *data1 |= ((static_cast<uint64_t>(extract_type_[15]) & 0x3) << 10);
      *data1 |= ((static_cast<uint64_t>(extract_type_[16]) & 0x3) << 12);
      *data1 |= ((static_cast<uint64_t>(extract_type_[17]) & 0x3) << 14);
      *data1 |= ((static_cast<uint64_t>(extract_type_[18]) & 0x3) << 16);
      *data1 |= ((static_cast<uint64_t>(extract_type_[19]) & 0x3) << 18);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[0]) & 0x1f) << 20);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[1]) & 0x1f) << 25);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[2]) & 0x1f) << 30);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[3]) & 0x1f) << 35);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[4]) & 0x1f) << 40);
      *data1 |= ((static_cast<uint64_t>(csum_en_[0]) & 0x1) << 45);
      *data1 |= ((static_cast<uint64_t>(csum_en_[1]) & 0x1) << 46);
      *data1 |= ((static_cast<uint64_t>(csum_en_[2]) & 0x1) << 47);
      *data1 |= ((static_cast<uint64_t>(csum_en_[3]) & 0x1) << 48);
      *data1 |= ((static_cast<uint64_t>(csum_en_[4]) & 0x1) << 49);
      *data1 |= ((static_cast<uint64_t>(dst_offset_inc_) & 0x1f) << 50);
      *data1 |= ((static_cast<uint64_t>(dst_offset_rst_) & 0x1) << 55);
      *data1 |= ((static_cast<uint64_t>(pri_upd_type_) & 0x1) << 56);
      *data1 |= ((static_cast<uint64_t>(pri_upd_src_) & 0x1f) << 57);
      *data1 |= ((static_cast<uint64_t>(pri_upd_en_shr_) & 0x3) << 62);
    }
    else if (offset >= 0x3 && offset < 0x4) {
      if (read_callback_) read_callback_();
      *data0 = ((static_cast<uint64_t>(pri_upd_en_shr_) & 0xc) >> 2);
      *data0 |= ((static_cast<uint64_t>(pri_upd_val_mask_) & 0x7) << 2);
      *data0 |= ((static_cast<uint64_t>(ver_upd_type_) & 0x1) << 5);
      *data0 |= ((static_cast<uint64_t>(ver_upd_src_) & 0x1f) << 6);
      *data0 |= ((static_cast<uint64_t>(ver_upd_en_shr_) & 0xf) << 11);
      *data0 |= ((static_cast<uint64_t>(ver_upd_val_mask_) & 0x3) << 15);
      *data0 |= (static_cast<uint64_t>(val_const_[0]) << 17);
      *data0 |= (static_cast<uint64_t>(val_const_[1]) << 33);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[0]) & 0x1) << 49);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[1]) & 0x1) << 50);
      *data0 |= ((static_cast<uint64_t>(val_const_32b_bond_) & 0x1) << 51);
      *data0 |= ((static_cast<uint64_t>(clot_type_[0]) & 0x1) << 52);
      *data0 |= ((static_cast<uint64_t>(clot_type_[1]) & 0x1) << 53);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[0]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[1]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(clot_len_src_[1]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[0]) & 0xf) << 2);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[1]) & 0xf) << 6);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[0]) & 0x3f) << 10);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[1]) & 0x3f) << 16);
      *data1 |= ((static_cast<uint64_t>(clot_len_add_) & 0x3f) << 22);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[0]) & 0x1f) << 28);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[1]) & 0x1f) << 33);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[0]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[1]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[0]) & 0x1) << 50);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[1]) & 0x1) << 51);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[0]) & 0x1) << 52);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[1]) & 0x1) << 53);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_stop_) & 0x1) << 54);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_final_amt_) & 0x3f) << 55);
      *data1 |= ((static_cast<uint64_t>(disable_partial_hdr_err_) & 0x1) << 61);
    }
    else {
      assert(0);
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      phv_src_[0] = (data0 & 0x3f);
      phv_src_[1] = ((data0 >> 6) & 0x3f);
      phv_src_[2] = ((data0 >> 12) & 0x3f);
      phv_src_[3] = ((data0 >> 18) & 0x3f);
      phv_src_[4] = ((data0 >> 24) & 0x3f);
      phv_src_[5] = ((data0 >> 30) & 0x3f);
      phv_src_[6] = ((data0 >> 36) & 0x3f);
      phv_src_[7] = ((data0 >> 42) & 0x3f);
      phv_src_[8] = ((data0 >> 48) & 0x3f);
      phv_src_[9] = ((data0 >> 54) & 0x3f);
      phv_src_[10] = (((data0 >> 60) & 0xf) | (phv_src_[10] & 0x30));
      phv_src_[10] = (((data1 << 4) & 0x30) | (phv_src_[10] & 0xf));
      phv_src_[11] = ((data1 >> 2) & 0x3f);
      phv_src_[12] = ((data1 >> 8) & 0x3f);
      phv_src_[13] = ((data1 >> 14) & 0x3f);
      phv_src_[14] = ((data1 >> 20) & 0x3f);
      phv_src_[15] = ((data1 >> 26) & 0x3f);
      phv_src_[16] = ((data1 >> 32) & 0x3f);
      phv_src_[17] = ((data1 >> 38) & 0x3f);
      phv_src_[18] = ((data1 >> 44) & 0x3f);
      phv_src_[19] = ((data1 >> 50) & 0x3f);
      phv_dst_[0] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1 && offset < 0x2) {
      phv_dst_[1] = data0;
      phv_dst_[2] = (data0 >> 8);
      phv_dst_[3] = (data0 >> 16);
      phv_dst_[4] = (data0 >> 24);
      phv_dst_[5] = (data0 >> 32);
      phv_dst_[6] = (data0 >> 40);
      phv_dst_[7] = (data0 >> 48);
      phv_dst_[8] = (data0 >> 56);
      phv_dst_[9] = data1;
      phv_dst_[10] = (data1 >> 8);
      phv_dst_[11] = (data1 >> 16);
      phv_dst_[12] = (data1 >> 24);
      phv_dst_[13] = (data1 >> 32);
      phv_dst_[14] = (data1 >> 40);
      phv_dst_[15] = (data1 >> 48);
      phv_dst_[16] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2 && offset < 0x3) {
      phv_dst_[17] = data0;
      phv_dst_[18] = (data0 >> 8);
      phv_dst_[19] = (data0 >> 16);
      phv_offset_add_dst_[0] = ((data0 >> 24) & 0x1);
      phv_offset_add_dst_[1] = ((data0 >> 25) & 0x1);
      phv_offset_add_dst_[2] = ((data0 >> 26) & 0x1);
      phv_offset_add_dst_[3] = ((data0 >> 27) & 0x1);
      phv_offset_add_dst_[4] = ((data0 >> 28) & 0x1);
      phv_offset_add_dst_[5] = ((data0 >> 29) & 0x1);
      phv_offset_add_dst_[6] = ((data0 >> 30) & 0x1);
      phv_offset_add_dst_[7] = ((data0 >> 31) & 0x1);
      phv_offset_add_dst_[8] = ((data0 >> 32) & 0x1);
      phv_offset_add_dst_[9] = ((data0 >> 33) & 0x1);
      phv_offset_add_dst_[10] = ((data0 >> 34) & 0x1);
      phv_offset_add_dst_[11] = ((data0 >> 35) & 0x1);
      phv_offset_add_dst_[12] = ((data0 >> 36) & 0x1);
      phv_offset_add_dst_[13] = ((data0 >> 37) & 0x1);
      phv_offset_add_dst_[14] = ((data0 >> 38) & 0x1);
      phv_offset_add_dst_[15] = ((data0 >> 39) & 0x1);
      phv_offset_add_dst_[16] = ((data0 >> 40) & 0x1);
      phv_offset_add_dst_[17] = ((data0 >> 41) & 0x1);
      phv_offset_add_dst_[18] = ((data0 >> 42) & 0x1);
      phv_offset_add_dst_[19] = ((data0 >> 43) & 0x1);
      extract_type_[0] = ((data0 >> 44) & 0x3);
      extract_type_[1] = ((data0 >> 46) & 0x3);
      extract_type_[2] = ((data0 >> 48) & 0x3);
      extract_type_[3] = ((data0 >> 50) & 0x3);
      extract_type_[4] = ((data0 >> 52) & 0x3);
      extract_type_[5] = ((data0 >> 54) & 0x3);
      extract_type_[6] = ((data0 >> 56) & 0x3);
      extract_type_[7] = ((data0 >> 58) & 0x3);
      extract_type_[8] = ((data0 >> 60) & 0x3);
      extract_type_[9] = ((data0 >> 62) & 0x3);
      extract_type_[10] = (data1 & 0x3);
      extract_type_[11] = ((data1 >> 2) & 0x3);
      extract_type_[12] = ((data1 >> 4) & 0x3);
      extract_type_[13] = ((data1 >> 6) & 0x3);
      extract_type_[14] = ((data1 >> 8) & 0x3);
      extract_type_[15] = ((data1 >> 10) & 0x3);
      extract_type_[16] = ((data1 >> 12) & 0x3);
      extract_type_[17] = ((data1 >> 14) & 0x3);
      extract_type_[18] = ((data1 >> 16) & 0x3);
      extract_type_[19] = ((data1 >> 18) & 0x3);
      csum_addr_[0] = ((data1 >> 20) & 0x1f);
      csum_addr_[1] = ((data1 >> 25) & 0x1f);
      csum_addr_[2] = ((data1 >> 30) & 0x1f);
      csum_addr_[3] = ((data1 >> 35) & 0x1f);
      csum_addr_[4] = ((data1 >> 40) & 0x1f);
      csum_en_[0] = ((data1 >> 45) & 0x1);
      csum_en_[1] = ((data1 >> 46) & 0x1);
      csum_en_[2] = ((data1 >> 47) & 0x1);
      csum_en_[3] = ((data1 >> 48) & 0x1);
      csum_en_[4] = ((data1 >> 49) & 0x1);
      dst_offset_inc_ = ((data1 >> 50) & 0x1f);
      dst_offset_rst_ = ((data1 >> 55) & 0x1);
      pri_upd_type_ = ((data1 >> 56) & 0x1);
      pri_upd_src_ = ((data1 >> 57) & 0x1f);
      pri_upd_en_shr_ = (((data1 >> 62) & 0x3) | (pri_upd_en_shr_ & 0xc));
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3 && offset < 0x4) {
      pri_upd_en_shr_ = (((data0 << 2) & 0xc) | (pri_upd_en_shr_ & 0x3));
      pri_upd_val_mask_ = ((data0 >> 2) & 0x7);
      ver_upd_type_ = ((data0 >> 5) & 0x1);
      ver_upd_src_ = ((data0 >> 6) & 0x1f);
      ver_upd_en_shr_ = ((data0 >> 11) & 0xf);
      ver_upd_val_mask_ = ((data0 >> 15) & 0x3);
      val_const_[0] = (data0 >> 17);
      val_const_[1] = (data0 >> 33);
      val_const_rot_[0] = ((data0 >> 49) & 0x1);
      val_const_rot_[1] = ((data0 >> 50) & 0x1);
      val_const_32b_bond_ = ((data0 >> 51) & 0x1);
      clot_type_[0] = ((data0 >> 52) & 0x1);
      clot_type_[1] = ((data0 >> 53) & 0x1);
      clot_len_src_[0] = ((data0 >> 54) & 0x3f);
      clot_len_src_[1] = (((data0 >> 60) & 0xf) | (clot_len_src_[1] & 0x30));
      clot_len_src_[1] = (((data1 << 4) & 0x30) | (clot_len_src_[1] & 0xf));
      clot_en_len_shr_[0] = ((data1 >> 2) & 0xf);
      clot_en_len_shr_[1] = ((data1 >> 6) & 0xf);
      clot_len_mask_[0] = ((data1 >> 10) & 0x3f);
      clot_len_mask_[1] = ((data1 >> 16) & 0x3f);
      clot_len_add_ = ((data1 >> 22) & 0x3f);
      clot_offset_[0] = ((data1 >> 28) & 0x1f);
      clot_offset_[1] = ((data1 >> 33) & 0x1f);
      clot_tag_[0] = ((data1 >> 38) & 0x3f);
      clot_tag_[1] = ((data1 >> 44) & 0x3f);
      clot_tag_offset_add_[0] = ((data1 >> 50) & 0x1);
      clot_tag_offset_add_[1] = ((data1 >> 51) & 0x1);
      clot_has_csum_[0] = ((data1 >> 52) & 0x1);
      clot_has_csum_[1] = ((data1 >> 53) & 0x1);
      hdr_len_inc_stop_ = ((data1 >> 54) & 0x1);
      hdr_len_inc_final_amt_ = ((data1 >> 55) & 0x3f);
      disable_partial_hdr_err_ = ((data1 >> 61) & 0x1);
      if (write_callback_) write_callback_();
    }
    else {
      assert(0);
    }
    return true;
  }

  void reset(
      
      ) {
    phv_src_[0] = 0;
    phv_src_[1] = 0;
    phv_src_[2] = 0;
    phv_src_[3] = 0;
    phv_src_[4] = 0;
    phv_src_[5] = 0;
    phv_src_[6] = 0;
    phv_src_[7] = 0;
    phv_src_[8] = 0;
    phv_src_[9] = 0;
    phv_src_[10] = 0;
    phv_src_[11] = 0;
    phv_src_[12] = 0;
    phv_src_[13] = 0;
    phv_src_[14] = 0;
    phv_src_[15] = 0;
    phv_src_[16] = 0;
    phv_src_[17] = 0;
    phv_src_[18] = 0;
    phv_src_[19] = 0;
    phv_dst_[0] = 0;
    phv_dst_[1] = 0;
    phv_dst_[2] = 0;
    phv_dst_[3] = 0;
    phv_dst_[4] = 0;
    phv_dst_[5] = 0;
    phv_dst_[6] = 0;
    phv_dst_[7] = 0;
    phv_dst_[8] = 0;
    phv_dst_[9] = 0;
    phv_dst_[10] = 0;
    phv_dst_[11] = 0;
    phv_dst_[12] = 0;
    phv_dst_[13] = 0;
    phv_dst_[14] = 0;
    phv_dst_[15] = 0;
    phv_dst_[16] = 0;
    phv_dst_[17] = 0;
    phv_dst_[18] = 0;
    phv_dst_[19] = 0;
    phv_offset_add_dst_[0] = 0;
    phv_offset_add_dst_[1] = 0;
    phv_offset_add_dst_[2] = 0;
    phv_offset_add_dst_[3] = 0;
    phv_offset_add_dst_[4] = 0;
    phv_offset_add_dst_[5] = 0;
    phv_offset_add_dst_[6] = 0;
    phv_offset_add_dst_[7] = 0;
    phv_offset_add_dst_[8] = 0;
    phv_offset_add_dst_[9] = 0;
    phv_offset_add_dst_[10] = 0;
    phv_offset_add_dst_[11] = 0;
    phv_offset_add_dst_[12] = 0;
    phv_offset_add_dst_[13] = 0;
    phv_offset_add_dst_[14] = 0;
    phv_offset_add_dst_[15] = 0;
    phv_offset_add_dst_[16] = 0;
    phv_offset_add_dst_[17] = 0;
    phv_offset_add_dst_[18] = 0;
    phv_offset_add_dst_[19] = 0;
    extract_type_[0] = 0;
    extract_type_[1] = 0;
    extract_type_[2] = 0;
    extract_type_[3] = 0;
    extract_type_[4] = 0;
    extract_type_[5] = 0;
    extract_type_[6] = 0;
    extract_type_[7] = 0;
    extract_type_[8] = 0;
    extract_type_[9] = 0;
    extract_type_[10] = 0;
    extract_type_[11] = 0;
    extract_type_[12] = 0;
    extract_type_[13] = 0;
    extract_type_[14] = 0;
    extract_type_[15] = 0;
    extract_type_[16] = 0;
    extract_type_[17] = 0;
    extract_type_[18] = 0;
    extract_type_[19] = 0;
    csum_addr_[0] = 0;
    csum_addr_[1] = 0;
    csum_addr_[2] = 0;
    csum_addr_[3] = 0;
    csum_addr_[4] = 0;
    csum_en_[0] = 0;
    csum_en_[1] = 0;
    csum_en_[2] = 0;
    csum_en_[3] = 0;
    csum_en_[4] = 0;
    dst_offset_inc_ = 0;
    dst_offset_rst_ = 0;
    pri_upd_type_ = 0;
    pri_upd_src_ = 0;
    pri_upd_en_shr_ = 0;
    pri_upd_val_mask_ = 0;
    ver_upd_type_ = 0;
    ver_upd_src_ = 0;
    ver_upd_en_shr_ = 0;
    ver_upd_val_mask_ = 0;
    val_const_[0] = 0;
    val_const_[1] = 0;
    val_const_rot_[0] = 0;
    val_const_rot_[1] = 0;
    val_const_32b_bond_ = 0;
    clot_type_[0] = 0;
    clot_type_[1] = 0;
    clot_len_src_[0] = 0;
    clot_len_src_[1] = 0;
    clot_en_len_shr_[0] = 0;
    clot_en_len_shr_[1] = 0;
    clot_len_mask_[0] = 0;
    clot_len_mask_[1] = 0;
    clot_len_add_ = 0;
    clot_offset_[0] = 0;
    clot_offset_[1] = 0;
    clot_tag_[0] = 0;
    clot_tag_[1] = 0;
    clot_tag_offset_add_[0] = 0;
    clot_tag_offset_add_[1] = 0;
    clot_has_csum_[0] = 0;
    clot_has_csum_[1] = 0;
    hdr_len_inc_stop_ = 0;
    hdr_len_inc_final_amt_ = 0;
    disable_partial_hdr_err_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRow") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRow") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 20 > phv_src_;
  std::array< uint8_t, 20 > phv_dst_;
  std::array< uint8_t, 20 > phv_offset_add_dst_;
  std::array< uint8_t, 20 > extract_type_;
  std::array< uint8_t, 5 > csum_addr_;
  std::array< uint8_t, 5 > csum_en_;
  uint8_t dst_offset_inc_;
  uint8_t dst_offset_rst_;
  uint8_t pri_upd_type_;
  uint8_t pri_upd_src_;
  uint8_t pri_upd_en_shr_;
  uint8_t pri_upd_val_mask_;
  uint8_t ver_upd_type_;
  uint8_t ver_upd_src_;
  uint8_t ver_upd_en_shr_;
  uint8_t ver_upd_val_mask_;
  std::array< uint16_t, 2 > val_const_;
  std::array< uint8_t, 2 > val_const_rot_;
  uint8_t val_const_32b_bond_;
  std::array< uint8_t, 2 > clot_type_;
  std::array< uint8_t, 2 > clot_len_src_;
  std::array< uint8_t, 2 > clot_en_len_shr_;
  std::array< uint8_t, 2 > clot_len_mask_;
  uint8_t clot_len_add_;
  std::array< uint8_t, 2 > clot_offset_;
  std::array< uint8_t, 2 > clot_tag_;
  std::array< uint8_t, 2 > clot_tag_offset_add_;
  std::array< uint8_t, 2 > clot_has_csum_;
  uint8_t hdr_len_inc_stop_;
  uint8_t hdr_len_inc_final_amt_;
  uint8_t disable_partial_hdr_err_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrPoActionRowMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRowMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, index_prsr_po_action_row), 4, true, write_callback, read_callback, std::string("PrsrPoActionRowMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec) + "," + boost::lexical_cast<std::string>(index_prsr_po_action_row))
    {
    }
  PrsrPoActionRowMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrPoActionRowMutable")
    {
    }
public:








  uint8_t phv_src(int j0) { return phv_src_[j0]; }
  void phv_src(int j0,const uint8_t &v) { phv_src_[j0]=v; }







  uint8_t phv_dst(int j0) { return phv_dst_[j0]; }
  void phv_dst(int j0,const uint8_t &v) { phv_dst_[j0]=v; }








  uint8_t phv_offset_add_dst(int j0) { return phv_offset_add_dst_[j0]; }
  void phv_offset_add_dst(int j0,const uint8_t &v) { phv_offset_add_dst_[j0]=v; }







  uint8_t extract_type(int j0) { return extract_type_[j0]; }
  void extract_type(int j0,const uint8_t &v) { extract_type_[j0]=v; }






  uint8_t csum_addr(int j0) { return csum_addr_[j0]; }
  void csum_addr(int j0,const uint8_t &v) { csum_addr_[j0]=v; }






  uint8_t csum_en(int j0) { return csum_en_[j0]; }
  void csum_en(int j0,const uint8_t &v) { csum_en_[j0]=v; }






  uint8_t dst_offset_inc() { return dst_offset_inc_; }
  void dst_offset_inc(const uint8_t &v) { dst_offset_inc_=v; }






  uint8_t dst_offset_rst() { return dst_offset_rst_; }
  void dst_offset_rst(const uint8_t &v) { dst_offset_rst_=v; }






  uint8_t pri_upd_type() { return pri_upd_type_; }
  void pri_upd_type(const uint8_t &v) { pri_upd_type_=v; }






  uint8_t pri_upd_src() { return pri_upd_src_; }
  void pri_upd_src(const uint8_t &v) { pri_upd_src_=v; }







  uint8_t pri_upd_en_shr() { return pri_upd_en_shr_; }
  void pri_upd_en_shr(const uint8_t &v) { pri_upd_en_shr_=v; }






  uint8_t pri_upd_val_mask() { return pri_upd_val_mask_; }
  void pri_upd_val_mask(const uint8_t &v) { pri_upd_val_mask_=v; }






  uint8_t ver_upd_type() { return ver_upd_type_; }
  void ver_upd_type(const uint8_t &v) { ver_upd_type_=v; }






  uint8_t ver_upd_src() { return ver_upd_src_; }
  void ver_upd_src(const uint8_t &v) { ver_upd_src_=v; }







  uint8_t ver_upd_en_shr() { return ver_upd_en_shr_; }
  void ver_upd_en_shr(const uint8_t &v) { ver_upd_en_shr_=v; }






  uint8_t ver_upd_val_mask() { return ver_upd_val_mask_; }
  void ver_upd_val_mask(const uint8_t &v) { ver_upd_val_mask_=v; }







  uint16_t val_const(int j0) { return val_const_[j0]; }
  void val_const(int j0,const uint16_t &v) { val_const_[j0]=v; }







  uint8_t val_const_rot(int j0) { return val_const_rot_[j0]; }
  void val_const_rot(int j0,const uint8_t &v) { val_const_rot_[j0]=v; }





  uint8_t val_const_32b_bond() { return val_const_32b_bond_; }
  void val_const_32b_bond(const uint8_t &v) { val_const_32b_bond_=v; }








  uint8_t clot_type(int j0) { return clot_type_[j0]; }
  void clot_type(int j0,const uint8_t &v) { clot_type_[j0]=v; }









  uint8_t clot_len_src(int j0) { return clot_len_src_[j0]; }
  void clot_len_src(int j0,const uint8_t &v) { clot_len_src_[j0]=v; }









  uint8_t clot_en_len_shr(int j0) { return clot_en_len_shr_[j0]; }
  void clot_en_len_shr(int j0,const uint8_t &v) { clot_en_len_shr_[j0]=v; }







  uint8_t clot_len_mask(int j0) { return clot_len_mask_[j0]; }
  void clot_len_mask(int j0,const uint8_t &v) { clot_len_mask_[j0]=v; }









  uint8_t clot_len_add() { return clot_len_add_; }
  void clot_len_add(const uint8_t &v) { clot_len_add_=v; }







  uint8_t clot_offset(int j0) { return clot_offset_[j0]; }
  void clot_offset(int j0,const uint8_t &v) { clot_offset_[j0]=v; }







  uint8_t clot_tag(int j0) { return clot_tag_[j0]; }
  void clot_tag(int j0,const uint8_t &v) { clot_tag_[j0]=v; }







  uint8_t clot_tag_offset_add(int j0) { return clot_tag_offset_add_[j0]; }
  void clot_tag_offset_add(int j0,const uint8_t &v) { clot_tag_offset_add_[j0]=v; }







  uint8_t clot_has_csum(int j0) { return clot_has_csum_[j0]; }
  void clot_has_csum(int j0,const uint8_t &v) { clot_has_csum_[j0]=v; }






  uint8_t hdr_len_inc_stop() { return hdr_len_inc_stop_; }
  void hdr_len_inc_stop(const uint8_t &v) { hdr_len_inc_stop_=v; }





  uint8_t hdr_len_inc_final_amt() { return hdr_len_inc_final_amt_; }
  void hdr_len_inc_final_amt(const uint8_t &v) { hdr_len_inc_final_amt_=v; }





  uint8_t disable_partial_hdr_err() { return disable_partial_hdr_err_; }
  void disable_partial_hdr_err(const uint8_t &v) { disable_partial_hdr_err_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      if (read_callback_) read_callback_();
      *data0 = (static_cast<uint64_t>(phv_src_[0]) & 0x3f);
      *data0 |= ((static_cast<uint64_t>(phv_src_[1]) & 0x3f) << 6);
      *data0 |= ((static_cast<uint64_t>(phv_src_[2]) & 0x3f) << 12);
      *data0 |= ((static_cast<uint64_t>(phv_src_[3]) & 0x3f) << 18);
      *data0 |= ((static_cast<uint64_t>(phv_src_[4]) & 0x3f) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_src_[5]) & 0x3f) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_src_[6]) & 0x3f) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_src_[7]) & 0x3f) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_src_[8]) & 0x3f) << 48);
      *data0 |= ((static_cast<uint64_t>(phv_src_[9]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(phv_src_[10]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(phv_src_[10]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(phv_src_[11]) & 0x3f) << 2);
      *data1 |= ((static_cast<uint64_t>(phv_src_[12]) & 0x3f) << 8);
      *data1 |= ((static_cast<uint64_t>(phv_src_[13]) & 0x3f) << 14);
      *data1 |= ((static_cast<uint64_t>(phv_src_[14]) & 0x3f) << 20);
      *data1 |= ((static_cast<uint64_t>(phv_src_[15]) & 0x3f) << 26);
      *data1 |= ((static_cast<uint64_t>(phv_src_[16]) & 0x3f) << 32);
      *data1 |= ((static_cast<uint64_t>(phv_src_[17]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(phv_src_[18]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(phv_src_[19]) & 0x3f) << 50);
      *data1 |= (static_cast<uint64_t>(phv_dst_[0]) << 56);
    }
    else if (offset >= 0x1 && offset < 0x2) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[1]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[2]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[3]) << 16);
      *data0 |= (static_cast<uint64_t>(phv_dst_[4]) << 24);
      *data0 |= (static_cast<uint64_t>(phv_dst_[5]) << 32);
      *data0 |= (static_cast<uint64_t>(phv_dst_[6]) << 40);
      *data0 |= (static_cast<uint64_t>(phv_dst_[7]) << 48);
      *data0 |= (static_cast<uint64_t>(phv_dst_[8]) << 56);
      *data1 = static_cast<uint64_t>(phv_dst_[9]);
      *data1 |= (static_cast<uint64_t>(phv_dst_[10]) << 8);
      *data1 |= (static_cast<uint64_t>(phv_dst_[11]) << 16);
      *data1 |= (static_cast<uint64_t>(phv_dst_[12]) << 24);
      *data1 |= (static_cast<uint64_t>(phv_dst_[13]) << 32);
      *data1 |= (static_cast<uint64_t>(phv_dst_[14]) << 40);
      *data1 |= (static_cast<uint64_t>(phv_dst_[15]) << 48);
      *data1 |= (static_cast<uint64_t>(phv_dst_[16]) << 56);
    }
    else if (offset >= 0x2 && offset < 0x3) {
      if (read_callback_) read_callback_();
      *data0 = static_cast<uint64_t>(phv_dst_[17]);
      *data0 |= (static_cast<uint64_t>(phv_dst_[18]) << 8);
      *data0 |= (static_cast<uint64_t>(phv_dst_[19]) << 16);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[0]) & 0x1) << 24);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[1]) & 0x1) << 25);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[2]) & 0x1) << 26);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[3]) & 0x1) << 27);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[4]) & 0x1) << 28);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[5]) & 0x1) << 29);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[6]) & 0x1) << 30);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[7]) & 0x1) << 31);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[8]) & 0x1) << 32);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[9]) & 0x1) << 33);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[10]) & 0x1) << 34);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[11]) & 0x1) << 35);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[12]) & 0x1) << 36);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[13]) & 0x1) << 37);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[14]) & 0x1) << 38);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[15]) & 0x1) << 39);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[16]) & 0x1) << 40);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[17]) & 0x1) << 41);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[18]) & 0x1) << 42);
      *data0 |= ((static_cast<uint64_t>(phv_offset_add_dst_[19]) & 0x1) << 43);
      *data0 |= ((static_cast<uint64_t>(extract_type_[0]) & 0x3) << 44);
      *data0 |= ((static_cast<uint64_t>(extract_type_[1]) & 0x3) << 46);
      *data0 |= ((static_cast<uint64_t>(extract_type_[2]) & 0x3) << 48);
      *data0 |= ((static_cast<uint64_t>(extract_type_[3]) & 0x3) << 50);
      *data0 |= ((static_cast<uint64_t>(extract_type_[4]) & 0x3) << 52);
      *data0 |= ((static_cast<uint64_t>(extract_type_[5]) & 0x3) << 54);
      *data0 |= ((static_cast<uint64_t>(extract_type_[6]) & 0x3) << 56);
      *data0 |= ((static_cast<uint64_t>(extract_type_[7]) & 0x3) << 58);
      *data0 |= ((static_cast<uint64_t>(extract_type_[8]) & 0x3) << 60);
      *data0 |= ((static_cast<uint64_t>(extract_type_[9]) & 0x3) << 62);
      *data1 = (static_cast<uint64_t>(extract_type_[10]) & 0x3);
      *data1 |= ((static_cast<uint64_t>(extract_type_[11]) & 0x3) << 2);
      *data1 |= ((static_cast<uint64_t>(extract_type_[12]) & 0x3) << 4);
      *data1 |= ((static_cast<uint64_t>(extract_type_[13]) & 0x3) << 6);
      *data1 |= ((static_cast<uint64_t>(extract_type_[14]) & 0x3) << 8);
      *data1 |= ((static_cast<uint64_t>(extract_type_[15]) & 0x3) << 10);
      *data1 |= ((static_cast<uint64_t>(extract_type_[16]) & 0x3) << 12);
      *data1 |= ((static_cast<uint64_t>(extract_type_[17]) & 0x3) << 14);
      *data1 |= ((static_cast<uint64_t>(extract_type_[18]) & 0x3) << 16);
      *data1 |= ((static_cast<uint64_t>(extract_type_[19]) & 0x3) << 18);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[0]) & 0x1f) << 20);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[1]) & 0x1f) << 25);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[2]) & 0x1f) << 30);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[3]) & 0x1f) << 35);
      *data1 |= ((static_cast<uint64_t>(csum_addr_[4]) & 0x1f) << 40);
      *data1 |= ((static_cast<uint64_t>(csum_en_[0]) & 0x1) << 45);
      *data1 |= ((static_cast<uint64_t>(csum_en_[1]) & 0x1) << 46);
      *data1 |= ((static_cast<uint64_t>(csum_en_[2]) & 0x1) << 47);
      *data1 |= ((static_cast<uint64_t>(csum_en_[3]) & 0x1) << 48);
      *data1 |= ((static_cast<uint64_t>(csum_en_[4]) & 0x1) << 49);
      *data1 |= ((static_cast<uint64_t>(dst_offset_inc_) & 0x1f) << 50);
      *data1 |= ((static_cast<uint64_t>(dst_offset_rst_) & 0x1) << 55);
      *data1 |= ((static_cast<uint64_t>(pri_upd_type_) & 0x1) << 56);
      *data1 |= ((static_cast<uint64_t>(pri_upd_src_) & 0x1f) << 57);
      *data1 |= ((static_cast<uint64_t>(pri_upd_en_shr_) & 0x3) << 62);
    }
    else if (offset >= 0x3 && offset < 0x4) {
      if (read_callback_) read_callback_();
      *data0 = ((static_cast<uint64_t>(pri_upd_en_shr_) & 0xc) >> 2);
      *data0 |= ((static_cast<uint64_t>(pri_upd_val_mask_) & 0x7) << 2);
      *data0 |= ((static_cast<uint64_t>(ver_upd_type_) & 0x1) << 5);
      *data0 |= ((static_cast<uint64_t>(ver_upd_src_) & 0x1f) << 6);
      *data0 |= ((static_cast<uint64_t>(ver_upd_en_shr_) & 0xf) << 11);
      *data0 |= ((static_cast<uint64_t>(ver_upd_val_mask_) & 0x3) << 15);
      *data0 |= (static_cast<uint64_t>(val_const_[0]) << 17);
      *data0 |= (static_cast<uint64_t>(val_const_[1]) << 33);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[0]) & 0x1) << 49);
      *data0 |= ((static_cast<uint64_t>(val_const_rot_[1]) & 0x1) << 50);
      *data0 |= ((static_cast<uint64_t>(val_const_32b_bond_) & 0x1) << 51);
      *data0 |= ((static_cast<uint64_t>(clot_type_[0]) & 0x1) << 52);
      *data0 |= ((static_cast<uint64_t>(clot_type_[1]) & 0x1) << 53);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[0]) & 0x3f) << 54);
      *data0 |= ((static_cast<uint64_t>(clot_len_src_[1]) & 0xf) << 60);
      *data1 = ((static_cast<uint64_t>(clot_len_src_[1]) & 0x30) >> 4);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[0]) & 0xf) << 2);
      *data1 |= ((static_cast<uint64_t>(clot_en_len_shr_[1]) & 0xf) << 6);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[0]) & 0x3f) << 10);
      *data1 |= ((static_cast<uint64_t>(clot_len_mask_[1]) & 0x3f) << 16);
      *data1 |= ((static_cast<uint64_t>(clot_len_add_) & 0x3f) << 22);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[0]) & 0x1f) << 28);
      *data1 |= ((static_cast<uint64_t>(clot_offset_[1]) & 0x1f) << 33);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[0]) & 0x3f) << 38);
      *data1 |= ((static_cast<uint64_t>(clot_tag_[1]) & 0x3f) << 44);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[0]) & 0x1) << 50);
      *data1 |= ((static_cast<uint64_t>(clot_tag_offset_add_[1]) & 0x1) << 51);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[0]) & 0x1) << 52);
      *data1 |= ((static_cast<uint64_t>(clot_has_csum_[1]) & 0x1) << 53);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_stop_) & 0x1) << 54);
      *data1 |= ((static_cast<uint64_t>(hdr_len_inc_final_amt_) & 0x3f) << 55);
      *data1 |= ((static_cast<uint64_t>(disable_partial_hdr_err_) & 0x1) << 61);
    }
    else {
      assert(0);
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      phv_src_[0] = (data0 & 0x3f);
      phv_src_[1] = ((data0 >> 6) & 0x3f);
      phv_src_[2] = ((data0 >> 12) & 0x3f);
      phv_src_[3] = ((data0 >> 18) & 0x3f);
      phv_src_[4] = ((data0 >> 24) & 0x3f);
      phv_src_[5] = ((data0 >> 30) & 0x3f);
      phv_src_[6] = ((data0 >> 36) & 0x3f);
      phv_src_[7] = ((data0 >> 42) & 0x3f);
      phv_src_[8] = ((data0 >> 48) & 0x3f);
      phv_src_[9] = ((data0 >> 54) & 0x3f);
      phv_src_[10] = (((data0 >> 60) & 0xf) | (phv_src_[10] & 0x30));
      phv_src_[10] = (((data1 << 4) & 0x30) | (phv_src_[10] & 0xf));
      phv_src_[11] = ((data1 >> 2) & 0x3f);
      phv_src_[12] = ((data1 >> 8) & 0x3f);
      phv_src_[13] = ((data1 >> 14) & 0x3f);
      phv_src_[14] = ((data1 >> 20) & 0x3f);
      phv_src_[15] = ((data1 >> 26) & 0x3f);
      phv_src_[16] = ((data1 >> 32) & 0x3f);
      phv_src_[17] = ((data1 >> 38) & 0x3f);
      phv_src_[18] = ((data1 >> 44) & 0x3f);
      phv_src_[19] = ((data1 >> 50) & 0x3f);
      phv_dst_[0] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1 && offset < 0x2) {
      phv_dst_[1] = data0;
      phv_dst_[2] = (data0 >> 8);
      phv_dst_[3] = (data0 >> 16);
      phv_dst_[4] = (data0 >> 24);
      phv_dst_[5] = (data0 >> 32);
      phv_dst_[6] = (data0 >> 40);
      phv_dst_[7] = (data0 >> 48);
      phv_dst_[8] = (data0 >> 56);
      phv_dst_[9] = data1;
      phv_dst_[10] = (data1 >> 8);
      phv_dst_[11] = (data1 >> 16);
      phv_dst_[12] = (data1 >> 24);
      phv_dst_[13] = (data1 >> 32);
      phv_dst_[14] = (data1 >> 40);
      phv_dst_[15] = (data1 >> 48);
      phv_dst_[16] = (data1 >> 56);
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2 && offset < 0x3) {
      phv_dst_[17] = data0;
      phv_dst_[18] = (data0 >> 8);
      phv_dst_[19] = (data0 >> 16);
      phv_offset_add_dst_[0] = ((data0 >> 24) & 0x1);
      phv_offset_add_dst_[1] = ((data0 >> 25) & 0x1);
      phv_offset_add_dst_[2] = ((data0 >> 26) & 0x1);
      phv_offset_add_dst_[3] = ((data0 >> 27) & 0x1);
      phv_offset_add_dst_[4] = ((data0 >> 28) & 0x1);
      phv_offset_add_dst_[5] = ((data0 >> 29) & 0x1);
      phv_offset_add_dst_[6] = ((data0 >> 30) & 0x1);
      phv_offset_add_dst_[7] = ((data0 >> 31) & 0x1);
      phv_offset_add_dst_[8] = ((data0 >> 32) & 0x1);
      phv_offset_add_dst_[9] = ((data0 >> 33) & 0x1);
      phv_offset_add_dst_[10] = ((data0 >> 34) & 0x1);
      phv_offset_add_dst_[11] = ((data0 >> 35) & 0x1);
      phv_offset_add_dst_[12] = ((data0 >> 36) & 0x1);
      phv_offset_add_dst_[13] = ((data0 >> 37) & 0x1);
      phv_offset_add_dst_[14] = ((data0 >> 38) & 0x1);
      phv_offset_add_dst_[15] = ((data0 >> 39) & 0x1);
      phv_offset_add_dst_[16] = ((data0 >> 40) & 0x1);
      phv_offset_add_dst_[17] = ((data0 >> 41) & 0x1);
      phv_offset_add_dst_[18] = ((data0 >> 42) & 0x1);
      phv_offset_add_dst_[19] = ((data0 >> 43) & 0x1);
      extract_type_[0] = ((data0 >> 44) & 0x3);
      extract_type_[1] = ((data0 >> 46) & 0x3);
      extract_type_[2] = ((data0 >> 48) & 0x3);
      extract_type_[3] = ((data0 >> 50) & 0x3);
      extract_type_[4] = ((data0 >> 52) & 0x3);
      extract_type_[5] = ((data0 >> 54) & 0x3);
      extract_type_[6] = ((data0 >> 56) & 0x3);
      extract_type_[7] = ((data0 >> 58) & 0x3);
      extract_type_[8] = ((data0 >> 60) & 0x3);
      extract_type_[9] = ((data0 >> 62) & 0x3);
      extract_type_[10] = (data1 & 0x3);
      extract_type_[11] = ((data1 >> 2) & 0x3);
      extract_type_[12] = ((data1 >> 4) & 0x3);
      extract_type_[13] = ((data1 >> 6) & 0x3);
      extract_type_[14] = ((data1 >> 8) & 0x3);
      extract_type_[15] = ((data1 >> 10) & 0x3);
      extract_type_[16] = ((data1 >> 12) & 0x3);
      extract_type_[17] = ((data1 >> 14) & 0x3);
      extract_type_[18] = ((data1 >> 16) & 0x3);
      extract_type_[19] = ((data1 >> 18) & 0x3);
      csum_addr_[0] = ((data1 >> 20) & 0x1f);
      csum_addr_[1] = ((data1 >> 25) & 0x1f);
      csum_addr_[2] = ((data1 >> 30) & 0x1f);
      csum_addr_[3] = ((data1 >> 35) & 0x1f);
      csum_addr_[4] = ((data1 >> 40) & 0x1f);
      csum_en_[0] = ((data1 >> 45) & 0x1);
      csum_en_[1] = ((data1 >> 46) & 0x1);
      csum_en_[2] = ((data1 >> 47) & 0x1);
      csum_en_[3] = ((data1 >> 48) & 0x1);
      csum_en_[4] = ((data1 >> 49) & 0x1);
      dst_offset_inc_ = ((data1 >> 50) & 0x1f);
      dst_offset_rst_ = ((data1 >> 55) & 0x1);
      pri_upd_type_ = ((data1 >> 56) & 0x1);
      pri_upd_src_ = ((data1 >> 57) & 0x1f);
      pri_upd_en_shr_ = (((data1 >> 62) & 0x3) | (pri_upd_en_shr_ & 0xc));
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3 && offset < 0x4) {
      pri_upd_en_shr_ = (((data0 << 2) & 0xc) | (pri_upd_en_shr_ & 0x3));
      pri_upd_val_mask_ = ((data0 >> 2) & 0x7);
      ver_upd_type_ = ((data0 >> 5) & 0x1);
      ver_upd_src_ = ((data0 >> 6) & 0x1f);
      ver_upd_en_shr_ = ((data0 >> 11) & 0xf);
      ver_upd_val_mask_ = ((data0 >> 15) & 0x3);
      val_const_[0] = (data0 >> 17);
      val_const_[1] = (data0 >> 33);
      val_const_rot_[0] = ((data0 >> 49) & 0x1);
      val_const_rot_[1] = ((data0 >> 50) & 0x1);
      val_const_32b_bond_ = ((data0 >> 51) & 0x1);
      clot_type_[0] = ((data0 >> 52) & 0x1);
      clot_type_[1] = ((data0 >> 53) & 0x1);
      clot_len_src_[0] = ((data0 >> 54) & 0x3f);
      clot_len_src_[1] = (((data0 >> 60) & 0xf) | (clot_len_src_[1] & 0x30));
      clot_len_src_[1] = (((data1 << 4) & 0x30) | (clot_len_src_[1] & 0xf));
      clot_en_len_shr_[0] = ((data1 >> 2) & 0xf);
      clot_en_len_shr_[1] = ((data1 >> 6) & 0xf);
      clot_len_mask_[0] = ((data1 >> 10) & 0x3f);
      clot_len_mask_[1] = ((data1 >> 16) & 0x3f);
      clot_len_add_ = ((data1 >> 22) & 0x3f);
      clot_offset_[0] = ((data1 >> 28) & 0x1f);
      clot_offset_[1] = ((data1 >> 33) & 0x1f);
      clot_tag_[0] = ((data1 >> 38) & 0x3f);
      clot_tag_[1] = ((data1 >> 44) & 0x3f);
      clot_tag_offset_add_[0] = ((data1 >> 50) & 0x1);
      clot_tag_offset_add_[1] = ((data1 >> 51) & 0x1);
      clot_has_csum_[0] = ((data1 >> 52) & 0x1);
      clot_has_csum_[1] = ((data1 >> 53) & 0x1);
      hdr_len_inc_stop_ = ((data1 >> 54) & 0x1);
      hdr_len_inc_final_amt_ = ((data1 >> 55) & 0x3f);
      disable_partial_hdr_err_ = ((data1 >> 61) & 0x1);
      if (write_callback_) write_callback_();
    }
    else {
      assert(0);
    }
    return true;
  }

  void reset(
      
      ) {
    phv_src_[0] = 0;
    phv_src_[1] = 0;
    phv_src_[2] = 0;
    phv_src_[3] = 0;
    phv_src_[4] = 0;
    phv_src_[5] = 0;
    phv_src_[6] = 0;
    phv_src_[7] = 0;
    phv_src_[8] = 0;
    phv_src_[9] = 0;
    phv_src_[10] = 0;
    phv_src_[11] = 0;
    phv_src_[12] = 0;
    phv_src_[13] = 0;
    phv_src_[14] = 0;
    phv_src_[15] = 0;
    phv_src_[16] = 0;
    phv_src_[17] = 0;
    phv_src_[18] = 0;
    phv_src_[19] = 0;
    phv_dst_[0] = 0;
    phv_dst_[1] = 0;
    phv_dst_[2] = 0;
    phv_dst_[3] = 0;
    phv_dst_[4] = 0;
    phv_dst_[5] = 0;
    phv_dst_[6] = 0;
    phv_dst_[7] = 0;
    phv_dst_[8] = 0;
    phv_dst_[9] = 0;
    phv_dst_[10] = 0;
    phv_dst_[11] = 0;
    phv_dst_[12] = 0;
    phv_dst_[13] = 0;
    phv_dst_[14] = 0;
    phv_dst_[15] = 0;
    phv_dst_[16] = 0;
    phv_dst_[17] = 0;
    phv_dst_[18] = 0;
    phv_dst_[19] = 0;
    phv_offset_add_dst_[0] = 0;
    phv_offset_add_dst_[1] = 0;
    phv_offset_add_dst_[2] = 0;
    phv_offset_add_dst_[3] = 0;
    phv_offset_add_dst_[4] = 0;
    phv_offset_add_dst_[5] = 0;
    phv_offset_add_dst_[6] = 0;
    phv_offset_add_dst_[7] = 0;
    phv_offset_add_dst_[8] = 0;
    phv_offset_add_dst_[9] = 0;
    phv_offset_add_dst_[10] = 0;
    phv_offset_add_dst_[11] = 0;
    phv_offset_add_dst_[12] = 0;
    phv_offset_add_dst_[13] = 0;
    phv_offset_add_dst_[14] = 0;
    phv_offset_add_dst_[15] = 0;
    phv_offset_add_dst_[16] = 0;
    phv_offset_add_dst_[17] = 0;
    phv_offset_add_dst_[18] = 0;
    phv_offset_add_dst_[19] = 0;
    extract_type_[0] = 0;
    extract_type_[1] = 0;
    extract_type_[2] = 0;
    extract_type_[3] = 0;
    extract_type_[4] = 0;
    extract_type_[5] = 0;
    extract_type_[6] = 0;
    extract_type_[7] = 0;
    extract_type_[8] = 0;
    extract_type_[9] = 0;
    extract_type_[10] = 0;
    extract_type_[11] = 0;
    extract_type_[12] = 0;
    extract_type_[13] = 0;
    extract_type_[14] = 0;
    extract_type_[15] = 0;
    extract_type_[16] = 0;
    extract_type_[17] = 0;
    extract_type_[18] = 0;
    extract_type_[19] = 0;
    csum_addr_[0] = 0;
    csum_addr_[1] = 0;
    csum_addr_[2] = 0;
    csum_addr_[3] = 0;
    csum_addr_[4] = 0;
    csum_en_[0] = 0;
    csum_en_[1] = 0;
    csum_en_[2] = 0;
    csum_en_[3] = 0;
    csum_en_[4] = 0;
    dst_offset_inc_ = 0;
    dst_offset_rst_ = 0;
    pri_upd_type_ = 0;
    pri_upd_src_ = 0;
    pri_upd_en_shr_ = 0;
    pri_upd_val_mask_ = 0;
    ver_upd_type_ = 0;
    ver_upd_src_ = 0;
    ver_upd_en_shr_ = 0;
    ver_upd_val_mask_ = 0;
    val_const_[0] = 0;
    val_const_[1] = 0;
    val_const_rot_[0] = 0;
    val_const_rot_[1] = 0;
    val_const_32b_bond_ = 0;
    clot_type_[0] = 0;
    clot_type_[1] = 0;
    clot_len_src_[0] = 0;
    clot_len_src_[1] = 0;
    clot_en_len_shr_[0] = 0;
    clot_en_len_shr_[1] = 0;
    clot_len_mask_[0] = 0;
    clot_len_mask_[1] = 0;
    clot_len_add_ = 0;
    clot_offset_[0] = 0;
    clot_offset_[1] = 0;
    clot_tag_[0] = 0;
    clot_tag_[1] = 0;
    clot_tag_offset_add_[0] = 0;
    clot_tag_offset_add_[1] = 0;
    clot_has_csum_[0] = 0;
    clot_has_csum_[1] = 0;
    hdr_len_inc_stop_ = 0;
    hdr_len_inc_final_amt_ = 0;
    disable_partial_hdr_err_ = 0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRowMutable") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("PrsrPoActionRowMutable") + ":\n";
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_src_[f]) ) + "\n";
      all_zeros &= (0 == phv_src_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("phv_offset_add_dst") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(phv_offset_add_dst_[f]) ) + "\n";
      all_zeros &= (0 == phv_offset_add_dst_[f]);
    }
    for (uint32_t f=0;f<20;++f) {
      r += indent_string + "  " + std::string("extract_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(extract_type_[f]) ) + "\n";
      all_zeros &= (0 == extract_type_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_addr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_addr_[f]) ) + "\n";
      all_zeros &= (0 == csum_addr_[f]);
    }
    for (uint32_t f=0;f<5;++f) {
      r += indent_string + "  " + std::string("csum_en") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(csum_en_[f]) ) + "\n";
      all_zeros &= (0 == csum_en_[f]);
    }
    r += indent_string + "  " + std::string("dst_offset_inc") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_inc_) ) + "\n";
    all_zeros &= (0 == dst_offset_inc_);
    r += indent_string + "  " + std::string("dst_offset_rst") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dst_offset_rst_) ) + "\n";
    all_zeros &= (0 == dst_offset_rst_);
    r += indent_string + "  " + std::string("pri_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_type_) ) + "\n";
    all_zeros &= (0 == pri_upd_type_);
    r += indent_string + "  " + std::string("pri_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_src_) ) + "\n";
    all_zeros &= (0 == pri_upd_src_);
    r += indent_string + "  " + std::string("pri_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == pri_upd_en_shr_);
    r += indent_string + "  " + std::string("pri_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(pri_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == pri_upd_val_mask_);
    r += indent_string + "  " + std::string("ver_upd_type") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_type_) ) + "\n";
    all_zeros &= (0 == ver_upd_type_);
    r += indent_string + "  " + std::string("ver_upd_src") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_src_) ) + "\n";
    all_zeros &= (0 == ver_upd_src_);
    r += indent_string + "  " + std::string("ver_upd_en_shr") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_en_shr_) ) + "\n";
    all_zeros &= (0 == ver_upd_en_shr_);
    r += indent_string + "  " + std::string("ver_upd_val_mask") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(ver_upd_val_mask_) ) + "\n";
    all_zeros &= (0 == ver_upd_val_mask_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_[f]) ) + "\n";
      all_zeros &= (0 == val_const_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("val_const_rot") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_rot_[f]) ) + "\n";
      all_zeros &= (0 == val_const_rot_[f]);
    }
    r += indent_string + "  " + std::string("val_const_32b_bond") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(val_const_32b_bond_) ) + "\n";
    all_zeros &= (0 == val_const_32b_bond_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_type") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_type_[f]) ) + "\n";
      all_zeros &= (0 == clot_type_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_src") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_src_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_src_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_en_len_shr") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_en_len_shr_[f]) ) + "\n";
      all_zeros &= (0 == clot_en_len_shr_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_len_mask") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_mask_[f]) ) + "\n";
      all_zeros &= (0 == clot_len_mask_[f]);
    }
    r += indent_string + "  " + std::string("clot_len_add") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_len_add_) ) + "\n";
    all_zeros &= (0 == clot_len_add_);
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_offset") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_offset_[f]) ) + "\n";
      all_zeros &= (0 == clot_offset_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_tag_offset_add") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_tag_offset_add_[f]) ) + "\n";
      all_zeros &= (0 == clot_tag_offset_add_[f]);
    }
    for (uint32_t f=0;f<2;++f) {
      r += indent_string + "  " + std::string("clot_has_csum") + "["+boost::lexical_cast<std::string>(f)+"]"+ ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(clot_has_csum_[f]) ) + "\n";
      all_zeros &= (0 == clot_has_csum_[f]);
    }
    r += indent_string + "  " + std::string("hdr_len_inc_stop") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_stop_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_stop_);
    r += indent_string + "  " + std::string("hdr_len_inc_final_amt") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(hdr_len_inc_final_amt_) ) + "\n";
    all_zeros &= (0 == hdr_len_inc_final_amt_);
    r += indent_string + "  " + std::string("disable_partial_hdr_err") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(disable_partial_hdr_err_) ) + "\n";
    all_zeros &= (0 == disable_partial_hdr_err_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< uint8_t, 20 > phv_src_;
  std::array< uint8_t, 20 > phv_dst_;
  std::array< uint8_t, 20 > phv_offset_add_dst_;
  std::array< uint8_t, 20 > extract_type_;
  std::array< uint8_t, 5 > csum_addr_;
  std::array< uint8_t, 5 > csum_en_;
  uint8_t dst_offset_inc_;
  uint8_t dst_offset_rst_;
  uint8_t pri_upd_type_;
  uint8_t pri_upd_src_;
  uint8_t pri_upd_en_shr_;
  uint8_t pri_upd_val_mask_;
  uint8_t ver_upd_type_;
  uint8_t ver_upd_src_;
  uint8_t ver_upd_en_shr_;
  uint8_t ver_upd_val_mask_;
  std::array< uint16_t, 2 > val_const_;
  std::array< uint8_t, 2 > val_const_rot_;
  uint8_t val_const_32b_bond_;
  std::array< uint8_t, 2 > clot_type_;
  std::array< uint8_t, 2 > clot_len_src_;
  std::array< uint8_t, 2 > clot_en_len_shr_;
  std::array< uint8_t, 2 > clot_len_mask_;
  uint8_t clot_len_add_;
  std::array< uint8_t, 2 > clot_offset_;
  std::array< uint8_t, 2 > clot_tag_;
  std::array< uint8_t, 2 > clot_tag_offset_add_;
  std::array< uint8_t, 2 > clot_has_csum_;
  uint8_t hdr_len_inc_stop_;
  uint8_t hdr_len_inc_final_amt_;
  uint8_t disable_partial_hdr_err_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int index_prsr_po_action_row
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        assert(index_prsr_po_action_row < 256);
        offset += index_prsr_po_action_row * 0x4; // prsr_po_action_row[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrsrPoActionRowArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRowArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 4 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), false, write_callback, read_callback, std::string("PrsrPoActionRowArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:








  uint8_t &phv_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_src(j0);
  }







  uint8_t &phv_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_dst(j0);
  }








  uint8_t &phv_offset_add_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_offset_add_dst(j0);
  }







  uint8_t &extract_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].extract_type(j0);
  }






  uint8_t &csum_addr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_addr(j0);
  }






  uint8_t &csum_en(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_en(j0);
  }






  uint8_t &dst_offset_inc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_inc();
  }






  uint8_t &dst_offset_rst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_rst();
  }






  uint8_t &pri_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_type();
  }






  uint8_t &pri_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_src();
  }







  uint8_t &pri_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_en_shr();
  }






  uint8_t &pri_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_val_mask();
  }






  uint8_t &ver_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_type();
  }






  uint8_t &ver_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_src();
  }







  uint8_t &ver_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_en_shr();
  }






  uint8_t &ver_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_val_mask();
  }







  uint16_t &val_const(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const(j0);
  }







  uint8_t &val_const_rot(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_rot(j0);
  }





  uint8_t &val_const_32b_bond(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_32b_bond();
  }








  uint8_t &clot_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_type(j0);
  }









  uint8_t &clot_len_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_src(j0);
  }









  uint8_t &clot_en_len_shr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_en_len_shr(j0);
  }







  uint8_t &clot_len_mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_mask(j0);
  }









  uint8_t &clot_len_add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_add();
  }







  uint8_t &clot_offset(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_offset(j0);
  }







  uint8_t &clot_tag(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag(j0);
  }







  uint8_t &clot_tag_offset_add(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag_offset_add(j0);
  }







  uint8_t &clot_has_csum(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_has_csum(j0);
  }






  uint8_t &hdr_len_inc_stop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_stop();
  }





  uint8_t &hdr_len_inc_final_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_final_amt();
  }





  uint8_t &disable_partial_hdr_err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].disable_partial_hdr_err();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/4;
    (*offset) -= (i*4);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoActionRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoActionRowArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoActionRow> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PrsrPoActionRowArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrPoActionRowArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 4 * ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1), true, write_callback, read_callback, std::string("PrsrPoActionRowArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec, 0))
    {
    }
public:








  uint8_t phv_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_src(j0);
  }
  void phv_src(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].phv_src(j0,v);
  }







  uint8_t phv_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_dst(j0);
  }
  void phv_dst(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].phv_dst(j0,v);
  }








  uint8_t phv_offset_add_dst(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].phv_offset_add_dst(j0);
  }
  void phv_offset_add_dst(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].phv_offset_add_dst(j0,v);
  }







  uint8_t extract_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].extract_type(j0);
  }
  void extract_type(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].extract_type(j0,v);
  }






  uint8_t csum_addr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_addr(j0);
  }
  void csum_addr(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].csum_addr(j0,v);
  }






  uint8_t csum_en(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csum_en(j0);
  }
  void csum_en(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].csum_en(j0,v);
  }






  uint8_t dst_offset_inc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_inc();
  }
  void dst_offset_inc(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst_offset_inc(v);
  }






  uint8_t dst_offset_rst(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dst_offset_rst();
  }
  void dst_offset_rst(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].dst_offset_rst(v);
  }






  uint8_t pri_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_type();
  }
  void pri_upd_type(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_type(v);
  }






  uint8_t pri_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_src();
  }
  void pri_upd_src(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_src(v);
  }







  uint8_t pri_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_en_shr();
  }
  void pri_upd_en_shr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_en_shr(v);
  }






  uint8_t pri_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].pri_upd_val_mask();
  }
  void pri_upd_val_mask(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].pri_upd_val_mask(v);
  }






  uint8_t ver_upd_type(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_type();
  }
  void ver_upd_type(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_type(v);
  }






  uint8_t ver_upd_src(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_src();
  }
  void ver_upd_src(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_src(v);
  }







  uint8_t ver_upd_en_shr(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_en_shr();
  }
  void ver_upd_en_shr(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_en_shr(v);
  }






  uint8_t ver_upd_val_mask(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ver_upd_val_mask();
  }
  void ver_upd_val_mask(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].ver_upd_val_mask(v);
  }







  uint16_t val_const(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const(j0);
  }
  void val_const(uint32_t a0,int j0,const uint16_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].val_const(j0,v);
  }







  uint8_t val_const_rot(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_rot(j0);
  }
  void val_const_rot(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].val_const_rot(j0,v);
  }





  uint8_t val_const_32b_bond(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].val_const_32b_bond();
  }
  void val_const_32b_bond(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].val_const_32b_bond(v);
  }








  uint8_t clot_type(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_type(j0);
  }
  void clot_type(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_type(j0,v);
  }









  uint8_t clot_len_src(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_src(j0);
  }
  void clot_len_src(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_len_src(j0,v);
  }









  uint8_t clot_en_len_shr(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_en_len_shr(j0);
  }
  void clot_en_len_shr(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_en_len_shr(j0,v);
  }







  uint8_t clot_len_mask(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_mask(j0);
  }
  void clot_len_mask(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_len_mask(j0,v);
  }









  uint8_t clot_len_add(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_len_add();
  }
  void clot_len_add(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_len_add(v);
  }







  uint8_t clot_offset(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_offset(j0);
  }
  void clot_offset(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_offset(j0,v);
  }







  uint8_t clot_tag(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag(j0);
  }
  void clot_tag(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_tag(j0,v);
  }







  uint8_t clot_tag_offset_add(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_tag_offset_add(j0);
  }
  void clot_tag_offset_add(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_tag_offset_add(j0,v);
  }







  uint8_t clot_has_csum(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].clot_has_csum(j0);
  }
  void clot_has_csum(uint32_t a0,int j0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].clot_has_csum(j0,v);
  }






  uint8_t hdr_len_inc_stop(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_stop();
  }
  void hdr_len_inc_stop(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].hdr_len_inc_stop(v);
  }





  uint8_t hdr_len_inc_final_amt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].hdr_len_inc_final_amt();
  }
  void hdr_len_inc_final_amt(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].hdr_len_inc_final_amt(v);
  }





  uint8_t disable_partial_hdr_err(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].disable_partial_hdr_err();
  }
  void disable_partial_hdr_err(uint32_t a0,const uint8_t &v) 
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    array[a0].disable_partial_hdr_err(v);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/4;
    (*offset) -= (i*4);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrPoActionRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrPoActionRowArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrPoActionRowMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 256;
            break;
          case 0:
            return 256;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};




class PrsrMemMainRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspec(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1728, false, write_callback, read_callback, std::string("PrsrMemMainRspec")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec))
    {
    }
  PrsrMemMainRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrsrMemMainRspec")
    {
    }
public:







  PrsrPoActionRow &po_action_row(int j0) { return po_action_row_[j0]; }








  PrsrMlTcamRow &ml_tcam_row(int j0) { return ml_tcam_row_[j0]; }







  PrsrMlEaRow &ml_ea_row(int j0) { return ml_ea_row_[j0]; }







  PrsrMlCtrInitRamM &ml_ctr_init_ram(int j0) { return ml_ctr_init_ram_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_0_row(int j0) { return po_csum_ctrl_0_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_1_row(int j0) { return po_csum_ctrl_1_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_2_row(int j0) { return po_csum_ctrl_2_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_3_row(int j0) { return po_csum_ctrl_3_row_[j0]; }






  PrsrPoCsumCtrlRow &po_csum_ctrl_4_row(int j0) { return po_csum_ctrl_4_row_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      po_action_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_tcam_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ea_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ctr_init_ram_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_0_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_1_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_2_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_3_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_4_row_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      po_action_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_tcam_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ea_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ctr_init_ram_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_0_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_1_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_2_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_3_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_4_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : po_action_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_tcam_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ea_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ctr_init_ram_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_0_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_1_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_2_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_3_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_4_row_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += po_action_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_tcam_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ea_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ctr_init_ram_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_0_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_1_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_2_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_3_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_4_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<256;++a0) {
      r += po_action_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_tcam_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_ea_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += ml_ctr_init_ram_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_0_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_1_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_2_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_3_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_4_row_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrPoActionRow, 256 > po_action_row_;
  std::array< PrsrMlTcamRow, 256 > ml_tcam_row_;
  std::array< PrsrMlEaRow, 256 > ml_ea_row_;
  std::array< PrsrMlCtrInitRamM, 16 > ml_ctr_init_ram_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_0_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_1_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_2_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_3_row_;
  std::array< PrsrPoCsumCtrlRow, 32 > po_csum_ctrl_4_row_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};




class PrsrMemMainRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspecMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem, index_prsr_mem_main_rspec), 1728, true, write_callback, read_callback, std::string("PrsrMemMainRspecMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem) + "," + boost::lexical_cast<std::string>(index_prsr_mem_main_rspec))
    {
    }
  PrsrMemMainRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrsrMemMainRspecMutable")
    {
    }
public:







  PrsrPoActionRowMutable &po_action_row(int j0) { return po_action_row_[j0]; }








  PrsrMlTcamRowMutable &ml_tcam_row(int j0) { return ml_tcam_row_[j0]; }







  PrsrMlEaRowMutable &ml_ea_row(int j0) { return ml_ea_row_[j0]; }







  PrsrMlCtrInitRamMMutable &ml_ctr_init_ram(int j0) { return ml_ctr_init_ram_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_0_row(int j0) { return po_csum_ctrl_0_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_1_row(int j0) { return po_csum_ctrl_1_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_2_row(int j0) { return po_csum_ctrl_2_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_3_row(int j0) { return po_csum_ctrl_3_row_[j0]; }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_4_row(int j0) { return po_csum_ctrl_4_row_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      po_action_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_tcam_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ea_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      ml_ctr_init_ram_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_0_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_1_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_2_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_3_row_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      if (read_callback_) read_callback_();
      po_csum_ctrl_4_row_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      po_action_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_tcam_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ea_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      ml_ctr_init_ram_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_0_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_1_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_2_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_3_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      po_csum_ctrl_4_row_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : po_action_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_tcam_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ea_row_) {
      f0.reset();
    }
    for (auto &f0 : ml_ctr_init_ram_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_0_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_1_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_2_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_3_row_) {
      f0.reset();
    }
    for (auto &f0 : po_csum_ctrl_4_row_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400) {
      offset -= 0x0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += po_action_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x500) {
      offset -= 0x400;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_tcam_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x600) {
      offset -= 0x500;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ea_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x610) {
      offset -= 0x600;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += ml_ctr_init_ram_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x620 && offset < 0x640) {
      offset -= 0x620;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_0_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x640 && offset < 0x660) {
      offset -= 0x640;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_1_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x660 && offset < 0x680) {
      offset -= 0x660;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_2_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x6a0) {
      offset -= 0x680;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_3_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a0 && offset < 0x6c0) {
      offset -= 0x6a0;
      int i0 = offset / 0x1;
      offset  -= i0 * 0x1;
      r += po_csum_ctrl_4_row_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<256;++a0) {
      r += po_action_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_tcam_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<256;++a0) {
      r += ml_ea_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += ml_ctr_init_ram_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_0_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_1_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_2_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_3_row_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<32;++a0) {
      r += po_csum_ctrl_4_row_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrPoActionRowMutable, 256 > po_action_row_;
  std::array< PrsrMlTcamRowMutable, 256 > ml_tcam_row_;
  std::array< PrsrMlEaRowMutable, 256 > ml_ea_row_;
  std::array< PrsrMlCtrInitRamMMutable, 16 > ml_ctr_init_ram_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_0_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_1_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_2_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_3_row_;
  std::array< PrsrPoCsumCtrlRowMutable, 32 > po_csum_ctrl_4_row_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int index_prsr_mem_main_rspec
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      case kIPrsrMem:
        assert(index_prsr_mem_main_rspec < 36);
        offset += index_prsr_mem_main_rspec * 0x800; // prsr_mem_main_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};




class PrsrMemMainRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspecArray(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem), 2048 * ArraySize(index_pipe_addrmap, selector_parde_mem, -1), false, write_callback, read_callback, std::string("PrsrMemMainRspecArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, 0))
    {
    }
public:







  PrsrPoActionRow &po_action_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_action_row(j0);
  }








  PrsrMlTcamRow &ml_tcam_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_tcam_row(j0);
  }







  PrsrMlEaRow &ml_ea_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ea_row(j0);
  }







  PrsrMlCtrInitRamM &ml_ctr_init_ram(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ctr_init_ram(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_0_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_0_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_1_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_1_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_2_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_2_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_3_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_3_row(j0);
  }






  PrsrPoCsumCtrlRow &po_csum_ctrl_4_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_4_row(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/2048;
    (*offset) -= (i*2048);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMemMainRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMemMainRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMemMainRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        break;
      case kIPrsrMem:
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};




class PrsrMemMainRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum PardeMemEnum {
    kEPrsrMem,
    kIPrsrMem
  };
public:
  PrsrMemMainRspecArrayMutable(
      int chipNumber, int index_pipe_addrmap, PardeMemEnum selector_parde_mem, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, selector_parde_mem), 2048 * ArraySize(index_pipe_addrmap, selector_parde_mem, -1), true, write_callback, read_callback, std::string("PrsrMemMainRspecArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(selector_parde_mem)),
    array(RealArraySize(index_pipe_addrmap, selector_parde_mem, -1)),
    size0_(ArraySize(index_pipe_addrmap, selector_parde_mem, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, selector_parde_mem, 0))
    {
    }
public:







  PrsrPoActionRowMutable &po_action_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_action_row(j0);
  }








  PrsrMlTcamRowMutable &ml_tcam_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_tcam_row(j0);
  }







  PrsrMlEaRowMutable &ml_ea_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ea_row(j0);
  }







  PrsrMlCtrInitRamMMutable &ml_ctr_init_ram(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].ml_ctr_init_ram(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_0_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_0_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_1_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_1_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_2_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_2_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_3_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_3_row(j0);
  }






  PrsrPoCsumCtrlRowMutable &po_csum_ctrl_4_row(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].po_csum_ctrl_4_row(j0);
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/2048;
    (*offset) -= (i*2048);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PrsrMemMainRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PrsrMemMainRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PrsrMemMainRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    switch (selector_parde_mem) {
      case kEPrsrMem:
        offset += 0x20000; // to get to e_prsr_mem
        break;
      case kIPrsrMem:
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, PardeMemEnum selector_parde_mem, int dimension
      ) {
    switch (selector_parde_mem) {
      case kEPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kIPrsrMem:
        switch (dimension) {
          case -1:
            return 36;
            break;
          case 0:
            return 36;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PardeMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PardeMem(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 221440, false, write_callback, read_callback, std::string("PardeMem")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PardeMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PardeMem")
    {
    }
public:



  PrsrMemMainRspec &i_prsr_mem(int j0) { return i_prsr_mem_[j0]; }



  PrsrMemMainRspec &e_prsr_mem(int j0) { return e_prsr_mem_[j0]; }





  PgrMemRspec &pgr_mem_rspec() { return pgr_mem_rspec_; }





  PgrPh0Rspec &pgr_ph0_rspec() { return pgr_ph0_rspec_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      i_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      e_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      if (read_callback_) read_callback_();
      pgr_mem_rspec_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      if (read_callback_) read_callback_();
      pgr_ph0_rspec_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      i_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      e_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      pgr_mem_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      pgr_ph0_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : i_prsr_mem_) {
      f0.reset();
    }
    for (auto &f0 : e_prsr_mem_) {
      f0.reset();
    }
    pgr_mem_rspec_.reset();
    pgr_ph0_rspec_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += i_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += e_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      r += pgr_mem_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      r += pgr_ph0_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<36;++a0) {
      r += i_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<36;++a0) {
      r += e_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pgr_mem_rspec_.to_string(print_zeros,indent_string) ;
    r += pgr_ph0_rspec_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrMemMainRspec, 36 > i_prsr_mem_;
  std::array< PrsrMemMainRspec, 36 > e_prsr_mem_;
  PgrMemRspec pgr_mem_rspec_;
  PgrPh0Rspec pgr_ph0_rspec_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    return offset;
  }

};








class PardeMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PardeMemMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 221440, true, write_callback, read_callback, std::string("PardeMemMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PardeMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PardeMemMutable")
    {
    }
public:



  PrsrMemMainRspecMutable &i_prsr_mem(int j0) { return i_prsr_mem_[j0]; }



  PrsrMemMainRspecMutable &e_prsr_mem(int j0) { return e_prsr_mem_[j0]; }





  PgrMemRspecMutable &pgr_mem_rspec() { return pgr_mem_rspec_; }





  PgrPh0RspecMutable &pgr_ph0_rspec() { return pgr_ph0_rspec_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      i_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      if (read_callback_) read_callback_();
      e_prsr_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      if (read_callback_) read_callback_();
      pgr_mem_rspec_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      if (read_callback_) read_callback_();
      pgr_ph0_rspec_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      i_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      e_prsr_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      pgr_mem_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      pgr_ph0_rspec_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : i_prsr_mem_) {
      f0.reset();
    }
    for (auto &f0 : e_prsr_mem_) {
      f0.reset();
    }
    pgr_mem_rspec_.reset();
    pgr_ph0_rspec_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0xf300) {
      offset -= 0x0;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += i_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x2f300) {
      offset -= 0x20000;
      int i0 = offset / 0x800;
      offset  -= i0 * 0x800;
      r += e_prsr_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x34000 && offset < 0x36000) {
      offset -= 0x34000;
      r += pgr_mem_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x36000 && offset < 0x36100) {
      offset -= 0x36000;
      r += pgr_ph0_rspec_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<36;++a0) {
      r += i_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<36;++a0) {
      r += e_prsr_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pgr_mem_rspec_.to_string(print_zeros,indent_string) ;
    r += pgr_ph0_rspec_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< PrsrMemMainRspecMutable, 36 > i_prsr_mem_;
  std::array< PrsrMemMainRspecMutable, 36 > e_prsr_mem_;
  PgrMemRspecMutable pgr_mem_rspec_;
  PgrPh0RspecMutable pgr_ph0_rspec_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    offset += 0x6080000000; // to get to parde
    return offset;
  }

};




class MauAddrmapDummyRegister : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmapDummyRegister(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, false, write_callback, read_callback, std::string("MauAddrmapDummyRegister")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmapDummyRegister(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "MauAddrmapDummyRegister")
    {
    }
public:
  uint64_t &dummy_field0() { return dummy_field0_; }
  uint64_t &dummy_field1() { return dummy_field1_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = dummy_field0_;
    *data1 = dummy_field1_;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    dummy_field0_ = data0;
    dummy_field1_ = data1;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    dummy_field0_ = UINT64_C(0);
    dummy_field1_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegister") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegister") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t dummy_field0_;
  uint64_t dummy_field1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};




class MauAddrmapDummyRegisterMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmapDummyRegisterMutable(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, true, write_callback, read_callback, std::string("MauAddrmapDummyRegisterMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmapDummyRegisterMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "MauAddrmapDummyRegisterMutable")
    {
    }
public:
  uint64_t dummy_field0() { return dummy_field0_; }
  void dummy_field0(const uint64_t &v) { dummy_field0_=v; }
  uint64_t dummy_field1() { return dummy_field1_; }
  void dummy_field1(const uint64_t &v) { dummy_field1_=v; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (read_callback_) read_callback_();
    *data0 = dummy_field0_;
    *data1 = dummy_field1_;
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    dummy_field0_ = data0;
    dummy_field1_ = data1;
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    dummy_field0_ = UINT64_C(0);
    dummy_field1_ = UINT64_C(0);
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegisterMutable") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("MauAddrmapDummyRegisterMutable") + ":\n";
    r += indent_string + "  " + std::string("dummy_field0") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field0_) ) + "\n";
    all_zeros &= (0 == dummy_field0_);
    r += indent_string + "  " + std::string("dummy_field1") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(dummy_field1_) ) + "\n";
    all_zeros &= (0 == dummy_field1_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint64_t dummy_field0_;
  uint64_t dummy_field1_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};








class MauAddrmap : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmap(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, false, write_callback, read_callback, std::string("MauAddrmap")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmap(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "MauAddrmap")
    {
    }
public:
  MauAddrmapDummyRegister &dummy_register() { return dummy_register_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      dummy_register_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      offset -= 0x0;
      dummy_register_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    dummy_register_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x1) {
      offset -= 0x0;
      r += dummy_register_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += dummy_register_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  MauAddrmapDummyRegister dummy_register_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};








class MauAddrmapMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  MauAddrmapMutable(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 1, true, write_callback, read_callback, std::string("MauAddrmapMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauAddrmapMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "MauAddrmapMutable")
    {
    }
public:
  MauAddrmapDummyRegisterMutable &dummy_register() { return dummy_register_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x1) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      dummy_register_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x1) {
      offset -= 0x0;
      dummy_register_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    dummy_register_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x1) {
      offset -= 0x0;
      r += dummy_register_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += dummy_register_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  MauAddrmapDummyRegisterMutable dummy_register_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    assert(index_mau_addrmap < 20);
    offset += index_mau_addrmap * 0x400000000; // mau_addrmap[]
    return offset;
  }

};








class MauAddrmapArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  MauAddrmapArray(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 17179869184 * ArraySize(index_pipe_addrmap, -1), false, write_callback, read_callback, std::string("MauAddrmapArray")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:
  MauAddrmapDummyRegister &dummy_register(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dummy_register();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/17179869184;
    (*offset) -= (i*17179869184);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("MauAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("MauAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<MauAddrmap> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class MauAddrmapArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  MauAddrmapArrayMutable(
      int chipNumber, int index_pipe_addrmap, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 17179869184 * ArraySize(index_pipe_addrmap, -1), true, write_callback, read_callback, std::string("MauAddrmapArrayMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap)),
    array(RealArraySize(index_pipe_addrmap, -1)),
    size0_(ArraySize(index_pipe_addrmap, 0)),
    real_size0_(RealArraySize(index_pipe_addrmap, 0))
    {
    }
public:
  MauAddrmapDummyRegisterMutable &dummy_register(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].dummy_register();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/17179869184;
    (*offset) -= (i*17179869184);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("MauAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("MauAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<MauAddrmapMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

  static int ArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int index_pipe_addrmap, int dimension
      ) {
    switch (dimension) {
      case -1:
        return 20;
        break;
      case 0:
        return 20;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PipeAddrmap : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PipeAddrmap(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 414464565504, false, write_callback, read_callback, std::string("PipeAddrmap")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PipeAddrmap(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PipeAddrmap")
    {
    }
public:







  MauAddrmap &mau(int j0) { return mau_[j0]; }





  PardeMem &parde() { return parde_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      if (read_callback_) read_callback_();
      mau_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      if (read_callback_) read_callback_();
      parde_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      mau_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      parde_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mau_) {
      f0.reset();
    }
    parde_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      r += mau_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      r += parde_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<20;++a0) {
      r += mau_[a0].to_string(print_zeros,indent_string) ;
    }
    r += parde_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< MauAddrmap, 20 > mau_;
  PardeMem parde_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

};








class PipeAddrmapMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PipeAddrmapMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_pipe_addrmap), 414464565504, true, write_callback, read_callback, std::string("PipeAddrmapMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  PipeAddrmapMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PipeAddrmapMutable")
    {
    }
public:







  MauAddrmapMutable &mau(int j0) { return mau_[j0]; }





  PardeMemMutable &parde() { return parde_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      if (read_callback_) read_callback_();
      mau_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      if (read_callback_) read_callback_();
      parde_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      mau_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      parde_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mau_) {
      f0.reset();
    }
    parde_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x14) {
      offset -= 0x0;
      int i0 = offset / 0x400000000;
      offset  -= i0 * 0x400000000;
      r += mau_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6080000000 && offset < 0x6080036100) {
      offset -= 0x6080000000;
      r += parde_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<20;++a0) {
      r += mau_[a0].to_string(print_zeros,indent_string) ;
    }
    r += parde_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< MauAddrmapMutable, 20 > mau_;
  PardeMemMutable parde_;
private:
  static uint64_t StartOffset(
      int index_pipe_addrmap
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x8000000000; // pipe_addrmap[]
    return offset;
  }

};








class PipeAddrmapArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PipeAddrmapArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 549755813888 * ArraySize(-1), false, write_callback, read_callback, std::string("PipeAddrmapArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  MauAddrmap &mau(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mau(j0);
  }





  PardeMem &parde(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].parde();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/549755813888;
    (*offset) -= (i*549755813888);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PipeAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PipeAddrmapArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PipeAddrmap> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class PipeAddrmapArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  PipeAddrmapArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 549755813888 * ArraySize(-1), true, write_callback, read_callback, std::string("PipeAddrmapArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  MauAddrmapMutable &mau(uint32_t a0,int j0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mau(j0);
  }





  PardeMemMutable &parde(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].parde();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/549755813888;
    (*offset) -= (i*549755813888);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("PipeAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("PipeAddrmapArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<PipeAddrmapMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x20000000000; // to get to pipes
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};











class PscBlockFreePtrMemory : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPscMemTopRspecEnum {
    kPscBlockGrp0,
    kPscBlockGrp1,
    kPscBlockGrp2,
    kPscBlockGrp3,
    kPscBlockGrp4,
    kPscBlockGrp5
  };
public:
  PscBlockFreePtrMemory(
      int chipNumber, TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_psc_mem_top_rspec), 32768, false, write_callback, read_callback, std::string("PscBlockFreePtrMemory")+":"+boost::lexical_cast<std::string>(selector_tm_psc_mem_top_rspec))
    {
    }
  PscBlockFreePtrMemory(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PscBlockFreePtrMemory")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        break;
      case kPscBlockGrp1:
        offset += 0x8000; // to get to psc_block_grp1
        break;
      case kPscBlockGrp2:
        offset += 0x10000; // to get to psc_block_grp2
        break;
      case kPscBlockGrp3:
        offset += 0x18000; // to get to psc_block_grp3
        break;
      case kPscBlockGrp4:
        offset += 0x20000; // to get to psc_block_grp4
        break;
      case kPscBlockGrp5:
        offset += 0x28000; // to get to psc_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class PscBlockFreePtrMemoryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPscMemTopRspecEnum {
    kPscBlockGrp0,
    kPscBlockGrp1,
    kPscBlockGrp2,
    kPscBlockGrp3,
    kPscBlockGrp4,
    kPscBlockGrp5
  };
public:
  PscBlockFreePtrMemoryMutable(
      int chipNumber, TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_psc_mem_top_rspec), 32768, true, write_callback, read_callback, std::string("PscBlockFreePtrMemoryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_psc_mem_top_rspec))
    {
    }
  PscBlockFreePtrMemoryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PscBlockFreePtrMemoryMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPscMemTopRspecEnum selector_tm_psc_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    switch (selector_tm_psc_mem_top_rspec) {
      case kPscBlockGrp0:
        break;
      case kPscBlockGrp1:
        offset += 0x8000; // to get to psc_block_grp1
        break;
      case kPscBlockGrp2:
        offset += 0x10000; // to get to psc_block_grp2
        break;
      case kPscBlockGrp3:
        offset += 0x18000; // to get to psc_block_grp3
        break;
      case kPscBlockGrp4:
        offset += 0x20000; // to get to psc_block_grp4
        break;
      case kPscBlockGrp5:
        offset += 0x28000; // to get to psc_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPscMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPscMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPscMemTopRspec"))
    {
    }
  TmPscMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPscMemTopRspec")
    {
    }
public:








  PscBlockFreePtrMemory &psc_block_grp0() { return psc_block_grp0_; }








  PscBlockFreePtrMemory &psc_block_grp1() { return psc_block_grp1_; }








  PscBlockFreePtrMemory &psc_block_grp2() { return psc_block_grp2_; }








  PscBlockFreePtrMemory &psc_block_grp3() { return psc_block_grp3_; }








  PscBlockFreePtrMemory &psc_block_grp4() { return psc_block_grp4_; }








  PscBlockFreePtrMemory &psc_block_grp5() { return psc_block_grp5_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      psc_block_grp0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      if (read_callback_) read_callback_();
      psc_block_grp1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      if (read_callback_) read_callback_();
      psc_block_grp2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      if (read_callback_) read_callback_();
      psc_block_grp3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      if (read_callback_) read_callback_();
      psc_block_grp4_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      if (read_callback_) read_callback_();
      psc_block_grp5_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      psc_block_grp0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      psc_block_grp1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      psc_block_grp2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      psc_block_grp3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      psc_block_grp4_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      psc_block_grp5_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    psc_block_grp0_.reset();
    psc_block_grp1_.reset();
    psc_block_grp2_.reset();
    psc_block_grp3_.reset();
    psc_block_grp4_.reset();
    psc_block_grp5_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      r += psc_block_grp0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      r += psc_block_grp1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      r += psc_block_grp2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      r += psc_block_grp3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      r += psc_block_grp4_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      r += psc_block_grp5_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += psc_block_grp0_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp1_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp2_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp3_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp4_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp5_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  PscBlockFreePtrMemory psc_block_grp0_;
  PscBlockFreePtrMemory psc_block_grp1_;
  PscBlockFreePtrMemory psc_block_grp2_;
  PscBlockFreePtrMemory psc_block_grp3_;
  PscBlockFreePtrMemory psc_block_grp4_;
  PscBlockFreePtrMemory psc_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    return offset;
  }

};








class TmPscMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPscMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPscMemTopRspecMutable"))
    {
    }
  TmPscMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPscMemTopRspecMutable")
    {
    }
public:








  PscBlockFreePtrMemoryMutable &psc_block_grp0() { return psc_block_grp0_; }








  PscBlockFreePtrMemoryMutable &psc_block_grp1() { return psc_block_grp1_; }








  PscBlockFreePtrMemoryMutable &psc_block_grp2() { return psc_block_grp2_; }








  PscBlockFreePtrMemoryMutable &psc_block_grp3() { return psc_block_grp3_; }








  PscBlockFreePtrMemoryMutable &psc_block_grp4() { return psc_block_grp4_; }








  PscBlockFreePtrMemoryMutable &psc_block_grp5() { return psc_block_grp5_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      psc_block_grp0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      if (read_callback_) read_callback_();
      psc_block_grp1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      if (read_callback_) read_callback_();
      psc_block_grp2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      if (read_callback_) read_callback_();
      psc_block_grp3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      if (read_callback_) read_callback_();
      psc_block_grp4_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      if (read_callback_) read_callback_();
      psc_block_grp5_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      psc_block_grp0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      psc_block_grp1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      psc_block_grp2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      psc_block_grp3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      psc_block_grp4_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      psc_block_grp5_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    psc_block_grp0_.reset();
    psc_block_grp1_.reset();
    psc_block_grp2_.reset();
    psc_block_grp3_.reset();
    psc_block_grp4_.reset();
    psc_block_grp5_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      r += psc_block_grp0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      r += psc_block_grp1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      r += psc_block_grp2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      r += psc_block_grp3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      r += psc_block_grp4_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      r += psc_block_grp5_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += psc_block_grp0_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp1_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp2_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp3_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp4_.to_string(print_zeros,indent_string) ;
    r += psc_block_grp5_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  PscBlockFreePtrMemoryMutable psc_block_grp0_;
  PscBlockFreePtrMemoryMutable psc_block_grp1_;
  PscBlockFreePtrMemoryMutable psc_block_grp2_;
  PscBlockFreePtrMemoryMutable psc_block_grp3_;
  PscBlockFreePtrMemoryMutable psc_block_grp4_;
  PscBlockFreePtrMemoryMutable psc_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6a00000000; // to get to tm_psc
    return offset;
  }

};








class TmPrePmtMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPmt0MemWord0,
    kPmt0MemWord1,
    kPmt0MemWord2,
    kPmt0MemWord3,
    kPmt1MemWord0,
    kPmt1MemWord1,
    kPmt1MemWord2,
    kPmt1MemWord3
  };
public:
  TmPrePmtMemWord(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 288, false, write_callback, read_callback, std::string("TmPrePmtMemWord")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPrePmtMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrePmtMemWord")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        offset += 0x80200000; // to get to pmt0_mem_word0
        break;
      case kPmt0MemWord1:
        offset += 0x80240000; // to get to pmt0_mem_word1
        break;
      case kPmt0MemWord2:
        offset += 0x80280000; // to get to pmt0_mem_word2
        break;
      case kPmt0MemWord3:
        offset += 0x802c0000; // to get to pmt0_mem_word3
        break;
      case kPmt1MemWord0:
        offset += 0x80300000; // to get to pmt1_mem_word0
        break;
      case kPmt1MemWord1:
        offset += 0x80340000; // to get to pmt1_mem_word1
        break;
      case kPmt1MemWord2:
        offset += 0x80380000; // to get to pmt1_mem_word2
        break;
      case kPmt1MemWord3:
        offset += 0x803c0000; // to get to pmt1_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPrePmtMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPmt0MemWord0,
    kPmt0MemWord1,
    kPmt0MemWord2,
    kPmt0MemWord3,
    kPmt1MemWord0,
    kPmt1MemWord1,
    kPmt1MemWord2,
    kPmt1MemWord3
  };
public:
  TmPrePmtMemWordMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 288, true, write_callback, read_callback, std::string("TmPrePmtMemWordMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPrePmtMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrePmtMemWordMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPmt0MemWord0:
        offset += 0x80200000; // to get to pmt0_mem_word0
        break;
      case kPmt0MemWord1:
        offset += 0x80240000; // to get to pmt0_mem_word1
        break;
      case kPmt0MemWord2:
        offset += 0x80280000; // to get to pmt0_mem_word2
        break;
      case kPmt0MemWord3:
        offset += 0x802c0000; // to get to pmt0_mem_word3
        break;
      case kPmt1MemWord0:
        offset += 0x80300000; // to get to pmt1_mem_word0
        break;
      case kPmt1MemWord1:
        offset += 0x80340000; // to get to pmt1_mem_word1
        break;
      case kPmt1MemWord2:
        offset += 0x80380000; // to get to pmt1_mem_word2
        break;
      case kPmt1MemWord3:
        offset += 0x803c0000; // to get to pmt1_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitBmMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0BmMemWord0,
    kLit0BmMemWord1,
    kLit0BmMemWord2,
    kLit0BmMemWord3,
    kLit1BmMemWord0,
    kLit1BmMemWord1,
    kLit1BmMemWord2,
    kLit1BmMemWord3
  };
public:
  TmPreLitBmMemWord(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 256, false, write_callback, read_callback, std::string("TmPreLitBmMemWord")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPreLitBmMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreLitBmMemWord")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        offset += 0x80000000; // to get to lit0_bm_mem_word0
        break;
      case kLit0BmMemWord1:
        offset += 0x80040000; // to get to lit0_bm_mem_word1
        break;
      case kLit0BmMemWord2:
        offset += 0x80080000; // to get to lit0_bm_mem_word2
        break;
      case kLit0BmMemWord3:
        offset += 0x800c0000; // to get to lit0_bm_mem_word3
        break;
      case kLit1BmMemWord0:
        offset += 0x80100000; // to get to lit1_bm_mem_word0
        break;
      case kLit1BmMemWord1:
        offset += 0x80140000; // to get to lit1_bm_mem_word1
        break;
      case kLit1BmMemWord2:
        offset += 0x80180000; // to get to lit1_bm_mem_word2
        break;
      case kLit1BmMemWord3:
        offset += 0x801c0000; // to get to lit1_bm_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitBmMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0BmMemWord0,
    kLit0BmMemWord1,
    kLit0BmMemWord2,
    kLit0BmMemWord3,
    kLit1BmMemWord0,
    kLit1BmMemWord1,
    kLit1BmMemWord2,
    kLit1BmMemWord3
  };
public:
  TmPreLitBmMemWordMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 256, true, write_callback, read_callback, std::string("TmPreLitBmMemWordMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPreLitBmMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreLitBmMemWordMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0BmMemWord0:
        offset += 0x80000000; // to get to lit0_bm_mem_word0
        break;
      case kLit0BmMemWord1:
        offset += 0x80040000; // to get to lit0_bm_mem_word1
        break;
      case kLit0BmMemWord2:
        offset += 0x80080000; // to get to lit0_bm_mem_word2
        break;
      case kLit0BmMemWord3:
        offset += 0x800c0000; // to get to lit0_bm_mem_word3
        break;
      case kLit1BmMemWord0:
        offset += 0x80100000; // to get to lit1_bm_mem_word0
        break;
      case kLit1BmMemWord1:
        offset += 0x80140000; // to get to lit1_bm_mem_word1
        break;
      case kLit1BmMemWord2:
        offset += 0x80180000; // to get to lit1_bm_mem_word2
        break;
      case kLit1BmMemWord3:
        offset += 0x801c0000; // to get to lit1_bm_mem_word3
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitNpMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0NpMemWord,
    kLit1NpMemWord
  };
public:
  TmPreLitNpMemWord(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 256, false, write_callback, read_callback, std::string("TmPreLitNpMemWord")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPreLitNpMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreLitNpMemWord")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        offset += 0x40200000; // to get to lit0_np_mem_word
        break;
      case kLit1NpMemWord:
        offset += 0x40300000; // to get to lit1_np_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreLitNpMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kLit0NpMemWord,
    kLit1NpMemWord
  };
public:
  TmPreLitNpMemWordMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 256, true, write_callback, read_callback, std::string("TmPreLitNpMemWordMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPreLitNpMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreLitNpMemWordMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kLit0NpMemWord:
        offset += 0x40200000; // to get to lit0_np_mem_word
        break;
      case kLit1NpMemWord:
        offset += 0x40300000; // to get to lit1_np_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPrePbtMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPbt0MemWord,
    kPbt1MemWord
  };
public:
  TmPrePbtMemWord(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 288, false, write_callback, read_callback, std::string("TmPrePbtMemWord")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPrePbtMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrePbtMemWord")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        offset += 0x40000000; // to get to pbt0_mem_word
        break;
      case kPbt1MemWord:
        offset += 0x40100000; // to get to pbt1_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPrePbtMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPreCommonMemRspecEnum {
    kPbt0MemWord,
    kPbt1MemWord
  };
public:
  TmPrePbtMemWordMutable(
      int chipNumber, TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_pre_common_mem_rspec), 288, true, write_callback, read_callback, std::string("TmPrePbtMemWordMutable")+":"+boost::lexical_cast<std::string>(selector_tm_pre_common_mem_rspec))
    {
    }
  TmPrePbtMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrePbtMemWordMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmPreCommonMemRspecEnum selector_tm_pre_common_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    switch (selector_tm_pre_common_mem_rspec) {
      case kPbt0MemWord:
        offset += 0x40000000; // to get to pbt0_mem_word
        break;
      case kPbt1MemWord:
        offset += 0x40100000; // to get to pbt1_mem_word
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmPreRdmMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreRdmMemWord(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 524288, false, write_callback, read_callback, std::string("TmPreRdmMemWord"))
    {
    }
  TmPreRdmMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreRdmMemWord")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    offset += 0x400000; // to get to rdm_mem_word
    return offset;
  }

};








class TmPreRdmMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreRdmMemWordMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 524288, true, write_callback, read_callback, std::string("TmPreRdmMemWordMutable"))
    {
    }
  TmPreRdmMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreRdmMemWordMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    offset += 0x400000; // to get to rdm_mem_word
    return offset;
  }

};








class TmPreCommonMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreCommonMemRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4294967296, false, write_callback, read_callback, std::string("TmPreCommonMemRspec"))
    {
    }
  TmPreCommonMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreCommonMemRspec")
    {
    }
public:





  TmPreRdmMemWord &rdm_mem_word() { return rdm_mem_word_; }





  TmPrePbtMemWord &pbt0_mem_word() { return pbt0_mem_word_; }





  TmPrePbtMemWord &pbt1_mem_word() { return pbt1_mem_word_; }





  TmPreLitNpMemWord &lit0_np_mem_word() { return lit0_np_mem_word_; }





  TmPreLitNpMemWord &lit1_np_mem_word() { return lit1_np_mem_word_; }





  TmPreLitBmMemWord &lit0_bm_mem_word0() { return lit0_bm_mem_word0_; }





  TmPreLitBmMemWord &lit0_bm_mem_word1() { return lit0_bm_mem_word1_; }





  TmPreLitBmMemWord &lit0_bm_mem_word2() { return lit0_bm_mem_word2_; }





  TmPreLitBmMemWord &lit0_bm_mem_word3() { return lit0_bm_mem_word3_; }





  TmPreLitBmMemWord &lit1_bm_mem_word0() { return lit1_bm_mem_word0_; }





  TmPreLitBmMemWord &lit1_bm_mem_word1() { return lit1_bm_mem_word1_; }





  TmPreLitBmMemWord &lit1_bm_mem_word2() { return lit1_bm_mem_word2_; }





  TmPreLitBmMemWord &lit1_bm_mem_word3() { return lit1_bm_mem_word3_; }





  TmPrePmtMemWord &pmt0_mem_word0() { return pmt0_mem_word0_; }





  TmPrePmtMemWord &pmt0_mem_word1() { return pmt0_mem_word1_; }





  TmPrePmtMemWord &pmt0_mem_word2() { return pmt0_mem_word2_; }





  TmPrePmtMemWord &pmt0_mem_word3() { return pmt0_mem_word3_; }





  TmPrePmtMemWord &pmt1_mem_word0() { return pmt1_mem_word0_; }





  TmPrePmtMemWord &pmt1_mem_word1() { return pmt1_mem_word1_; }





  TmPrePmtMemWord &pmt1_mem_word2() { return pmt1_mem_word2_; }





  TmPrePmtMemWord &pmt1_mem_word3() { return pmt1_mem_word3_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      if (read_callback_) read_callback_();
      rdm_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      if (read_callback_) read_callback_();
      pbt0_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      if (read_callback_) read_callback_();
      pbt1_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      if (read_callback_) read_callback_();
      lit0_np_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      if (read_callback_) read_callback_();
      lit1_np_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      if (read_callback_) read_callback_();
      pmt0_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      if (read_callback_) read_callback_();
      pmt0_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      if (read_callback_) read_callback_();
      pmt0_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      if (read_callback_) read_callback_();
      pmt0_mem_word3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      if (read_callback_) read_callback_();
      pmt1_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      if (read_callback_) read_callback_();
      pmt1_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      if (read_callback_) read_callback_();
      pmt1_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      if (read_callback_) read_callback_();
      pmt1_mem_word3_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      rdm_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      pbt0_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      pbt1_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      lit0_np_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      lit1_np_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      lit0_bm_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      lit0_bm_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      lit0_bm_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      lit0_bm_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      lit1_bm_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      lit1_bm_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      lit1_bm_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      lit1_bm_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      pmt0_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      pmt0_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      pmt0_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      pmt0_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      pmt1_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      pmt1_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      pmt1_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      pmt1_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    rdm_mem_word_.reset();
    pbt0_mem_word_.reset();
    pbt1_mem_word_.reset();
    lit0_np_mem_word_.reset();
    lit1_np_mem_word_.reset();
    lit0_bm_mem_word0_.reset();
    lit0_bm_mem_word1_.reset();
    lit0_bm_mem_word2_.reset();
    lit0_bm_mem_word3_.reset();
    lit1_bm_mem_word0_.reset();
    lit1_bm_mem_word1_.reset();
    lit1_bm_mem_word2_.reset();
    lit1_bm_mem_word3_.reset();
    pmt0_mem_word0_.reset();
    pmt0_mem_word1_.reset();
    pmt0_mem_word2_.reset();
    pmt0_mem_word3_.reset();
    pmt1_mem_word0_.reset();
    pmt1_mem_word1_.reset();
    pmt1_mem_word2_.reset();
    pmt1_mem_word3_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      r += rdm_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      r += pbt0_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      r += pbt1_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      r += lit0_np_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      r += lit1_np_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      r += lit0_bm_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      r += lit0_bm_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      r += lit0_bm_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      r += lit0_bm_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      r += lit1_bm_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      r += lit1_bm_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      r += lit1_bm_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      r += lit1_bm_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      r += pmt0_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      r += pmt0_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      r += pmt0_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      r += pmt0_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      r += pmt1_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      r += pmt1_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      r += pmt1_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      r += pmt1_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += rdm_mem_word_.to_string(print_zeros,indent_string) ;
    r += pbt0_mem_word_.to_string(print_zeros,indent_string) ;
    r += pbt1_mem_word_.to_string(print_zeros,indent_string) ;
    r += lit0_np_mem_word_.to_string(print_zeros,indent_string) ;
    r += lit1_np_mem_word_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word0_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word1_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word2_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word3_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word0_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word1_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word2_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word3_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word0_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word1_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word2_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word3_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word0_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word1_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word2_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word3_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmPreRdmMemWord rdm_mem_word_;
  TmPrePbtMemWord pbt0_mem_word_;
  TmPrePbtMemWord pbt1_mem_word_;
  TmPreLitNpMemWord lit0_np_mem_word_;
  TmPreLitNpMemWord lit1_np_mem_word_;
  TmPreLitBmMemWord lit0_bm_mem_word0_;
  TmPreLitBmMemWord lit0_bm_mem_word1_;
  TmPreLitBmMemWord lit0_bm_mem_word2_;
  TmPreLitBmMemWord lit0_bm_mem_word3_;
  TmPreLitBmMemWord lit1_bm_mem_word0_;
  TmPreLitBmMemWord lit1_bm_mem_word1_;
  TmPreLitBmMemWord lit1_bm_mem_word2_;
  TmPreLitBmMemWord lit1_bm_mem_word3_;
  TmPrePmtMemWord pmt0_mem_word0_;
  TmPrePmtMemWord pmt0_mem_word1_;
  TmPrePmtMemWord pmt0_mem_word2_;
  TmPrePmtMemWord pmt0_mem_word3_;
  TmPrePmtMemWord pmt1_mem_word0_;
  TmPrePmtMemWord pmt1_mem_word1_;
  TmPrePmtMemWord pmt1_mem_word2_;
  TmPrePmtMemWord pmt1_mem_word3_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    return offset;
  }

};








class TmPreCommonMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreCommonMemRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4294967296, true, write_callback, read_callback, std::string("TmPreCommonMemRspecMutable"))
    {
    }
  TmPreCommonMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreCommonMemRspecMutable")
    {
    }
public:





  TmPreRdmMemWordMutable &rdm_mem_word() { return rdm_mem_word_; }





  TmPrePbtMemWordMutable &pbt0_mem_word() { return pbt0_mem_word_; }





  TmPrePbtMemWordMutable &pbt1_mem_word() { return pbt1_mem_word_; }





  TmPreLitNpMemWordMutable &lit0_np_mem_word() { return lit0_np_mem_word_; }





  TmPreLitNpMemWordMutable &lit1_np_mem_word() { return lit1_np_mem_word_; }





  TmPreLitBmMemWordMutable &lit0_bm_mem_word0() { return lit0_bm_mem_word0_; }





  TmPreLitBmMemWordMutable &lit0_bm_mem_word1() { return lit0_bm_mem_word1_; }





  TmPreLitBmMemWordMutable &lit0_bm_mem_word2() { return lit0_bm_mem_word2_; }





  TmPreLitBmMemWordMutable &lit0_bm_mem_word3() { return lit0_bm_mem_word3_; }





  TmPreLitBmMemWordMutable &lit1_bm_mem_word0() { return lit1_bm_mem_word0_; }





  TmPreLitBmMemWordMutable &lit1_bm_mem_word1() { return lit1_bm_mem_word1_; }





  TmPreLitBmMemWordMutable &lit1_bm_mem_word2() { return lit1_bm_mem_word2_; }





  TmPreLitBmMemWordMutable &lit1_bm_mem_word3() { return lit1_bm_mem_word3_; }





  TmPrePmtMemWordMutable &pmt0_mem_word0() { return pmt0_mem_word0_; }





  TmPrePmtMemWordMutable &pmt0_mem_word1() { return pmt0_mem_word1_; }





  TmPrePmtMemWordMutable &pmt0_mem_word2() { return pmt0_mem_word2_; }





  TmPrePmtMemWordMutable &pmt0_mem_word3() { return pmt0_mem_word3_; }





  TmPrePmtMemWordMutable &pmt1_mem_word0() { return pmt1_mem_word0_; }





  TmPrePmtMemWordMutable &pmt1_mem_word1() { return pmt1_mem_word1_; }





  TmPrePmtMemWordMutable &pmt1_mem_word2() { return pmt1_mem_word2_; }





  TmPrePmtMemWordMutable &pmt1_mem_word3() { return pmt1_mem_word3_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      if (read_callback_) read_callback_();
      rdm_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      if (read_callback_) read_callback_();
      pbt0_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      if (read_callback_) read_callback_();
      pbt1_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      if (read_callback_) read_callback_();
      lit0_np_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      if (read_callback_) read_callback_();
      lit1_np_mem_word_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      if (read_callback_) read_callback_();
      lit0_bm_mem_word3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      if (read_callback_) read_callback_();
      lit1_bm_mem_word3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      if (read_callback_) read_callback_();
      pmt0_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      if (read_callback_) read_callback_();
      pmt0_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      if (read_callback_) read_callback_();
      pmt0_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      if (read_callback_) read_callback_();
      pmt0_mem_word3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      if (read_callback_) read_callback_();
      pmt1_mem_word0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      if (read_callback_) read_callback_();
      pmt1_mem_word1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      if (read_callback_) read_callback_();
      pmt1_mem_word2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      if (read_callback_) read_callback_();
      pmt1_mem_word3_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      rdm_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      pbt0_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      pbt1_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      lit0_np_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      lit1_np_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      lit0_bm_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      lit0_bm_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      lit0_bm_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      lit0_bm_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      lit1_bm_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      lit1_bm_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      lit1_bm_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      lit1_bm_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      pmt0_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      pmt0_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      pmt0_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      pmt0_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      pmt1_mem_word0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      pmt1_mem_word1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      pmt1_mem_word2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      pmt1_mem_word3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    rdm_mem_word_.reset();
    pbt0_mem_word_.reset();
    pbt1_mem_word_.reset();
    lit0_np_mem_word_.reset();
    lit1_np_mem_word_.reset();
    lit0_bm_mem_word0_.reset();
    lit0_bm_mem_word1_.reset();
    lit0_bm_mem_word2_.reset();
    lit0_bm_mem_word3_.reset();
    lit1_bm_mem_word0_.reset();
    lit1_bm_mem_word1_.reset();
    lit1_bm_mem_word2_.reset();
    lit1_bm_mem_word3_.reset();
    pmt0_mem_word0_.reset();
    pmt0_mem_word1_.reset();
    pmt0_mem_word2_.reset();
    pmt0_mem_word3_.reset();
    pmt1_mem_word0_.reset();
    pmt1_mem_word1_.reset();
    pmt1_mem_word2_.reset();
    pmt1_mem_word3_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x400000 && offset < 0x480000) {
      offset -= 0x400000;
      r += rdm_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40000000 && offset < 0x40000120) {
      offset -= 0x40000000;
      r += pbt0_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40100000 && offset < 0x40100120) {
      offset -= 0x40100000;
      r += pbt1_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40200000 && offset < 0x40200100) {
      offset -= 0x40200000;
      r += lit0_np_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40300000 && offset < 0x40300100) {
      offset -= 0x40300000;
      r += lit1_np_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000000 && offset < 0x80000100) {
      offset -= 0x80000000;
      r += lit0_bm_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80040000 && offset < 0x80040100) {
      offset -= 0x80040000;
      r += lit0_bm_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80080000 && offset < 0x80080100) {
      offset -= 0x80080000;
      r += lit0_bm_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800c0000 && offset < 0x800c0100) {
      offset -= 0x800c0000;
      r += lit0_bm_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80100000 && offset < 0x80100100) {
      offset -= 0x80100000;
      r += lit1_bm_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80140000 && offset < 0x80140100) {
      offset -= 0x80140000;
      r += lit1_bm_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80180000 && offset < 0x80180100) {
      offset -= 0x80180000;
      r += lit1_bm_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x801c0000 && offset < 0x801c0100) {
      offset -= 0x801c0000;
      r += lit1_bm_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80200000 && offset < 0x80200120) {
      offset -= 0x80200000;
      r += pmt0_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80240000 && offset < 0x80240120) {
      offset -= 0x80240000;
      r += pmt0_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80280000 && offset < 0x80280120) {
      offset -= 0x80280000;
      r += pmt0_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x802c0000 && offset < 0x802c0120) {
      offset -= 0x802c0000;
      r += pmt0_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80300000 && offset < 0x80300120) {
      offset -= 0x80300000;
      r += pmt1_mem_word0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80340000 && offset < 0x80340120) {
      offset -= 0x80340000;
      r += pmt1_mem_word1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80380000 && offset < 0x80380120) {
      offset -= 0x80380000;
      r += pmt1_mem_word2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x803c0000 && offset < 0x803c0120) {
      offset -= 0x803c0000;
      r += pmt1_mem_word3_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += rdm_mem_word_.to_string(print_zeros,indent_string) ;
    r += pbt0_mem_word_.to_string(print_zeros,indent_string) ;
    r += pbt1_mem_word_.to_string(print_zeros,indent_string) ;
    r += lit0_np_mem_word_.to_string(print_zeros,indent_string) ;
    r += lit1_np_mem_word_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word0_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word1_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word2_.to_string(print_zeros,indent_string) ;
    r += lit0_bm_mem_word3_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word0_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word1_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word2_.to_string(print_zeros,indent_string) ;
    r += lit1_bm_mem_word3_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word0_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word1_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word2_.to_string(print_zeros,indent_string) ;
    r += pmt0_mem_word3_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word0_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word1_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word2_.to_string(print_zeros,indent_string) ;
    r += pmt1_mem_word3_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmPreRdmMemWordMutable rdm_mem_word_;
  TmPrePbtMemWordMutable pbt0_mem_word_;
  TmPrePbtMemWordMutable pbt1_mem_word_;
  TmPreLitNpMemWordMutable lit0_np_mem_word_;
  TmPreLitNpMemWordMutable lit1_np_mem_word_;
  TmPreLitBmMemWordMutable lit0_bm_mem_word0_;
  TmPreLitBmMemWordMutable lit0_bm_mem_word1_;
  TmPreLitBmMemWordMutable lit0_bm_mem_word2_;
  TmPreLitBmMemWordMutable lit0_bm_mem_word3_;
  TmPreLitBmMemWordMutable lit1_bm_mem_word0_;
  TmPreLitBmMemWordMutable lit1_bm_mem_word1_;
  TmPreLitBmMemWordMutable lit1_bm_mem_word2_;
  TmPreLitBmMemWordMutable lit1_bm_mem_word3_;
  TmPrePmtMemWordMutable pmt0_mem_word0_;
  TmPrePmtMemWordMutable pmt0_mem_word1_;
  TmPrePmtMemWordMutable pmt0_mem_word2_;
  TmPrePmtMemWordMutable pmt0_mem_word3_;
  TmPrePmtMemWordMutable pmt1_mem_word0_;
  TmPrePmtMemWordMutable pmt1_mem_word1_;
  TmPrePmtMemWordMutable pmt1_mem_word2_;
  TmPrePmtMemWordMutable pmt1_mem_word3_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    offset += 0x100000000; // to get to pre_common_mem
    return offset;
  }

};








class TmPreMitMemWord : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMitMemWord(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 16384, false, write_callback, read_callback, std::string("TmPreMitMemWord")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec))
    {
    }
  TmPreMitMemWord(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreMitMemWord")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

};








class TmPreMitMemWordMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMitMemWordMutable(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 16384, true, write_callback, read_callback, std::string("TmPreMitMemWordMutable")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec))
    {
    }
  TmPreMitMemWordMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreMitMemWordMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrePipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrePipeMemRspec(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 1048576, false, write_callback, read_callback, std::string("TmPrePipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec))
    {
    }
  TmPrePipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrePipeMemRspec")
    {
    }
public:





  TmPreMitMemWord &mit_mem_word() { return mit_mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x4000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      mit_mem_word_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x4000) {
      offset -= 0x0;
      mit_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    mit_mem_word_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x4000) {
      offset -= 0x0;
      r += mit_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += mit_mem_word_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmPreMitMemWord mit_mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrePipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrePipeMemRspecMutable(
      int chipNumber, int index_tm_pre_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pre_pipe_mem_rspec), 1048576, true, write_callback, read_callback, std::string("TmPrePipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_pre_pipe_mem_rspec))
    {
    }
  TmPrePipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrePipeMemRspecMutable")
    {
    }
public:





  TmPreMitMemWordMutable &mit_mem_word() { return mit_mem_word_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x4000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      mit_mem_word_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x4000) {
      offset -= 0x0;
      mit_mem_word_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    mit_mem_word_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x4000) {
      offset -= 0x0;
      r += mit_mem_word_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += mit_mem_word_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmPreMitMemWordMutable mit_mem_word_;
private:
  static uint64_t StartOffset(
      int index_tm_pre_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    assert(index_tm_pre_pipe_mem_rspec < 4);
    offset += index_tm_pre_pipe_mem_rspec * 0x100000; // tm_pre_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrePipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrePipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 1048576 * ArraySize(-1), false, write_callback, read_callback, std::string("TmPrePipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:





  TmPreMitMemWord &mit_mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mit_mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1048576;
    (*offset) -= (i*1048576);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrePipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrePipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 1048576 * ArraySize(-1), true, write_callback, read_callback, std::string("TmPrePipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:





  TmPreMitMemWordMutable &mit_mem_word(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].mit_mem_word();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/1048576;
    (*offset) -= (i*1048576);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrePipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrePipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrePipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPreMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPreMemTopRspec"))
    {
    }
  TmPreMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPreMemTopRspec")
    {
    }
public:







  TmPrePipeMemRspec &pre_pipe_mem(int j0) { return pre_pipe_mem_[j0]; }





  TmPreCommonMemRspec &pre_common_mem() { return pre_common_mem_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      if (read_callback_) read_callback_();
      pre_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      if (read_callback_) read_callback_();
      pre_common_mem_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      pre_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      pre_common_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pre_pipe_mem_) {
      f0.reset();
    }
    pre_common_mem_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      r += pre_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      r += pre_common_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pre_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pre_common_mem_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrePipeMemRspec, 4 > pre_pipe_mem_;
  TmPreCommonMemRspec pre_common_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

};








class TmPreMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPreMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPreMemTopRspecMutable"))
    {
    }
  TmPreMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPreMemTopRspecMutable")
    {
    }
public:







  TmPrePipeMemRspecMutable &pre_pipe_mem(int j0) { return pre_pipe_mem_[j0]; }





  TmPreCommonMemRspecMutable &pre_common_mem() { return pre_common_mem_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      if (read_callback_) read_callback_();
      pre_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      if (read_callback_) read_callback_();
      pre_common_mem_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      pre_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      pre_common_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pre_pipe_mem_) {
      f0.reset();
    }
    pre_common_mem_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x400000) {
      offset -= 0x0;
      int i0 = offset / 0x100000;
      offset  -= i0 * 0x100000;
      r += pre_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100000000 && offset < 0x200000000) {
      offset -= 0x100000000;
      r += pre_common_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pre_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += pre_common_mem_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrePipeMemRspecMutable, 4 > pre_pipe_mem_;
  TmPreCommonMemRspecMutable pre_common_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6600000000; // to get to tm_pre
    return offset;
  }

};










class PrcTag : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcTag(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 512, false, write_callback, read_callback, std::string("PrcTag")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  PrcTag(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcTag")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x22400; // to get to csr_memory_prc_tag
    return offset;
  }

};










class PrcTagMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcTagMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 512, true, write_callback, read_callback, std::string("PrcTagMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  PrcTagMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcTagMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x22400; // to get to csr_memory_prc_tag
    return offset;
  }

};








class PrcCache : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPrcPipeMemRspecEnum {
    kCsrMemoryPrcCache0,
    kCsrMemoryPrcCache1
  };
public:
  PrcCache(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec), 512, false, write_callback, read_callback, std::string("PrcCache")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_prc_pipe_mem_rspec))
    {
    }
  PrcCache(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcCache")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        offset += 0x22000; // to get to csr_memory_prc_cache0
        break;
      case kCsrMemoryPrcCache1:
        offset += 0x22200; // to get to csr_memory_prc_cache1
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrcCacheMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmPrcPipeMemRspecEnum {
    kCsrMemoryPrcCache0,
    kCsrMemoryPrcCache1
  };
public:
  PrcCacheMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec, selector_tm_prc_pipe_mem_rspec), 512, true, write_callback, read_callback, std::string("PrcCacheMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_prc_pipe_mem_rspec))
    {
    }
  PrcCacheMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcCacheMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec, TmPrcPipeMemRspecEnum selector_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    switch (selector_tm_prc_pipe_mem_rspec) {
      case kCsrMemoryPrcCache0:
        offset += 0x22000; // to get to csr_memory_prc_cache0
        break;
      case kCsrMemoryPrcCache1:
        offset += 0x22200; // to get to csr_memory_prc_cache1
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class PrcMap : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcMap(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 6144, false, write_callback, read_callback, std::string("PrcMap")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  PrcMap(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcMap")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x20000; // to get to csr_memory_prc_map
    return offset;
  }

};








class PrcMapMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcMapMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 6144, true, write_callback, read_callback, std::string("PrcMapMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  PrcMapMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcMapMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    offset += 0x20000; // to get to csr_memory_prc_map
    return offset;
  }

};










class PrcPrm : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcPrm(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 98304, false, write_callback, read_callback, std::string("PrcPrm")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  PrcPrm(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PrcPrm")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

};










class PrcPrmMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PrcPrmMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 98304, true, write_callback, read_callback, std::string("PrcPrmMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  PrcPrmMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PrcPrmMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrcPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcPipeMemRspec(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmPrcPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  TmPrcPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrcPipeMemRspec")
    {
    }
public:







  PrcPrm &csr_memory_prc_prm() { return csr_memory_prc_prm_; }





  PrcMap &csr_memory_prc_map() { return csr_memory_prc_map_; }





  PrcCache &csr_memory_prc_cache0() { return csr_memory_prc_cache0_; }





  PrcCache &csr_memory_prc_cache1() { return csr_memory_prc_cache1_; }







  PrcTag &csr_memory_prc_tag() { return csr_memory_prc_tag_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x18000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_prc_prm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      if (read_callback_) read_callback_();
      csr_memory_prc_map_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      if (read_callback_) read_callback_();
      csr_memory_prc_tag_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x18000) {
      offset -= 0x0;
      csr_memory_prc_prm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      csr_memory_prc_map_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      csr_memory_prc_cache0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      csr_memory_prc_cache1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      csr_memory_prc_tag_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_prc_prm_.reset();
    csr_memory_prc_map_.reset();
    csr_memory_prc_cache0_.reset();
    csr_memory_prc_cache1_.reset();
    csr_memory_prc_tag_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x18000) {
      offset -= 0x0;
      r += csr_memory_prc_prm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      r += csr_memory_prc_map_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      r += csr_memory_prc_cache0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      r += csr_memory_prc_cache1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      r += csr_memory_prc_tag_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_prc_prm_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_map_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_cache0_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_cache1_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_tag_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  PrcPrm csr_memory_prc_prm_;
  PrcMap csr_memory_prc_map_;
  PrcCache csr_memory_prc_cache0_;
  PrcCache csr_memory_prc_cache1_;
  PrcTag csr_memory_prc_tag_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrcPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcPipeMemRspecMutable(
      int chipNumber, int index_tm_prc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_prc_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmPrcPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_prc_pipe_mem_rspec))
    {
    }
  TmPrcPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrcPipeMemRspecMutable")
    {
    }
public:







  PrcPrmMutable &csr_memory_prc_prm() { return csr_memory_prc_prm_; }





  PrcMapMutable &csr_memory_prc_map() { return csr_memory_prc_map_; }





  PrcCacheMutable &csr_memory_prc_cache0() { return csr_memory_prc_cache0_; }





  PrcCacheMutable &csr_memory_prc_cache1() { return csr_memory_prc_cache1_; }







  PrcTagMutable &csr_memory_prc_tag() { return csr_memory_prc_tag_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x18000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_prc_prm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      if (read_callback_) read_callback_();
      csr_memory_prc_map_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      if (read_callback_) read_callback_();
      csr_memory_prc_cache1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      if (read_callback_) read_callback_();
      csr_memory_prc_tag_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x18000) {
      offset -= 0x0;
      csr_memory_prc_prm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      csr_memory_prc_map_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      csr_memory_prc_cache0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      csr_memory_prc_cache1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      csr_memory_prc_tag_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_prc_prm_.reset();
    csr_memory_prc_map_.reset();
    csr_memory_prc_cache0_.reset();
    csr_memory_prc_cache1_.reset();
    csr_memory_prc_tag_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x18000) {
      offset -= 0x0;
      r += csr_memory_prc_prm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x21800) {
      offset -= 0x20000;
      r += csr_memory_prc_map_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22000 && offset < 0x22200) {
      offset -= 0x22000;
      r += csr_memory_prc_cache0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22200 && offset < 0x22400) {
      offset -= 0x22200;
      r += csr_memory_prc_cache1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x22400 && offset < 0x22600) {
      offset -= 0x22400;
      r += csr_memory_prc_tag_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_prc_prm_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_map_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_cache0_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_cache1_.to_string(print_zeros,indent_string) ;
    r += csr_memory_prc_tag_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  PrcPrmMutable csr_memory_prc_prm_;
  PrcMapMutable csr_memory_prc_map_;
  PrcCacheMutable csr_memory_prc_cache0_;
  PrcCacheMutable csr_memory_prc_cache1_;
  PrcTagMutable csr_memory_prc_tag_;
private:
  static uint64_t StartOffset(
      int index_tm_prc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    assert(index_tm_prc_pipe_mem_rspec < 4);
    offset += index_tm_prc_pipe_mem_rspec * 0x10000000; // tm_prc_pipe_mem_rspec[]
    return offset;
  }

};








class TmPrcPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrcPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmPrcPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  PrcPrm &csr_memory_prc_prm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_prm();
  }





  PrcMap &csr_memory_prc_map(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_map();
  }





  PrcCache &csr_memory_prc_cache0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache0();
  }





  PrcCache &csr_memory_prc_cache1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache1();
  }







  PrcTag &csr_memory_prc_tag(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_tag();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrcPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrcPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPrcPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmPrcPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  PrcPrmMutable &csr_memory_prc_prm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_prm();
  }





  PrcMapMutable &csr_memory_prc_map(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_map();
  }





  PrcCacheMutable &csr_memory_prc_cache0(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache0();
  }





  PrcCacheMutable &csr_memory_prc_cache1(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_cache1();
  }







  PrcTagMutable &csr_memory_prc_tag(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_prc_tag();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPrcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPrcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPrcPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPrcMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPrcMemTopRspec"))
    {
    }
  TmPrcMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPrcMemTopRspec")
    {
    }
public:







  TmPrcPipeMemRspec &prc_mem(int j0) { return prc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      prc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      prc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : prc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += prc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += prc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrcPipeMemRspec, 4 > prc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

};








class TmPrcMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPrcMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPrcMemTopRspecMutable"))
    {
    }
  TmPrcMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPrcMemTopRspecMutable")
    {
    }
public:







  TmPrcPipeMemRspecMutable &prc_mem(int j0) { return prc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      prc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      prc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : prc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += prc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += prc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPrcPipeMemRspecMutable, 4 > prc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x6200000000; // to get to tm_prc
    return offset;
  }

};








class QlcVq : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcVq(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 2048, false, write_callback, read_callback, std::string("QlcVq")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  QlcVq(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QlcVq")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80800; // to get to csr_memory_qlc_vq
    return offset;
  }

};








class QlcVqMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcVqMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 2048, true, write_callback, read_callback, std::string("QlcVqMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  QlcVqMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QlcVqMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80800; // to get to csr_memory_qlc_vq
    return offset;
  }

};








class QlcHt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcHt(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 2048, false, write_callback, read_callback, std::string("QlcHt")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  QlcHt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QlcHt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80000; // to get to csr_memory_qlc_ht
    return offset;
  }

};








class QlcHtMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcHtMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 2048, true, write_callback, read_callback, std::string("QlcHtMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  QlcHtMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QlcHtMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    offset += 0x80000; // to get to csr_memory_qlc_ht
    return offset;
  }

};










class QlcQlm : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcQlm(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 524288, false, write_callback, read_callback, std::string("QlcQlm")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  QlcQlm(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QlcQlm")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

};










class QlcQlmMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QlcQlmMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 524288, true, write_callback, read_callback, std::string("QlcQlmMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  QlcQlmMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QlcQlmMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

};








class TmQlcPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcPipeMemRspec(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmQlcPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  TmQlcPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQlcPipeMemRspec")
    {
    }
public:







  QlcQlm &csr_memory_qlc_qlm() { return csr_memory_qlc_qlm_; }





  QlcHt &csr_memory_qlc_ht() { return csr_memory_qlc_ht_; }





  QlcVq &csr_memory_qlc_vq() { return csr_memory_qlc_vq_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x80000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_qlc_qlm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000 && offset < 0x80800) {
      offset -= 0x80000;
      if (read_callback_) read_callback_();
      csr_memory_qlc_ht_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80800 && offset < 0x81000) {
      offset -= 0x80800;
      if (read_callback_) read_callback_();
      csr_memory_qlc_vq_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x80000) {
      offset -= 0x0;
      csr_memory_qlc_qlm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000 && offset < 0x80800) {
      offset -= 0x80000;
      csr_memory_qlc_ht_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80800 && offset < 0x81000) {
      offset -= 0x80800;
      csr_memory_qlc_vq_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_qlc_qlm_.reset();
    csr_memory_qlc_ht_.reset();
    csr_memory_qlc_vq_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x80000) {
      offset -= 0x0;
      r += csr_memory_qlc_qlm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000 && offset < 0x80800) {
      offset -= 0x80000;
      r += csr_memory_qlc_ht_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80800 && offset < 0x81000) {
      offset -= 0x80800;
      r += csr_memory_qlc_vq_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_qlc_qlm_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qlc_ht_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qlc_vq_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  QlcQlm csr_memory_qlc_qlm_;
  QlcHt csr_memory_qlc_ht_;
  QlcVq csr_memory_qlc_vq_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

};








class TmQlcPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcPipeMemRspecMutable(
      int chipNumber, int index_tm_qlc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qlc_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmQlcPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_qlc_pipe_mem_rspec))
    {
    }
  TmQlcPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQlcPipeMemRspecMutable")
    {
    }
public:







  QlcQlmMutable &csr_memory_qlc_qlm() { return csr_memory_qlc_qlm_; }





  QlcHtMutable &csr_memory_qlc_ht() { return csr_memory_qlc_ht_; }





  QlcVqMutable &csr_memory_qlc_vq() { return csr_memory_qlc_vq_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x80000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_qlc_qlm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80000 && offset < 0x80800) {
      offset -= 0x80000;
      if (read_callback_) read_callback_();
      csr_memory_qlc_ht_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80800 && offset < 0x81000) {
      offset -= 0x80800;
      if (read_callback_) read_callback_();
      csr_memory_qlc_vq_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x80000) {
      offset -= 0x0;
      csr_memory_qlc_qlm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80000 && offset < 0x80800) {
      offset -= 0x80000;
      csr_memory_qlc_ht_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80800 && offset < 0x81000) {
      offset -= 0x80800;
      csr_memory_qlc_vq_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_qlc_qlm_.reset();
    csr_memory_qlc_ht_.reset();
    csr_memory_qlc_vq_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x80000) {
      offset -= 0x0;
      r += csr_memory_qlc_qlm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80000 && offset < 0x80800) {
      offset -= 0x80000;
      r += csr_memory_qlc_ht_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80800 && offset < 0x81000) {
      offset -= 0x80800;
      r += csr_memory_qlc_vq_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_qlc_qlm_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qlc_ht_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qlc_vq_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  QlcQlmMutable csr_memory_qlc_qlm_;
  QlcHtMutable csr_memory_qlc_ht_;
  QlcVqMutable csr_memory_qlc_vq_;
private:
  static uint64_t StartOffset(
      int index_tm_qlc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    assert(index_tm_qlc_pipe_mem_rspec < 4);
    offset += index_tm_qlc_pipe_mem_rspec * 0x10000000; // tm_qlc_pipe_mem_rspec[]
    return offset;
  }

};








class TmQlcPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQlcPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmQlcPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  QlcQlm &csr_memory_qlc_qlm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_qlm();
  }





  QlcHt &csr_memory_qlc_ht(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_ht();
  }





  QlcVq &csr_memory_qlc_vq(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_vq();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQlcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQlcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQlcPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQlcPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQlcPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmQlcPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:







  QlcQlmMutable &csr_memory_qlc_qlm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_qlm();
  }





  QlcHtMutable &csr_memory_qlc_ht(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_ht();
  }





  QlcVqMutable &csr_memory_qlc_vq(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qlc_vq();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQlcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQlcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQlcPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQlcMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmQlcMemTopRspec"))
    {
    }
  TmQlcMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQlcMemTopRspec")
    {
    }
public:







  TmQlcPipeMemRspec &qlc_mem(int j0) { return qlc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qlc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qlc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qlc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qlc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qlc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQlcPipeMemRspec, 4 > qlc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

};








class TmQlcMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQlcMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmQlcMemTopRspecMutable"))
    {
    }
  TmQlcMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQlcMemTopRspecMutable")
    {
    }
public:







  TmQlcPipeMemRspecMutable &qlc_mem(int j0) { return qlc_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qlc_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qlc_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qlc_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qlc_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qlc_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQlcPipeMemRspecMutable, 4 > qlc_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5e00000000; // to get to tm_qlc
    return offset;
  }

};








class PexClm : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PexClm(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 393216, false, write_callback, read_callback, std::string("PexClm")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec))
    {
    }
  PexClm(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "PexClm")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

};








class PexClmMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  PexClmMutable(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 393216, true, write_callback, read_callback, std::string("PexClmMutable")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec))
    {
    }
  PexClmMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "PexClmMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

};








class TmPexPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexPipeMemRspec(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmPexPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec))
    {
    }
  TmPexPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPexPipeMemRspec")
    {
    }
public:





  PexClm &csr_memory_pex_clm() { return csr_memory_pex_clm_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_pex_clm_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      csr_memory_pex_clm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_pex_clm_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      r += csr_memory_pex_clm_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_pex_clm_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  PexClm csr_memory_pex_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

};








class TmPexPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexPipeMemRspecMutable(
      int chipNumber, int index_tm_pex_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_pex_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmPexPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_pex_pipe_mem_rspec))
    {
    }
  TmPexPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPexPipeMemRspecMutable")
    {
    }
public:





  PexClmMutable &csr_memory_pex_clm() { return csr_memory_pex_clm_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_pex_clm_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      csr_memory_pex_clm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_pex_clm_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      r += csr_memory_pex_clm_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_pex_clm_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  PexClmMutable csr_memory_pex_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_pex_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    assert(index_tm_pex_pipe_mem_rspec < 4);
    offset += index_tm_pex_pipe_mem_rspec * 0x10000000; // tm_pex_pipe_mem_rspec[]
    return offset;
  }

};








class TmPexPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPexPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmPexPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:





  PexClm &csr_memory_pex_clm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_pex_clm();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPexPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPexPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPexPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPexPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmPexPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmPexPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:





  PexClmMutable &csr_memory_pex_clm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_pex_clm();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmPexPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmPexPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmPexPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmPexMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmPexMemTopRspec"))
    {
    }
  TmPexMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmPexMemTopRspec")
    {
    }
public:







  TmPexPipeMemRspec &pex(int j0) { return pex_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      pex_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      pex_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pex_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += pex_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pex_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPexPipeMemRspec, 4 > pex_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

};








class TmPexMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmPexMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmPexMemTopRspecMutable"))
    {
    }
  TmPexMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmPexMemTopRspecMutable")
    {
    }
public:







  TmPexPipeMemRspecMutable &pex(int j0) { return pex_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      pex_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      pex_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : pex_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += pex_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pex_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmPexPipeMemRspecMutable, 4 > pex_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5a00000000; // to get to tm_pex
    return offset;
  }

};








class ClcClm : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  ClcClm(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 393216, false, write_callback, read_callback, std::string("ClcClm")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec))
    {
    }
  ClcClm(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "ClcClm")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

};








class ClcClmMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  ClcClmMutable(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 393216, true, write_callback, read_callback, std::string("ClcClmMutable")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec))
    {
    }
  ClcClmMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "ClcClmMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

};








class TmClcPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcPipeMemRspec(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmClcPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec))
    {
    }
  TmClcPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmClcPipeMemRspec")
    {
    }
public:





  ClcClm &csr_memory_clc_clm() { return csr_memory_clc_clm_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_clc_clm_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      csr_memory_clc_clm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_clc_clm_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      r += csr_memory_clc_clm_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_clc_clm_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  ClcClm csr_memory_clc_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

};








class TmClcPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcPipeMemRspecMutable(
      int chipNumber, int index_tm_clc_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_clc_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmClcPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_clc_pipe_mem_rspec))
    {
    }
  TmClcPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmClcPipeMemRspecMutable")
    {
    }
public:





  ClcClmMutable &csr_memory_clc_clm() { return csr_memory_clc_clm_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x60000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_clc_clm_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x60000) {
      offset -= 0x0;
      csr_memory_clc_clm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_clc_clm_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x60000) {
      offset -= 0x0;
      r += csr_memory_clc_clm_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_clc_clm_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  ClcClmMutable csr_memory_clc_clm_;
private:
  static uint64_t StartOffset(
      int index_tm_clc_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    assert(index_tm_clc_pipe_mem_rspec < 4);
    offset += index_tm_clc_pipe_mem_rspec * 0x10000000; // tm_clc_pipe_mem_rspec[]
    return offset;
  }

};








class TmClcPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmClcPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmClcPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:





  ClcClm &csr_memory_clc_clm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_clc_clm();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmClcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmClcPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmClcPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmClcPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmClcPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmClcPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:





  ClcClmMutable &csr_memory_clc_clm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_clc_clm();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmClcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmClcPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmClcPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmClcMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmClcMemTopRspec"))
    {
    }
  TmClcMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmClcMemTopRspec")
    {
    }
public:







  TmClcPipeMemRspec &clc(int j0) { return clc_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      clc_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      clc_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : clc_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += clc_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += clc_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmClcPipeMemRspec, 4 > clc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

};








class TmClcMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmClcMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmClcMemTopRspecMutable"))
    {
    }
  TmClcMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmClcMemTopRspecMutable")
    {
    }
public:







  TmClcPipeMemRspecMutable &clc(int j0) { return clc_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      clc_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      clc_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : clc_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += clc_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += clc_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmClcPipeMemRspecMutable, 4 > clc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x5600000000; // to get to tm_clc
    return offset;
  }

};







class SchQOccR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQOccR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("SchQOccR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQOccR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQOccR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQOccRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQOccRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("SchQOccRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQOccRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQOccRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x5000; // to get to q_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchL1OccR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1OccR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("SchL1OccR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchL1OccR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchL1OccR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchL1OccRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1OccRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("SchL1OccRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchL1OccRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchL1OccRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4e00; // to get to l1_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchPOccR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPOccR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 72, false, write_callback, read_callback, std::string("SchPOccR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchPOccR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchPOccR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchPOccRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPOccRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 72, true, write_callback, read_callback, std::string("SchPOccRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchPOccRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchPOccRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4c80; // to get to p_occ_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueueAdvFcStatusR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueueAdvFcStatusR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("SchQueueAdvFcStatusR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQueueAdvFcStatusR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQueueAdvFcStatusR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueueAdvFcStatusRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueueAdvFcStatusRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("SchQueueAdvFcStatusRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQueueAdvFcStatusRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQueueAdvFcStatusRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4800; // to get to q_adv_fc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueuePfcStatusR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueuePfcStatusR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("SchQueuePfcStatusR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQueuePfcStatusR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQueuePfcStatusR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};







class SchQueuePfcStatusRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQueuePfcStatusRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("SchQueuePfcStatusRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQueuePfcStatusRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQueuePfcStatusRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x4000; // to get to q_pfc_status_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketDynamicR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketDynamicR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("SchQExcessbucketDynamicR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQExcessbucketDynamicR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQExcessbucketDynamicR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketDynamicRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketDynamicRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("SchQExcessbucketDynamicRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQExcessbucketDynamicRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQExcessbucketDynamicRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3800; // to get to q_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketStaticR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketStaticR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("SchQExcessbucketStaticR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQExcessbucketStaticR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchQExcessbucketStaticR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchQExcessbucketStaticRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchQExcessbucketStaticRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("SchQExcessbucketStaticRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchQExcessbucketStaticRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchQExcessbucketStaticRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x3000; // to get to q_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMaxLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMaxLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMaxLbDynamicMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMaxLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMaxLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMaxLbDynamicMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2800; // to get to q_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMaxLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMaxLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMaxLbStaticMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMaxLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMaxLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMaxLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMaxLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMaxLbStaticMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x2000; // to get to q_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMinLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMinLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMinLbDynamicMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecQMinLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMinLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMinLbDynamicMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1800; // to get to q_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMinLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMinLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecQMinLbStaticMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecQMinLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecQMinLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("TmSchPipeMemRspecQMinLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecQMinLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecQMinLbStaticMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x1000; // to get to q_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketDynamicR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketDynamicR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("SchL1ExcessbucketDynamicR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchL1ExcessbucketDynamicR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchL1ExcessbucketDynamicR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketDynamicRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketDynamicRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("SchL1ExcessbucketDynamicRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchL1ExcessbucketDynamicRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchL1ExcessbucketDynamicRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xc00; // to get to l1_exc_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketStaticR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketStaticR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("SchL1ExcessbucketStaticR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchL1ExcessbucketStaticR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchL1ExcessbucketStaticR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchL1ExcessbucketStaticRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchL1ExcessbucketStaticRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("SchL1ExcessbucketStaticRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchL1ExcessbucketStaticRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchL1ExcessbucketStaticRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0xa00; // to get to l1_exc_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MaxLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MaxLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MaxLbDynamicMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MaxLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MaxLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MaxLbDynamicMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x800; // to get to l1_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MaxLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MaxLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MaxLbStaticMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MaxLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MaxLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MaxLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MaxLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MaxLbStaticMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x600; // to get to l1_max_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MinLbDynamicMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbDynamicMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbDynamicMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MinLbDynamicMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MinLbDynamicMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class TmSchPipeMemRspecL1MinLbDynamicMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbDynamicMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbDynamicMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MinLbDynamicMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MinLbDynamicMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x400; // to get to l1_min_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MinLbStaticMem : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbStaticMem(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbStaticMem")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MinLbStaticMem(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspecL1MinLbStaticMem")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class TmSchPipeMemRspecL1MinLbStaticMemMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecL1MinLbStaticMemMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("TmSchPipeMemRspecL1MinLbStaticMemMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecL1MinLbStaticMemMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecL1MinLbStaticMemMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x200; // to get to l1_min_lb_static_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchPLeakybucketDynamicR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketDynamicR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 72, false, write_callback, read_callback, std::string("SchPLeakybucketDynamicR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchPLeakybucketDynamicR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchPLeakybucketDynamicR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class SchPLeakybucketDynamicRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketDynamicRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 72, true, write_callback, read_callback, std::string("SchPLeakybucketDynamicRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchPLeakybucketDynamicRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchPLeakybucketDynamicRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        offset += 0x80; // to get to port_max_lb_dynamic_mem
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class SchPLeakybucketStaticR : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketStaticR(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 72, false, write_callback, read_callback, std::string("SchPLeakybucketStaticR")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchPLeakybucketStaticR(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "SchPLeakybucketStaticR")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class SchPLeakybucketStaticRMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  SchPLeakybucketStaticRMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 72, true, write_callback, read_callback, std::string("SchPLeakybucketStaticRMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  SchPLeakybucketStaticRMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "SchPLeakybucketStaticRMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmSchPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspec(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmSchPipeMemRspec")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchPipeMemRspec")
    {
    }
public:






  SchPLeakybucketStaticR &port_max_lb_static_mem() { return port_max_lb_static_mem_; }








  SchPLeakybucketDynamicR &port_max_lb_dynamic_mem() { return port_max_lb_dynamic_mem_; }






  TmSchPipeMemRspecL1MinLbStaticMem &l1_min_lb_static_mem() { return l1_min_lb_static_mem_; }








  TmSchPipeMemRspecL1MinLbDynamicMem &l1_min_lb_dynamic_mem() { return l1_min_lb_dynamic_mem_; }






  TmSchPipeMemRspecL1MaxLbStaticMem &l1_max_lb_static_mem() { return l1_max_lb_static_mem_; }








  TmSchPipeMemRspecL1MaxLbDynamicMem &l1_max_lb_dynamic_mem() { return l1_max_lb_dynamic_mem_; }








  SchL1ExcessbucketStaticR &l1_exc_static_mem() { return l1_exc_static_mem_; }








  SchL1ExcessbucketDynamicR &l1_exc_dynamic_mem() { return l1_exc_dynamic_mem_; }






  TmSchPipeMemRspecQMinLbStaticMem &q_min_lb_static_mem() { return q_min_lb_static_mem_; }








  TmSchPipeMemRspecQMinLbDynamicMem &q_min_lb_dynamic_mem() { return q_min_lb_dynamic_mem_; }






  TmSchPipeMemRspecQMaxLbStaticMem &q_max_lb_static_mem() { return q_max_lb_static_mem_; }








  TmSchPipeMemRspecQMaxLbDynamicMem &q_max_lb_dynamic_mem() { return q_max_lb_dynamic_mem_; }








  SchQExcessbucketStaticR &q_exc_static_mem() { return q_exc_static_mem_; }








  SchQExcessbucketDynamicR &q_exc_dynamic_mem() { return q_exc_dynamic_mem_; }




  SchQueuePfcStatusR &q_pfc_status_mem() { return q_pfc_status_mem_; }




  SchQueueAdvFcStatusR &q_adv_fc_status_mem() { return q_adv_fc_status_mem_; }




  SchPOccR &p_occ_mem() { return p_occ_mem_; }




  SchL1OccR &l1_occ_mem() { return l1_occ_mem_; }




  SchQOccR &q_occ_mem() { return q_occ_mem_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      port_max_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      if (read_callback_) read_callback_();
      port_max_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      if (read_callback_) read_callback_();
      l1_min_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      if (read_callback_) read_callback_();
      l1_min_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      if (read_callback_) read_callback_();
      l1_max_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      if (read_callback_) read_callback_();
      l1_max_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      if (read_callback_) read_callback_();
      l1_exc_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      if (read_callback_) read_callback_();
      l1_exc_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      if (read_callback_) read_callback_();
      q_min_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      if (read_callback_) read_callback_();
      q_min_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      if (read_callback_) read_callback_();
      q_max_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      if (read_callback_) read_callback_();
      q_max_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      if (read_callback_) read_callback_();
      q_exc_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      if (read_callback_) read_callback_();
      q_exc_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      if (read_callback_) read_callback_();
      q_pfc_status_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      if (read_callback_) read_callback_();
      q_adv_fc_status_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      if (read_callback_) read_callback_();
      p_occ_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      if (read_callback_) read_callback_();
      l1_occ_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      if (read_callback_) read_callback_();
      q_occ_mem_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      port_max_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      port_max_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      l1_min_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      l1_min_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      l1_max_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      l1_max_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      l1_exc_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      l1_exc_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      q_min_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      q_min_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      q_max_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      q_max_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      q_exc_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      q_exc_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      q_pfc_status_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      q_adv_fc_status_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      p_occ_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      l1_occ_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      q_occ_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    port_max_lb_static_mem_.reset();
    port_max_lb_dynamic_mem_.reset();
    l1_min_lb_static_mem_.reset();
    l1_min_lb_dynamic_mem_.reset();
    l1_max_lb_static_mem_.reset();
    l1_max_lb_dynamic_mem_.reset();
    l1_exc_static_mem_.reset();
    l1_exc_dynamic_mem_.reset();
    q_min_lb_static_mem_.reset();
    q_min_lb_dynamic_mem_.reset();
    q_max_lb_static_mem_.reset();
    q_max_lb_dynamic_mem_.reset();
    q_exc_static_mem_.reset();
    q_exc_dynamic_mem_.reset();
    q_pfc_status_mem_.reset();
    q_adv_fc_status_mem_.reset();
    p_occ_mem_.reset();
    l1_occ_mem_.reset();
    q_occ_mem_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      r += port_max_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      r += port_max_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      r += l1_min_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      r += l1_min_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      r += l1_max_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      r += l1_max_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      r += l1_exc_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      r += l1_exc_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      r += q_min_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      r += q_min_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      r += q_max_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      r += q_max_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      r += q_exc_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      r += q_exc_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      r += q_pfc_status_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      r += q_adv_fc_status_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      r += p_occ_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      r += l1_occ_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      r += q_occ_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += port_max_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += port_max_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += l1_min_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += l1_min_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += l1_max_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += l1_max_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += l1_exc_static_mem_.to_string(print_zeros,indent_string) ;
    r += l1_exc_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_min_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += q_min_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_max_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += q_max_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_exc_static_mem_.to_string(print_zeros,indent_string) ;
    r += q_exc_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_pfc_status_mem_.to_string(print_zeros,indent_string) ;
    r += q_adv_fc_status_mem_.to_string(print_zeros,indent_string) ;
    r += p_occ_mem_.to_string(print_zeros,indent_string) ;
    r += l1_occ_mem_.to_string(print_zeros,indent_string) ;
    r += q_occ_mem_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  SchPLeakybucketStaticR port_max_lb_static_mem_;
  SchPLeakybucketDynamicR port_max_lb_dynamic_mem_;
  TmSchPipeMemRspecL1MinLbStaticMem l1_min_lb_static_mem_;
  TmSchPipeMemRspecL1MinLbDynamicMem l1_min_lb_dynamic_mem_;
  TmSchPipeMemRspecL1MaxLbStaticMem l1_max_lb_static_mem_;
  TmSchPipeMemRspecL1MaxLbDynamicMem l1_max_lb_dynamic_mem_;
  SchL1ExcessbucketStaticR l1_exc_static_mem_;
  SchL1ExcessbucketDynamicR l1_exc_dynamic_mem_;
  TmSchPipeMemRspecQMinLbStaticMem q_min_lb_static_mem_;
  TmSchPipeMemRspecQMinLbDynamicMem q_min_lb_dynamic_mem_;
  TmSchPipeMemRspecQMaxLbStaticMem q_max_lb_static_mem_;
  TmSchPipeMemRspecQMaxLbDynamicMem q_max_lb_dynamic_mem_;
  SchQExcessbucketStaticR q_exc_static_mem_;
  SchQExcessbucketDynamicR q_exc_dynamic_mem_;
  SchQueuePfcStatusR q_pfc_status_mem_;
  SchQueueAdvFcStatusR q_adv_fc_status_mem_;
  SchPOccR p_occ_mem_;
  SchL1OccR l1_occ_mem_;
  SchQOccR q_occ_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmSchPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec, index_tm_sch_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmSchPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec) + "," + boost::lexical_cast<std::string>(index_tm_sch_pipe_mem_rspec))
    {
    }
  TmSchPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchPipeMemRspecMutable")
    {
    }
public:






  SchPLeakybucketStaticRMutable &port_max_lb_static_mem() { return port_max_lb_static_mem_; }








  SchPLeakybucketDynamicRMutable &port_max_lb_dynamic_mem() { return port_max_lb_dynamic_mem_; }






  TmSchPipeMemRspecL1MinLbStaticMemMutable &l1_min_lb_static_mem() { return l1_min_lb_static_mem_; }








  TmSchPipeMemRspecL1MinLbDynamicMemMutable &l1_min_lb_dynamic_mem() { return l1_min_lb_dynamic_mem_; }






  TmSchPipeMemRspecL1MaxLbStaticMemMutable &l1_max_lb_static_mem() { return l1_max_lb_static_mem_; }








  TmSchPipeMemRspecL1MaxLbDynamicMemMutable &l1_max_lb_dynamic_mem() { return l1_max_lb_dynamic_mem_; }








  SchL1ExcessbucketStaticRMutable &l1_exc_static_mem() { return l1_exc_static_mem_; }








  SchL1ExcessbucketDynamicRMutable &l1_exc_dynamic_mem() { return l1_exc_dynamic_mem_; }






  TmSchPipeMemRspecQMinLbStaticMemMutable &q_min_lb_static_mem() { return q_min_lb_static_mem_; }








  TmSchPipeMemRspecQMinLbDynamicMemMutable &q_min_lb_dynamic_mem() { return q_min_lb_dynamic_mem_; }






  TmSchPipeMemRspecQMaxLbStaticMemMutable &q_max_lb_static_mem() { return q_max_lb_static_mem_; }








  TmSchPipeMemRspecQMaxLbDynamicMemMutable &q_max_lb_dynamic_mem() { return q_max_lb_dynamic_mem_; }








  SchQExcessbucketStaticRMutable &q_exc_static_mem() { return q_exc_static_mem_; }








  SchQExcessbucketDynamicRMutable &q_exc_dynamic_mem() { return q_exc_dynamic_mem_; }




  SchQueuePfcStatusRMutable &q_pfc_status_mem() { return q_pfc_status_mem_; }




  SchQueueAdvFcStatusRMutable &q_adv_fc_status_mem() { return q_adv_fc_status_mem_; }




  SchPOccRMutable &p_occ_mem() { return p_occ_mem_; }




  SchL1OccRMutable &l1_occ_mem() { return l1_occ_mem_; }




  SchQOccRMutable &q_occ_mem() { return q_occ_mem_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x48) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      port_max_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      if (read_callback_) read_callback_();
      port_max_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      if (read_callback_) read_callback_();
      l1_min_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      if (read_callback_) read_callback_();
      l1_min_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      if (read_callback_) read_callback_();
      l1_max_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      if (read_callback_) read_callback_();
      l1_max_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      if (read_callback_) read_callback_();
      l1_exc_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      if (read_callback_) read_callback_();
      l1_exc_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      if (read_callback_) read_callback_();
      q_min_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      if (read_callback_) read_callback_();
      q_min_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      if (read_callback_) read_callback_();
      q_max_lb_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      if (read_callback_) read_callback_();
      q_max_lb_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      if (read_callback_) read_callback_();
      q_exc_static_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      if (read_callback_) read_callback_();
      q_exc_dynamic_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      if (read_callback_) read_callback_();
      q_pfc_status_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      if (read_callback_) read_callback_();
      q_adv_fc_status_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      if (read_callback_) read_callback_();
      p_occ_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      if (read_callback_) read_callback_();
      l1_occ_mem_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      if (read_callback_) read_callback_();
      q_occ_mem_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x48) {
      offset -= 0x0;
      port_max_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      port_max_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      l1_min_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      l1_min_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      l1_max_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      l1_max_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      l1_exc_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      l1_exc_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      q_min_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      q_min_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      q_max_lb_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      q_max_lb_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      q_exc_static_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      q_exc_dynamic_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      q_pfc_status_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      q_adv_fc_status_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      p_occ_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      l1_occ_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      q_occ_mem_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    port_max_lb_static_mem_.reset();
    port_max_lb_dynamic_mem_.reset();
    l1_min_lb_static_mem_.reset();
    l1_min_lb_dynamic_mem_.reset();
    l1_max_lb_static_mem_.reset();
    l1_max_lb_dynamic_mem_.reset();
    l1_exc_static_mem_.reset();
    l1_exc_dynamic_mem_.reset();
    q_min_lb_static_mem_.reset();
    q_min_lb_dynamic_mem_.reset();
    q_max_lb_static_mem_.reset();
    q_max_lb_dynamic_mem_.reset();
    q_exc_static_mem_.reset();
    q_exc_dynamic_mem_.reset();
    q_pfc_status_mem_.reset();
    q_adv_fc_status_mem_.reset();
    p_occ_mem_.reset();
    l1_occ_mem_.reset();
    q_occ_mem_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x48) {
      offset -= 0x0;
      r += port_max_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0xc8) {
      offset -= 0x80;
      r += port_max_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      r += l1_min_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      r += l1_min_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x720) {
      offset -= 0x600;
      r += l1_max_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      r += l1_max_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xb20) {
      offset -= 0xa00;
      r += l1_exc_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xd20) {
      offset -= 0xc00;
      r += l1_exc_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      r += q_min_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      r += q_min_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      r += q_max_lb_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      r += q_max_lb_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      r += q_exc_static_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3800 && offset < 0x3c80) {
      offset -= 0x3800;
      r += q_exc_dynamic_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4000 && offset < 0x4480) {
      offset -= 0x4000;
      r += q_pfc_status_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4800 && offset < 0x4c80) {
      offset -= 0x4800;
      r += q_adv_fc_status_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4c80 && offset < 0x4cc8) {
      offset -= 0x4c80;
      r += p_occ_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00 && offset < 0x4f20) {
      offset -= 0x4e00;
      r += l1_occ_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5000 && offset < 0x5480) {
      offset -= 0x5000;
      r += q_occ_mem_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += port_max_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += port_max_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += l1_min_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += l1_min_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += l1_max_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += l1_max_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += l1_exc_static_mem_.to_string(print_zeros,indent_string) ;
    r += l1_exc_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_min_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += q_min_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_max_lb_static_mem_.to_string(print_zeros,indent_string) ;
    r += q_max_lb_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_exc_static_mem_.to_string(print_zeros,indent_string) ;
    r += q_exc_dynamic_mem_.to_string(print_zeros,indent_string) ;
    r += q_pfc_status_mem_.to_string(print_zeros,indent_string) ;
    r += q_adv_fc_status_mem_.to_string(print_zeros,indent_string) ;
    r += p_occ_mem_.to_string(print_zeros,indent_string) ;
    r += l1_occ_mem_.to_string(print_zeros,indent_string) ;
    r += q_occ_mem_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  SchPLeakybucketStaticRMutable port_max_lb_static_mem_;
  SchPLeakybucketDynamicRMutable port_max_lb_dynamic_mem_;
  TmSchPipeMemRspecL1MinLbStaticMemMutable l1_min_lb_static_mem_;
  TmSchPipeMemRspecL1MinLbDynamicMemMutable l1_min_lb_dynamic_mem_;
  TmSchPipeMemRspecL1MaxLbStaticMemMutable l1_max_lb_static_mem_;
  TmSchPipeMemRspecL1MaxLbDynamicMemMutable l1_max_lb_dynamic_mem_;
  SchL1ExcessbucketStaticRMutable l1_exc_static_mem_;
  SchL1ExcessbucketDynamicRMutable l1_exc_dynamic_mem_;
  TmSchPipeMemRspecQMinLbStaticMemMutable q_min_lb_static_mem_;
  TmSchPipeMemRspecQMinLbDynamicMemMutable q_min_lb_dynamic_mem_;
  TmSchPipeMemRspecQMaxLbStaticMemMutable q_max_lb_static_mem_;
  TmSchPipeMemRspecQMaxLbDynamicMemMutable q_max_lb_dynamic_mem_;
  SchQExcessbucketStaticRMutable q_exc_static_mem_;
  SchQExcessbucketDynamicRMutable q_exc_dynamic_mem_;
  SchQueuePfcStatusRMutable q_pfc_status_mem_;
  SchQueueAdvFcStatusRMutable q_adv_fc_status_mem_;
  SchPOccRMutable p_occ_mem_;
  SchL1OccRMutable l1_occ_mem_;
  SchQOccRMutable q_occ_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int index_tm_sch_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        assert(index_tm_sch_pipe_mem_rspec < 2);
        offset += index_tm_sch_pipe_mem_rspec * 0x10000000; // tm_sch_pipe_mem_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmSchPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecArray(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 268435456 * ArraySize(selector_tm_top_mem_rspec, -1), false, write_callback, read_callback, std::string("TmSchPipeMemRspecArray")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, 0))
    {
    }
public:






  SchPLeakybucketStaticR &port_max_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_static_mem();
  }








  SchPLeakybucketDynamicR &port_max_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_dynamic_mem();
  }






  TmSchPipeMemRspecL1MinLbStaticMem &l1_min_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_static_mem();
  }








  TmSchPipeMemRspecL1MinLbDynamicMem &l1_min_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_dynamic_mem();
  }






  TmSchPipeMemRspecL1MaxLbStaticMem &l1_max_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_static_mem();
  }








  TmSchPipeMemRspecL1MaxLbDynamicMem &l1_max_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_dynamic_mem();
  }








  SchL1ExcessbucketStaticR &l1_exc_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_static_mem();
  }








  SchL1ExcessbucketDynamicR &l1_exc_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_dynamic_mem();
  }






  TmSchPipeMemRspecQMinLbStaticMem &q_min_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_static_mem();
  }








  TmSchPipeMemRspecQMinLbDynamicMem &q_min_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_dynamic_mem();
  }






  TmSchPipeMemRspecQMaxLbStaticMem &q_max_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_static_mem();
  }








  TmSchPipeMemRspecQMaxLbDynamicMem &q_max_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_dynamic_mem();
  }








  SchQExcessbucketStaticR &q_exc_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_static_mem();
  }








  SchQExcessbucketDynamicR &q_exc_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_dynamic_mem();
  }




  SchQueuePfcStatusR &q_pfc_status_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_pfc_status_mem();
  }




  SchQueueAdvFcStatusR &q_adv_fc_status_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_adv_fc_status_mem();
  }




  SchPOccR &p_occ_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].p_occ_mem();
  }




  SchL1OccR &l1_occ_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_occ_mem();
  }




  SchQOccR &q_occ_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_occ_mem();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmSchPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchPipeMemRspecArrayMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 268435456 * ArraySize(selector_tm_top_mem_rspec, -1), true, write_callback, read_callback, std::string("TmSchPipeMemRspecArrayMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec)),
    array(RealArraySize(selector_tm_top_mem_rspec, -1)),
    size0_(ArraySize(selector_tm_top_mem_rspec, 0)),
    real_size0_(RealArraySize(selector_tm_top_mem_rspec, 0))
    {
    }
public:






  SchPLeakybucketStaticRMutable &port_max_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_static_mem();
  }








  SchPLeakybucketDynamicRMutable &port_max_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].port_max_lb_dynamic_mem();
  }






  TmSchPipeMemRspecL1MinLbStaticMemMutable &l1_min_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_static_mem();
  }








  TmSchPipeMemRspecL1MinLbDynamicMemMutable &l1_min_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_min_lb_dynamic_mem();
  }






  TmSchPipeMemRspecL1MaxLbStaticMemMutable &l1_max_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_static_mem();
  }








  TmSchPipeMemRspecL1MaxLbDynamicMemMutable &l1_max_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_max_lb_dynamic_mem();
  }








  SchL1ExcessbucketStaticRMutable &l1_exc_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_static_mem();
  }








  SchL1ExcessbucketDynamicRMutable &l1_exc_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_exc_dynamic_mem();
  }






  TmSchPipeMemRspecQMinLbStaticMemMutable &q_min_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_static_mem();
  }








  TmSchPipeMemRspecQMinLbDynamicMemMutable &q_min_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_min_lb_dynamic_mem();
  }






  TmSchPipeMemRspecQMaxLbStaticMemMutable &q_max_lb_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_static_mem();
  }








  TmSchPipeMemRspecQMaxLbDynamicMemMutable &q_max_lb_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_max_lb_dynamic_mem();
  }








  SchQExcessbucketStaticRMutable &q_exc_static_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_static_mem();
  }








  SchQExcessbucketDynamicRMutable &q_exc_dynamic_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_exc_dynamic_mem();
  }




  SchQueuePfcStatusRMutable &q_pfc_status_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_pfc_status_mem();
  }




  SchQueueAdvFcStatusRMutable &q_adv_fc_status_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_adv_fc_status_mem();
  }




  SchPOccRMutable &p_occ_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].p_occ_mem();
  }




  SchL1OccRMutable &l1_occ_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].l1_occ_mem();
  }




  SchQOccRMutable &q_occ_mem(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].q_occ_mem();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmSchPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmSchPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmSchPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int ArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      TmTopMemRspecEnum selector_tm_top_mem_rspec, int dimension
      ) {
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      case kTmSchb:
        switch (dimension) {
          case -1:
            return 2;
            break;
          case 0:
            return 2;
            break;
          default:
            assert(0);
            break;
        }
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmSchMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchMemTopRspec(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 8589934592, false, write_callback, read_callback, std::string("TmSchMemTopRspec")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec))
    {
    }
  TmSchMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmSchMemTopRspec")
    {
    }
public:







  TmSchPipeMemRspec &sch_pipe_mem(int j0) { return sch_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      sch_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      sch_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : sch_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += sch_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<2;++a0) {
      r += sch_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmSchPipeMemRspec, 2 > sch_pipe_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmSchMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmTopMemRspecEnum {
    kTmScha,
    kTmSchb
  };
public:
  TmSchMemTopRspecMutable(
      int chipNumber, TmTopMemRspecEnum selector_tm_top_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_top_mem_rspec), 8589934592, true, write_callback, read_callback, std::string("TmSchMemTopRspecMutable")+":"+boost::lexical_cast<std::string>(selector_tm_top_mem_rspec))
    {
    }
  TmSchMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmSchMemTopRspecMutable")
    {
    }
public:







  TmSchPipeMemRspecMutable &sch_pipe_mem(int j0) { return sch_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      sch_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      sch_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : sch_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x20000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += sch_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<2;++a0) {
      r += sch_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmSchPipeMemRspecMutable, 2 > sch_pipe_mem_;
private:
  static uint64_t StartOffset(
      TmTopMemRspecEnum selector_tm_top_mem_rspec
      ) {
    uint64_t offset=0;
    switch (selector_tm_top_mem_rspec) {
      case kTmScha:
        offset += 0x4e00000000; // to get to tm_scha
        break;
      case kTmSchb:
        offset += 0x5200000000; // to get to tm_schb
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};










class QacQidMapping : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQidMapping(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 288, false, write_callback, read_callback, std::string("QacQidMapping")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQidMapping(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQidMapping")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3600; // to get to csr_memory_qac_qid_mapping
    return offset;
  }

};










class QacQidMappingMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQidMappingMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 288, true, write_callback, read_callback, std::string("QacQidMappingMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQidMappingMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQidMappingMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3600; // to get to csr_memory_qac_qid_mapping
    return offset;
  }

};








class QacDropCountQueue : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountQueue(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("QacDropCountQueue")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacDropCountQueue(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacDropCountQueue")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3000; // to get to csr_memory_qac_drop_count_queue
    return offset;
  }

};








class QacDropCountQueueMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountQueueMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("QacDropCountQueueMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacDropCountQueueMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacDropCountQueueMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x3000; // to get to csr_memory_qac_drop_count_queue
    return offset;
  }

};








class QacDropCountPort : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountPort(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 216, false, write_callback, read_callback, std::string("QacDropCountPort")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacDropCountPort(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacDropCountPort")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2e00; // to get to csr_memory_qac_drop_count_port
    return offset;
  }

};








class QacDropCountPortMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacDropCountPortMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 216, true, write_callback, read_callback, std::string("QacDropCountPortMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacDropCountPortMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacDropCountPortMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2e00; // to get to csr_memory_qac_drop_count_port
    return offset;
  }

};









class QacPortCellCount : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortCellCount(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 72, false, write_callback, read_callback, std::string("QacPortCellCount")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacPortCellCount(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacPortCellCount")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d80; // to get to csr_memory_qac_port_cell_count
    return offset;
  }

};









class QacPortCellCountMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortCellCountMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 72, true, write_callback, read_callback, std::string("QacPortCellCountMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacPortCellCountMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacPortCellCountMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d80; // to get to csr_memory_qac_port_cell_count
    return offset;
  }

};









class QacPortConfig : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortConfig(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 72, false, write_callback, read_callback, std::string("QacPortConfig")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacPortConfig(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacPortConfig")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d00; // to get to csr_memory_qac_port_config
    return offset;
  }

};









class QacPortConfigMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortConfigMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 72, true, write_callback, read_callback, std::string("QacPortConfigMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacPortConfigMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacPortConfigMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2d00; // to get to csr_memory_qac_port_config
    return offset;
  }

};









class QacPortWmCellCount : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortWmCellCount(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 72, false, write_callback, read_callback, std::string("QacPortWmCellCount")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacPortWmCellCount(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacPortWmCellCount")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2c80; // to get to csr_memory_qac_port_wm_cell_count
    return offset;
  }

};









class QacPortWmCellCountMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacPortWmCellCountMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 72, true, write_callback, read_callback, std::string("QacPortWmCellCountMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacPortWmCellCountMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacPortWmCellCountMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2c80; // to get to csr_memory_qac_port_wm_cell_count
    return offset;
  }

};









class QacQueueWmCellCount : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueWmCellCount(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("QacQueueWmCellCount")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueWmCellCount(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueWmCellCount")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2800; // to get to csr_memory_qac_queue_wm_cell_count
    return offset;
  }

};









class QacQueueWmCellCountMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueWmCellCountMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("QacQueueWmCellCountMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueWmCellCountMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueWmCellCountMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2800; // to get to csr_memory_qac_queue_wm_cell_count
    return offset;
  }

};









class QacQueueCellCount : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueCellCount(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("QacQueueCellCount")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueCellCount(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueCellCount")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_qac_queue_cell_count
    return offset;
  }

};









class QacQueueCellCountMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueCellCountMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("QacQueueCellCountMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueCellCountMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueCellCountMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_qac_queue_cell_count
    return offset;
  }

};










class QacQueueColorLimit : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueColorLimit(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("QacQueueColorLimit")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueColorLimit(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueColorLimit")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_qac_queue_color_limit
    return offset;
  }

};










class QacQueueColorLimitMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueColorLimitMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("QacQueueColorLimitMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueColorLimitMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueColorLimitMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_qac_queue_color_limit
    return offset;
  }

};









class QacQueueApConfig : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueApConfig(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("QacQueueApConfig")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueApConfig(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueApConfig")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_qac_queue_ap_config
    return offset;
  }

};









class QacQueueApConfigMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueApConfigMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("QacQueueApConfigMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueApConfigMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueApConfigMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_qac_queue_ap_config
    return offset;
  }

};










class QacQueueShrThrdConfig : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueShrThrdConfig(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("QacQueueShrThrdConfig")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueShrThrdConfig(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueShrThrdConfig")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x800; // to get to csr_memory_qac_queue_shr_thrd_config
    return offset;
  }

};










class QacQueueShrThrdConfigMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueShrThrdConfigMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("QacQueueShrThrdConfigMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueShrThrdConfigMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueShrThrdConfigMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    offset += 0x800; // to get to csr_memory_qac_queue_shr_thrd_config
    return offset;
  }

};









class QacQueueMinThrdConfig : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueMinThrdConfig(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("QacQueueMinThrdConfig")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueMinThrdConfig(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "QacQueueMinThrdConfig")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

};









class QacQueueMinThrdConfigMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  QacQueueMinThrdConfigMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("QacQueueMinThrdConfigMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  QacQueueMinThrdConfigMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "QacQueueMinThrdConfigMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

};








class TmQacPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacPipeMemRspec(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmQacPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  TmQacPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQacPipeMemRspec")
    {
    }
public:






  QacQueueMinThrdConfig &csr_memory_qac_queue_min_thrd_config() { return csr_memory_qac_queue_min_thrd_config_; }







  QacQueueShrThrdConfig &csr_memory_qac_queue_shr_thrd_config() { return csr_memory_qac_queue_shr_thrd_config_; }






  QacQueueApConfig &csr_memory_qac_queue_ap_config() { return csr_memory_qac_queue_ap_config_; }







  QacQueueColorLimit &csr_memory_qac_queue_color_limit() { return csr_memory_qac_queue_color_limit_; }






  QacQueueCellCount &csr_memory_qac_queue_cell_count() { return csr_memory_qac_queue_cell_count_; }






  QacQueueWmCellCount &csr_memory_qac_queue_wm_cell_count() { return csr_memory_qac_queue_wm_cell_count_; }






  QacPortWmCellCount &csr_memory_qac_port_wm_cell_count() { return csr_memory_qac_port_wm_cell_count_; }






  QacPortConfig &csr_memory_qac_port_config() { return csr_memory_qac_port_config_; }






  QacPortCellCount &csr_memory_qac_port_cell_count() { return csr_memory_qac_port_cell_count_; }





  QacDropCountPort &csr_memory_qac_drop_count_port() { return csr_memory_qac_drop_count_port_; }





  QacDropCountQueue &csr_memory_qac_drop_count_queue() { return csr_memory_qac_drop_count_queue_; }







  QacQidMapping &csr_memory_qac_qid_mapping() { return csr_memory_qac_qid_mapping_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x480) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_min_thrd_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_shr_thrd_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_ap_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_color_limit_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_wm_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_wm_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_port_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_queue_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      if (read_callback_) read_callback_();
      csr_memory_qac_qid_mapping_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x480) {
      offset -= 0x0;
      csr_memory_qac_queue_min_thrd_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      csr_memory_qac_queue_shr_thrd_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      csr_memory_qac_queue_ap_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      csr_memory_qac_queue_color_limit_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      csr_memory_qac_queue_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      csr_memory_qac_queue_wm_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      csr_memory_qac_port_wm_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      csr_memory_qac_port_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      csr_memory_qac_port_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      csr_memory_qac_drop_count_port_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      csr_memory_qac_drop_count_queue_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      csr_memory_qac_qid_mapping_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_qac_queue_min_thrd_config_.reset();
    csr_memory_qac_queue_shr_thrd_config_.reset();
    csr_memory_qac_queue_ap_config_.reset();
    csr_memory_qac_queue_color_limit_.reset();
    csr_memory_qac_queue_cell_count_.reset();
    csr_memory_qac_queue_wm_cell_count_.reset();
    csr_memory_qac_port_wm_cell_count_.reset();
    csr_memory_qac_port_config_.reset();
    csr_memory_qac_port_cell_count_.reset();
    csr_memory_qac_drop_count_port_.reset();
    csr_memory_qac_drop_count_queue_.reset();
    csr_memory_qac_qid_mapping_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x480) {
      offset -= 0x0;
      r += csr_memory_qac_queue_min_thrd_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      r += csr_memory_qac_queue_shr_thrd_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      r += csr_memory_qac_queue_ap_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      r += csr_memory_qac_queue_color_limit_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      r += csr_memory_qac_queue_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      r += csr_memory_qac_queue_wm_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      r += csr_memory_qac_port_wm_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      r += csr_memory_qac_port_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      r += csr_memory_qac_port_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      r += csr_memory_qac_drop_count_port_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      r += csr_memory_qac_drop_count_queue_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      r += csr_memory_qac_qid_mapping_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_qac_queue_min_thrd_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_shr_thrd_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_ap_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_color_limit_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_wm_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_port_wm_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_port_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_port_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_drop_count_port_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_drop_count_queue_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_qid_mapping_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  QacQueueMinThrdConfig csr_memory_qac_queue_min_thrd_config_;
  QacQueueShrThrdConfig csr_memory_qac_queue_shr_thrd_config_;
  QacQueueApConfig csr_memory_qac_queue_ap_config_;
  QacQueueColorLimit csr_memory_qac_queue_color_limit_;
  QacQueueCellCount csr_memory_qac_queue_cell_count_;
  QacQueueWmCellCount csr_memory_qac_queue_wm_cell_count_;
  QacPortWmCellCount csr_memory_qac_port_wm_cell_count_;
  QacPortConfig csr_memory_qac_port_config_;
  QacPortCellCount csr_memory_qac_port_cell_count_;
  QacDropCountPort csr_memory_qac_drop_count_port_;
  QacDropCountQueue csr_memory_qac_drop_count_queue_;
  QacQidMapping csr_memory_qac_qid_mapping_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

};








class TmQacPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacPipeMemRspecMutable(
      int chipNumber, int index_tm_qac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_qac_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmQacPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_qac_pipe_mem_rspec))
    {
    }
  TmQacPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQacPipeMemRspecMutable")
    {
    }
public:






  QacQueueMinThrdConfigMutable &csr_memory_qac_queue_min_thrd_config() { return csr_memory_qac_queue_min_thrd_config_; }







  QacQueueShrThrdConfigMutable &csr_memory_qac_queue_shr_thrd_config() { return csr_memory_qac_queue_shr_thrd_config_; }






  QacQueueApConfigMutable &csr_memory_qac_queue_ap_config() { return csr_memory_qac_queue_ap_config_; }







  QacQueueColorLimitMutable &csr_memory_qac_queue_color_limit() { return csr_memory_qac_queue_color_limit_; }






  QacQueueCellCountMutable &csr_memory_qac_queue_cell_count() { return csr_memory_qac_queue_cell_count_; }






  QacQueueWmCellCountMutable &csr_memory_qac_queue_wm_cell_count() { return csr_memory_qac_queue_wm_cell_count_; }






  QacPortWmCellCountMutable &csr_memory_qac_port_wm_cell_count() { return csr_memory_qac_port_wm_cell_count_; }






  QacPortConfigMutable &csr_memory_qac_port_config() { return csr_memory_qac_port_config_; }






  QacPortCellCountMutable &csr_memory_qac_port_cell_count() { return csr_memory_qac_port_cell_count_; }





  QacDropCountPortMutable &csr_memory_qac_drop_count_port() { return csr_memory_qac_drop_count_port_; }





  QacDropCountQueueMutable &csr_memory_qac_drop_count_queue() { return csr_memory_qac_drop_count_queue_; }







  QacQidMappingMutable &csr_memory_qac_qid_mapping() { return csr_memory_qac_qid_mapping_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x480) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_min_thrd_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_shr_thrd_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_ap_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_color_limit_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      if (read_callback_) read_callback_();
      csr_memory_qac_queue_wm_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_wm_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_config_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      if (read_callback_) read_callback_();
      csr_memory_qac_port_cell_count_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_port_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      if (read_callback_) read_callback_();
      csr_memory_qac_drop_count_queue_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      if (read_callback_) read_callback_();
      csr_memory_qac_qid_mapping_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x480) {
      offset -= 0x0;
      csr_memory_qac_queue_min_thrd_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      csr_memory_qac_queue_shr_thrd_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      csr_memory_qac_queue_ap_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      csr_memory_qac_queue_color_limit_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      csr_memory_qac_queue_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      csr_memory_qac_queue_wm_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      csr_memory_qac_port_wm_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      csr_memory_qac_port_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      csr_memory_qac_port_cell_count_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      csr_memory_qac_drop_count_port_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      csr_memory_qac_drop_count_queue_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      csr_memory_qac_qid_mapping_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_qac_queue_min_thrd_config_.reset();
    csr_memory_qac_queue_shr_thrd_config_.reset();
    csr_memory_qac_queue_ap_config_.reset();
    csr_memory_qac_queue_color_limit_.reset();
    csr_memory_qac_queue_cell_count_.reset();
    csr_memory_qac_queue_wm_cell_count_.reset();
    csr_memory_qac_port_wm_cell_count_.reset();
    csr_memory_qac_port_config_.reset();
    csr_memory_qac_port_cell_count_.reset();
    csr_memory_qac_drop_count_port_.reset();
    csr_memory_qac_drop_count_queue_.reset();
    csr_memory_qac_qid_mapping_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x480) {
      offset -= 0x0;
      r += csr_memory_qac_queue_min_thrd_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0xc80) {
      offset -= 0x800;
      r += csr_memory_qac_queue_shr_thrd_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1480) {
      offset -= 0x1000;
      r += csr_memory_qac_queue_ap_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      r += csr_memory_qac_queue_color_limit_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      r += csr_memory_qac_queue_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2c80) {
      offset -= 0x2800;
      r += csr_memory_qac_queue_wm_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c80 && offset < 0x2cc8) {
      offset -= 0x2c80;
      r += csr_memory_qac_port_wm_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d00 && offset < 0x2d48) {
      offset -= 0x2d00;
      r += csr_memory_qac_port_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2d80 && offset < 0x2dc8) {
      offset -= 0x2d80;
      r += csr_memory_qac_port_cell_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2e00 && offset < 0x2ed8) {
      offset -= 0x2e00;
      r += csr_memory_qac_drop_count_port_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3480) {
      offset -= 0x3000;
      r += csr_memory_qac_drop_count_queue_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3600 && offset < 0x3720) {
      offset -= 0x3600;
      r += csr_memory_qac_qid_mapping_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_qac_queue_min_thrd_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_shr_thrd_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_ap_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_color_limit_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_queue_wm_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_port_wm_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_port_config_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_port_cell_count_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_drop_count_port_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_drop_count_queue_.to_string(print_zeros,indent_string) ;
    r += csr_memory_qac_qid_mapping_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  QacQueueMinThrdConfigMutable csr_memory_qac_queue_min_thrd_config_;
  QacQueueShrThrdConfigMutable csr_memory_qac_queue_shr_thrd_config_;
  QacQueueApConfigMutable csr_memory_qac_queue_ap_config_;
  QacQueueColorLimitMutable csr_memory_qac_queue_color_limit_;
  QacQueueCellCountMutable csr_memory_qac_queue_cell_count_;
  QacQueueWmCellCountMutable csr_memory_qac_queue_wm_cell_count_;
  QacPortWmCellCountMutable csr_memory_qac_port_wm_cell_count_;
  QacPortConfigMutable csr_memory_qac_port_config_;
  QacPortCellCountMutable csr_memory_qac_port_cell_count_;
  QacDropCountPortMutable csr_memory_qac_drop_count_port_;
  QacDropCountQueueMutable csr_memory_qac_drop_count_queue_;
  QacQidMappingMutable csr_memory_qac_qid_mapping_;
private:
  static uint64_t StartOffset(
      int index_tm_qac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    assert(index_tm_qac_pipe_mem_rspec < 4);
    offset += index_tm_qac_pipe_mem_rspec * 0x10000000; // tm_qac_pipe_mem_rspec[]
    return offset;
  }

};








class TmQacPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQacPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmQacPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:






  QacQueueMinThrdConfig &csr_memory_qac_queue_min_thrd_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_min_thrd_config();
  }







  QacQueueShrThrdConfig &csr_memory_qac_queue_shr_thrd_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_shr_thrd_config();
  }






  QacQueueApConfig &csr_memory_qac_queue_ap_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_ap_config();
  }







  QacQueueColorLimit &csr_memory_qac_queue_color_limit(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_color_limit();
  }






  QacQueueCellCount &csr_memory_qac_queue_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_cell_count();
  }






  QacQueueWmCellCount &csr_memory_qac_queue_wm_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_wm_cell_count();
  }






  QacPortWmCellCount &csr_memory_qac_port_wm_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_wm_cell_count();
  }






  QacPortConfig &csr_memory_qac_port_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_config();
  }






  QacPortCellCount &csr_memory_qac_port_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_cell_count();
  }





  QacDropCountPort &csr_memory_qac_drop_count_port(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_port();
  }





  QacDropCountQueue &csr_memory_qac_drop_count_queue(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_queue();
  }







  QacQidMapping &csr_memory_qac_qid_mapping(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_qid_mapping();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQacPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQacPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmQacPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmQacPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:






  QacQueueMinThrdConfigMutable &csr_memory_qac_queue_min_thrd_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_min_thrd_config();
  }







  QacQueueShrThrdConfigMutable &csr_memory_qac_queue_shr_thrd_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_shr_thrd_config();
  }






  QacQueueApConfigMutable &csr_memory_qac_queue_ap_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_ap_config();
  }







  QacQueueColorLimitMutable &csr_memory_qac_queue_color_limit(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_color_limit();
  }






  QacQueueCellCountMutable &csr_memory_qac_queue_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_cell_count();
  }






  QacQueueWmCellCountMutable &csr_memory_qac_queue_wm_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_queue_wm_cell_count();
  }






  QacPortWmCellCountMutable &csr_memory_qac_port_wm_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_wm_cell_count();
  }






  QacPortConfigMutable &csr_memory_qac_port_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_config();
  }






  QacPortCellCountMutable &csr_memory_qac_port_cell_count(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_port_cell_count();
  }





  QacDropCountPortMutable &csr_memory_qac_drop_count_port(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_port();
  }





  QacDropCountQueueMutable &csr_memory_qac_drop_count_queue(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_drop_count_queue();
  }







  QacQidMappingMutable &csr_memory_qac_qid_mapping(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_qac_qid_mapping();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmQacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmQacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmQacPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmQacMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmQacMemTopRspec"))
    {
    }
  TmQacMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmQacMemTopRspec")
    {
    }
public:







  TmQacPipeMemRspec &qac_pipe_mem(int j0) { return qac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQacPipeMemRspec, 4 > qac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

};








class TmQacMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmQacMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmQacMemTopRspecMutable"))
    {
    }
  TmQacMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmQacMemTopRspecMutable")
    {
    }
public:







  TmQacPipeMemRspecMutable &qac_pipe_mem(int j0) { return qac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      qac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      qac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : qac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += qac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += qac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmQacPipeMemRspecMutable, 4 > qac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4a00000000; // to get to tm_qac
    return offset;
  }

};









class CaaBlockFreePtrMemory : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmCaaMemTopRspecEnum {
    kCaaBlockGrp0,
    kCaaBlockGrp1,
    kCaaBlockGrp2,
    kCaaBlockGrp3,
    kCaaBlockGrp4,
    kCaaBlockGrp5
  };
public:
  CaaBlockFreePtrMemory(
      int chipNumber, TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_caa_mem_top_rspec), 32768, false, write_callback, read_callback, std::string("CaaBlockFreePtrMemory")+":"+boost::lexical_cast<std::string>(selector_tm_caa_mem_top_rspec))
    {
    }
  CaaBlockFreePtrMemory(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "CaaBlockFreePtrMemory")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        break;
      case kCaaBlockGrp1:
        offset += 0x8000; // to get to caa_block_grp1
        break;
      case kCaaBlockGrp2:
        offset += 0x10000; // to get to caa_block_grp2
        break;
      case kCaaBlockGrp3:
        offset += 0x18000; // to get to caa_block_grp3
        break;
      case kCaaBlockGrp4:
        offset += 0x20000; // to get to caa_block_grp4
        break;
      case kCaaBlockGrp5:
        offset += 0x28000; // to get to caa_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class CaaBlockFreePtrMemoryMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmCaaMemTopRspecEnum {
    kCaaBlockGrp0,
    kCaaBlockGrp1,
    kCaaBlockGrp2,
    kCaaBlockGrp3,
    kCaaBlockGrp4,
    kCaaBlockGrp5
  };
public:
  CaaBlockFreePtrMemoryMutable(
      int chipNumber, TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(selector_tm_caa_mem_top_rspec), 32768, true, write_callback, read_callback, std::string("CaaBlockFreePtrMemoryMutable")+":"+boost::lexical_cast<std::string>(selector_tm_caa_mem_top_rspec))
    {
    }
  CaaBlockFreePtrMemoryMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "CaaBlockFreePtrMemoryMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      TmCaaMemTopRspecEnum selector_tm_caa_mem_top_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    switch (selector_tm_caa_mem_top_rspec) {
      case kCaaBlockGrp0:
        break;
      case kCaaBlockGrp1:
        offset += 0x8000; // to get to caa_block_grp1
        break;
      case kCaaBlockGrp2:
        offset += 0x10000; // to get to caa_block_grp2
        break;
      case kCaaBlockGrp3:
        offset += 0x18000; // to get to caa_block_grp3
        break;
      case kCaaBlockGrp4:
        offset += 0x20000; // to get to caa_block_grp4
        break;
      case kCaaBlockGrp5:
        offset += 0x28000; // to get to caa_block_grp5
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class TmCaaMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmCaaMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmCaaMemTopRspec"))
    {
    }
  TmCaaMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmCaaMemTopRspec")
    {
    }
public:






  CaaBlockFreePtrMemory &caa_block_grp0() { return caa_block_grp0_; }






  CaaBlockFreePtrMemory &caa_block_grp1() { return caa_block_grp1_; }






  CaaBlockFreePtrMemory &caa_block_grp2() { return caa_block_grp2_; }






  CaaBlockFreePtrMemory &caa_block_grp3() { return caa_block_grp3_; }






  CaaBlockFreePtrMemory &caa_block_grp4() { return caa_block_grp4_; }






  CaaBlockFreePtrMemory &caa_block_grp5() { return caa_block_grp5_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      caa_block_grp0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      if (read_callback_) read_callback_();
      caa_block_grp1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      if (read_callback_) read_callback_();
      caa_block_grp2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      if (read_callback_) read_callback_();
      caa_block_grp3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      if (read_callback_) read_callback_();
      caa_block_grp4_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      if (read_callback_) read_callback_();
      caa_block_grp5_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      caa_block_grp0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      caa_block_grp1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      caa_block_grp2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      caa_block_grp3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      caa_block_grp4_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      caa_block_grp5_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    caa_block_grp0_.reset();
    caa_block_grp1_.reset();
    caa_block_grp2_.reset();
    caa_block_grp3_.reset();
    caa_block_grp4_.reset();
    caa_block_grp5_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      r += caa_block_grp0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      r += caa_block_grp1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      r += caa_block_grp2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      r += caa_block_grp3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      r += caa_block_grp4_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      r += caa_block_grp5_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += caa_block_grp0_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp1_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp2_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp3_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp4_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp5_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  CaaBlockFreePtrMemory caa_block_grp0_;
  CaaBlockFreePtrMemory caa_block_grp1_;
  CaaBlockFreePtrMemory caa_block_grp2_;
  CaaBlockFreePtrMemory caa_block_grp3_;
  CaaBlockFreePtrMemory caa_block_grp4_;
  CaaBlockFreePtrMemory caa_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    return offset;
  }

};








class TmCaaMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmCaaMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmCaaMemTopRspecMutable"))
    {
    }
  TmCaaMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmCaaMemTopRspecMutable")
    {
    }
public:






  CaaBlockFreePtrMemoryMutable &caa_block_grp0() { return caa_block_grp0_; }






  CaaBlockFreePtrMemoryMutable &caa_block_grp1() { return caa_block_grp1_; }






  CaaBlockFreePtrMemoryMutable &caa_block_grp2() { return caa_block_grp2_; }






  CaaBlockFreePtrMemoryMutable &caa_block_grp3() { return caa_block_grp3_; }






  CaaBlockFreePtrMemoryMutable &caa_block_grp4() { return caa_block_grp4_; }






  CaaBlockFreePtrMemoryMutable &caa_block_grp5() { return caa_block_grp5_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x8000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      caa_block_grp0_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      if (read_callback_) read_callback_();
      caa_block_grp1_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      if (read_callback_) read_callback_();
      caa_block_grp2_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      if (read_callback_) read_callback_();
      caa_block_grp3_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      if (read_callback_) read_callback_();
      caa_block_grp4_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      if (read_callback_) read_callback_();
      caa_block_grp5_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x8000) {
      offset -= 0x0;
      caa_block_grp0_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      caa_block_grp1_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      caa_block_grp2_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      caa_block_grp3_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      caa_block_grp4_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      caa_block_grp5_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    caa_block_grp0_.reset();
    caa_block_grp1_.reset();
    caa_block_grp2_.reset();
    caa_block_grp3_.reset();
    caa_block_grp4_.reset();
    caa_block_grp5_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x8000) {
      offset -= 0x0;
      r += caa_block_grp0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x10000) {
      offset -= 0x8000;
      r += caa_block_grp1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10000 && offset < 0x18000) {
      offset -= 0x10000;
      r += caa_block_grp2_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      r += caa_block_grp3_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000 && offset < 0x28000) {
      offset -= 0x20000;
      r += caa_block_grp4_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28000 && offset < 0x30000) {
      offset -= 0x28000;
      r += caa_block_grp5_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += caa_block_grp0_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp1_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp2_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp3_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp4_.to_string(print_zeros,indent_string) ;
    r += caa_block_grp5_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  CaaBlockFreePtrMemoryMutable caa_block_grp0_;
  CaaBlockFreePtrMemoryMutable caa_block_grp1_;
  CaaBlockFreePtrMemoryMutable caa_block_grp2_;
  CaaBlockFreePtrMemoryMutable caa_block_grp3_;
  CaaBlockFreePtrMemoryMutable caa_block_grp4_;
  CaaBlockFreePtrMemoryMutable caa_block_grp5_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4600000000; // to get to tm_caa
    return offset;
  }

};









class WacQacqApConfig : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqApConfig(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("WacQacqApConfig")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacQacqApConfig(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacQacqApConfig")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_wac_qacq_ap_config
    return offset;
  }

};









class WacQacqApConfigMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqApConfigMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("WacQacqApConfigMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacQacqApConfigMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacQacqApConfigMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x2000; // to get to csr_memory_wac_qacq_ap_config
    return offset;
  }

};









class WacQacqState : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqState(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1152, false, write_callback, read_callback, std::string("WacQacqState")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacQacqState(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacQacqState")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_wac_qacq_state
    return offset;
  }

};









class WacQacqStateMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQacqStateMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 1152, true, write_callback, read_callback, std::string("WacQacqStateMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacQacqStateMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacQacqStateMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1800; // to get to csr_memory_wac_qacq_state
    return offset;
  }

};











class WacQidMap : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQidMap(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 576, false, write_callback, read_callback, std::string("WacQidMap")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacQidMap(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacQidMap")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_wac_qid_map
    return offset;
  }

};











class WacQidMapMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacQidMapMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 576, true, write_callback, read_callback, std::string("WacQidMapMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacQidMapMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacQidMapMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x1000; // to get to csr_memory_wac_qid_map
    return offset;
  }

};










class WacPfcState : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPfcState(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 72, false, write_callback, read_callback, std::string("WacPfcState")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPfcState(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPfcState")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf80; // to get to csr_memory_wac_pfc_state
    return offset;
  }

};










class WacPfcStateMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPfcStateMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 72, true, write_callback, read_callback, std::string("WacPfcStateMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPfcStateMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPfcStateMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf80; // to get to csr_memory_wac_pfc_state
    return offset;
  }

};










class WacDropCountPort : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPort(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacDropCountPort")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacDropCountPort(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacDropCountPort")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf00; // to get to csr_memory_wac_drop_count_port
    return offset;
  }

};










class WacDropCountPortMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPortMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacDropCountPortMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacDropCountPortMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacDropCountPortMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xf00; // to get to csr_memory_wac_drop_count_port
    return offset;
  }

};















class WacDropCountPpg : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPpg(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 201, false, write_callback, read_callback, std::string("WacDropCountPpg")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacDropCountPpg(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacDropCountPpg")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xe00; // to get to csr_memory_wac_drop_count_ppg
    return offset;
  }

};















class WacDropCountPpgMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacDropCountPpgMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 201, true, write_callback, read_callback, std::string("WacDropCountPpgMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacDropCountPpgMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacDropCountPpgMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xe00; // to get to csr_memory_wac_drop_count_ppg
    return offset;
  }

};









class WacPgWmCnt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgWmCnt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 201, false, write_callback, read_callback, std::string("WacPgWmCnt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgWmCnt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgWmCnt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xd00; // to get to csr_memory_wac_pg_wm_cnt
    return offset;
  }

};









class WacPgWmCntMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgWmCntMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 201, true, write_callback, read_callback, std::string("WacPgWmCntMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgWmCntMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgWmCntMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xd00; // to get to csr_memory_wac_pg_wm_cnt
    return offset;
  }

};








class WacPortSt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortSt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacPortSt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortSt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortSt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xc80; // to get to csr_memory_wac_port_st
    return offset;
  }

};








class WacPortStMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortStMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacPortStMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortStMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortStMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0xc80; // to get to csr_memory_wac_port_st
    return offset;
  }

};











class WacPortCnt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrCnt,
    kCsrMemoryWacPortMinCnt,
    kCsrMemoryWacPortShrCnt,
    kCsrMemoryWacPortWm
  };
public:
  WacPortCnt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacPortCnt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortCnt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortCnt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        offset += 0xb80; // to get to csr_memory_wac_port_hdr_cnt
        break;
      case kCsrMemoryWacPortMinCnt:
        offset += 0xb00; // to get to csr_memory_wac_port_min_cnt
        break;
      case kCsrMemoryWacPortShrCnt:
        offset += 0xc00; // to get to csr_memory_wac_port_shr_cnt
        break;
      case kCsrMemoryWacPortWm:
        offset += 0xa80; // to get to csr_memory_wac_port_wm
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class WacPortCntMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrCnt,
    kCsrMemoryWacPortMinCnt,
    kCsrMemoryWacPortShrCnt,
    kCsrMemoryWacPortWm
  };
public:
  WacPortCntMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacPortCntMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortCntMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortCntMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrCnt:
        offset += 0xb80; // to get to csr_memory_wac_port_hdr_cnt
        break;
      case kCsrMemoryWacPortMinCnt:
        offset += 0xb00; // to get to csr_memory_wac_port_min_cnt
        break;
      case kCsrMemoryWacPortShrCnt:
        offset += 0xc00; // to get to csr_memory_wac_port_shr_cnt
        break;
      case kCsrMemoryWacPortWm:
        offset += 0xa80; // to get to csr_memory_wac_port_wm
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class WacPortTh : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrTh,
    kCsrMemoryWacPortShrTh
  };
public:
  WacPortTh(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacPortTh")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortTh(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortTh")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        offset += 0xa00; // to get to csr_memory_wac_port_hdr_th
        break;
      case kCsrMemoryWacPortShrTh:
        offset += 0x980; // to get to csr_memory_wac_port_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};











class WacPortThMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPortHdrTh,
    kCsrMemoryWacPortShrTh
  };
public:
  WacPortThMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacPortThMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortThMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortThMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPortHdrTh:
        offset += 0xa00; // to get to csr_memory_wac_port_hdr_th
        break;
      case kCsrMemoryWacPortShrTh:
        offset += 0x980; // to get to csr_memory_wac_port_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgTh : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinTh,
    kCsrMemoryWacPgShrTh
  };
public:
  WacPgTh(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacPgTh")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgTh(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgTh")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        offset += 0x880; // to get to csr_memory_wac_pg_min_th
        break;
      case kCsrMemoryWacPgShrTh:
        offset += 0x900; // to get to csr_memory_wac_pg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgThMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinTh,
    kCsrMemoryWacPgShrTh
  };
public:
  WacPgThMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacPgThMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgThMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgThMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinTh:
        offset += 0x880; // to get to csr_memory_wac_pg_min_th
        break;
      case kCsrMemoryWacPgShrTh:
        offset += 0x900; // to get to csr_memory_wac_pg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgCnt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinCnt,
    kCsrMemoryWacPgShrCnt
  };
public:
  WacPgCnt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacPgCnt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgCnt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgCnt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        offset += 0x780; // to get to csr_memory_wac_pg_min_cnt
        break;
      case kCsrMemoryWacPgShrCnt:
        offset += 0x800; // to get to csr_memory_wac_pg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgCntMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPgMinCnt,
    kCsrMemoryWacPgShrCnt
  };
public:
  WacPgCntMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacPgCntMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgCntMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgCntMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPgMinCnt:
        offset += 0x780; // to get to csr_memory_wac_pg_min_cnt
        break;
      case kCsrMemoryWacPgShrCnt:
        offset += 0x800; // to get to csr_memory_wac_pg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPgOffIdx : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgOffIdx(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacPgOffIdx")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgOffIdx(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgOffIdx")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x700; // to get to csr_memory_wac_pg_off_idx
    return offset;
  }

};









class WacPgOffIdxMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgOffIdxMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacPgOffIdxMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgOffIdxMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgOffIdxMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x700; // to get to csr_memory_wac_pg_off_idx
    return offset;
  }

};








class WacPpgOffIdx : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgOffIdx(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, false, write_callback, read_callback, std::string("WacPpgOffIdx")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgOffIdx(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgOffIdx")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x680; // to get to csr_memory_wac_ppg_off_idx
    return offset;
  }

};








class WacPpgOffIdxMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgOffIdxMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, true, write_callback, read_callback, std::string("WacPpgOffIdxMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgOffIdxMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgOffIdxMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x680; // to get to csr_memory_wac_ppg_off_idx
    return offset;
  }

};









class WacPgDropSt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgDropSt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, false, write_callback, read_callback, std::string("WacPgDropSt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgDropSt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPgDropSt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x600; // to get to csr_memory_wac_pg_drop_st
    return offset;
  }

};









class WacPgDropStMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPgDropStMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 73, true, write_callback, read_callback, std::string("WacPgDropStMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPgDropStMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPgDropStMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x600; // to get to csr_memory_wac_pg_drop_st
    return offset;
  }

};








class WacPpgDropSt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgDropSt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, false, write_callback, read_callback, std::string("WacPpgDropSt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgDropSt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgDropSt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x580; // to get to csr_memory_wac_ppg_drop_st
    return offset;
  }

};








class WacPpgDropStMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgDropStMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, true, write_callback, read_callback, std::string("WacPpgDropStMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgDropStMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgDropStMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x580; // to get to csr_memory_wac_ppg_drop_st
    return offset;
  }

};








class WacPpgIcos : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgIcos(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, false, write_callback, read_callback, std::string("WacPpgIcos")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgIcos(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgIcos")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x500; // to get to csr_memory_wac_ppg_icos
    return offset;
  }

};








class WacPpgIcosMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgIcosMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, true, write_callback, read_callback, std::string("WacPpgIcosMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgIcosMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgIcosMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x500; // to get to csr_memory_wac_ppg_icos
    return offset;
  }

};








class WacPpgPfc : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgPfc(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, false, write_callback, read_callback, std::string("WacPpgPfc")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgPfc(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgPfc")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x480; // to get to csr_memory_wac_ppg_pfc
    return offset;
  }

};








class WacPpgPfcMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPpgPfcMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 128, true, write_callback, read_callback, std::string("WacPpgPfcMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgPfcMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgPfcMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    offset += 0x480; // to get to csr_memory_wac_ppg_pfc
    return offset;
  }

};








class WacPpgTh : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrTh,
    kCsrMemoryWacPpgMinTh,
    kCsrMemoryWacPpgShrTh
  };
public:
  WacPpgTh(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 128, false, write_callback, read_callback, std::string("WacPpgTh")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgTh(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgTh")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        offset += 0x400; // to get to csr_memory_wac_ppg_hdr_th
        break;
      case kCsrMemoryWacPpgMinTh:
        offset += 0x300; // to get to csr_memory_wac_ppg_min_th
        break;
      case kCsrMemoryWacPpgShrTh:
        offset += 0x380; // to get to csr_memory_wac_ppg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class WacPpgThMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrTh,
    kCsrMemoryWacPpgMinTh,
    kCsrMemoryWacPpgShrTh
  };
public:
  WacPpgThMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 128, true, write_callback, read_callback, std::string("WacPpgThMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgThMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgThMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrTh:
        offset += 0x400; // to get to csr_memory_wac_ppg_hdr_th
        break;
      case kCsrMemoryWacPpgMinTh:
        offset += 0x300; // to get to csr_memory_wac_ppg_min_th
        break;
      case kCsrMemoryWacPpgShrTh:
        offset += 0x380; // to get to csr_memory_wac_ppg_shr_th
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class WacPpgCnt : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrCnt,
    kCsrMemoryWacPpgMinCnt,
    kCsrMemoryWacPpgShrCnt
  };
public:
  WacPpgCnt(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 128, false, write_callback, read_callback, std::string("WacPpgCnt")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgCnt(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPpgCnt")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        offset += 0x280; // to get to csr_memory_wac_ppg_hdr_cnt
        break;
      case kCsrMemoryWacPpgMinCnt:
        offset += 0x180; // to get to csr_memory_wac_ppg_min_cnt
        break;
      case kCsrMemoryWacPpgShrCnt:
        offset += 0x200; // to get to csr_memory_wac_ppg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};








class WacPpgCntMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  enum TmWacPipeMemRspecEnum {
    kCsrMemoryWacPpgHdrCnt,
    kCsrMemoryWacPpgMinCnt,
    kCsrMemoryWacPpgShrCnt
  };
public:
  WacPpgCntMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec, selector_tm_wac_pipe_mem_rspec), 128, true, write_callback, read_callback, std::string("WacPpgCntMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec) + "," + boost::lexical_cast<std::string>(selector_tm_wac_pipe_mem_rspec))
    {
    }
  WacPpgCntMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPpgCntMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec, TmWacPipeMemRspecEnum selector_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    switch (selector_tm_wac_pipe_mem_rspec) {
      case kCsrMemoryWacPpgHdrCnt:
        offset += 0x280; // to get to csr_memory_wac_ppg_hdr_cnt
        break;
      case kCsrMemoryWacPpgMinCnt:
        offset += 0x180; // to get to csr_memory_wac_ppg_min_cnt
        break;
      case kCsrMemoryWacPpgShrCnt:
        offset += 0x200; // to get to csr_memory_wac_ppg_shr_cnt
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









class WacPortPpgMapping : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortPpgMapping(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 292, false, write_callback, read_callback, std::string("WacPortPpgMapping")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortPpgMapping(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "WacPortPpgMapping")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

};









class WacPortPpgMappingMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  WacPortPpgMappingMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 292, true, write_callback, read_callback, std::string("WacPortPpgMappingMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  WacPortPpgMappingMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "WacPortPpgMappingMutable")
    {
    }
public:

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    return true;
  }

  void reset(
      
      ) {
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

};








class TmWacPipeMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacPipeMemRspec(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 268435456, false, write_callback, read_callback, std::string("TmWacPipeMemRspec")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  TmWacPipeMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmWacPipeMemRspec")
    {
    }
public:






  WacPortPpgMapping &csr_memory_wac_port_ppg_mapping() { return csr_memory_wac_port_ppg_mapping_; }





  WacPpgCnt &csr_memory_wac_ppg_min_cnt() { return csr_memory_wac_ppg_min_cnt_; }





  WacPpgCnt &csr_memory_wac_ppg_shr_cnt() { return csr_memory_wac_ppg_shr_cnt_; }





  WacPpgCnt &csr_memory_wac_ppg_hdr_cnt() { return csr_memory_wac_ppg_hdr_cnt_; }





  WacPpgTh &csr_memory_wac_ppg_min_th() { return csr_memory_wac_ppg_min_th_; }





  WacPpgTh &csr_memory_wac_ppg_shr_th() { return csr_memory_wac_ppg_shr_th_; }





  WacPpgTh &csr_memory_wac_ppg_hdr_th() { return csr_memory_wac_ppg_hdr_th_; }





  WacPpgPfc &csr_memory_wac_ppg_pfc() { return csr_memory_wac_ppg_pfc_; }





  WacPpgIcos &csr_memory_wac_ppg_icos() { return csr_memory_wac_ppg_icos_; }





  WacPpgDropSt &csr_memory_wac_ppg_drop_st() { return csr_memory_wac_ppg_drop_st_; }






  WacPgDropSt &csr_memory_wac_pg_drop_st() { return csr_memory_wac_pg_drop_st_; }





  WacPpgOffIdx &csr_memory_wac_ppg_off_idx() { return csr_memory_wac_ppg_off_idx_; }






  WacPgOffIdx &csr_memory_wac_pg_off_idx() { return csr_memory_wac_pg_off_idx_; }






  WacPgCnt &csr_memory_wac_pg_min_cnt() { return csr_memory_wac_pg_min_cnt_; }






  WacPgCnt &csr_memory_wac_pg_shr_cnt() { return csr_memory_wac_pg_shr_cnt_; }






  WacPgTh &csr_memory_wac_pg_min_th() { return csr_memory_wac_pg_min_th_; }






  WacPgTh &csr_memory_wac_pg_shr_th() { return csr_memory_wac_pg_shr_th_; }








  WacPortTh &csr_memory_wac_port_shr_th() { return csr_memory_wac_port_shr_th_; }








  WacPortTh &csr_memory_wac_port_hdr_th() { return csr_memory_wac_port_hdr_th_; }








  WacPortCnt &csr_memory_wac_port_wm() { return csr_memory_wac_port_wm_; }








  WacPortCnt &csr_memory_wac_port_min_cnt() { return csr_memory_wac_port_min_cnt_; }








  WacPortCnt &csr_memory_wac_port_hdr_cnt() { return csr_memory_wac_port_hdr_cnt_; }








  WacPortCnt &csr_memory_wac_port_shr_cnt() { return csr_memory_wac_port_shr_cnt_; }





  WacPortSt &csr_memory_wac_port_st() { return csr_memory_wac_port_st_; }






  WacPgWmCnt &csr_memory_wac_pg_wm_cnt() { return csr_memory_wac_pg_wm_cnt_; }












  WacDropCountPpg &csr_memory_wac_drop_count_ppg() { return csr_memory_wac_drop_count_ppg_; }







  WacDropCountPort &csr_memory_wac_drop_count_port() { return csr_memory_wac_drop_count_port_; }







  WacPfcState &csr_memory_wac_pfc_state() { return csr_memory_wac_pfc_state_; }








  WacQidMap &csr_memory_wac_qid_map() { return csr_memory_wac_qid_map_; }






  WacQacqState &csr_memory_wac_qacq_state() { return csr_memory_wac_qacq_state_; }






  WacQacqApConfig &csr_memory_wac_qacq_ap_config() { return csr_memory_wac_qacq_ap_config_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x124) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_ppg_mapping_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_pfc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_icos_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_drop_st_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_drop_st_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_off_idx_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_off_idx_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_wm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_min_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_st_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_wm_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_ppg_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_port_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      if (read_callback_) read_callback_();
      csr_memory_wac_pfc_state_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      if (read_callback_) read_callback_();
      csr_memory_wac_qid_map_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_state_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_ap_config_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x124) {
      offset -= 0x0;
      csr_memory_wac_port_ppg_mapping_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      csr_memory_wac_ppg_min_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      csr_memory_wac_ppg_shr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      csr_memory_wac_ppg_hdr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      csr_memory_wac_ppg_min_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      csr_memory_wac_ppg_shr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      csr_memory_wac_ppg_hdr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      csr_memory_wac_ppg_pfc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      csr_memory_wac_ppg_icos_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      csr_memory_wac_ppg_drop_st_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      csr_memory_wac_pg_drop_st_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      csr_memory_wac_ppg_off_idx_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      csr_memory_wac_pg_off_idx_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      csr_memory_wac_pg_min_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      csr_memory_wac_pg_shr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      csr_memory_wac_pg_min_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      csr_memory_wac_pg_shr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      csr_memory_wac_port_shr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      csr_memory_wac_port_hdr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      csr_memory_wac_port_wm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      csr_memory_wac_port_min_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      csr_memory_wac_port_hdr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      csr_memory_wac_port_shr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      csr_memory_wac_port_st_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      csr_memory_wac_pg_wm_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      csr_memory_wac_drop_count_ppg_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      csr_memory_wac_drop_count_port_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      csr_memory_wac_pfc_state_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      csr_memory_wac_qid_map_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      csr_memory_wac_qacq_state_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      csr_memory_wac_qacq_ap_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_wac_port_ppg_mapping_.reset();
    csr_memory_wac_ppg_min_cnt_.reset();
    csr_memory_wac_ppg_shr_cnt_.reset();
    csr_memory_wac_ppg_hdr_cnt_.reset();
    csr_memory_wac_ppg_min_th_.reset();
    csr_memory_wac_ppg_shr_th_.reset();
    csr_memory_wac_ppg_hdr_th_.reset();
    csr_memory_wac_ppg_pfc_.reset();
    csr_memory_wac_ppg_icos_.reset();
    csr_memory_wac_ppg_drop_st_.reset();
    csr_memory_wac_pg_drop_st_.reset();
    csr_memory_wac_ppg_off_idx_.reset();
    csr_memory_wac_pg_off_idx_.reset();
    csr_memory_wac_pg_min_cnt_.reset();
    csr_memory_wac_pg_shr_cnt_.reset();
    csr_memory_wac_pg_min_th_.reset();
    csr_memory_wac_pg_shr_th_.reset();
    csr_memory_wac_port_shr_th_.reset();
    csr_memory_wac_port_hdr_th_.reset();
    csr_memory_wac_port_wm_.reset();
    csr_memory_wac_port_min_cnt_.reset();
    csr_memory_wac_port_hdr_cnt_.reset();
    csr_memory_wac_port_shr_cnt_.reset();
    csr_memory_wac_port_st_.reset();
    csr_memory_wac_pg_wm_cnt_.reset();
    csr_memory_wac_drop_count_ppg_.reset();
    csr_memory_wac_drop_count_port_.reset();
    csr_memory_wac_pfc_state_.reset();
    csr_memory_wac_qid_map_.reset();
    csr_memory_wac_qacq_state_.reset();
    csr_memory_wac_qacq_ap_config_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x124) {
      offset -= 0x0;
      r += csr_memory_wac_port_ppg_mapping_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      r += csr_memory_wac_ppg_min_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      r += csr_memory_wac_ppg_shr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      r += csr_memory_wac_ppg_hdr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      r += csr_memory_wac_ppg_min_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      r += csr_memory_wac_ppg_shr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      r += csr_memory_wac_ppg_hdr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      r += csr_memory_wac_ppg_pfc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      r += csr_memory_wac_ppg_icos_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      r += csr_memory_wac_ppg_drop_st_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      r += csr_memory_wac_pg_drop_st_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      r += csr_memory_wac_ppg_off_idx_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      r += csr_memory_wac_pg_off_idx_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      r += csr_memory_wac_pg_min_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      r += csr_memory_wac_pg_shr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      r += csr_memory_wac_pg_min_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      r += csr_memory_wac_pg_shr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      r += csr_memory_wac_port_shr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      r += csr_memory_wac_port_hdr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      r += csr_memory_wac_port_wm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      r += csr_memory_wac_port_min_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      r += csr_memory_wac_port_hdr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      r += csr_memory_wac_port_shr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      r += csr_memory_wac_port_st_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      r += csr_memory_wac_pg_wm_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      r += csr_memory_wac_drop_count_ppg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      r += csr_memory_wac_drop_count_port_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      r += csr_memory_wac_pfc_state_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      r += csr_memory_wac_qid_map_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      r += csr_memory_wac_qacq_state_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      r += csr_memory_wac_qacq_ap_config_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_wac_port_ppg_mapping_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_min_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_shr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_hdr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_min_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_shr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_hdr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_pfc_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_icos_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_drop_st_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_drop_st_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_off_idx_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_off_idx_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_min_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_shr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_min_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_shr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_shr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_hdr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_wm_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_min_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_hdr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_shr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_st_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_wm_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_drop_count_ppg_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_drop_count_port_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pfc_state_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_qid_map_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_qacq_state_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_qacq_ap_config_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  WacPortPpgMapping csr_memory_wac_port_ppg_mapping_;
  WacPpgCnt csr_memory_wac_ppg_min_cnt_;
  WacPpgCnt csr_memory_wac_ppg_shr_cnt_;
  WacPpgCnt csr_memory_wac_ppg_hdr_cnt_;
  WacPpgTh csr_memory_wac_ppg_min_th_;
  WacPpgTh csr_memory_wac_ppg_shr_th_;
  WacPpgTh csr_memory_wac_ppg_hdr_th_;
  WacPpgPfc csr_memory_wac_ppg_pfc_;
  WacPpgIcos csr_memory_wac_ppg_icos_;
  WacPpgDropSt csr_memory_wac_ppg_drop_st_;
  WacPgDropSt csr_memory_wac_pg_drop_st_;
  WacPpgOffIdx csr_memory_wac_ppg_off_idx_;
  WacPgOffIdx csr_memory_wac_pg_off_idx_;
  WacPgCnt csr_memory_wac_pg_min_cnt_;
  WacPgCnt csr_memory_wac_pg_shr_cnt_;
  WacPgTh csr_memory_wac_pg_min_th_;
  WacPgTh csr_memory_wac_pg_shr_th_;
  WacPortTh csr_memory_wac_port_shr_th_;
  WacPortTh csr_memory_wac_port_hdr_th_;
  WacPortCnt csr_memory_wac_port_wm_;
  WacPortCnt csr_memory_wac_port_min_cnt_;
  WacPortCnt csr_memory_wac_port_hdr_cnt_;
  WacPortCnt csr_memory_wac_port_shr_cnt_;
  WacPortSt csr_memory_wac_port_st_;
  WacPgWmCnt csr_memory_wac_pg_wm_cnt_;
  WacDropCountPpg csr_memory_wac_drop_count_ppg_;
  WacDropCountPort csr_memory_wac_drop_count_port_;
  WacPfcState csr_memory_wac_pfc_state_;
  WacQidMap csr_memory_wac_qid_map_;
  WacQacqState csr_memory_wac_qacq_state_;
  WacQacqApConfig csr_memory_wac_qacq_ap_config_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

};








class TmWacPipeMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacPipeMemRspecMutable(
      int chipNumber, int index_tm_wac_pipe_mem_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(index_tm_wac_pipe_mem_rspec), 268435456, true, write_callback, read_callback, std::string("TmWacPipeMemRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_mem_rspec))
    {
    }
  TmWacPipeMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmWacPipeMemRspecMutable")
    {
    }
public:






  WacPortPpgMappingMutable &csr_memory_wac_port_ppg_mapping() { return csr_memory_wac_port_ppg_mapping_; }





  WacPpgCntMutable &csr_memory_wac_ppg_min_cnt() { return csr_memory_wac_ppg_min_cnt_; }





  WacPpgCntMutable &csr_memory_wac_ppg_shr_cnt() { return csr_memory_wac_ppg_shr_cnt_; }





  WacPpgCntMutable &csr_memory_wac_ppg_hdr_cnt() { return csr_memory_wac_ppg_hdr_cnt_; }





  WacPpgThMutable &csr_memory_wac_ppg_min_th() { return csr_memory_wac_ppg_min_th_; }





  WacPpgThMutable &csr_memory_wac_ppg_shr_th() { return csr_memory_wac_ppg_shr_th_; }





  WacPpgThMutable &csr_memory_wac_ppg_hdr_th() { return csr_memory_wac_ppg_hdr_th_; }





  WacPpgPfcMutable &csr_memory_wac_ppg_pfc() { return csr_memory_wac_ppg_pfc_; }





  WacPpgIcosMutable &csr_memory_wac_ppg_icos() { return csr_memory_wac_ppg_icos_; }





  WacPpgDropStMutable &csr_memory_wac_ppg_drop_st() { return csr_memory_wac_ppg_drop_st_; }






  WacPgDropStMutable &csr_memory_wac_pg_drop_st() { return csr_memory_wac_pg_drop_st_; }





  WacPpgOffIdxMutable &csr_memory_wac_ppg_off_idx() { return csr_memory_wac_ppg_off_idx_; }






  WacPgOffIdxMutable &csr_memory_wac_pg_off_idx() { return csr_memory_wac_pg_off_idx_; }






  WacPgCntMutable &csr_memory_wac_pg_min_cnt() { return csr_memory_wac_pg_min_cnt_; }






  WacPgCntMutable &csr_memory_wac_pg_shr_cnt() { return csr_memory_wac_pg_shr_cnt_; }






  WacPgThMutable &csr_memory_wac_pg_min_th() { return csr_memory_wac_pg_min_th_; }






  WacPgThMutable &csr_memory_wac_pg_shr_th() { return csr_memory_wac_pg_shr_th_; }








  WacPortThMutable &csr_memory_wac_port_shr_th() { return csr_memory_wac_port_shr_th_; }








  WacPortThMutable &csr_memory_wac_port_hdr_th() { return csr_memory_wac_port_hdr_th_; }








  WacPortCntMutable &csr_memory_wac_port_wm() { return csr_memory_wac_port_wm_; }








  WacPortCntMutable &csr_memory_wac_port_min_cnt() { return csr_memory_wac_port_min_cnt_; }








  WacPortCntMutable &csr_memory_wac_port_hdr_cnt() { return csr_memory_wac_port_hdr_cnt_; }








  WacPortCntMutable &csr_memory_wac_port_shr_cnt() { return csr_memory_wac_port_shr_cnt_; }





  WacPortStMutable &csr_memory_wac_port_st() { return csr_memory_wac_port_st_; }






  WacPgWmCntMutable &csr_memory_wac_pg_wm_cnt() { return csr_memory_wac_pg_wm_cnt_; }












  WacDropCountPpgMutable &csr_memory_wac_drop_count_ppg() { return csr_memory_wac_drop_count_ppg_; }







  WacDropCountPortMutable &csr_memory_wac_drop_count_port() { return csr_memory_wac_drop_count_port_; }







  WacPfcStateMutable &csr_memory_wac_pfc_state() { return csr_memory_wac_pfc_state_; }








  WacQidMapMutable &csr_memory_wac_qid_map() { return csr_memory_wac_qid_map_; }






  WacQacqStateMutable &csr_memory_wac_qacq_state() { return csr_memory_wac_qacq_state_; }






  WacQacqApConfigMutable &csr_memory_wac_qacq_ap_config() { return csr_memory_wac_qacq_ap_config_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x124) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_ppg_mapping_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_min_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_shr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_hdr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_pfc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_icos_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_drop_st_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_drop_st_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      if (read_callback_) read_callback_();
      csr_memory_wac_ppg_off_idx_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_off_idx_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_min_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_shr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_th_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_wm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_min_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_hdr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_shr_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      if (read_callback_) read_callback_();
      csr_memory_wac_port_st_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      if (read_callback_) read_callback_();
      csr_memory_wac_pg_wm_cnt_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_ppg_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      if (read_callback_) read_callback_();
      csr_memory_wac_drop_count_port_.read( offset, data0,data1,T );
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      if (read_callback_) read_callback_();
      csr_memory_wac_pfc_state_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      if (read_callback_) read_callback_();
      csr_memory_wac_qid_map_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_state_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      if (read_callback_) read_callback_();
      csr_memory_wac_qacq_ap_config_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x124) {
      offset -= 0x0;
      csr_memory_wac_port_ppg_mapping_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      csr_memory_wac_ppg_min_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      csr_memory_wac_ppg_shr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      csr_memory_wac_ppg_hdr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      csr_memory_wac_ppg_min_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      csr_memory_wac_ppg_shr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      csr_memory_wac_ppg_hdr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      csr_memory_wac_ppg_pfc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      csr_memory_wac_ppg_icos_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      csr_memory_wac_ppg_drop_st_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      csr_memory_wac_pg_drop_st_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      csr_memory_wac_ppg_off_idx_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      csr_memory_wac_pg_off_idx_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      csr_memory_wac_pg_min_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      csr_memory_wac_pg_shr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      csr_memory_wac_pg_min_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      csr_memory_wac_pg_shr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      csr_memory_wac_port_shr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      csr_memory_wac_port_hdr_th_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      csr_memory_wac_port_wm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      csr_memory_wac_port_min_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      csr_memory_wac_port_hdr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      csr_memory_wac_port_shr_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      csr_memory_wac_port_st_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      csr_memory_wac_pg_wm_cnt_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      csr_memory_wac_drop_count_ppg_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      csr_memory_wac_drop_count_port_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      csr_memory_wac_pfc_state_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      csr_memory_wac_qid_map_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      csr_memory_wac_qacq_state_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      csr_memory_wac_qacq_ap_config_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    csr_memory_wac_port_ppg_mapping_.reset();
    csr_memory_wac_ppg_min_cnt_.reset();
    csr_memory_wac_ppg_shr_cnt_.reset();
    csr_memory_wac_ppg_hdr_cnt_.reset();
    csr_memory_wac_ppg_min_th_.reset();
    csr_memory_wac_ppg_shr_th_.reset();
    csr_memory_wac_ppg_hdr_th_.reset();
    csr_memory_wac_ppg_pfc_.reset();
    csr_memory_wac_ppg_icos_.reset();
    csr_memory_wac_ppg_drop_st_.reset();
    csr_memory_wac_pg_drop_st_.reset();
    csr_memory_wac_ppg_off_idx_.reset();
    csr_memory_wac_pg_off_idx_.reset();
    csr_memory_wac_pg_min_cnt_.reset();
    csr_memory_wac_pg_shr_cnt_.reset();
    csr_memory_wac_pg_min_th_.reset();
    csr_memory_wac_pg_shr_th_.reset();
    csr_memory_wac_port_shr_th_.reset();
    csr_memory_wac_port_hdr_th_.reset();
    csr_memory_wac_port_wm_.reset();
    csr_memory_wac_port_min_cnt_.reset();
    csr_memory_wac_port_hdr_cnt_.reset();
    csr_memory_wac_port_shr_cnt_.reset();
    csr_memory_wac_port_st_.reset();
    csr_memory_wac_pg_wm_cnt_.reset();
    csr_memory_wac_drop_count_ppg_.reset();
    csr_memory_wac_drop_count_port_.reset();
    csr_memory_wac_pfc_state_.reset();
    csr_memory_wac_qid_map_.reset();
    csr_memory_wac_qacq_state_.reset();
    csr_memory_wac_qacq_ap_config_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x124) {
      offset -= 0x0;
      r += csr_memory_wac_port_ppg_mapping_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      r += csr_memory_wac_ppg_min_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      r += csr_memory_wac_ppg_shr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      r += csr_memory_wac_ppg_hdr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      r += csr_memory_wac_ppg_min_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      r += csr_memory_wac_ppg_shr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      r += csr_memory_wac_ppg_hdr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      r += csr_memory_wac_ppg_pfc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      r += csr_memory_wac_ppg_icos_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      r += csr_memory_wac_ppg_drop_st_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x649) {
      offset -= 0x600;
      r += csr_memory_wac_pg_drop_st_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x700) {
      offset -= 0x680;
      r += csr_memory_wac_ppg_off_idx_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x700 && offset < 0x749) {
      offset -= 0x700;
      r += csr_memory_wac_pg_off_idx_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x780 && offset < 0x7c9) {
      offset -= 0x780;
      r += csr_memory_wac_pg_min_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x849) {
      offset -= 0x800;
      r += csr_memory_wac_pg_shr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x880 && offset < 0x8c9) {
      offset -= 0x880;
      r += csr_memory_wac_pg_min_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x900 && offset < 0x949) {
      offset -= 0x900;
      r += csr_memory_wac_pg_shr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x980 && offset < 0x9c9) {
      offset -= 0x980;
      r += csr_memory_wac_port_shr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa00 && offset < 0xa49) {
      offset -= 0xa00;
      r += csr_memory_wac_port_hdr_th_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa80 && offset < 0xac9) {
      offset -= 0xa80;
      r += csr_memory_wac_port_wm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb00 && offset < 0xb49) {
      offset -= 0xb00;
      r += csr_memory_wac_port_min_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb80 && offset < 0xbc9) {
      offset -= 0xb80;
      r += csr_memory_wac_port_hdr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc00 && offset < 0xc49) {
      offset -= 0xc00;
      r += csr_memory_wac_port_shr_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc80 && offset < 0xcc9) {
      offset -= 0xc80;
      r += csr_memory_wac_port_st_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd00 && offset < 0xdc9) {
      offset -= 0xd00;
      r += csr_memory_wac_pg_wm_cnt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe00 && offset < 0xec9) {
      offset -= 0xe00;
      r += csr_memory_wac_drop_count_ppg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf00 && offset < 0xf49) {
      offset -= 0xf00;
      r += csr_memory_wac_drop_count_port_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf80 && offset < 0xfc8) {
      offset -= 0xf80;
      r += csr_memory_wac_pfc_state_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1240) {
      offset -= 0x1000;
      r += csr_memory_wac_qid_map_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1c80) {
      offset -= 0x1800;
      r += csr_memory_wac_qacq_state_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2480) {
      offset -= 0x2000;
      r += csr_memory_wac_qacq_ap_config_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += csr_memory_wac_port_ppg_mapping_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_min_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_shr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_hdr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_min_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_shr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_hdr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_pfc_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_icos_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_drop_st_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_drop_st_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_ppg_off_idx_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_off_idx_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_min_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_shr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_min_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_shr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_shr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_hdr_th_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_wm_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_min_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_hdr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_shr_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_port_st_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pg_wm_cnt_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_drop_count_ppg_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_drop_count_port_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_pfc_state_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_qid_map_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_qacq_state_.to_string(print_zeros,indent_string) ;
    r += csr_memory_wac_qacq_ap_config_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  WacPortPpgMappingMutable csr_memory_wac_port_ppg_mapping_;
  WacPpgCntMutable csr_memory_wac_ppg_min_cnt_;
  WacPpgCntMutable csr_memory_wac_ppg_shr_cnt_;
  WacPpgCntMutable csr_memory_wac_ppg_hdr_cnt_;
  WacPpgThMutable csr_memory_wac_ppg_min_th_;
  WacPpgThMutable csr_memory_wac_ppg_shr_th_;
  WacPpgThMutable csr_memory_wac_ppg_hdr_th_;
  WacPpgPfcMutable csr_memory_wac_ppg_pfc_;
  WacPpgIcosMutable csr_memory_wac_ppg_icos_;
  WacPpgDropStMutable csr_memory_wac_ppg_drop_st_;
  WacPgDropStMutable csr_memory_wac_pg_drop_st_;
  WacPpgOffIdxMutable csr_memory_wac_ppg_off_idx_;
  WacPgOffIdxMutable csr_memory_wac_pg_off_idx_;
  WacPgCntMutable csr_memory_wac_pg_min_cnt_;
  WacPgCntMutable csr_memory_wac_pg_shr_cnt_;
  WacPgThMutable csr_memory_wac_pg_min_th_;
  WacPgThMutable csr_memory_wac_pg_shr_th_;
  WacPortThMutable csr_memory_wac_port_shr_th_;
  WacPortThMutable csr_memory_wac_port_hdr_th_;
  WacPortCntMutable csr_memory_wac_port_wm_;
  WacPortCntMutable csr_memory_wac_port_min_cnt_;
  WacPortCntMutable csr_memory_wac_port_hdr_cnt_;
  WacPortCntMutable csr_memory_wac_port_shr_cnt_;
  WacPortStMutable csr_memory_wac_port_st_;
  WacPgWmCntMutable csr_memory_wac_pg_wm_cnt_;
  WacDropCountPpgMutable csr_memory_wac_drop_count_ppg_;
  WacDropCountPortMutable csr_memory_wac_drop_count_port_;
  WacPfcStateMutable csr_memory_wac_pfc_state_;
  WacQidMapMutable csr_memory_wac_qid_map_;
  WacQacqStateMutable csr_memory_wac_qacq_state_;
  WacQacqApConfigMutable csr_memory_wac_qacq_ap_config_;
private:
  static uint64_t StartOffset(
      int index_tm_wac_pipe_mem_rspec
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    assert(index_tm_wac_pipe_mem_rspec < 4);
    offset += index_tm_wac_pipe_mem_rspec * 0x10000000; // tm_wac_pipe_mem_rspec[]
    return offset;
  }

};








class TmWacPipeMemRspecArray : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmWacPipeMemRspecArray(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), false, write_callback, read_callback, std::string("TmWacPipeMemRspecArray")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:






  WacPortPpgMapping &csr_memory_wac_port_ppg_mapping(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_ppg_mapping();
  }





  WacPpgCnt &csr_memory_wac_ppg_min_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_cnt();
  }





  WacPpgCnt &csr_memory_wac_ppg_shr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_cnt();
  }





  WacPpgCnt &csr_memory_wac_ppg_hdr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_cnt();
  }





  WacPpgTh &csr_memory_wac_ppg_min_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_th();
  }





  WacPpgTh &csr_memory_wac_ppg_shr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_th();
  }





  WacPpgTh &csr_memory_wac_ppg_hdr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_th();
  }





  WacPpgPfc &csr_memory_wac_ppg_pfc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_pfc();
  }





  WacPpgIcos &csr_memory_wac_ppg_icos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_icos();
  }





  WacPpgDropSt &csr_memory_wac_ppg_drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_drop_st();
  }






  WacPgDropSt &csr_memory_wac_pg_drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_drop_st();
  }





  WacPpgOffIdx &csr_memory_wac_ppg_off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_off_idx();
  }






  WacPgOffIdx &csr_memory_wac_pg_off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_off_idx();
  }






  WacPgCnt &csr_memory_wac_pg_min_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_cnt();
  }






  WacPgCnt &csr_memory_wac_pg_shr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_cnt();
  }






  WacPgTh &csr_memory_wac_pg_min_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_th();
  }






  WacPgTh &csr_memory_wac_pg_shr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_th();
  }








  WacPortTh &csr_memory_wac_port_shr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_th();
  }








  WacPortTh &csr_memory_wac_port_hdr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_th();
  }








  WacPortCnt &csr_memory_wac_port_wm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_wm();
  }








  WacPortCnt &csr_memory_wac_port_min_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_min_cnt();
  }








  WacPortCnt &csr_memory_wac_port_hdr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_cnt();
  }








  WacPortCnt &csr_memory_wac_port_shr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_cnt();
  }





  WacPortSt &csr_memory_wac_port_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_st();
  }






  WacPgWmCnt &csr_memory_wac_pg_wm_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_wm_cnt();
  }












  WacDropCountPpg &csr_memory_wac_drop_count_ppg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_ppg();
  }







  WacDropCountPort &csr_memory_wac_drop_count_port(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_port();
  }







  WacPfcState &csr_memory_wac_pfc_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pfc_state();
  }








  WacQidMap &csr_memory_wac_qid_map(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qid_map();
  }






  WacQacqState &csr_memory_wac_qacq_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_state();
  }






  WacQacqApConfig &csr_memory_wac_qacq_ap_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_ap_config();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmWacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmWacPipeMemRspecArray") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmWacPipeMemRspec> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmWacPipeMemRspecArrayMutable : public model_core::RegisterBlockIndirect<RegisterArrayCallback> {
public:
  TmWacPipeMemRspecArrayMutable(
      int chipNumber, RegisterArrayCallback& write_callback = 0, RegisterArrayCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 268435456 * ArraySize(-1), true, write_callback, read_callback, std::string("TmWacPipeMemRspecArrayMutable")),
    array(RealArraySize(-1)),
    size0_(ArraySize(0)),
    real_size0_(RealArraySize(0))
    {
    }
public:






  WacPortPpgMappingMutable &csr_memory_wac_port_ppg_mapping(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_ppg_mapping();
  }





  WacPpgCntMutable &csr_memory_wac_ppg_min_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_cnt();
  }





  WacPpgCntMutable &csr_memory_wac_ppg_shr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_cnt();
  }





  WacPpgCntMutable &csr_memory_wac_ppg_hdr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_cnt();
  }





  WacPpgThMutable &csr_memory_wac_ppg_min_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_min_th();
  }





  WacPpgThMutable &csr_memory_wac_ppg_shr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_shr_th();
  }





  WacPpgThMutable &csr_memory_wac_ppg_hdr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_hdr_th();
  }





  WacPpgPfcMutable &csr_memory_wac_ppg_pfc(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_pfc();
  }





  WacPpgIcosMutable &csr_memory_wac_ppg_icos(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_icos();
  }





  WacPpgDropStMutable &csr_memory_wac_ppg_drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_drop_st();
  }






  WacPgDropStMutable &csr_memory_wac_pg_drop_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_drop_st();
  }





  WacPpgOffIdxMutable &csr_memory_wac_ppg_off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_ppg_off_idx();
  }






  WacPgOffIdxMutable &csr_memory_wac_pg_off_idx(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_off_idx();
  }






  WacPgCntMutable &csr_memory_wac_pg_min_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_cnt();
  }






  WacPgCntMutable &csr_memory_wac_pg_shr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_cnt();
  }






  WacPgThMutable &csr_memory_wac_pg_min_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_min_th();
  }






  WacPgThMutable &csr_memory_wac_pg_shr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_shr_th();
  }








  WacPortThMutable &csr_memory_wac_port_shr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_th();
  }








  WacPortThMutable &csr_memory_wac_port_hdr_th(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_th();
  }








  WacPortCntMutable &csr_memory_wac_port_wm(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_wm();
  }








  WacPortCntMutable &csr_memory_wac_port_min_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_min_cnt();
  }








  WacPortCntMutable &csr_memory_wac_port_hdr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_hdr_cnt();
  }








  WacPortCntMutable &csr_memory_wac_port_shr_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_shr_cnt();
  }





  WacPortStMutable &csr_memory_wac_port_st(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_port_st();
  }






  WacPgWmCntMutable &csr_memory_wac_pg_wm_cnt(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pg_wm_cnt();
  }












  WacDropCountPpgMutable &csr_memory_wac_drop_count_ppg(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_ppg();
  }







  WacDropCountPortMutable &csr_memory_wac_drop_count_port(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_drop_count_port();
  }







  WacPfcStateMutable &csr_memory_wac_pfc_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_pfc_state();
  }








  WacQidMapMutable &csr_memory_wac_qid_map(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qid_map();
  }






  WacQacqStateMutable &csr_memory_wac_qacq_state(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_state();
  }






  WacQacqApConfigMutable &csr_memory_wac_qacq_ap_config(uint32_t a0)
  {
    CheckArrayBounds(a0,real_size0_,size0_,0,0,false);
    return array[a0].csr_memory_wac_qacq_ap_config();
  }
  bool calculate_index(
      uint64_t* offset, uint32_t* a0
      ) const {
    int i = (*offset)/268435456;
    (*offset) -= (i*268435456);
    uint32_t t = i;
    *a0 = t;
    bool in_bounds = true;
    in_bounds &= CheckArrayBounds(*a0,real_size0_,size0_,*offset,0,true);
    return in_bounds;
  }


  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    if (read_callback_) read_callback_(a0);
    array[a0].read(offset,data0,data1,T);
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return true;
    array[a0].write(offset,data0,data1,T);
    if (write_callback_) write_callback_(a0);
    return true;
  }

  void reset(
      
      ) {
    for (uint32_t i=0;i<array.size();++i) {
      array[i].reset();
      int t = i;
      int a0 = t;
      if (write_callback_) write_callback_(a0);
    }
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    uint32_t a0;
     if (!calculate_index(&offset,&a0)) return "OUT_OF_BOUNDS";
    std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
    if (! r_s.empty()) {
      r += indent_string + std::string("TmWacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<real_size0_;++a0) {
      std::string r_s = array[a0].to_string(print_zeros,indent_string+"  ");
      if (! r_s.empty()) {
        r += indent_string + std::string("TmWacPipeMemRspecArrayMutable") + "["+boost::lexical_cast<std::string>(a0)+"]"+ ":\n" + r_s ;
      }
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::vector<TmWacPipeMemRspecMutable> array;
  uint32_t size0_;
  uint32_t real_size0_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

  static int ArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

  static int RealArraySize(
      int dimension
      ) {
    switch (dimension) {
      case -1:
        return 4;
        break;
      case 0:
        return 4;
        break;
      default:
        assert(0);
        break;
    }
  }

};








class TmWacMemTopRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacMemTopRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, false, write_callback, read_callback, std::string("TmWacMemTopRspec"))
    {
    }
  TmWacMemTopRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmWacMemTopRspec")
    {
    }
public:







  TmWacPipeMemRspec &wac_pipe_mem(int j0) { return wac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      wac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      wac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : wac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += wac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += wac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmWacPipeMemRspec, 4 > wac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

};








class TmWacMemTopRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmWacMemTopRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 8589934592, true, write_callback, read_callback, std::string("TmWacMemTopRspecMutable"))
    {
    }
  TmWacMemTopRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmWacMemTopRspecMutable")
    {
    }
public:







  TmWacPipeMemRspecMutable &wac_pipe_mem(int j0) { return wac_pipe_mem_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      if (read_callback_) read_callback_();
      wac_pipe_mem_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      wac_pipe_mem_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : wac_pipe_mem_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x40000000) {
      offset -= 0x0;
      int i0 = offset / 0x10000000;
      offset  -= i0 * 0x10000000;
      r += wac_pipe_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<4;++a0) {
      r += wac_pipe_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< TmWacPipeMemRspecMutable, 4 > wac_pipe_mem_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    offset += 0x4200000000; // to get to tm_wac
    return offset;
  }

};








class TmTopMemRspec : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmTopMemRspec(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 463856467968, false, write_callback, read_callback, std::string("TmTopMemRspec"))
    {
    }
  TmTopMemRspec(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "TmTopMemRspec")
    {
    }
public:





  TmWacMemTopRspec &tm_wac() { return tm_wac_; }





  TmCaaMemTopRspec &tm_caa() { return tm_caa_; }





  TmQacMemTopRspec &tm_qac() { return tm_qac_; }





  TmSchMemTopRspec &tm_scha() { return tm_scha_; }





  TmSchMemTopRspec &tm_schb() { return tm_schb_; }





  TmClcMemTopRspec &tm_clc() { return tm_clc_; }





  TmPexMemTopRspec &tm_pex() { return tm_pex_; }





  TmQlcMemTopRspec &tm_qlc() { return tm_qlc_; }





  TmPrcMemTopRspec &tm_prc() { return tm_prc_; }





  TmPreMemTopRspec &tm_pre() { return tm_pre_; }





  TmPscMemTopRspec &tm_psc() { return tm_psc_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      if (read_callback_) read_callback_();
      tm_wac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      if (read_callback_) read_callback_();
      tm_caa_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      if (read_callback_) read_callback_();
      tm_qac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      if (read_callback_) read_callback_();
      tm_scha_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      if (read_callback_) read_callback_();
      tm_schb_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      if (read_callback_) read_callback_();
      tm_clc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      if (read_callback_) read_callback_();
      tm_pex_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      if (read_callback_) read_callback_();
      tm_qlc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      if (read_callback_) read_callback_();
      tm_prc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      if (read_callback_) read_callback_();
      tm_pre_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      if (read_callback_) read_callback_();
      tm_psc_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      tm_wac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      tm_caa_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      tm_qac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      tm_scha_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      tm_schb_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      tm_clc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      tm_pex_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      tm_qlc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      tm_prc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      tm_pre_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      tm_psc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_wac_.reset();
    tm_caa_.reset();
    tm_qac_.reset();
    tm_scha_.reset();
    tm_schb_.reset();
    tm_clc_.reset();
    tm_pex_.reset();
    tm_qlc_.reset();
    tm_prc_.reset();
    tm_pre_.reset();
    tm_psc_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      r += tm_wac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      r += tm_caa_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      r += tm_qac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      r += tm_scha_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      r += tm_schb_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      r += tm_clc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      r += tm_pex_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      r += tm_qlc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      r += tm_prc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      r += tm_pre_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      r += tm_psc_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_wac_.to_string(print_zeros,indent_string) ;
    r += tm_caa_.to_string(print_zeros,indent_string) ;
    r += tm_qac_.to_string(print_zeros,indent_string) ;
    r += tm_scha_.to_string(print_zeros,indent_string) ;
    r += tm_schb_.to_string(print_zeros,indent_string) ;
    r += tm_clc_.to_string(print_zeros,indent_string) ;
    r += tm_pex_.to_string(print_zeros,indent_string) ;
    r += tm_qlc_.to_string(print_zeros,indent_string) ;
    r += tm_prc_.to_string(print_zeros,indent_string) ;
    r += tm_pre_.to_string(print_zeros,indent_string) ;
    r += tm_psc_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmWacMemTopRspec tm_wac_;
  TmCaaMemTopRspec tm_caa_;
  TmQacMemTopRspec tm_qac_;
  TmSchMemTopRspec tm_scha_;
  TmSchMemTopRspec tm_schb_;
  TmClcMemTopRspec tm_clc_;
  TmPexMemTopRspec tm_pex_;
  TmQlcMemTopRspec tm_qlc_;
  TmPrcMemTopRspec tm_prc_;
  TmPreMemTopRspec tm_pre_;
  TmPscMemTopRspec tm_psc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};








class TmTopMemRspecMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  TmTopMemRspecMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 463856467968, true, write_callback, read_callback, std::string("TmTopMemRspecMutable"))
    {
    }
  TmTopMemRspecMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "TmTopMemRspecMutable")
    {
    }
public:





  TmWacMemTopRspecMutable &tm_wac() { return tm_wac_; }





  TmCaaMemTopRspecMutable &tm_caa() { return tm_caa_; }





  TmQacMemTopRspecMutable &tm_qac() { return tm_qac_; }





  TmSchMemTopRspecMutable &tm_scha() { return tm_scha_; }





  TmSchMemTopRspecMutable &tm_schb() { return tm_schb_; }





  TmClcMemTopRspecMutable &tm_clc() { return tm_clc_; }





  TmPexMemTopRspecMutable &tm_pex() { return tm_pex_; }





  TmQlcMemTopRspecMutable &tm_qlc() { return tm_qlc_; }





  TmPrcMemTopRspecMutable &tm_prc() { return tm_prc_; }





  TmPreMemTopRspecMutable &tm_pre() { return tm_pre_; }





  TmPscMemTopRspecMutable &tm_psc() { return tm_psc_; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      if (read_callback_) read_callback_();
      tm_wac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      if (read_callback_) read_callback_();
      tm_caa_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      if (read_callback_) read_callback_();
      tm_qac_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      if (read_callback_) read_callback_();
      tm_scha_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      if (read_callback_) read_callback_();
      tm_schb_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      if (read_callback_) read_callback_();
      tm_clc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      if (read_callback_) read_callback_();
      tm_pex_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      if (read_callback_) read_callback_();
      tm_qlc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      if (read_callback_) read_callback_();
      tm_prc_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      if (read_callback_) read_callback_();
      tm_pre_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      if (read_callback_) read_callback_();
      tm_psc_.read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      tm_wac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      tm_caa_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      tm_qac_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      tm_scha_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      tm_schb_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      tm_clc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      tm_pex_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      tm_qlc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      tm_prc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      tm_pre_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      tm_psc_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_wac_.reset();
    tm_caa_.reset();
    tm_qac_.reset();
    tm_scha_.reset();
    tm_schb_.reset();
    tm_clc_.reset();
    tm_pex_.reset();
    tm_qlc_.reset();
    tm_prc_.reset();
    tm_pre_.reset();
    tm_psc_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x4200000000 && offset < 0x4400000000) {
      offset -= 0x4200000000;
      r += tm_wac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4600000000 && offset < 0x4800000000) {
      offset -= 0x4600000000;
      r += tm_caa_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4a00000000 && offset < 0x4c00000000) {
      offset -= 0x4a00000000;
      r += tm_qac_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4e00000000 && offset < 0x5000000000) {
      offset -= 0x4e00000000;
      r += tm_scha_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5200000000 && offset < 0x5400000000) {
      offset -= 0x5200000000;
      r += tm_schb_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5600000000 && offset < 0x5800000000) {
      offset -= 0x5600000000;
      r += tm_clc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5a00000000 && offset < 0x5c00000000) {
      offset -= 0x5a00000000;
      r += tm_pex_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5e00000000 && offset < 0x6000000000) {
      offset -= 0x5e00000000;
      r += tm_qlc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6200000000 && offset < 0x6400000000) {
      offset -= 0x6200000000;
      r += tm_prc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6600000000 && offset < 0x6800000000) {
      offset -= 0x6600000000;
      r += tm_pre_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6a00000000 && offset < 0x6c00000000) {
      offset -= 0x6a00000000;
      r += tm_psc_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_wac_.to_string(print_zeros,indent_string) ;
    r += tm_caa_.to_string(print_zeros,indent_string) ;
    r += tm_qac_.to_string(print_zeros,indent_string) ;
    r += tm_scha_.to_string(print_zeros,indent_string) ;
    r += tm_schb_.to_string(print_zeros,indent_string) ;
    r += tm_clc_.to_string(print_zeros,indent_string) ;
    r += tm_pex_.to_string(print_zeros,indent_string) ;
    r += tm_qlc_.to_string(print_zeros,indent_string) ;
    r += tm_prc_.to_string(print_zeros,indent_string) ;
    r += tm_pre_.to_string(print_zeros,indent_string) ;
    r += tm_psc_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmWacMemTopRspecMutable tm_wac_;
  TmCaaMemTopRspecMutable tm_caa_;
  TmQacMemTopRspecMutable tm_qac_;
  TmSchMemTopRspecMutable tm_scha_;
  TmSchMemTopRspecMutable tm_schb_;
  TmClcMemTopRspecMutable tm_clc_;
  TmPexMemTopRspecMutable tm_pex_;
  TmQlcMemTopRspecMutable tm_qlc_;
  TmPrcMemTopRspecMutable tm_prc_;
  TmPreMemTopRspecMutable tm_pre_;
  TmPscMemTopRspecMutable tm_psc_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};








class Chip : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  Chip(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4398046511104, false, write_callback, read_callback, std::string("Chip"))
    {
    }
  Chip(
      
  )
    : RegisterBlockIndirect(0, 0, 0, false, 0, 0, "Chip")
    {
    }
public:





  TmTopMemRspec &tm() { return tm_; }







  PipeAddrmap &pipes(int j0) { return pipes_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      tm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      if (read_callback_) read_callback_();
      pipes_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      tm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      pipes_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_.reset();
    for (auto &f0 : pipes_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      r += tm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      r += pipes_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pipes_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmTopMemRspec tm_;
  std::array< PipeAddrmap, 4 > pipes_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};








class ChipMutable : public model_core::RegisterBlockIndirect<RegisterCallback> {
public:
  ChipMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlockIndirect(chipNumber, StartOffset(), 4398046511104, true, write_callback, read_callback, std::string("ChipMutable"))
    {
    }
  ChipMutable(
      
  )
    : RegisterBlockIndirect(0, 0, 0, true, 0, 0, "ChipMutable")
    {
    }
public:





  TmTopMemRspecMutable &tm() { return tm_; }







  PipeAddrmapMutable &pipes(int j0) { return pipes_[j0]; }

  bool read(
      uint64_t offset, uint64_t* data0, uint64_t* data1, uint64_t T
      ) const {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      tm_.read( offset, data0,data1,T );
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      if (read_callback_) read_callback_();
      pipes_[ i0 ].read( offset, data0,data1,T );
    }
    return true;
  }


  bool write(
      uint64_t offset, uint64_t data0, uint64_t data1, uint64_t T
      ) {
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      tm_.write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      pipes_[ i0 ].write( offset, data0,data1,T );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    tm_.reset();
    for (auto &f0 : pipes_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint64_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x6c00000000) {
      offset -= 0x0;
      r += tm_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20000000000 && offset < 0x382000d8400) {
      offset -= 0x20000000000;
      int i0 = offset / 0x8000000000;
      offset  -= i0 * 0x8000000000;
      r += pipes_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += tm_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pipes_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmTopMemRspecMutable tm_;
  std::array< PipeAddrmapMutable, 4 > pipes_;
private:
  static uint64_t StartOffset(
      
      ) {
    uint64_t offset=0;
    return offset;
  }

};
  }; // namespace memory_classes
}; // namespace jbayB0
#endif // #ifndef ___JBAYB0_REGISTER_INCLUDES_MODEL_MEM_H__
