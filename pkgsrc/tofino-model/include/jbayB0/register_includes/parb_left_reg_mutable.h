/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_PARB_LEFT_REG_MUTABLE_H__
#define __REGISTER_INCLUDES_PARB_LEFT_REG_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>









#include "parb_bubble_count_mutable.h"
#include "parb_chnl_ctrl_mutable.h"
#include "parb_dpr_slot_ctrl_mutable.h"
#include "parb_dpr_slot_status_mutable.h"
#include "parb_dprs_input_fifo_count_mutable.h"
#include "parb_left_reg_i_afifo_oflow_err_log_mutable.h"
#include "parb_left_reg_i_arb_cred_oflow_err_log_mutable.h"
#include "parb_left_reg_i_arb_cred_uflow_err_log_mutable.h"
#include "parb_left_reg_i_avail_oflow_err_log_mutable.h"
#include "parb_left_reg_i_bcnt_oflow_err_log_mutable.h"
#include "parb_left_reg_i_phv_rate_ctrl_mutable.h"
#include "parb_left_reg_intr_mutable.h"
#include "parb_left_reg_port_rate_cfg_mutable.h"
#include "parb_phv_count_mutable.h"
#include "parb_port_debug_en_mutable.h"
#include "parb_port_debug_mutable.h"
#include "parb_priority_inc_r_mutable.h"
#include "parb_tdm_last_entry_mutable.h"
#include "parb_tdm_table_entry_mutable.h"
#include "parb_wb_ctrl_mutable.h"

namespace jbayB0 {
  namespace register_classes {

class ParbLeftRegMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  ParbLeftRegMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap), 1904, true, write_callback, read_callback, std::string("ParbLeftRegMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  ParbLeftRegMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "ParbLeftRegMutable")
    {
    }
public:









  ParbLeftRegPortRateCfgMutable &port_rate_cfg(int j0) { return port_rate_cfg_[j0]; }






  ParbLeftRegIPhvRateCtrlMutable &i_phv_rate_ctrl() { return i_phv_rate_ctrl_; }







  ParbChnlCtrlMutable &i_chnl_ctrl(int j0) { return i_chnl_ctrl_[j0]; }







  ParbDprsInputFifoCountMutable &i_dprsr_cred_status(int j0) { return i_dprsr_cred_status_[j0]; }





  ParbBubbleCountMutable &i_bubble_count() { return i_bubble_count_; }





  ParbPhvCountMutable &i_phv_count() { return i_phv_count_; }





  ParbPhvCountMutable &i_eop_count() { return i_eop_count_; }





  ParbPhvCountMutable &i_norm_phv_count() { return i_norm_phv_count_; }





  ParbPhvCountMutable &i_norm_eop_count() { return i_norm_eop_count_; }





  ParbPhvCountMutable &i_resub_phv_count() { return i_resub_phv_count_; }





  ParbPhvCountMutable &i_resub_eop_count() { return i_resub_eop_count_; }







  ParbPortDebugMutable &i_port_dbg(int j0) { return i_port_dbg_[j0]; }





  ParbTdmLastEntryMutable &i_tdm_last_entry() { return i_tdm_last_entry_; }






  ParbTdmTableEntryMutable &i_tdm_table(int j0) { return i_tdm_table_[j0]; }





  ParbDprSlotCtrlMutable &i_slot_ctrl() { return i_slot_ctrl_; }





  ParbDprSlotStatusMutable &i_slot_status() { return i_slot_status_; }







  ParbPriorityIncRMutable &i_pri_inc_ctrl_400g() { return i_pri_inc_ctrl_400g_; }







  ParbPriorityIncRMutable &i_pri_inc_ctrl_200g() { return i_pri_inc_ctrl_200g_; }







  ParbPriorityIncRMutable &i_pri_inc_ctrl_100g() { return i_pri_inc_ctrl_100g_; }







  ParbPriorityIncRMutable &i_pri_inc_ctrl_50g() { return i_pri_inc_ctrl_50g_; }







  ParbPriorityIncRMutable &i_pri_inc_ctrl_40g() { return i_pri_inc_ctrl_40g_; }







  ParbPriorityIncRMutable &i_pri_inc_ctrl_25g() { return i_pri_inc_ctrl_25g_; }







  ParbPriorityIncRMutable &i_pri_inc_ctrl_10g() { return i_pri_inc_ctrl_10g_; }





  ParbLeftRegIAvailOflowErrLogMutable &i_avail_oflow_err_log() { return i_avail_oflow_err_log_; }





  ParbLeftRegIBcntOflowErrLogMutable &i_bcnt_oflow_err_log() { return i_bcnt_oflow_err_log_; }





  ParbLeftRegIAfifoOflowErrLogMutable &i_afifo_oflow_err_log() { return i_afifo_oflow_err_log_; }





  ParbLeftRegIArbCredUflowErrLogMutable &i_arb_cred_uflow_err_log() { return i_arb_cred_uflow_err_log_; }





  ParbLeftRegIArbCredOflowErrLogMutable &i_arb_cred_oflow_err_log() { return i_arb_cred_oflow_err_log_; }





  ParbPortDebugEnMutable &i_port_dbg_en() { return i_port_dbg_en_; }





  ParbWbCtrlMutable &i_wb_ctrl() { return i_wb_ctrl_; }
  ParbLeftRegIntrMutable &intr() { return intr_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x40 && offset < 0x64) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_rate_cfg_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      if (read_callback_) read_callback_();
      i_phv_rate_ctrl_.read( offset, data );
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      i_chnl_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      i_dprsr_cred_status_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x520 && offset < 0x528) {
      offset -= 0x520;
      if (read_callback_) read_callback_();
      i_bubble_count_.read( offset, data );
    }
    else if (offset >= 0x528 && offset < 0x530) {
      offset -= 0x528;
      if (read_callback_) read_callback_();
      i_phv_count_.read( offset, data );
    }
    else if (offset >= 0x530 && offset < 0x538) {
      offset -= 0x530;
      if (read_callback_) read_callback_();
      i_eop_count_.read( offset, data );
    }
    else if (offset >= 0x538 && offset < 0x540) {
      offset -= 0x538;
      if (read_callback_) read_callback_();
      i_norm_phv_count_.read( offset, data );
    }
    else if (offset >= 0x540 && offset < 0x548) {
      offset -= 0x540;
      if (read_callback_) read_callback_();
      i_norm_eop_count_.read( offset, data );
    }
    else if (offset >= 0x548 && offset < 0x550) {
      offset -= 0x548;
      if (read_callback_) read_callback_();
      i_resub_phv_count_.read( offset, data );
    }
    else if (offset >= 0x550 && offset < 0x558) {
      offset -= 0x550;
      if (read_callback_) read_callback_();
      i_resub_eop_count_.read( offset, data );
    }
    else if (offset >= 0x580 && offset < 0x5c8) {
      offset -= 0x580;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      i_port_dbg_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x5c8 && offset < 0x5cc) {
      offset -= 0x5c8;
      if (read_callback_) read_callback_();
      i_tdm_last_entry_.read( offset, data );
    }
    else if (offset >= 0x600 && offset < 0x700) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      i_tdm_table_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x700 && offset < 0x704) {
      offset -= 0x700;
      if (read_callback_) read_callback_();
      i_slot_ctrl_.read( offset, data );
    }
    else if (offset >= 0x704 && offset < 0x708) {
      offset -= 0x704;
      if (read_callback_) read_callback_();
      i_slot_status_.read( offset, data );
    }
    else if (offset >= 0x708 && offset < 0x70c) {
      offset -= 0x708;
      if (read_callback_) read_callback_();
      i_pri_inc_ctrl_400g_.read( offset, data );
    }
    else if (offset >= 0x70c && offset < 0x710) {
      offset -= 0x70c;
      if (read_callback_) read_callback_();
      i_pri_inc_ctrl_200g_.read( offset, data );
    }
    else if (offset >= 0x710 && offset < 0x714) {
      offset -= 0x710;
      if (read_callback_) read_callback_();
      i_pri_inc_ctrl_100g_.read( offset, data );
    }
    else if (offset >= 0x714 && offset < 0x718) {
      offset -= 0x714;
      if (read_callback_) read_callback_();
      i_pri_inc_ctrl_50g_.read( offset, data );
    }
    else if (offset >= 0x718 && offset < 0x71c) {
      offset -= 0x718;
      if (read_callback_) read_callback_();
      i_pri_inc_ctrl_40g_.read( offset, data );
    }
    else if (offset >= 0x71c && offset < 0x720) {
      offset -= 0x71c;
      if (read_callback_) read_callback_();
      i_pri_inc_ctrl_25g_.read( offset, data );
    }
    else if (offset >= 0x720 && offset < 0x724) {
      offset -= 0x720;
      if (read_callback_) read_callback_();
      i_pri_inc_ctrl_10g_.read( offset, data );
    }
    else if (offset >= 0x754 && offset < 0x758) {
      offset -= 0x754;
      if (read_callback_) read_callback_();
      i_avail_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x758 && offset < 0x75c) {
      offset -= 0x758;
      if (read_callback_) read_callback_();
      i_bcnt_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x75c && offset < 0x760) {
      offset -= 0x75c;
      if (read_callback_) read_callback_();
      i_afifo_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x760 && offset < 0x764) {
      offset -= 0x760;
      if (read_callback_) read_callback_();
      i_arb_cred_uflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x764 && offset < 0x768) {
      offset -= 0x764;
      if (read_callback_) read_callback_();
      i_arb_cred_oflow_err_log_.read( offset, data );
    }
    else if (offset >= 0x768 && offset < 0x76c) {
      offset -= 0x768;
      if (read_callback_) read_callback_();
      i_port_dbg_en_.read( offset, data );
    }
    else if (offset >= 0x76c && offset < 0x770) {
      offset -= 0x76c;
      if (read_callback_) read_callback_();
      i_wb_ctrl_.read( offset, data );
    }
    else if (offset >= 0x740 && offset < 0x754) {
      offset -= 0x740;
      if (read_callback_) read_callback_();
      intr_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x40 && offset < 0x64) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_rate_cfg_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      i_phv_rate_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      i_chnl_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      i_dprsr_cred_status_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x520 && offset < 0x528) {
      offset -= 0x520;
      i_bubble_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x528 && offset < 0x530) {
      offset -= 0x528;
      i_phv_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x530 && offset < 0x538) {
      offset -= 0x530;
      i_eop_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x538 && offset < 0x540) {
      offset -= 0x538;
      i_norm_phv_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x540 && offset < 0x548) {
      offset -= 0x540;
      i_norm_eop_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x548 && offset < 0x550) {
      offset -= 0x548;
      i_resub_phv_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x550 && offset < 0x558) {
      offset -= 0x550;
      i_resub_eop_count_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x580 && offset < 0x5c8) {
      offset -= 0x580;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      i_port_dbg_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5c8 && offset < 0x5cc) {
      offset -= 0x5c8;
      i_tdm_last_entry_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x700) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      i_tdm_table_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x700 && offset < 0x704) {
      offset -= 0x700;
      i_slot_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x704 && offset < 0x708) {
      offset -= 0x704;
      i_slot_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x708 && offset < 0x70c) {
      offset -= 0x708;
      i_pri_inc_ctrl_400g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x70c && offset < 0x710) {
      offset -= 0x70c;
      i_pri_inc_ctrl_200g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x710 && offset < 0x714) {
      offset -= 0x710;
      i_pri_inc_ctrl_100g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x714 && offset < 0x718) {
      offset -= 0x714;
      i_pri_inc_ctrl_50g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x718 && offset < 0x71c) {
      offset -= 0x718;
      i_pri_inc_ctrl_40g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x71c && offset < 0x720) {
      offset -= 0x71c;
      i_pri_inc_ctrl_25g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x720 && offset < 0x724) {
      offset -= 0x720;
      i_pri_inc_ctrl_10g_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x754 && offset < 0x758) {
      offset -= 0x754;
      i_avail_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x758 && offset < 0x75c) {
      offset -= 0x758;
      i_bcnt_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x75c && offset < 0x760) {
      offset -= 0x75c;
      i_afifo_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x760 && offset < 0x764) {
      offset -= 0x760;
      i_arb_cred_uflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x764 && offset < 0x768) {
      offset -= 0x764;
      i_arb_cred_oflow_err_log_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x768 && offset < 0x76c) {
      offset -= 0x768;
      i_port_dbg_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x76c && offset < 0x770) {
      offset -= 0x76c;
      i_wb_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x740 && offset < 0x754) {
      offset -= 0x740;
      intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : port_rate_cfg_) {
      f0.reset();
    }
    i_phv_rate_ctrl_.reset();
    for (auto &f0 : i_chnl_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : i_dprsr_cred_status_) {
      f0.reset();
    }
    i_bubble_count_.reset();
    i_phv_count_.reset();
    i_eop_count_.reset();
    i_norm_phv_count_.reset();
    i_norm_eop_count_.reset();
    i_resub_phv_count_.reset();
    i_resub_eop_count_.reset();
    for (auto &f0 : i_port_dbg_) {
      f0.reset();
    }
    i_tdm_last_entry_.reset();
    for (auto &f0 : i_tdm_table_) {
      f0.reset();
    }
    i_slot_ctrl_.reset();
    i_slot_status_.reset();
    i_pri_inc_ctrl_400g_.reset();
    i_pri_inc_ctrl_200g_.reset();
    i_pri_inc_ctrl_100g_.reset();
    i_pri_inc_ctrl_50g_.reset();
    i_pri_inc_ctrl_40g_.reset();
    i_pri_inc_ctrl_25g_.reset();
    i_pri_inc_ctrl_10g_.reset();
    i_avail_oflow_err_log_.reset();
    i_bcnt_oflow_err_log_.reset();
    i_afifo_oflow_err_log_.reset();
    i_arb_cred_uflow_err_log_.reset();
    i_arb_cred_oflow_err_log_.reset();
    i_port_dbg_en_.reset();
    i_wb_ctrl_.reset();
    intr_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x40 && offset < 0x64) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_rate_cfg_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      r += i_phv_rate_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += i_chnl_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += i_dprsr_cred_status_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x520 && offset < 0x528) {
      offset -= 0x520;
      r += i_bubble_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x528 && offset < 0x530) {
      offset -= 0x528;
      r += i_phv_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x530 && offset < 0x538) {
      offset -= 0x530;
      r += i_eop_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x538 && offset < 0x540) {
      offset -= 0x538;
      r += i_norm_phv_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x540 && offset < 0x548) {
      offset -= 0x540;
      r += i_norm_eop_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x548 && offset < 0x550) {
      offset -= 0x548;
      r += i_resub_phv_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x550 && offset < 0x558) {
      offset -= 0x550;
      r += i_resub_eop_count_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x580 && offset < 0x5c8) {
      offset -= 0x580;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += i_port_dbg_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5c8 && offset < 0x5cc) {
      offset -= 0x5c8;
      r += i_tdm_last_entry_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x700) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += i_tdm_table_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x700 && offset < 0x704) {
      offset -= 0x700;
      r += i_slot_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x704 && offset < 0x708) {
      offset -= 0x704;
      r += i_slot_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x708 && offset < 0x70c) {
      offset -= 0x708;
      r += i_pri_inc_ctrl_400g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x70c && offset < 0x710) {
      offset -= 0x70c;
      r += i_pri_inc_ctrl_200g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x710 && offset < 0x714) {
      offset -= 0x710;
      r += i_pri_inc_ctrl_100g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x714 && offset < 0x718) {
      offset -= 0x714;
      r += i_pri_inc_ctrl_50g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x718 && offset < 0x71c) {
      offset -= 0x718;
      r += i_pri_inc_ctrl_40g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x71c && offset < 0x720) {
      offset -= 0x71c;
      r += i_pri_inc_ctrl_25g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x720 && offset < 0x724) {
      offset -= 0x720;
      r += i_pri_inc_ctrl_10g_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x754 && offset < 0x758) {
      offset -= 0x754;
      r += i_avail_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x758 && offset < 0x75c) {
      offset -= 0x758;
      r += i_bcnt_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x75c && offset < 0x760) {
      offset -= 0x75c;
      r += i_afifo_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x760 && offset < 0x764) {
      offset -= 0x760;
      r += i_arb_cred_uflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x764 && offset < 0x768) {
      offset -= 0x764;
      r += i_arb_cred_oflow_err_log_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x768 && offset < 0x76c) {
      offset -= 0x768;
      r += i_port_dbg_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x76c && offset < 0x770) {
      offset -= 0x76c;
      r += i_wb_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x740 && offset < 0x754) {
      offset -= 0x740;
      r += intr_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a0=0;a0<9;++a0) {
      r += port_rate_cfg_[a0].to_string(print_zeros,indent_string) ;
    }
    r += i_phv_rate_ctrl_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<72;++a0) {
      r += i_chnl_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += i_dprsr_cred_status_[a0].to_string(print_zeros,indent_string) ;
    }
    r += i_bubble_count_.to_string(print_zeros,indent_string) ;
    r += i_phv_count_.to_string(print_zeros,indent_string) ;
    r += i_eop_count_.to_string(print_zeros,indent_string) ;
    r += i_norm_phv_count_.to_string(print_zeros,indent_string) ;
    r += i_norm_eop_count_.to_string(print_zeros,indent_string) ;
    r += i_resub_phv_count_.to_string(print_zeros,indent_string) ;
    r += i_resub_eop_count_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<18;++a0) {
      r += i_port_dbg_[a0].to_string(print_zeros,indent_string) ;
    }
    r += i_tdm_last_entry_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<64;++a0) {
      r += i_tdm_table_[a0].to_string(print_zeros,indent_string) ;
    }
    r += i_slot_ctrl_.to_string(print_zeros,indent_string) ;
    r += i_slot_status_.to_string(print_zeros,indent_string) ;
    r += i_pri_inc_ctrl_400g_.to_string(print_zeros,indent_string) ;
    r += i_pri_inc_ctrl_200g_.to_string(print_zeros,indent_string) ;
    r += i_pri_inc_ctrl_100g_.to_string(print_zeros,indent_string) ;
    r += i_pri_inc_ctrl_50g_.to_string(print_zeros,indent_string) ;
    r += i_pri_inc_ctrl_40g_.to_string(print_zeros,indent_string) ;
    r += i_pri_inc_ctrl_25g_.to_string(print_zeros,indent_string) ;
    r += i_pri_inc_ctrl_10g_.to_string(print_zeros,indent_string) ;
    r += i_avail_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += i_bcnt_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += i_afifo_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += i_arb_cred_uflow_err_log_.to_string(print_zeros,indent_string) ;
    r += i_arb_cred_oflow_err_log_.to_string(print_zeros,indent_string) ;
    r += i_port_dbg_en_.to_string(print_zeros,indent_string) ;
    r += i_wb_ctrl_.to_string(print_zeros,indent_string) ;
    r += intr_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< ParbLeftRegPortRateCfgMutable, 9 > port_rate_cfg_;
  ParbLeftRegIPhvRateCtrlMutable i_phv_rate_ctrl_;
  std::array< ParbChnlCtrlMutable, 72 > i_chnl_ctrl_;
  std::array< ParbDprsInputFifoCountMutable, 72 > i_dprsr_cred_status_;
  ParbBubbleCountMutable i_bubble_count_;
  ParbPhvCountMutable i_phv_count_;
  ParbPhvCountMutable i_eop_count_;
  ParbPhvCountMutable i_norm_phv_count_;
  ParbPhvCountMutable i_norm_eop_count_;
  ParbPhvCountMutable i_resub_phv_count_;
  ParbPhvCountMutable i_resub_eop_count_;
  std::array< ParbPortDebugMutable, 18 > i_port_dbg_;
  ParbTdmLastEntryMutable i_tdm_last_entry_;
  std::array< ParbTdmTableEntryMutable, 64 > i_tdm_table_;
  ParbDprSlotCtrlMutable i_slot_ctrl_;
  ParbDprSlotStatusMutable i_slot_status_;
  ParbPriorityIncRMutable i_pri_inc_ctrl_400g_;
  ParbPriorityIncRMutable i_pri_inc_ctrl_200g_;
  ParbPriorityIncRMutable i_pri_inc_ctrl_100g_;
  ParbPriorityIncRMutable i_pri_inc_ctrl_50g_;
  ParbPriorityIncRMutable i_pri_inc_ctrl_40g_;
  ParbPriorityIncRMutable i_pri_inc_ctrl_25g_;
  ParbPriorityIncRMutable i_pri_inc_ctrl_10g_;
  ParbLeftRegIAvailOflowErrLogMutable i_avail_oflow_err_log_;
  ParbLeftRegIBcntOflowErrLogMutable i_bcnt_oflow_err_log_;
  ParbLeftRegIAfifoOflowErrLogMutable i_afifo_oflow_err_log_;
  ParbLeftRegIArbCredUflowErrLogMutable i_arb_cred_uflow_err_log_;
  ParbLeftRegIArbCredOflowErrLogMutable i_arb_cred_oflow_err_log_;
  ParbPortDebugEnMutable i_port_dbg_en_;
  ParbWbCtrlMutable i_wb_ctrl_;
  ParbLeftRegIntrMutable intr_;
private:
  static int StartOffset(
      int index_pipe_addrmap
      ) {
    int offset=0;
    offset += 0x4000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x1000000; // pipe_addrmap[]
    offset += 0xc00000; // to get to pardereg
    offset += 0x14000; // to get to parbreg
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace jbayB0

#endif // __REGISTER_INCLUDES_PARB_LEFT_REG_MUTABLE_H__
