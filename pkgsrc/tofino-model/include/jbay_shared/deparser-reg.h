/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

#ifndef _JBAY_SHARED_DEPARSER_REG_
#define _JBAY_SHARED_DEPARSER_REG_

#include <cstdint>
#include <array>
#include <vector>
#include <boost/integer/static_log2.hpp>
#include <model_core/shadow_counter.h>
#include <rmt-log.h>
#include <phv.h>
#include <pipe-object.h>
#include <deparser.h>
#include <register_adapters.h>
#include <deparser-chip-reg.h>
#include <mcn_test.h>
#include <register_includes/dprsr_pov_position_r.h>
#include <register_includes/dprsr_cnt_vld_i_phv_mutable.h>
#include <register_includes/dprsr_input_ing_and_egr_g_pp_ctr_cfg_data.h>
#include <register_includes/dprsr_input_ing_and_egr_g_pp_ctr_cfg_mask.h>
#include <register_includes/pp_ctr_cfg48_r_mutable.h>
#include <register_includes/dprsr_pre_version_r.h>
#include <register_includes/fd_chunk_info_r.h>
#include <register_includes/fd_bytesel_chunk_info_r.h>
#include <register_includes/fd_byte_is_phv_r.h>
#include <register_includes/fd_byte_off_info_r.h>

#include <register_includes/dprsr_csum_row_entry_array.h>

#include <register_includes/dprsr_csum_pov_one_engine.h>
#include <register_includes/dprsr_csum_pov_invert_engine.h>
#include <register_includes/dprsr_csum_thread_reg.h>



#include <register_includes/dprsr_i_fullcsum_engine_g_csum_constant.h>
#include <register_includes/dprsr_i_fullcsum_engine_g_zeros_as_ones.h>
#include <register_includes/dprsr_i_fullcsum_engine_g_tags_array.h>
#include <register_includes/dprsr_fullcsum_row_entry_array.h>

#include <register_includes/dprsr_hdr_xbar_const_defs_r.h>

#include <register_includes/fd_word_clot_sel_info_r.h>


#include <register_includes/dprsr_ic_regs_e_phv8_grp.h>
#include <register_includes/dprsr_ic_regs_e_phv16_grp.h>
#include <register_includes/dprsr_ic_regs_e_phv32_grp.h>
#include <register_includes/dprsr_ic_regs_i_phv8_grp.h>
#include <register_includes/dprsr_ic_regs_i_phv16_grp.h>
#include <register_includes/dprsr_ic_regs_i_phv32_grp.h>

#include <register_includes/dprsr_inp_egr_unicast_check_r.h>
#include <register_includes/dprsr_teop_inhibit_r.h>

//[[[cog
//       for i_ in range(0,9) :
//               cog.outl("#include <register_includes/dprsr_ic_regs_mac{0}_en.h>".format(i_))
//               cog.outl("#include <register_includes/dprsr_ic_regs_mac{0}_rates.h>".format(i_))
// ]]]
#include <register_includes/dprsr_ic_regs_mac0_en.h>
#include <register_includes/dprsr_ic_regs_mac0_rates.h>
#include <register_includes/dprsr_ic_regs_mac1_en.h>
#include <register_includes/dprsr_ic_regs_mac1_rates.h>
#include <register_includes/dprsr_ic_regs_mac2_en.h>
#include <register_includes/dprsr_ic_regs_mac2_rates.h>
#include <register_includes/dprsr_ic_regs_mac3_en.h>
#include <register_includes/dprsr_ic_regs_mac3_rates.h>
#include <register_includes/dprsr_ic_regs_mac4_en.h>
#include <register_includes/dprsr_ic_regs_mac4_rates.h>
#include <register_includes/dprsr_ic_regs_mac5_en.h>
#include <register_includes/dprsr_ic_regs_mac5_rates.h>
#include <register_includes/dprsr_ic_regs_mac6_en.h>
#include <register_includes/dprsr_ic_regs_mac6_rates.h>
#include <register_includes/dprsr_ic_regs_mac7_en.h>
#include <register_includes/dprsr_ic_regs_mac7_rates.h>
#include <register_includes/dprsr_ic_regs_mac8_en.h>
#include <register_includes/dprsr_ic_regs_mac8_rates.h>
// [[[end]]] (checksum: e6974551650a00f04db9080a18cbb056)

#include <register_includes/dprsr_mirror_table_entry_r_array.h>
#include <register_includes/dprsr_resubmit_pktgen_table_entry_r_array.h>
#include <register_includes/dprsr_perf_count_r_array_mutable.h>
#include <register_includes/dprsr_perf_count_r_mutable.h>
#include <register_includes/dprsr_perf_byt_count_r_array_mutable.h>
#include <register_includes/dprsr_perf_byt_count_r_mutable.h>
#include <register_includes/dprsr_perf_probe_r_mutable.h>
#include <deparser-perf-count-adapter.h>
// to update the autogenerated stuff use:
//   cog.py -cr deparser-reg.h ../../src/jbay/deparser-reg.cpp ../../src/jbay/deparser-ingress.cpp ../../src/jbay/deparser-egress.cpp ../../src/jbay/deparser.cpp


//[[[cog import deparser_metadata as metadata ]]]
//[[[end]]] (checksum: d41d8cd98f00b204e9800998ecf8427e)
//[[[cog cog.out(metadata.includes) ]]]
#include <register_includes/dprsr_input_ingress_only_g_m_learn_sel.h>
#include <register_includes/dprsr_input_ingress_only_g_m_resub_sel.h>
#include <register_includes/dprsr_input_ingress_only_g_m_pgen.h>
#include <register_includes/dprsr_input_ingress_only_g_m_pgen_len.h>
#include <register_includes/dprsr_input_ingress_only_g_m_pgen_addr.h>
#include <register_includes/dprsr_input_ingress_only_g_m_egress_unicast_port.h>
#include <register_includes/dprsr_input_ingress_only_g_m_mgid1.h>
#include <register_includes/dprsr_input_ingress_only_g_m_mgid2.h>
#include <register_includes/dprsr_input_ingress_only_g_m_copy_to_cpu.h>
#include <register_includes/dprsr_input_ingress_only_g_m_mirr_sel.h>
#include <register_includes/dprsr_input_ingress_only_g_m_drop_ctl.h>
#include <register_includes/dprsr_input_egress_only_g_m_egress_unicast_port.h>
#include <register_includes/dprsr_input_egress_only_g_m_mirr_sel.h>
#include <register_includes/dprsr_input_egress_only_g_m_drop_ctl.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_hash1.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_hash2.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_copy_to_cpu_cos.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_deflect_on_drop.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_icos.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_pkt_color.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_qid.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_xid_l1.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_xid_l2.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_rid.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_bypss_egr.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_ct_disable.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_ct_mcast.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_io_sel.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_hash.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_epipe_port.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_qid.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_dond_ctrl.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_icos.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_mc_ctrl.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_c2c_ctrl.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mirr_coal_smpl_len.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_afc.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mtu_trunc_len.h>
#include <register_includes/dprsr_ingress_hdr_meta_for_input_g_m_mtu_trunc_err_f.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_force_tx_err.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_capture_tx_ts.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_tx_pkt_has_offsets.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_io_sel.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_hash.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_epipe_port.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_qid.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_dond_ctrl.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_icos.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_mc_ctrl.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_c2c_ctrl.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mirr_coal_smpl_len.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_afc.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mtu_trunc_len.h>
#include <register_includes/dprsr_egress_hdr_meta_for_input_g_m_mtu_trunc_err_f.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_hash1.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_hash2.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_copy_to_cpu_cos.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_deflect_on_drop.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_icos.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_pkt_color.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_qid.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_xid_l1.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_xid_l2.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_rid.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_bypss_egr.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_ct_disable.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_ct_mcast.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_io_sel.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_hash.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_epipe_port.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_qid.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_dond_ctrl.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_icos.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_mc_ctrl.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_c2c_ctrl.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mirr_coal_smpl_len.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_afc.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mtu_trunc_len.h>
#include <register_includes/dprsr_header_ingress_meta_g_m_mtu_trunc_err_f.h>
#include <register_includes/dprsr_header_egress_meta_g_m_force_tx_err.h>
#include <register_includes/dprsr_header_egress_meta_g_m_capture_tx_ts.h>
#include <register_includes/dprsr_header_egress_meta_g_m_tx_pkt_has_offsets.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_io_sel.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_hash.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_epipe_port.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_qid.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_dond_ctrl.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_icos.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_mc_ctrl.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_c2c_ctrl.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mirr_coal_smpl_len.h>
#include <register_includes/dprsr_header_egress_meta_g_m_afc.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mtu_trunc_len.h>
#include <register_includes/dprsr_header_egress_meta_g_m_mtu_trunc_err_f.h>
//[[[end]]] (checksum: 6ae24313cc890be0cd2ed2b68a74cc6a)


namespace MODEL_CHIP_NAMESPACE {


// FdChunkReg holds the per chunk registers in the Field Dictionary.
// It is instantated by:
//  FdSliceReg
//   +-> FdIEReg[4]                - one per slice
//        +-> FdWordReg[2]         - ingress, egress
//             +-> FdChunkReg[16]  - one per word
//   And then it mostly instantiates register in arrays of 8 - one for each chunk within the word.
//     So there are 16*8=128 chunks total.
//   Also instantiates fd_word_clot_sel_info_r_, not strictly part of FD, but here because there's
//    one per word.
//  A few of the registers are no longer per slice, but are instantiated here for checking purposes
struct FdChunkReg {
  FdChunkReg(int chip, int pipe, int slice, bool egress, int word);

  void reset();

  Deparser::FdChunk get_chunk(int chunk);

  uint8_t get_clot_sel_segment_tag(int index);

  int word_index_;
  template< typename T > using ChunkArray = std::array< T, 8 >;

  // these are the registers in dprsr_h_fd_full_chunk_g
  ChunkArray<register_classes::FdChunkInfoR>   fd_chunk_info_r_;
  ChunkArray<register_classes::FdByteIsPhvR>   fd_byte_is_phv_r_;
  ChunkArray<register_classes::FdByteOffInfoR> fd_byte_off_info_r_;
  // this is the copy of info in dprsr_h_fd_chunk_cfg_g  - no longer a complete copy!
  ChunkArray<register_classes::FdByteselChunkInfoR>   fd_chunk_info_r_duplicate_;

  // these two are not strictly part of the Field Dictionary, but here
  //  because there is one per word
  register_classes::FdWordClotSelInfoR fd_word_clot_sel_info_r_;
  // A copy that is used in the compression logic
  register_classes::FdWordClotSelInfoR fd_word_clot_sel_info_r_duplicate_;

};


struct FdWordReg {
  FdWordReg(int chip, int pipe, int slice, bool egress) :
      chunks_{{
      { chip, pipe, slice, egress, 0 },
      { chip, pipe, slice, egress, 1 },
      { chip, pipe, slice, egress, 2 },
      { chip, pipe, slice, egress, 3 },
      { chip, pipe, slice, egress, 4 },
      { chip, pipe, slice, egress, 5 },
      { chip, pipe, slice, egress, 6 },
      { chip, pipe, slice, egress, 7 },
      { chip, pipe, slice, egress, 8 },
      { chip, pipe, slice, egress, 9 },
      { chip, pipe, slice, egress, 10 },
      { chip, pipe, slice, egress, 11 },
      { chip, pipe, slice, egress, 12 },
      { chip, pipe, slice, egress, 13 },
      { chip, pipe, slice, egress, 14 },
      { chip, pipe, slice, egress, 15 } }}

  {
    reset();
  }
  void reset() {
    for (int i=0;i<16;++i) {
      chunks_[i].reset();
    }
  }
  std::array< FdChunkReg, 16 > chunks_;

};

struct FdIEReg {
  FdIEReg(int chip, int pipe, int slice ) :
      ie_{{
      { chip, pipe, slice, false /*ingress*/  },
      { chip, pipe, slice, true  /* egress*/  } }}
  {
    reset();
  }
  void reset() {
    for (int egress=0;egress<=1;++egress) {
      ie_[egress].reset();
    }
  }

  std::array< FdWordReg, 2 > ie_;
};

struct FdSliceReg {
  FdSliceReg(int chip, int pipe ) :
      slices_{{ { chip, pipe, 0 }, { chip, pipe, 1 }, { chip, pipe, 2 }, { chip, pipe, 3 } }}
  {
    reset();
  }
  void reset() {
    for (int slice=0; slice<4; ++slice) {
      slices_[slice].reset();
    }
  }

  std::array< FdIEReg, 4 > slices_;

};


class DeparserReg : public PipeObject {


 public:
  enum IngressEgressIndexEnum {
    kIngress = 0,
    kEgress };

  static constexpr int kWords         = Deparser::kWords;
  static constexpr int kChunksPerWord = Deparser::kChunksPerWord;
  static constexpr int kBytesPerChunk = Deparser::kBytesPerChunk;
  static constexpr int kSlices        = Deparser::kSlices;
  static constexpr int kNumConstants  = Deparser::kNumConstants;

  DeparserReg(RmtObjectManager *om,int chip, int pipe);
  virtual ~DeparserReg();


  static constexpr int kPovWidth = 128;

  void Reset();

  bool is_valid_slice_index(int index) {
    return (index >= 0) && (index < RmtDefs::kDeparserSlicesPerPipe);
  }

  bool is_valid_slice_channel_index(int index) {
    return (index >= 0) && (index < RmtDefs::kDeparserChannelsPerSlice);
  };

  uint32_t get_pov_pos(bool egress, int index) {
    RMT_ASSERT(index < Deparser::kPovWidth/8);
    return pov_position_[egress_flag_to_index(egress)].phvs(index);
  }

  bool ChecksumEngineThreadIsEgress(int engine) {
    return csum_thread_reg_.thread(engine);
  }

  void
  GetChecksumEntry(int engine, const int index,
                   int* pov, bool* swap_bytes, bool* zero_msb, bool* zero_lsb) {
    auto& reg_array = phv_csum_row_entry_array_.csum_row_entry_array_[engine];
    *pov        = reg_array.pov(index);
    *swap_bytes = reg_array.swap(index);
    *zero_msb   = reg_array.zero_m_s_b(index);
    *zero_lsb   = reg_array.zero_l_s_b(index);
  }

  bool GetFullChecksumPhvEntryValid(int slice, int engine,int index,
                                    const BitVector<kPovWidth>& pov) {
    return GetFullChecksumEntryValid( csum_row_entry_array_phv_[engine], engine,index,pov);
  }
  bool GetFullChecksumClotEntryValid(int slice, int engine,int index,
                                     const BitVector<kPovWidth>& pov) {
    return GetFullChecksumEntryValid( csum_row_entry_array_clot_[engine], engine,index,pov);
  }

  bool
  zeros_as_ones(int slice, int engine) {
    auto& reg = zeros_as_ones_[engine];
    return reg.en() ? true : false;
  }
  int
  tag(int slice, bool egress, int engine, int index) {
    auto& reg = tags_array_[engine];
    return reg.tag(index);
  }

  // These functions return true if the PHV is assigned to the corresponding
  // gress. They also check that the PHV is not assigned to the other gress.
  bool  CheckEgressDeparserPhvGroupConfig(const int &phv_idx);
  bool  CheckIngressDeparserPhvGroupConfig(const int &phv_idx);

  //[[[cog cog.out(metadata.width_defs,dedent=True,trimblanklines=True) ]]]
  static constexpr int kLearnSelWidth                   = 3;
  static constexpr int kResubSelWidth                   = 3;
  static constexpr int kPgenWidth                       = 1;
  static constexpr int kPgenLenWidth                    = 14;
  static constexpr int kPgenAddrWidth                   = 10;
//  WIP/jbay specific value now in now in RmtDefs...
//  static constexpr int kIngressEgressUnicastPortWidth   = 9;
  static constexpr int kMgid1Width                      = 16;
  static constexpr int kMgid2Width                      = 16;
  static constexpr int kCopyToCpuWidth                  = 1;
  static constexpr int kIngressMirrSelWidth             = 4;
  static constexpr int kIngressDropCtlWidth             = 3;
//  WIP/jbay specific value now in now in RmtDefs...
//  static constexpr int kEgressEgressUnicastPortWidth    = 9;
  static constexpr int kEgressMirrSelWidth              = 4;
  static constexpr int kEgressDropCtlWidth              = 3;
  static constexpr int kHash1Width                      = 13;
  static constexpr int kHash2Width                      = 13;
  static constexpr int kCopyToCpuCosWidth               = 3;
  static constexpr int kDeflectOnDropWidth              = 1;
  static constexpr int kIcosWidth                       = 3;
  static constexpr int kPktColorWidth                   = 2;
  static constexpr int kQidWidth                        = 7;
  static constexpr int kXidL1Width                      = 16;
//  WIP/jbay specific value now in now in RmtDefs...
//  static constexpr int kXidL2Width                      = 9;
  static constexpr int kRidWidth                        = 16;
  static constexpr int kBypssEgrWidth                   = 1;
  static constexpr int kCtDisableWidth                  = 1;
  static constexpr int kCtMcastWidth                    = 1;
  static constexpr int kIngressMirrIoSelWidth           = 1;
  static constexpr int kIngressMirrHashWidth            = 13;
//  WIP/jbay specific value now in now in RmtDefs...
//  static constexpr int kIngressMirrEpipePortWidth       = 9;
  static constexpr int kIngressMirrQidWidth             = 7;
  static constexpr int kIngressMirrDondCtrlWidth        = 1;
  static constexpr int kIngressMirrIcosWidth            = 3;
  static constexpr int kIngressMirrMcCtrlWidth          = 1;
  static constexpr int kIngressMirrC2cCtrlWidth         = 1;
  static constexpr int kIngressMirrCoalSmplLenWidth     = 8;
  static constexpr int kIngressAfcWidth                 = 32;
  static constexpr int kIngressMtuTruncLenWidth         = 14;
  static constexpr int kIngressMtuTruncErrFWidth        = 1;
  static constexpr int kForceTxErrWidth                 = 1;
  static constexpr int kCaptureTxTsWidth                = 1;
  static constexpr int kTxPktHasOffsetsWidth            = 1;
  static constexpr int kEgressMirrIoSelWidth            = 1;
  static constexpr int kEgressMirrHashWidth             = 13;
//  WIP/jbay specific value now in now in RmtDefs...
//  static constexpr int kEgressMirrEpipePortWidth        = 9;
  static constexpr int kEgressMirrQidWidth              = 7;
  static constexpr int kEgressMirrDondCtrlWidth         = 1;
  static constexpr int kEgressMirrIcosWidth             = 3;
  static constexpr int kEgressMirrMcCtrlWidth           = 1;
  static constexpr int kEgressMirrC2cCtrlWidth          = 1;
  static constexpr int kEgressMirrCoalSmplLenWidth      = 8;
  static constexpr int kEgressAfcWidth                  = 32;
  static constexpr int kEgressMtuTruncLenWidth          = 14;
  static constexpr int kEgressMtuTruncErrFWidth         = 1;
  //[[[end]]] (checksum: 17b61ea0c56ff6f25d3ab3177849e244)


  //[[[cog cog.out(metadata.accessors,dedent=True,trimblanklines=True) ]]]
  bool get_learn_sel_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_learn_sel_, phv, pov, kLearnSelWidth, ret_value );
  }

  bool get_resub_sel_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_resub_sel_, phv, pov, kResubSelWidth, ret_value );
  }

  bool get_pgen_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_pgen_, phv, pov, kPgenWidth, ret_value );
  }

  bool get_pgen_len_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_pgen_len_, phv, pov, kPgenLenWidth, ret_value );
  }

  bool get_pgen_addr_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_pgen_addr_, phv, pov, kPgenAddrWidth, ret_value );
  }

  bool get_i_egress_unicast_port_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata(m_i_egress_unicast_port_, phv, pov, RmtDefs::kDeparserEgressUnicastPortWidth, ret_value );
  }

  bool get_mgid1_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata(m_mgid1_, phv, pov, kMgid1Width, ret_value );
  }

  bool get_mgid2_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata(m_mgid2_, phv, pov, kMgid2Width, ret_value );
  }

  bool get_copy_to_cpu_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_copy_to_cpu_, phv, pov, kCopyToCpuWidth, ret_value );
  }

  bool get_i_mirr_sel_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_i_mirr_sel_, phv, pov, kIngressMirrSelWidth, ret_value );
  }

  bool get_i_drop_ctl_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_i_drop_ctl_, phv, pov, kIngressDropCtlWidth, ret_value );
  }

  bool get_e_egress_unicast_port_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata(m_e_egress_unicast_port_, phv, pov, RmtDefs::kDeparserEgressUnicastPortWidth, ret_value );
  }

  bool get_e_mirr_sel_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_e_mirr_sel_, phv, pov, kEgressMirrSelWidth, ret_value );
  }

  bool get_e_drop_ctl_info( const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_with_shift(m_e_drop_ctl_, phv, pov, kEgressDropCtlWidth, ret_value );
  }

  bool get_hash1_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_hash1_.reg_[slice], m_hash1_pov_reg_, phv, pov, kHash1Width, ret_value );
  }

  bool get_hash2_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_hash2_.reg_[slice], m_hash2_pov_reg_, phv, pov, kHash2Width, ret_value );
  }

  bool get_copy_to_cpu_cos_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_copy_to_cpu_cos_.reg_[slice], m_copy_to_cpu_cos_pov_reg_, phv, pov, kCopyToCpuCosWidth, ret_value );
  }

  bool get_deflect_on_drop_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_deflect_on_drop_.reg_[slice], m_deflect_on_drop_pov_reg_, phv, pov, kDeflectOnDropWidth, ret_value );
  }

  bool get_icos_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_icos_.reg_[slice], m_icos_pov_reg_, phv, pov, kIcosWidth, ret_value );
  }

  bool get_pkt_color_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_pkt_color_.reg_[slice], m_pkt_color_pov_reg_, phv, pov, kPktColorWidth, ret_value );
  }

  bool get_qid_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_qid_.reg_[slice], m_qid_pov_reg_, phv, pov, kQidWidth, ret_value );
  }

  bool get_xid_l1_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_xid_l1_.reg_[slice], m_xid_l1_pov_reg_, phv, pov, kXidL1Width, ret_value );
  }

  bool get_xid_l2_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_xid_l2_.reg_[slice], m_xid_l2_pov_reg_, phv, pov,
                                              RmtDefs::kDeparserXidL2Width, ret_value );
  }

  bool get_rid_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_rid_.reg_[slice], m_rid_pov_reg_, phv, pov, kRidWidth, ret_value );
  }

  bool get_bypss_egr_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_bypss_egr_.reg_[slice], m_bypss_egr_pov_reg_, phv, pov, kBypssEgrWidth, ret_value );
  }

  bool get_ct_disable_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_ct_disable_.reg_[slice], m_ct_disable_pov_reg_, phv, pov, kCtDisableWidth, ret_value );
  }

  bool get_ct_mcast_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_ct_mcast_.reg_[slice], m_ct_mcast_pov_reg_, phv, pov, kCtMcastWidth, ret_value );
  }

  bool get_i_mirr_io_sel_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_io_sel_.reg_[slice], m_i_mirr_io_sel_pov_reg_, phv, pov, kIngressMirrIoSelWidth, ret_value );
  }

  bool get_i_mirr_hash_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_hash_.reg_[slice], m_i_mirr_hash_pov_reg_, phv, pov, kIngressMirrHashWidth, ret_value );
  }

  bool get_i_mirr_epipe_port_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(
           m_i_mirr_epipe_port_.reg_[slice], m_i_mirr_epipe_port_pov_reg_, phv,
           pov, RmtDefs::kDeparserMirrEpipePortWidth, ret_value );
  }

  bool get_i_mirr_qid_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_qid_.reg_[slice], m_i_mirr_qid_pov_reg_, phv, pov, kIngressMirrQidWidth, ret_value );
  }

  bool get_i_mirr_dond_ctrl_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_dond_ctrl_.reg_[slice], m_i_mirr_dond_ctrl_pov_reg_, phv, pov, kIngressMirrDondCtrlWidth, ret_value );
  }

  bool get_i_mirr_icos_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_icos_.reg_[slice], m_i_mirr_icos_pov_reg_, phv, pov, kIngressMirrIcosWidth, ret_value );
  }

  bool get_i_mirr_mc_ctrl_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_mc_ctrl_.reg_[slice], m_i_mirr_mc_ctrl_pov_reg_, phv, pov, kIngressMirrMcCtrlWidth, ret_value );
  }

  bool get_i_mirr_c2c_ctrl_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_c2c_ctrl_.reg_[slice], m_i_mirr_c2c_ctrl_pov_reg_, phv, pov, kIngressMirrC2cCtrlWidth, ret_value );
  }

  bool get_i_mirr_coal_smpl_len_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mirr_coal_smpl_len_.reg_[slice], m_i_mirr_coal_smpl_len_pov_reg_, phv, pov, kIngressMirrCoalSmplLenWidth, ret_value );
  }

  bool get_i_afc_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_afc_.reg_[slice], m_i_afc_pov_reg_, phv, pov, kIngressAfcWidth, ret_value );
  }

  bool get_i_mtu_trunc_len_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mtu_trunc_len_.reg_[slice], m_i_mtu_trunc_len_pov_reg_, phv, pov, kIngressMtuTruncLenWidth, ret_value );
  }

  bool get_i_mtu_trunc_err_f_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_i_mtu_trunc_err_f_.reg_[slice], m_i_mtu_trunc_err_f_pov_reg_, phv, pov, kIngressMtuTruncErrFWidth, ret_value );
  }

  bool get_force_tx_err_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_force_tx_err_.reg_[slice], m_force_tx_err_pov_reg_, phv, pov, kForceTxErrWidth, ret_value );
  }

  bool get_capture_tx_ts_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_capture_tx_ts_.reg_[slice], m_capture_tx_ts_pov_reg_, phv, pov, kCaptureTxTsWidth, ret_value );
  }

  bool get_tx_pkt_has_offsets_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_tx_pkt_has_offsets_.reg_[slice], m_tx_pkt_has_offsets_pov_reg_, phv, pov, kTxPktHasOffsetsWidth, ret_value );
  }

  bool get_e_mirr_io_sel_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_io_sel_.reg_[slice], m_e_mirr_io_sel_pov_reg_, phv, pov, kEgressMirrIoSelWidth, ret_value );
  }

  bool get_e_mirr_hash_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_hash_.reg_[slice], m_e_mirr_hash_pov_reg_, phv, pov, kEgressMirrHashWidth, ret_value );
  }

  bool get_e_mirr_epipe_port_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(
           m_e_mirr_epipe_port_.reg_[slice], m_e_mirr_epipe_port_pov_reg_, phv,
           pov, RmtDefs::kDeparserMirrEpipePortWidth, ret_value );
  }

  bool get_e_mirr_qid_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_qid_.reg_[slice], m_e_mirr_qid_pov_reg_, phv, pov, kEgressMirrQidWidth, ret_value );
  }

  bool get_e_mirr_dond_ctrl_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_dond_ctrl_.reg_[slice], m_e_mirr_dond_ctrl_pov_reg_, phv, pov, kEgressMirrDondCtrlWidth, ret_value );
  }

  bool get_e_mirr_icos_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_icos_.reg_[slice], m_e_mirr_icos_pov_reg_, phv, pov, kEgressMirrIcosWidth, ret_value );
  }

  bool get_e_mirr_mc_ctrl_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_mc_ctrl_.reg_[slice], m_e_mirr_mc_ctrl_pov_reg_, phv, pov, kEgressMirrMcCtrlWidth, ret_value );
  }

  bool get_e_mirr_c2c_ctrl_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_c2c_ctrl_.reg_[slice], m_e_mirr_c2c_ctrl_pov_reg_, phv, pov, kEgressMirrC2cCtrlWidth, ret_value );
  }

  bool get_e_mirr_coal_smpl_len_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mirr_coal_smpl_len_.reg_[slice], m_e_mirr_coal_smpl_len_pov_reg_, phv, pov, kEgressMirrCoalSmplLenWidth, ret_value );
  }

  bool get_e_afc_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_afc_.reg_[slice], m_e_afc_pov_reg_, phv, pov, kEgressAfcWidth, ret_value );
  }

  bool get_e_mtu_trunc_len_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mtu_trunc_len_.reg_[slice], m_e_mtu_trunc_len_pov_reg_, phv, pov, kEgressMtuTruncLenWidth, ret_value );
  }

  bool get_e_mtu_trunc_err_f_info(int slice, const Phv &phv, const BitVector<kPovWidth> &pov, uint64_t* ret_value) {
       return get_metadata_pov_reg_with_shift(m_e_mtu_trunc_err_f_.reg_[slice], m_e_mtu_trunc_err_f_pov_reg_, phv, pov, kEgressMtuTruncErrFWidth, ret_value );
  }
//[[[end]]] (checksum: 68ef0dad538fbc8a57b575edb260ecb1)

  //dprsr_pre_version_r_
  bool get_pre_version(int slice);

  uint8_t get_copy_to_cpu_pipe_vector();
  uint8_t get_ingress_min_pkt_len(int slice);
  uint8_t get_egress_min_pkt_len(int slice);

  uint16_t get_multicast_pipe_vector(int table_num, int mgid);
  // for unit tests...
  void set_multicast_pipe_vector(int table_num, int mgid, uint16_t val);

  // Getters for mirror registers.
  void get_mirror_table_entry(const bool &egress,int slice,
                              const uint8_t mirror_table_idx,
                              std::vector<uint8_t> *phv_idx_list,
                              uint8_t *mirror_id_phv_idx);

  void get_resubmit_table_entry(const uint8_t resubmit_table_idx, bool *valid,
                                std::vector<uint8_t> *phv_idx_list);

  void get_packet_gen_table_entry(bool *valid,
                                std::vector<uint8_t> *phv_idx_list);

  int phv_idx(const int &csum_idx, int *shift);

  Deparser::FdChunk get_chunk(int slice, bool egress, int word, int chunk);

  uint8_t get_constant(bool egress, int slice, int which);

  bool port_enabled(bool egress, int slice, int slice_channel);

  DeparserChipReg& chip_reg();

  void increment_phv_counter(bool egress);

  void increment_learn_counter();

  void increment_configurable_counter(bool egress, uint8_t port);

  void increment_perf_pkt_counter(bool egress,
                                  int slice,
                                  int slice_channel,
                                  uint64_t amount = 1);

  void increment_perf_byte_counter(bool egress,
                                   int slice,
                                   int slice_channel,
                                   uint64_t amount = 1);

  bool test_csum_pov(int engine, int which_bit, const BitVector<kPovWidth> &pov);

  uint16_t get_csum_constant(int slice, bool egress, int engine);

  uint8_t get_clot_sel_segment_tag(int slice, bool egress, int word, int index);

  uint8_t get_i_afc_mode(int slice) { return 0; }

  int  phv_group(const int &phv_idx);
  bool CheckDeparserPhvGroupConfig(const int &phv_idx, const uint32_t &val);

  bool EgressUnicastNeedsCheck();
  bool teop_inhibit(int slice);

 private:
  // don't use this directly, always go through one of the four accessor functions below
  template<typename T>
  bool get_metadata_internal(T &register_block, const Phv &phv, const BitVector<kPovWidth> &pov, int width, uint64_t* ret_value,
                             int pov_index, bool disable, int shift) {
    int  phv_index = register_block.phv();

    RMT_ASSERT( width < 64 );   // mask below can't handle more than 63 bits
    RMT_ASSERT( pov_index < 256 );
    if (disable || ( 0 == pov.get_bit( pov_index ) ) ) {
      *ret_value = 0;
    }
    else {
      // The Tofino model is way more complicated (see Deparser::GetMetadataFromPhv())
      //  if things don't match then maybe this will need to add that complexity!
      uint64_t mask =  (UINT64_C(1) << width) - 1;
      *ret_value = mask & (phv.get_d(phv_index) >> shift);
      return true;
    }
    return false;
  }
  // Accessor functions for different types of metadata all combinations of:
  //   with pov in same register, with pov in different register
  //   without shift and with shift
  template<typename T>
  uint64_t get_metadata(T &register_block, const Phv &phv, const BitVector<kPovWidth> &pov, int width,uint64_t* ret_value) {
    int  pov_index = register_block.pov();
    bool disable   = register_block.disable();
    int shift = 0;
    return get_metadata_internal( register_block, phv, pov, width, ret_value, pov_index, disable, shift );
  }
  template<typename T>
  uint64_t get_metadata_with_shift(T &register_block, const Phv &phv, const BitVector<kPovWidth> &pov, int width,uint64_t* ret_value) {
    int  pov_index = register_block.pov();
    bool disable   = register_block.disable();
    int shift = register_block.shft();
    return get_metadata_internal( register_block, phv, pov, width, ret_value, pov_index, disable, shift );
  }

  template<typename T, typename PT>
  uint64_t get_metadata_pov_reg(T &register_block, PT &pov_register_block,const Phv &phv, const BitVector<kPovWidth> &pov, int width,uint64_t* ret_value) {
    int pov_index = pov_register_block.pov();
    bool disable   = register_block.dis();
    int shift = 0;
    return get_metadata_internal( register_block, phv, pov, width, ret_value, pov_index, disable, shift );
  }
  template<typename T, typename PT>
  uint64_t get_metadata_pov_reg_with_shift(T &register_block, PT &pov_register_block,const Phv &phv, const BitVector<kPovWidth> &pov, int width,uint64_t* ret_value) {
    int pov_index = pov_register_block.pov();
    bool disable   = register_block.dis();
    int shift = register_block.shft();
    return get_metadata_internal( register_block, phv, pov, width, ret_value, pov_index, disable, shift );
  }

  bool GetFullChecksumEntryValid(register_classes::DprsrFullcsumRowEntryArray& reg,int engine,int index,
                                 const BitVector<kPovWidth>& pov);

 private:
  bool ctor_running_;
  DeparserChipReg              deparser_chip_reg_; // chip specific registers

  int egress_flag_to_index(bool egress);
  void sample_perf_counter(bool egress, int slice);

  // Input phase Ingress
  std::array< register_classes::DprsrPovPositionR, 2 > pov_position_;    // ingress, egress

  std::array< register_classes::DprsrCntVldIPhvMutable, 2 > cnt_vld_i_phv_;  // ingress, egress

  // ingress, egress
  std::array< register_classes::DprsrInputIngAndEgrGPpCtrCfgData, 2 > pp_ctr_cfg_data_;
  std::array< register_classes::DprsrInputIngAndEgrGPpCtrCfgMask, 2 > pp_ctr_cfg_mask_;
  std::array< register_classes::PpCtrCfg48RMutable, 2 >               pp_ctr_cfg48_r_;

  template<typename T>
  struct SliceReg {
    SliceReg(int chip, int pipe) :
        reg_{{
        { deparser_in_hdr_adapter(reg_[0], chip, pipe, 0) },
        { deparser_in_hdr_adapter(reg_[1], chip, pipe, 1) },
        { deparser_in_hdr_adapter(reg_[2], chip, pipe, 2) },
        { deparser_in_hdr_adapter(reg_[3], chip, pipe, 3) } }}
    {
      reset();
    }
    template <typename T2>
    SliceReg(int chip, int pipe, T2 e) :
        reg_{{
        { deparser_in_hdr_adapter(reg_[0], chip, pipe, 0, e) },
        { deparser_in_hdr_adapter(reg_[1], chip, pipe, 1, e) },
        { deparser_in_hdr_adapter(reg_[2], chip, pipe, 2, e) },
        { deparser_in_hdr_adapter(reg_[3], chip, pipe, 3, e) } }}
    {
      static_assert(RmtDefs::kDeparserSlicesPerPipe == 4,
                    "kDeparserSlicesPerPipe assumed to be 4");
      reset();
    }
    void reset() {
      for (int i = 0; i < RmtDefs::kDeparserSlicesPerPipe; ++i) reg_[i].reset();
    }
    std::array<T, RmtDefs::kDeparserSlicesPerPipe> reg_;
  };

  //[[[cog cog.out(metadata.defines) ]]]
  register_classes::DprsrInputIngressOnlyGMLearnSel                      m_learn_sel_;
  register_classes::DprsrInputIngressOnlyGMResubSel                      m_resub_sel_;
  register_classes::DprsrInputIngressOnlyGMPgen                          m_pgen_;
  register_classes::DprsrInputIngressOnlyGMPgenLen                       m_pgen_len_;
  register_classes::DprsrInputIngressOnlyGMPgenAddr                      m_pgen_addr_;
  register_classes::DprsrInputIngressOnlyGMEgressUnicastPort             m_i_egress_unicast_port_;
  register_classes::DprsrInputIngressOnlyGMMgid1                         m_mgid1_;
  register_classes::DprsrInputIngressOnlyGMMgid2                         m_mgid2_;
  register_classes::DprsrInputIngressOnlyGMCopyToCpu                     m_copy_to_cpu_;
  register_classes::DprsrInputIngressOnlyGMMirrSel                       m_i_mirr_sel_;
  register_classes::DprsrInputIngressOnlyGMDropCtl                       m_i_drop_ctl_;
  register_classes::DprsrInputEgressOnlyGMEgressUnicastPort              m_e_egress_unicast_port_;
  register_classes::DprsrInputEgressOnlyGMMirrSel                        m_e_mirr_sel_;
  register_classes::DprsrInputEgressOnlyGMDropCtl                        m_e_drop_ctl_;
  register_classes::DprsrIngressHdrMetaForInputGMHash1                   m_hash1_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMHash2                   m_hash2_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMCopyToCpuCos            m_copy_to_cpu_cos_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMDeflectOnDrop           m_deflect_on_drop_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMIcos                    m_icos_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMPktColor                m_pkt_color_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMQid                     m_qid_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMXidL1                   m_xid_l1_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMXidL2                   m_xid_l2_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMRid                     m_rid_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMBypssEgr                m_bypss_egr_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMCtDisable               m_ct_disable_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMCtMcast                 m_ct_mcast_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrIoSel               m_i_mirr_io_sel_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrHash                m_i_mirr_hash_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrEpipePort           m_i_mirr_epipe_port_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrQid                 m_i_mirr_qid_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrDondCtrl            m_i_mirr_dond_ctrl_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrIcos                m_i_mirr_icos_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrMcCtrl              m_i_mirr_mc_ctrl_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrC2cCtrl             m_i_mirr_c2c_ctrl_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMirrCoalSmplLen         m_i_mirr_coal_smpl_len_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMAfc                     m_i_afc_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMtuTruncLen             m_i_mtu_trunc_len_pov_reg_;
  register_classes::DprsrIngressHdrMetaForInputGMMtuTruncErrF            m_i_mtu_trunc_err_f_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMForceTxErr               m_force_tx_err_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMCaptureTxTs              m_capture_tx_ts_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMTxPktHasOffsets          m_tx_pkt_has_offsets_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrIoSel                m_e_mirr_io_sel_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrHash                 m_e_mirr_hash_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrEpipePort            m_e_mirr_epipe_port_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrQid                  m_e_mirr_qid_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrDondCtrl             m_e_mirr_dond_ctrl_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrIcos                 m_e_mirr_icos_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrMcCtrl               m_e_mirr_mc_ctrl_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrC2cCtrl              m_e_mirr_c2c_ctrl_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMirrCoalSmplLen          m_e_mirr_coal_smpl_len_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMAfc                      m_e_afc_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMtuTruncLen              m_e_mtu_trunc_len_pov_reg_;
  register_classes::DprsrEgressHdrMetaForInputGMMtuTruncErrF             m_e_mtu_trunc_err_f_pov_reg_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMHash1>              m_hash1_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMHash2>              m_hash2_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMCopyToCpuCos>       m_copy_to_cpu_cos_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMDeflectOnDrop>      m_deflect_on_drop_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMIcos>               m_icos_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMPktColor>           m_pkt_color_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMQid>                m_qid_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMXidL1>              m_xid_l1_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMXidL2>              m_xid_l2_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMRid>                m_rid_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMBypssEgr>           m_bypss_egr_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMCtDisable>          m_ct_disable_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMCtMcast>            m_ct_mcast_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrIoSel>          m_i_mirr_io_sel_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrHash>           m_i_mirr_hash_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrEpipePort>      m_i_mirr_epipe_port_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrQid>            m_i_mirr_qid_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrDondCtrl>       m_i_mirr_dond_ctrl_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrIcos>           m_i_mirr_icos_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrMcCtrl>         m_i_mirr_mc_ctrl_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrC2cCtrl>        m_i_mirr_c2c_ctrl_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMirrCoalSmplLen>    m_i_mirr_coal_smpl_len_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMAfc>                m_i_afc_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMtuTruncLen>        m_i_mtu_trunc_len_;
  SliceReg<register_classes::DprsrHeaderIngressMetaGMMtuTruncErrF>       m_i_mtu_trunc_err_f_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMForceTxErr>          m_force_tx_err_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMCaptureTxTs>         m_capture_tx_ts_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMTxPktHasOffsets>     m_tx_pkt_has_offsets_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrIoSel>           m_e_mirr_io_sel_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrHash>            m_e_mirr_hash_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrEpipePort>       m_e_mirr_epipe_port_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrQid>             m_e_mirr_qid_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrDondCtrl>        m_e_mirr_dond_ctrl_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrIcos>            m_e_mirr_icos_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrMcCtrl>          m_e_mirr_mc_ctrl_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrC2cCtrl>         m_e_mirr_c2c_ctrl_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMirrCoalSmplLen>     m_e_mirr_coal_smpl_len_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMAfc>                 m_e_afc_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMtuTruncLen>         m_e_mtu_trunc_len_;
  SliceReg<register_classes::DprsrHeaderEgressMetaGMMtuTruncErrF>        m_e_mtu_trunc_err_f_;
  //[[[end]]] (checksum: 9fcf94d51e19d3e40132d5fb6771434b)

  SliceReg<register_classes::DprsrPreVersionR>     dprsr_pre_version_r_;


  // rows for eight checksum engines
  struct EnginesCsumRows {
    EnginesCsumRows(int chip,int pipe);

    void reset();

    std::array<register_classes::DprsrCsumRowEntryArray,8> csum_row_entry_array_;

  };

  // checksum
  // In inp 288 entries for PHV
  EnginesCsumRows                             phv_csum_row_entry_array_;

  // one for whole of inp: dprsr_csum_thread_reg
  register_classes::DprsrCsumThreadReg csum_thread_reg_;

  // per engine in inp
  //dprsr_csum_pov_one_engine    byte_sel[4]
  std::array<register_classes::DprsrCsumPovOneEngine,8> csum_pov_one_engine_;
  std::array<register_classes::DprsrCsumPovInvertEngine,8> csum_pov_invert_engine_;


 private:

  // checksum engine related
  std::array<register_classes::DprsrIFullcsumEngineGCsumConstant,8> csum_constant_;
  std::array<register_classes::DprsrIFullcsumEngineGZerosAsOnes,8>  zeros_as_ones_;
  std::array<register_classes::DprsrIFullcsumEngineGTagsArray,8>    tags_array_;
  std::array<register_classes::DprsrFullcsumRowEntryArray,8>        csum_row_entry_array_phv_;
  std::array<register_classes::DprsrFullcsumRowEntryArray,8>        csum_row_entry_array_clot_;


  std::array<SliceReg<register_classes::DprsrHdrXbarConstDefsR>,2> hdr_xbar_const_defs_r_; // eight constants each for ingress,egress per slice


  // These rates registers are not implemented, no one has asked for them yet.

  //[[[cog
  //       for i_ in range(0,9) :
  //           for r_ in ["En","Rates"] :
  //               cog.outl("register_classes::DprsrIcRegsMac{0}{1} ic_regs_mac{0}_{2}_;".format(i_,r_,r_.lower()) )
  // ]]]
  register_classes::DprsrIcRegsMac0En ic_regs_mac0_en_;
  register_classes::DprsrIcRegsMac0Rates ic_regs_mac0_rates_;
  register_classes::DprsrIcRegsMac1En ic_regs_mac1_en_;
  register_classes::DprsrIcRegsMac1Rates ic_regs_mac1_rates_;
  register_classes::DprsrIcRegsMac2En ic_regs_mac2_en_;
  register_classes::DprsrIcRegsMac2Rates ic_regs_mac2_rates_;
  register_classes::DprsrIcRegsMac3En ic_regs_mac3_en_;
  register_classes::DprsrIcRegsMac3Rates ic_regs_mac3_rates_;
  register_classes::DprsrIcRegsMac4En ic_regs_mac4_en_;
  register_classes::DprsrIcRegsMac4Rates ic_regs_mac4_rates_;
  register_classes::DprsrIcRegsMac5En ic_regs_mac5_en_;
  register_classes::DprsrIcRegsMac5Rates ic_regs_mac5_rates_;
  register_classes::DprsrIcRegsMac6En ic_regs_mac6_en_;
  register_classes::DprsrIcRegsMac6Rates ic_regs_mac6_rates_;
  register_classes::DprsrIcRegsMac7En ic_regs_mac7_en_;
  register_classes::DprsrIcRegsMac7Rates ic_regs_mac7_rates_;
  register_classes::DprsrIcRegsMac8En ic_regs_mac8_en_;
  register_classes::DprsrIcRegsMac8Rates ic_regs_mac8_rates_;
  //[[[end]]] (checksum: 275113643c0b66f33c8e8f73cab42992)

  register_classes::DprsrIcRegsIPhv8Grp  ic_regs_i_phv_8_grp_;
  register_classes::DprsrIcRegsIPhv16Grp ic_regs_i_phv_16_grp_;
  register_classes::DprsrIcRegsIPhv32Grp ic_regs_i_phv_32_grp_;
  register_classes::DprsrIcRegsEPhv8Grp  ic_regs_e_phv_8_grp_;
  register_classes::DprsrIcRegsEPhv16Grp ic_regs_e_phv_16_grp_;
  register_classes::DprsrIcRegsEPhv32Grp ic_regs_e_phv_32_grp_;

  register_classes::DprsrInpEgrUnicastCheckR  inp_egr_unicast_check_r_;
  SliceReg< register_classes::DprsrTeopInhibitR >      teop_inhibit_r_;

  // outer arrays indexed 0->ingress, 1->egress
  std::array<SliceReg<register_classes::DprsrMirrorTableEntryRArray>,2>    mirror_table_entry_r_array_;
  std::array<SliceReg<register_classes::DprsrPerfCountRArrayMutable>,2>    perf_pkt_array_;
  std::array<SliceReg<register_classes::DprsrPerfBytCountRArrayMutable>,2> perf_byte_array_;
  // use an adapter class for the time snapshot registers to hide WIP/jbay differences
  std::array<SliceReg<DeparserPerfCountTimeAdapter>,2>    perf_pkt_time_;
  std::array<SliceReg<DeparserPerfBytCountTimeAdapter>,2> perf_byte_time_;

  // encapsulate an array of 4 counter probe regs each of which will call back
  // on writes the sample_perf_counter method
  template <typename T>
  struct SliceProbeReg {
    SliceProbeReg(int chip, int pipe, bool e, DeparserReg *dprsr_reg) :
        reg_{{
        { deparser_in_hdr_adapter(reg_[0], chip, pipe, 0, e,
            [dprsr_reg, e]()->void{ dprsr_reg->sample_perf_counter(e, 0); }) },
        { deparser_in_hdr_adapter(reg_[1], chip, pipe, 1, e,
            [dprsr_reg, e]()->void{ dprsr_reg->sample_perf_counter(e, 1); }) },
        { deparser_in_hdr_adapter(reg_[2], chip, pipe, 2, e,
            [dprsr_reg, e]()->void{ dprsr_reg->sample_perf_counter(e, 2); }) },
        { deparser_in_hdr_adapter(reg_[3], chip, pipe, 3, e,
            [dprsr_reg, e]()->void{ dprsr_reg->sample_perf_counter(e, 3); }) } }}
    {
      static_assert(RmtDefs::kDeparserSlicesPerPipe == 4,
                    "kDeparserSlicesPerPipe assumed to be 4");
      reset();
    }
    void reset() {
      for (int i = 0; i < RmtDefs::kDeparserSlicesPerPipe; ++i) reg_[i].reset();
    }
    std::array<T, RmtDefs::kDeparserSlicesPerPipe> reg_;
  };
  // encapsulate an array of 4 ShadowCounterArrays, one per slice, each of
  // which will update a corresponding SliceReg reg when sampled.
  template<typename T>
  struct SliceShadowCounterArray {
    SliceShadowCounterArray(int width, SliceReg<T> *slice_reg) :
      ctr_{{
        model_core::ShadowCounterArray<RmtDefs::kDeparserChannelsPerSlice>(
          width, [slice_reg](uint32_t index, uint64_t value) {
            slice_reg->reg_[0].count(index, value);
          }),
        model_core::ShadowCounterArray<RmtDefs::kDeparserChannelsPerSlice>(
          width, [slice_reg](uint32_t index, uint64_t value) {
            slice_reg->reg_[1].count(index, value);
          }),
        model_core::ShadowCounterArray<RmtDefs::kDeparserChannelsPerSlice>(
          width, [slice_reg](uint32_t index, uint64_t value) {
            slice_reg->reg_[2].count(index, value);
          }),
        model_core::ShadowCounterArray<RmtDefs::kDeparserChannelsPerSlice>(
          width, [slice_reg](uint32_t index, uint64_t value) {
            slice_reg->reg_[3].count(index, value);
          })  }}
    {
      static_assert(RmtDefs::kDeparserSlicesPerPipe == 4,
                    "kDeparserSlicesPerPipe assumed to be 4");
    }
    std::array<model_core::ShadowCounterArray<RmtDefs::kDeparserChannelsPerSlice>,
               RmtDefs::kDeparserSlicesPerPipe>                            ctr_;
  };
  std::array<SliceProbeReg<register_classes::DprsrPerfProbeRMutable>,2>    perf_probe_;
  std::array<SliceShadowCounterArray<
                 register_classes::DprsrPerfCountRArrayMutable>,2>         shadow_perf_pkt_array_;
  std::array<SliceShadowCounterArray<
                 register_classes::DprsrPerfBytCountRArrayMutable>,2>      shadow_perf_byte_array_;
  register_classes::DprsrResubmitPktgenTableEntryRArray resubmit_table_entry_r_array_;
  register_classes::DprsrResubmitPktgenTableEntryR      pktgen_table_entry_r_;


  FdSliceReg fd_;



};


}

#endif // _JBAY_SHARED_DEPARSER_REG_
