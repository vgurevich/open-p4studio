/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_DPRSR_OE_REGS_H__
#define __REGISTER_INCLUDES_DPRSR_OE_REGS_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "dpr_o_dbg_ctrl_r.h"
#include "dpr_o_dbg_r.h"
#include "dprsr_byte_adj_fifo_thresh_r.h"
#include "dprsr_c_r_c640_cfg_r.h"
#include "dprsr_c_r_c_cfg_r.h"
#include "dprsr_c_r_c_chk_dis_r.h"
#include "dprsr_c_t_m_ch_empty_r.h"
#include "dprsr_cnt_oe_pkts.h"
#include "dprsr_edf_thresh_r.h"
#include "dprsr_o_ctm_delay_cfg_r.h"
#include "dprsr_oe_ebuf_ctrl_r.h"
#include "dprsr_oe_regs_ctm_crc_err.h"
#include "dprsr_oe_regs_diagbus_cfg.h"
#include "dprsr_oe_regs_e_ctm_pkt_err.h"
#include "dprsr_oe_regs_e_disc_pkts.h"
#include "dprsr_oe_regs_e_egr_pkt_err.h"
#include "dprsr_oe_regs_e_fwd_pkts.h"
#include "dprsr_oe_regs_e_mirr_hdr.h"
#include "dprsr_oe_regs_e_mirr_hdr_mbe.h"
#include "dprsr_oe_regs_e_mirr_hdr_mbe_errlog.h"
#include "dprsr_oe_regs_e_mirr_hdr_sbe.h"
#include "dprsr_oe_regs_e_mirr_hdr_sbe_errlog.h"
#include "dprsr_oe_regs_e_mirr_pkts.h"
#include "dprsr_oe_regs_intr.h"
#include "dprsr_oe_regs_mirr_hdr_e_mbe_err.h"
#include "dprsr_oe_regs_mirr_hdr_e_sbe_err.h"
#include "dprsr_oe_regs_offset_beyond_pkt_err.h"
#include "dprsr_out_arbiter_ctrl_r.h"

namespace tofino {
  namespace register_classes {

class DprsrOeRegs : public model_core::RegisterBlock<RegisterCallback> {
public:
  DprsrOeRegs(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap), 4096, false, write_callback, read_callback, std::string("DprsrOeRegs")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  DprsrOeRegs(
      
  )
    : RegisterBlock(0, 0, 0, false, 0, 0, "DprsrOeRegs")
    {
    }
public:





  DprsrOutArbiterCtrlR &arb_ctrl() { return arb_ctrl_; }





  DprsrCntOePkts &cnt_pkts() { return cnt_pkts_; }





  DprsrOeEbufCtrlR &ebuf_ctrl() { return ebuf_ctrl_; }





  DprsrCRCCfgR &crc_zero() { return crc_zero_; }





  DprsrCRCChkDisR &crc_chk() { return crc_chk_; }





  DprsrCRC640CfgR &crc_gen_cfg() { return crc_gen_cfg_; }





  DprsrCTMChEmptyR &ctm_ch_fifo() { return ctm_ch_fifo_; }






  DprsrByteAdjFifoThreshR &byte_adj() { return byte_adj_; }





  DprODbgCtrlR &arb_dbg_ctrl() { return arb_dbg_ctrl_; }






  DprODbgR &arb_dbg() { return arb_dbg_; }






  DprsrOeRegsEMirrHdr &e_mirr_hdr() { return e_mirr_hdr_; }





  DprsrOeRegsEMirrHdrSbe &e_mirr_hdr_sbe() { return e_mirr_hdr_sbe_; }





  DprsrOeRegsEMirrHdrMbe &e_mirr_hdr_mbe() { return e_mirr_hdr_mbe_; }





  DprsrOeRegsEMirrHdrMbeErrlog &e_mirr_hdr_mbe_errlog() { return e_mirr_hdr_mbe_errlog_; }





  DprsrOeRegsEMirrHdrSbeErrlog &e_mirr_hdr_sbe_errlog() { return e_mirr_hdr_sbe_errlog_; }





  DprsrOeRegsMirrHdrESbeErr &mirr_hdr_e_sbe_err() { return mirr_hdr_e_sbe_err_; }





  DprsrOeRegsMirrHdrEMbeErr &mirr_hdr_e_mbe_err() { return mirr_hdr_e_mbe_err_; }







  DprsrOeRegsCtmCrcErr &ctm_crc_err(int j0) { return ctm_crc_err_[j0]; }





  DprsrOeRegsEEgrPktErr &e_egr_pkt_err() { return e_egr_pkt_err_; }





  DprsrOeRegsECtmPktErr &e_ctm_pkt_err() { return e_ctm_pkt_err_; }





  DprsrOeRegsEFwdPkts &e_fwd_pkts() { return e_fwd_pkts_; }





  DprsrOeRegsEDiscPkts &e_disc_pkts() { return e_disc_pkts_; }





  DprsrOeRegsEMirrPkts &e_mirr_pkts() { return e_mirr_pkts_; }





  DprsrOeRegsDiagbusCfg &diagbus_cfg() { return diagbus_cfg_; }





  DprsrOCtmDelayCfgR &ctm_fcu_cfg() { return ctm_fcu_cfg_; }





  DprsrOeRegsOffsetBeyondPktErr &offset_beyond_pkt_err() { return offset_beyond_pkt_err_; }







  DprsrEdfThreshR &edf_min_thresh() { return edf_min_thresh_; }
  DprsrOeRegsIntr &intr() { return intr_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      if (read_callback_) read_callback_();
      arb_ctrl_.read( offset, data );
    }
    else if (offset >= 0x8 && offset < 0x10) {
      offset -= 0x8;
      if (read_callback_) read_callback_();
      cnt_pkts_.read( offset, data );
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      if (read_callback_) read_callback_();
      ebuf_ctrl_.read( offset, data );
    }
    else if (offset >= 0x20 && offset < 0x2c) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      crc_zero_.read( offset, data );
    }
    else if (offset >= 0x30 && offset < 0x3c) {
      offset -= 0x30;
      if (read_callback_) read_callback_();
      crc_chk_.read( offset, data );
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      if (read_callback_) read_callback_();
      crc_gen_cfg_.read( offset, data );
    }
    else if (offset >= 0x40 && offset < 0x4c) {
      offset -= 0x40;
      if (read_callback_) read_callback_();
      ctm_ch_fifo_.read( offset, data );
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      if (read_callback_) read_callback_();
      byte_adj_.read( offset, data );
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      if (read_callback_) read_callback_();
      arb_dbg_ctrl_.read( offset, data );
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      if (read_callback_) read_callback_();
      arb_dbg_.read( offset, data );
    }
    else if (offset >= 0x600 && offset < 0x604) {
      offset -= 0x600;
      if (read_callback_) read_callback_();
      e_mirr_hdr_.read( offset, data );
    }
    else if (offset >= 0x604 && offset < 0x608) {
      offset -= 0x604;
      if (read_callback_) read_callback_();
      e_mirr_hdr_sbe_.read( offset, data );
    }
    else if (offset >= 0x608 && offset < 0x60c) {
      offset -= 0x608;
      if (read_callback_) read_callback_();
      e_mirr_hdr_mbe_.read( offset, data );
    }
    else if (offset >= 0x634 && offset < 0x638) {
      offset -= 0x634;
      if (read_callback_) read_callback_();
      e_mirr_hdr_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x638 && offset < 0x63c) {
      offset -= 0x638;
      if (read_callback_) read_callback_();
      e_mirr_hdr_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x63c && offset < 0x640) {
      offset -= 0x63c;
      if (read_callback_) read_callback_();
      mirr_hdr_e_sbe_err_.read( offset, data );
    }
    else if (offset >= 0x640 && offset < 0x644) {
      offset -= 0x640;
      if (read_callback_) read_callback_();
      mirr_hdr_e_mbe_err_.read( offset, data );
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      ctm_crc_err_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x920 && offset < 0x924) {
      offset -= 0x920;
      if (read_callback_) read_callback_();
      e_egr_pkt_err_.read( offset, data );
    }
    else if (offset >= 0x924 && offset < 0x928) {
      offset -= 0x924;
      if (read_callback_) read_callback_();
      e_ctm_pkt_err_.read( offset, data );
    }
    else if (offset >= 0x928 && offset < 0x930) {
      offset -= 0x928;
      if (read_callback_) read_callback_();
      e_fwd_pkts_.read( offset, data );
    }
    else if (offset >= 0x930 && offset < 0x938) {
      offset -= 0x930;
      if (read_callback_) read_callback_();
      e_disc_pkts_.read( offset, data );
    }
    else if (offset >= 0x938 && offset < 0x940) {
      offset -= 0x938;
      if (read_callback_) read_callback_();
      e_mirr_pkts_.read( offset, data );
    }
    else if (offset >= 0x940 && offset < 0x944) {
      offset -= 0x940;
      if (read_callback_) read_callback_();
      diagbus_cfg_.read( offset, data );
    }
    else if (offset >= 0x944 && offset < 0x948) {
      offset -= 0x944;
      if (read_callback_) read_callback_();
      ctm_fcu_cfg_.read( offset, data );
    }
    else if (offset >= 0x948 && offset < 0x94c) {
      offset -= 0x948;
      if (read_callback_) read_callback_();
      offset_beyond_pkt_err_.read( offset, data );
    }
    else if (offset >= 0x94c && offset < 0x950) {
      offset -= 0x94c;
      if (read_callback_) read_callback_();
      edf_min_thresh_.read( offset, data );
    }
    else if (offset >= 0x620 && offset < 0x634) {
      offset -= 0x620;
      if (read_callback_) read_callback_();
      intr_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      arb_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8 && offset < 0x10) {
      offset -= 0x8;
      cnt_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      ebuf_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20 && offset < 0x2c) {
      offset -= 0x20;
      crc_zero_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x30 && offset < 0x3c) {
      offset -= 0x30;
      crc_chk_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      crc_gen_cfg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40 && offset < 0x4c) {
      offset -= 0x40;
      ctm_ch_fifo_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      byte_adj_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      arb_dbg_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      arb_dbg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x604) {
      offset -= 0x600;
      e_mirr_hdr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x604 && offset < 0x608) {
      offset -= 0x604;
      e_mirr_hdr_sbe_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x608 && offset < 0x60c) {
      offset -= 0x608;
      e_mirr_hdr_mbe_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x634 && offset < 0x638) {
      offset -= 0x634;
      e_mirr_hdr_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x638 && offset < 0x63c) {
      offset -= 0x638;
      e_mirr_hdr_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x63c && offset < 0x640) {
      offset -= 0x63c;
      mirr_hdr_e_sbe_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x640 && offset < 0x644) {
      offset -= 0x640;
      mirr_hdr_e_mbe_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      ctm_crc_err_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x920 && offset < 0x924) {
      offset -= 0x920;
      e_egr_pkt_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x924 && offset < 0x928) {
      offset -= 0x924;
      e_ctm_pkt_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x928 && offset < 0x930) {
      offset -= 0x928;
      e_fwd_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x930 && offset < 0x938) {
      offset -= 0x930;
      e_disc_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x938 && offset < 0x940) {
      offset -= 0x938;
      e_mirr_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x940 && offset < 0x944) {
      offset -= 0x940;
      diagbus_cfg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x944 && offset < 0x948) {
      offset -= 0x944;
      ctm_fcu_cfg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x948 && offset < 0x94c) {
      offset -= 0x948;
      offset_beyond_pkt_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x94c && offset < 0x950) {
      offset -= 0x94c;
      edf_min_thresh_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x620 && offset < 0x634) {
      offset -= 0x620;
      intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    arb_ctrl_.reset();
    cnt_pkts_.reset();
    ebuf_ctrl_.reset();
    crc_zero_.reset();
    crc_chk_.reset();
    crc_gen_cfg_.reset();
    ctm_ch_fifo_.reset();
    byte_adj_.reset();
    arb_dbg_ctrl_.reset();
    arb_dbg_.reset();
    e_mirr_hdr_.reset();
    e_mirr_hdr_sbe_.reset();
    e_mirr_hdr_mbe_.reset();
    e_mirr_hdr_mbe_errlog_.reset();
    e_mirr_hdr_sbe_errlog_.reset();
    mirr_hdr_e_sbe_err_.reset();
    mirr_hdr_e_mbe_err_.reset();
    for (auto &f0 : ctm_crc_err_) {
      f0.reset();
    }
    e_egr_pkt_err_.reset();
    e_ctm_pkt_err_.reset();
    e_fwd_pkts_.reset();
    e_disc_pkts_.reset();
    e_mirr_pkts_.reset();
    diagbus_cfg_.reset();
    ctm_fcu_cfg_.reset();
    offset_beyond_pkt_err_.reset();
    edf_min_thresh_.reset();
    intr_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      r += arb_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8 && offset < 0x10) {
      offset -= 0x8;
      r += cnt_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      r += ebuf_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20 && offset < 0x2c) {
      offset -= 0x20;
      r += crc_zero_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x30 && offset < 0x3c) {
      offset -= 0x30;
      r += crc_chk_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      r += crc_gen_cfg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40 && offset < 0x4c) {
      offset -= 0x40;
      r += ctm_ch_fifo_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      r += byte_adj_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      r += arb_dbg_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      r += arb_dbg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x604) {
      offset -= 0x600;
      r += e_mirr_hdr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x604 && offset < 0x608) {
      offset -= 0x604;
      r += e_mirr_hdr_sbe_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x608 && offset < 0x60c) {
      offset -= 0x608;
      r += e_mirr_hdr_mbe_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x634 && offset < 0x638) {
      offset -= 0x634;
      r += e_mirr_hdr_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x638 && offset < 0x63c) {
      offset -= 0x638;
      r += e_mirr_hdr_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x63c && offset < 0x640) {
      offset -= 0x63c;
      r += mirr_hdr_e_sbe_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x640 && offset < 0x644) {
      offset -= 0x640;
      r += mirr_hdr_e_mbe_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += ctm_crc_err_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x920 && offset < 0x924) {
      offset -= 0x920;
      r += e_egr_pkt_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x924 && offset < 0x928) {
      offset -= 0x924;
      r += e_ctm_pkt_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x928 && offset < 0x930) {
      offset -= 0x928;
      r += e_fwd_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x930 && offset < 0x938) {
      offset -= 0x930;
      r += e_disc_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x938 && offset < 0x940) {
      offset -= 0x938;
      r += e_mirr_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x940 && offset < 0x944) {
      offset -= 0x940;
      r += diagbus_cfg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x944 && offset < 0x948) {
      offset -= 0x944;
      r += ctm_fcu_cfg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x948 && offset < 0x94c) {
      offset -= 0x948;
      r += offset_beyond_pkt_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x94c && offset < 0x950) {
      offset -= 0x94c;
      r += edf_min_thresh_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x620 && offset < 0x634) {
      offset -= 0x620;
      r += intr_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += arb_ctrl_.to_string(print_zeros,indent_string) ;
    r += cnt_pkts_.to_string(print_zeros,indent_string) ;
    r += ebuf_ctrl_.to_string(print_zeros,indent_string) ;
    r += crc_zero_.to_string(print_zeros,indent_string) ;
    r += crc_chk_.to_string(print_zeros,indent_string) ;
    r += crc_gen_cfg_.to_string(print_zeros,indent_string) ;
    r += ctm_ch_fifo_.to_string(print_zeros,indent_string) ;
    r += byte_adj_.to_string(print_zeros,indent_string) ;
    r += arb_dbg_ctrl_.to_string(print_zeros,indent_string) ;
    r += arb_dbg_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_sbe_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_mbe_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += mirr_hdr_e_sbe_err_.to_string(print_zeros,indent_string) ;
    r += mirr_hdr_e_mbe_err_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<72;++a0) {
      r += ctm_crc_err_[a0].to_string(print_zeros,indent_string) ;
    }
    r += e_egr_pkt_err_.to_string(print_zeros,indent_string) ;
    r += e_ctm_pkt_err_.to_string(print_zeros,indent_string) ;
    r += e_fwd_pkts_.to_string(print_zeros,indent_string) ;
    r += e_disc_pkts_.to_string(print_zeros,indent_string) ;
    r += e_mirr_pkts_.to_string(print_zeros,indent_string) ;
    r += diagbus_cfg_.to_string(print_zeros,indent_string) ;
    r += ctm_fcu_cfg_.to_string(print_zeros,indent_string) ;
    r += offset_beyond_pkt_err_.to_string(print_zeros,indent_string) ;
    r += edf_min_thresh_.to_string(print_zeros,indent_string) ;
    r += intr_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  DprsrOutArbiterCtrlR arb_ctrl_;
  DprsrCntOePkts cnt_pkts_;
  DprsrOeEbufCtrlR ebuf_ctrl_;
  DprsrCRCCfgR crc_zero_;
  DprsrCRCChkDisR crc_chk_;
  DprsrCRC640CfgR crc_gen_cfg_;
  DprsrCTMChEmptyR ctm_ch_fifo_;
  DprsrByteAdjFifoThreshR byte_adj_;
  DprODbgCtrlR arb_dbg_ctrl_;
  DprODbgR arb_dbg_;
  DprsrOeRegsEMirrHdr e_mirr_hdr_;
  DprsrOeRegsEMirrHdrSbe e_mirr_hdr_sbe_;
  DprsrOeRegsEMirrHdrMbe e_mirr_hdr_mbe_;
  DprsrOeRegsEMirrHdrMbeErrlog e_mirr_hdr_mbe_errlog_;
  DprsrOeRegsEMirrHdrSbeErrlog e_mirr_hdr_sbe_errlog_;
  DprsrOeRegsMirrHdrESbeErr mirr_hdr_e_sbe_err_;
  DprsrOeRegsMirrHdrEMbeErr mirr_hdr_e_mbe_err_;
  std::array< DprsrOeRegsCtmCrcErr, 72 > ctm_crc_err_;
  DprsrOeRegsEEgrPktErr e_egr_pkt_err_;
  DprsrOeRegsECtmPktErr e_ctm_pkt_err_;
  DprsrOeRegsEFwdPkts e_fwd_pkts_;
  DprsrOeRegsEDiscPkts e_disc_pkts_;
  DprsrOeRegsEMirrPkts e_mirr_pkts_;
  DprsrOeRegsDiagbusCfg diagbus_cfg_;
  DprsrOCtmDelayCfgR ctm_fcu_cfg_;
  DprsrOeRegsOffsetBeyondPktErr offset_beyond_pkt_err_;
  DprsrEdfThreshR edf_min_thresh_;
  DprsrOeRegsIntr intr_;
private:
  static int StartOffset(
      int index_pipe_addrmap
      ) {
    int offset=0;
    offset += 0x2000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x800000; // pipe_addrmap[]
    offset += 0x780000; // to get to deparser
    offset += 0x18000; // to get to out_egr
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace tofino

#endif // __REGISTER_INCLUDES_DPRSR_OE_REGS_H__
