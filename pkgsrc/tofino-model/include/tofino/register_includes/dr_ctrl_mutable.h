/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_DR_CTRL_MUTABLE_H__
#define __REGISTER_INCLUDES_DR_CTRL_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>












namespace tofino {
  namespace register_classes {

class DrCtrlMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  enum CbcRspecEnum {
    kCbcLqFmDr,
    kCbcLqRxDr,
    kCbcWlCplDr,
    kCbcWlTxDr
  };
  enum MbcRspecEnum {
    kMbcMacCplDr,
    kMbcMacTxDr
  };
  enum PbcRspecEnum {
    kPbcDiagFmDr,
    kPbcDiagRxDr,
    kPbcIdleFmDr,
    kPbcIdleRxDr,
    kPbcIlCplDr,
    kPbcIlTxDr,
    kPbcRbCplDr,
    kPbcRbTxDr,
    kPbcStatFmDr,
    kPbcStatRxDr,
    kPbcWbCplDr,
    kPbcWbTxDr
  };
  enum TbcRspecEnum {
    kTbcCplDr,
    kTbcFmDr,
    kTbcRxDr,
    kTbcTxDr
  };
public:
  DrCtrlMutable(
      int chipNumber, CbcRspecEnum selector_cbc_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_cbc_rspec), 4, true, write_callback, read_callback, std::string("DrCtrlMutable")+":"+boost::lexical_cast<std::string>(selector_cbc_rspec))
    {
    }
  DrCtrlMutable(
      int chipNumber, MbcRspecEnum selector_mbc_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_mbc_rspec), 4, true, write_callback, read_callback, std::string("DrCtrlMutable")+":"+boost::lexical_cast<std::string>(selector_mbc_rspec))
    {
    }
  DrCtrlMutable(
      int chipNumber, PbcRspecEnum selector_pbc_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_pbc_rspec), 4, true, write_callback, read_callback, std::string("DrCtrlMutable")+":"+boost::lexical_cast<std::string>(selector_pbc_rspec))
    {
    }
  DrCtrlMutable(
      int chipNumber, PbcRspecEnum selector_pbc_rspec, int index_dru_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_pbc_rspec, index_dru_rspec), 4, true, write_callback, read_callback, std::string("DrCtrlMutable")+":"+boost::lexical_cast<std::string>(selector_pbc_rspec) + "," + boost::lexical_cast<std::string>(index_dru_rspec))
    {
    }
  DrCtrlMutable(
      int chipNumber, TbcRspecEnum selector_tbc_rspec, int index_dru_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_tbc_rspec, index_dru_rspec), 4, true, write_callback, read_callback, std::string("DrCtrlMutable")+":"+boost::lexical_cast<std::string>(selector_tbc_rspec) + "," + boost::lexical_cast<std::string>(index_dru_rspec))
    {
    }
  DrCtrlMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "DrCtrlMutable")
    {
    }
public:






  uint8_t en() { return en_; }
  void en(const uint8_t &v) { en_=v; }







  uint8_t write_time_mode() { return write_time_mode_; }
  void write_time_mode(const uint8_t &v) { write_time_mode_=v; }







  uint8_t head_ptr_mode() { return head_ptr_mode_; }
  void head_ptr_mode(const uint8_t &v) { head_ptr_mode_=v; }







  uint8_t tail_ptr_mode() { return tail_ptr_mode_; }
  void tail_ptr_mode(const uint8_t &v) { tail_ptr_mode_=v; }





  uint32_t rsvd() { return rsvd_; }
  void rsvd(const uint32_t &v) { rsvd_=v; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (read_callback_) read_callback_();
    *data = (en_ & 0x1);
    *data |= ((write_time_mode_ & 0x1) << 1);
    *data |= ((head_ptr_mode_ & 0x1) << 2);
    *data |= ((tail_ptr_mode_ & 0x1) << 3);
    *data |= ((rsvd_ & 0xfffffff) << 4);
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    en_ = (data & 0x1);
    write_time_mode_ = ((data >> 1) & 0x1);
    head_ptr_mode_ = ((data >> 2) & 0x1);
    tail_ptr_mode_ = ((data >> 3) & 0x1);
    rsvd_ = ((data >> 4) & 0xfffffff);
    if (write_callback_) write_callback_();
    return true;
  }

  void reset(
      
      ) {
    en_ = 0x0;
    write_time_mode_ = 0x0;
    head_ptr_mode_ = 0x0;
    tail_ptr_mode_ = 0x0;
    rsvd_ = 0x0;
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("DrCtrlMutable") + ":\n";
    r += indent_string + "  " + std::string("en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(en_) ) + "\n";
    all_zeros &= (0 == en_);
    r += indent_string + "  " + std::string("write_time_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(write_time_mode_) ) + "\n";
    all_zeros &= (0 == write_time_mode_);
    r += indent_string + "  " + std::string("head_ptr_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(head_ptr_mode_) ) + "\n";
    all_zeros &= (0 == head_ptr_mode_);
    r += indent_string + "  " + std::string("tail_ptr_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(tail_ptr_mode_) ) + "\n";
    all_zeros &= (0 == tail_ptr_mode_);
    r += indent_string + "  " + std::string("rsvd") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rsvd_) ) + "\n";
    all_zeros &= (0 == rsvd_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    r += indent_string + std::string("DrCtrlMutable") + ":\n";
    r += indent_string + "  " + std::string("en") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(en_) ) + "\n";
    all_zeros &= (0 == en_);
    r += indent_string + "  " + std::string("write_time_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(write_time_mode_) ) + "\n";
    all_zeros &= (0 == write_time_mode_);
    r += indent_string + "  " + std::string("head_ptr_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(head_ptr_mode_) ) + "\n";
    all_zeros &= (0 == head_ptr_mode_);
    r += indent_string + "  " + std::string("tail_ptr_mode") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(tail_ptr_mode_) ) + "\n";
    all_zeros &= (0 == tail_ptr_mode_);
    r += indent_string + "  " + std::string("rsvd") +  ": 0x" + boost::str( boost::format("%x") % static_cast<uint>(rsvd_) ) + "\n";
    all_zeros &= (0 == rsvd_);
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  uint8_t en_;
  uint8_t write_time_mode_;
  uint8_t head_ptr_mode_;
  uint8_t tail_ptr_mode_;
  uint32_t rsvd_;
private:
  static int StartOffset(
      CbcRspecEnum selector_cbc_rspec
      ) {
    int offset=0;
    offset += 0x140000; // to get to cbc
    switch (selector_cbc_rspec) {
      case kCbcLqFmDr:
        offset += 0x180; // to get to cbc_lq_fm_dr
        break;
      case kCbcLqRxDr:
        offset += 0x1c0; // to get to cbc_lq_rx_dr
        break;
      case kCbcWlCplDr:
        offset += 0x140; // to get to cbc_wl_cpl_dr
        break;
      case kCbcWlTxDr:
        offset += 0x100; // to get to cbc_wl_tx_dr
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      MbcRspecEnum selector_mbc_rspec
      ) {
    int offset=0;
    offset += 0xc0000; // to get to mbc
    switch (selector_mbc_rspec) {
      case kMbcMacCplDr:
        offset += 0x140; // to get to mbc_mac_cpl_dr
        break;
      case kMbcMacTxDr:
        offset += 0x100; // to get to mbc_mac_tx_dr
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      PbcRspecEnum selector_pbc_rspec
      ) {
    int offset=0;
    offset += 0x100000; // to get to pbc
    switch (selector_pbc_rspec) {
      case kPbcDiagFmDr:
        offset += 0xa00; // to get to pbc_diag_fm_dr
        break;
      case kPbcDiagRxDr:
        offset += 0xa40; // to get to pbc_diag_rx_dr
        break;
      case kPbcIdleFmDr:
        offset += 0x980; // to get to pbc_idle_fm_dr
        break;
      case kPbcIdleRxDr:
        offset += 0x9c0; // to get to pbc_idle_rx_dr
        break;
      case kPbcRbCplDr:
        offset += 0x8c0; // to get to pbc_rb_cpl_dr
        break;
      case kPbcRbTxDr:
        offset += 0x880; // to get to pbc_rb_tx_dr
        break;
      case kPbcStatFmDr:
        offset += 0x900; // to get to pbc_stat_fm_dr
        break;
      case kPbcStatRxDr:
        offset += 0x940; // to get to pbc_stat_rx_dr
        break;
      case kPbcWbCplDr:
        offset += 0x840; // to get to pbc_wb_cpl_dr
        break;
      case kPbcWbTxDr:
        offset += 0x800; // to get to pbc_wb_tx_dr
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      PbcRspecEnum selector_pbc_rspec, int index_dru_rspec
      ) {
    int offset=0;
    offset += 0x100000; // to get to pbc
    switch (selector_pbc_rspec) {
      case kPbcIlCplDr:
        offset += 0x600; // to get to pbc_il_cpl_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kPbcIlTxDr:
        offset += 0x400; // to get to pbc_il_tx_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      TbcRspecEnum selector_tbc_rspec, int index_dru_rspec
      ) {
    int offset=0;
    offset += 0x180000; // to get to tbc
    switch (selector_tbc_rspec) {
      case kTbcCplDr:
        offset += 0x200; // to get to tbc_cpl_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kTbcFmDr:
        offset += 0x400; // to get to tbc_fm_dr
        assert(index_dru_rspec < 8);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kTbcRxDr:
        offset += 0x600; // to get to tbc_rx_dr
        assert(index_dru_rspec < 8);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kTbcTxDr:
        offset += 0x100; // to get to tbc_tx_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace tofino

#endif // __REGISTER_INCLUDES_DR_CTRL_MUTABLE_H__
