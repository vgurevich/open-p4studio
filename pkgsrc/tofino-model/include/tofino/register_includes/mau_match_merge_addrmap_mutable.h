/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_MAU_MATCH_MERGE_ADDRMAP_MUTABLE_H__
#define __REGISTER_INCLUDES_MAU_MATCH_MERGE_ADDRMAP_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "actiondata_error_ctl_mutable.h"
#include "emm_ecc_error_ctl_mutable.h"
#include "err_idata_ovr_ctl_mutable.h"
#include "err_idata_ovr_fifo_ctl_mutable.h"
#include "exact_match_delay_thread_mutable.h"
#include "exact_match_logical_result_delay_mutable.h"
#include "exact_match_logical_result_en_mutable.h"
#include "exact_match_phys_result_delay_mutable.h"
#include "exact_match_phys_result_en_mutable.h"
#include "exact_match_phys_result_thread_mutable.h"
#include "gateway_en_mutable.h"
#include "gateway_inhibit_lut_mutable.h"
#include "gateway_next_table_lut_mutable.h"
#include "gateway_payload_data_mutable.h"
#include "gateway_payload_exact_pbus_mutable.h"
#include "gateway_payload_match_adr_mutable.h"
#include "gateway_payload_tind_pbus_mutable.h"
#include "gateway_to_logicaltable_xbar_ctl_mutable.h"
#include "gateway_to_pbus_xbar_ctl_mutable.h"
#include "gfm_parity_error_ctl_mutable.h"
#include "imem_parity_error_ctl_mutable.h"
#include "logical_table_thread_mutable.h"
#include "match_to_logical_table_ixbar_outputmap_mutable.h"
#include "mau_action_instruction_adr_default_mutable.h"
#include "mau_action_instruction_adr_exact_shiftcount_mutable.h"
#include "mau_action_instruction_adr_map_data_mutable.h"
#include "mau_action_instruction_adr_map_en_mutable.h"
#include "mau_action_instruction_adr_mask_mutable.h"
#include "mau_action_instruction_adr_miss_value_mutable.h"
#include "mau_action_instruction_adr_per_entry_en_mux_ctl_mutable.h"
#include "mau_action_instruction_adr_tcam_actionbit_map_en_mutable.h"
#include "mau_action_instruction_adr_tcam_shiftcount_mutable.h"
#include "mau_actiondata_adr_default_mutable.h"
#include "mau_actiondata_adr_exact_shiftcount_mutable.h"
#include "mau_actiondata_adr_mask_mutable.h"
#include "mau_actiondata_adr_miss_value_mutable.h"
#include "mau_actiondata_adr_per_entry_en_mux_ctl_mutable.h"
#include "mau_actiondata_adr_tcam_actionbit_map_data_mutable.h"
#include "mau_actiondata_adr_tcam_actionbit_map_en_mutable.h"
#include "mau_actiondata_adr_tcam_shiftcount_mutable.h"
#include "mau_actiondata_adr_vpn_shiftcount_mutable.h"
#include "mau_hash_group_config_mutable.h"
#include "mau_hash_group_expand_mutable.h"
#include "mau_hash_group_mask_mutable.h"
#include "mau_hash_group_shiftcount_mutable.h"
#include "mau_hash_group_xbar_ctl_mutable.h"
#include "mau_idletime_adr_default_mutable.h"
#include "mau_idletime_adr_exact_shiftcount_mutable.h"
#include "mau_idletime_adr_mask_mutable.h"
#include "mau_idletime_adr_miss_value_mutable.h"
#include "mau_idletime_adr_per_entry_en_mux_ctl_mutable.h"
#include "mau_idletime_adr_tcam_actionbit_map_data_mutable.h"
#include "mau_idletime_adr_tcam_actionbit_map_en_mutable.h"
#include "mau_idletime_adr_tcam_shiftcount_mutable.h"
#include "mau_immediate_data_default_mutable.h"
#include "mau_immediate_data_exact_shiftcount_mutable.h"
#include "mau_immediate_data_mask_mutable.h"
#include "mau_immediate_data_miss_value_mutable.h"
#include "mau_immediate_data_tcam_actionbit_map_data_mutable.h"
#include "mau_immediate_data_tcam_actionbit_map_en_mutable.h"
#include "mau_immediate_data_tcam_shiftcount_mutable.h"
#include "mau_logical_to_meter_alu_map_mutable.h"
#include "mau_mapram_color_map_to_logical_ctl_mutable.h"
#include "mau_match_central_mapram_read_color_oflo_ctl_mutable.h"
#include "mau_match_merge_col_addrmap_mutable.h"
#include "mau_meter_adr_default_mutable.h"
#include "mau_meter_adr_exact_shiftcount_mutable.h"
#include "mau_meter_adr_mask_mutable.h"
#include "mau_meter_adr_miss_value_mutable.h"
#include "mau_meter_adr_per_entry_en_mux_ctl_mutable.h"
#include "mau_meter_adr_tcam_actionbit_map_data_mutable.h"
#include "mau_meter_adr_tcam_actionbit_map_en_mutable.h"
#include "mau_meter_adr_tcam_shiftcount_mutable.h"
#include "mau_meter_adr_type_position_mutable.h"
#include "mau_meter_alu_to_logical_map_mutable.h"
#include "mau_meter_precolor_hash_map_to_logical_ctl_mutable.h"
#include "mau_meter_precolor_hash_sel_mutable.h"
#include "mau_payload_shifter_enable_mutable.h"
#include "mau_physical_to_meter_alu_ixbar_map_mutable.h"
#include "mau_selector_action_entry_size_mutable.h"
#include "mau_selector_hash_sps_enable_mutable.h"
#include "mau_selectorlength_default_mutable.h"
#include "mau_selectorlength_mask_mutable.h"
#include "mau_selectorlength_shiftcount_mutable.h"
#include "mau_snapshot_capture_datapath_error_mutable.h"
#include "mau_snapshot_gateway_table_inhibit_logical_mutable.h"
#include "mau_snapshot_logical_table_hit_mutable.h"
#include "mau_snapshot_next_table_out_mutable.h"
#include "mau_snapshot_physical_exact_match_hit_address_mutable.h"
#include "mau_snapshot_physical_tcam_hit_address_mutable.h"
#include "mau_snapshot_table_active_mutable.h"
#include "mau_stateful_log_counter_clear_mutable.h"
#include "mau_stateful_log_counter_ctl_mutable.h"
#include "mau_stateful_log_counter_mutable.h"
#include "mau_stateful_log_ctl_ixbar_map_mutable.h"
#include "mau_stateful_log_instruction_width_mutable.h"
#include "mau_stateful_log_vpn_hole_en_mutable.h"
#include "mau_stateful_log_vpn_limit_mutable.h"
#include "mau_stateful_log_vpn_offset_mutable.h"
#include "mau_stats_adr_default_mutable.h"
#include "mau_stats_adr_exact_shiftcount_mutable.h"
#include "mau_stats_adr_hole_swizzle_mode_mutable.h"
#include "mau_stats_adr_mask_mutable.h"
#include "mau_stats_adr_miss_value_mutable.h"
#include "mau_stats_adr_per_entry_en_mux_ctl_mutable.h"
#include "mau_stats_adr_tcam_actionbit_map_data_mutable.h"
#include "mau_stats_adr_tcam_actionbit_map_en_mutable.h"
#include "mau_stats_adr_tcam_shiftcount_mutable.h"
#include "mau_table_counter_clear_mutable.h"
#include "mau_table_counter_ctl_mutable.h"
#include "mau_table_counter_mutable.h"
#include "meter_alu_thread_mutable.h"
#include "next_table_format_data_mutable.h"
#include "next_table_map_data_mutable.h"
#include "next_table_map_en_mutable.h"
#include "next_table_tcam_actionbit_map_en_mutable.h"
#include "o_error_fifo_ctl_mutable.h"
#include "predication_ctl_mutable.h"
#include "prev_error_ctl_mutable.h"
#include "s2p_meter_error_ctl_mutable.h"
#include "s2p_stats_error_ctl_mutable.h"
#include "stash_hitmap_output_map_mutable.h"
#include "stash_next_table_lut_mutable.h"
#include "stash_row_nxtable_bus_drive_mutable.h"
#include "tcam_hit_to_logical_table_ixbar_outputmap_mutable.h"
#include "tcam_match_adr_to_physical_oxbar_outputmap_mutable.h"
#include "tcam_match_error_ctl_mutable.h"
#include "tcam_table_prop_mutable.h"
#include "tind_bus_prop_mutable.h"
#include "tind_ecc_error_ctl_mutable.h"
#include "tind_ram_data_size_mutable.h"

namespace tofino {
  namespace register_classes {

class MauMatchMergeAddrmapMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  MauMatchMergeAddrmapMutable(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 16384, true, write_callback, read_callback, std::string("MauMatchMergeAddrmapMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauMatchMergeAddrmapMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "MauMatchMergeAddrmapMutable")
    {
    }
public:











  MauMeterAdrDefaultMutable &mau_meter_adr_default(int j1,int j0) { return mau_meter_adr_default_[j1][j0]; }





















  MauMeterAdrPerEntryEnMuxCtlMutable &mau_meter_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_meter_adr_per_entry_en_mux_ctl_[j1][j0]; }









  MauMeterAdrTcamActionbitMapDataMutable &mau_meter_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_meter_adr_tcam_actionbit_map_data_[j1][j0]; }











  MauIdletimeAdrMaskMutable &mau_idletime_adr_mask(int j1,int j0) { return mau_idletime_adr_mask_[j1][j0]; }











  MauIdletimeAdrDefaultMutable &mau_idletime_adr_default(int j1,int j0) { return mau_idletime_adr_default_[j1][j0]; }









  MauIdletimeAdrTcamActionbitMapDataMutable &mau_idletime_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_idletime_adr_tcam_actionbit_map_data_[j1][j0]; }





















  MauIdletimeAdrPerEntryEnMuxCtlMutable &mau_idletime_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_idletime_adr_per_entry_en_mux_ctl_[j1][j0]; }


















  MauSelectorlengthShiftcountMutable &mau_selectorlength_shiftcount(int j1,int j0) { return mau_selectorlength_shiftcount_[j1][j0]; }











  MauSelectorlengthMaskMutable &mau_selectorlength_mask(int j1,int j0) { return mau_selectorlength_mask_[j1][j0]; }











  MauSelectorlengthDefaultMutable &mau_selectorlength_default(int j1,int j0) { return mau_selectorlength_default_[j1][j0]; }






















  MauMeterAdrTypePositionMutable &mau_meter_adr_type_position(int j1,int j0) { return mau_meter_adr_type_position_[j1][j0]; }












  GatewayPayloadMatchAdrMutable &gateway_payload_match_adr(int j2,int j1,int j0) { return gateway_payload_match_adr_[j2][j1][j0]; }













  TcamMatchAdrToPhysicalOxbarOutputmapMutable &tcam_match_adr_to_physical_oxbar_outputmap(int j0) { return tcam_match_adr_to_physical_oxbar_outputmap_[j0]; }



















  TindRamDataSizeMutable &tind_ram_data_size(int j0) { return tind_ram_data_size_[j0]; }











  NextTableFormatDataMutable &next_table_format_data(int j0) { return next_table_format_data_[j0]; }










  MauImmediateDataTcamShiftcountMutable &mau_immediate_data_tcam_shiftcount(int j0) { return mau_immediate_data_tcam_shiftcount_[j0]; }








  MauImmediateDataMissValueMutable &mau_immediate_data_miss_value(int j0) { return mau_immediate_data_miss_value_[j0]; }










  MauActionInstructionAdrTcamShiftcountMutable &mau_action_instruction_adr_tcam_shiftcount(int j0) { return mau_action_instruction_adr_tcam_shiftcount_[j0]; }








  MauActionInstructionAdrMissValueMutable &mau_action_instruction_adr_miss_value(int j0) { return mau_action_instruction_adr_miss_value_[j0]; }











  MauActiondataAdrTcamShiftcountMutable &mau_actiondata_adr_tcam_shiftcount(int j0) { return mau_actiondata_adr_tcam_shiftcount_[j0]; }








  MauActiondataAdrMissValueMutable &mau_actiondata_adr_miss_value(int j0) { return mau_actiondata_adr_miss_value_[j0]; }














  MauStatsAdrTcamShiftcountMutable &mau_stats_adr_tcam_shiftcount(int j0) { return mau_stats_adr_tcam_shiftcount_[j0]; }








  MauStatsAdrMissValueMutable &mau_stats_adr_miss_value(int j0) { return mau_stats_adr_miss_value_[j0]; }















  MauMeterAdrTcamShiftcountMutable &mau_meter_adr_tcam_shiftcount(int j0) { return mau_meter_adr_tcam_shiftcount_[j0]; }








  MauMeterAdrMissValueMutable &mau_meter_adr_miss_value(int j0) { return mau_meter_adr_miss_value_[j0]; }














  MauIdletimeAdrTcamShiftcountMutable &mau_idletime_adr_tcam_shiftcount(int j0) { return mau_idletime_adr_tcam_shiftcount_[j0]; }








  MauIdletimeAdrMissValueMutable &mau_idletime_adr_miss_value(int j0) { return mau_idletime_adr_miss_value_[j0]; }





















  MauHashGroupXbarCtlMutable &mau_hash_group_xbar_ctl(int j1,int j0) { return mau_hash_group_xbar_ctl_[j1][j0]; }






















  StashHitmapOutputMapMutable &stash_hitmap_output_map(int j1,int j0) { return stash_hitmap_output_map_[j1][j0]; }













  StashNextTableLutMutable &stash_next_table_lut(int j1,int j0) { return stash_next_table_lut_[j1][j0]; }













  StashRowNxtableBusDriveMutable &stash_row_nxtable_bus_drive(int j1,int j0) { return stash_row_nxtable_bus_drive_[j1][j0]; }

















  GatewayToLogicaltableXbarCtlMutable &gateway_to_logicaltable_xbar_ctl(int j0) { return gateway_to_logicaltable_xbar_ctl_[j0]; }













  GatewayInhibitLutMutable &gateway_inhibit_lut(int j0) { return gateway_inhibit_lut_[j0]; }














  GatewayToPbusXbarCtlMutable &gateway_to_pbus_xbar_ctl(int j0) { return gateway_to_pbus_xbar_ctl_[j0]; }








  TindBusPropMutable &tind_bus_prop(int j0) { return tind_bus_prop_[j0]; }







  MauSnapshotPhysicalTcamHitAddressMutable &mau_snapshot_physical_tcam_hit_address(int j0) { return mau_snapshot_physical_tcam_hit_address_[j0]; }







  MauSnapshotPhysicalExactMatchHitAddressMutable &mau_snapshot_physical_exact_match_hit_address(int j0) { return mau_snapshot_physical_exact_match_hit_address_[j0]; }








  MauTableCounterMutable &mau_table_counter(int j1,int j0) { return mau_table_counter_[j1][j0]; }












  TcamHitToLogicalTableIxbarOutputmapMutable &tcam_hit_to_logical_table_ixbar_outputmap(int j0) { return tcam_hit_to_logical_table_ixbar_outputmap_[j0]; }









  MauHashGroupMaskMutable &mau_hash_group_mask(int j0) { return mau_hash_group_mask_[j0]; }





















  GatewayPayloadTindPbusMutable &gateway_payload_tind_pbus(int j0) { return gateway_payload_tind_pbus_[j0]; }





















  GatewayPayloadExactPbusMutable &gateway_payload_exact_pbus(int j0) { return gateway_payload_exact_pbus_[j0]; }








  TcamTablePropMutable &tcam_table_prop(int j0) { return tcam_table_prop_[j0]; }










  ExactMatchDelayThreadMutable &exact_match_delay_thread(int j0) { return exact_match_delay_thread_[j0]; }










  LogicalTableThreadMutable &logical_table_thread(int j0) { return logical_table_thread_[j0]; }














  MauPhysicalToMeterAluIxbarMapMutable &mau_physical_to_meter_alu_ixbar_map(int j1,int j0) { return mau_physical_to_meter_alu_ixbar_map_[j1][j0]; }










  MauMeterPrecolorHashMapToLogicalCtlMutable &mau_meter_precolor_hash_map_to_logical_ctl(int j0) { return mau_meter_precolor_hash_map_to_logical_ctl_[j0]; }






















  MauSelectorActionEntrySizeMutable &mau_selector_action_entry_size(int j0) { return mau_selector_action_entry_size_[j0]; }








  MauStatefulLogCounterMutable &mau_stateful_log_counter(int j1,int j0) { return mau_stateful_log_counter_[j1][j0]; }













  MauStatefulLogCtlIxbarMapMutable &mau_stateful_log_ctl_ixbar_map(int j1,int j0) { return mau_stateful_log_ctl_ixbar_map_[j1][j0]; }








  MeterAluThreadMutable &meter_alu_thread(int j0) { return meter_alu_thread_[j0]; }









  ExactMatchPhysResultDelayMutable &exact_match_phys_result_delay(int j0) { return exact_match_phys_result_delay_[j0]; }









  ExactMatchPhysResultEnMutable &exact_match_phys_result_en(int j0) { return exact_match_phys_result_en_[j0]; }









  ExactMatchPhysResultThreadMutable &exact_match_phys_result_thread(int j0) { return exact_match_phys_result_thread_[j0]; }














  MauActionInstructionAdrMapEnMutable &mau_action_instruction_adr_map_en(int j0) { return mau_action_instruction_adr_map_en_[j0]; }






















  MauMapramColorMapToLogicalCtlMutable &mau_mapram_color_map_to_logical_ctl(int j0) { return mau_mapram_color_map_to_logical_ctl_[j0]; }









  MauHashGroupExpandMutable &mau_hash_group_expand(int j0) { return mau_hash_group_expand_[j0]; }










  MauMeterAluToLogicalMapMutable &mau_meter_alu_to_logical_map(int j0) { return mau_meter_alu_to_logical_map_[j0]; }














  PredicationCtlMutable &predication_ctl(int j0) { return predication_ctl_[j0]; }








  MauSnapshotNextTableOutMutable &mau_snapshot_next_table_out(int j0) { return mau_snapshot_next_table_out_[j0]; }








  MauSnapshotCaptureDatapathErrorMutable &mau_snapshot_capture_datapath_error(int j0) { return mau_snapshot_capture_datapath_error_[j0]; }

















  MauTableCounterCtlMutable &mau_table_counter_ctl(int j0) { return mau_table_counter_ctl_[j0]; }


















  MauStatefulLogCounterCtlMutable &mau_stateful_log_counter_ctl(int j0) { return mau_stateful_log_counter_ctl_[j0]; }








  MauStatefulLogVpnLimitMutable &mau_stateful_log_vpn_limit(int j0) { return mau_stateful_log_vpn_limit_[j0]; }











  MauImmediateDataExactShiftcountMutable &mau_immediate_data_exact_shiftcount(int j1,int j0) { return mau_immediate_data_exact_shiftcount_[j1][j0]; }











  MauActionInstructionAdrExactShiftcountMutable &mau_action_instruction_adr_exact_shiftcount(int j1,int j0) { return mau_action_instruction_adr_exact_shiftcount_[j1][j0]; }












  MauActiondataAdrExactShiftcountMutable &mau_actiondata_adr_exact_shiftcount(int j1,int j0) { return mau_actiondata_adr_exact_shiftcount_[j1][j0]; }















  MauStatsAdrExactShiftcountMutable &mau_stats_adr_exact_shiftcount(int j1,int j0) { return mau_stats_adr_exact_shiftcount_[j1][j0]; }
















  MauMeterAdrExactShiftcountMutable &mau_meter_adr_exact_shiftcount(int j1,int j0) { return mau_meter_adr_exact_shiftcount_[j1][j0]; }















  MauIdletimeAdrExactShiftcountMutable &mau_idletime_adr_exact_shiftcount(int j1,int j0) { return mau_idletime_adr_exact_shiftcount_[j1][j0]; }












  GatewayNextTableLutMutable &gateway_next_table_lut(int j1,int j0) { return gateway_next_table_lut_[j1][j0]; }









  MauStatefulLogVpnOffsetMutable &mau_stateful_log_vpn_offset(int j0) { return mau_stateful_log_vpn_offset_[j0]; }








  TcamMatchErrorCtlMutable &tcam_match_error_ctl(int j0) { return tcam_match_error_ctl_[j0]; }








  TindEccErrorCtlMutable &tind_ecc_error_ctl(int j0) { return tind_ecc_error_ctl_[j0]; }








  GfmParityErrorCtlMutable &gfm_parity_error_ctl(int j0) { return gfm_parity_error_ctl_[j0]; }








  EmmEccErrorCtlMutable &emm_ecc_error_ctl(int j0) { return emm_ecc_error_ctl_[j0]; }








  PrevErrorCtlMutable &prev_error_ctl(int j0) { return prev_error_ctl_[j0]; }








  ErrIdataOvrFifoCtlMutable &err_idata_ovr_fifo_ctl(int j0) { return err_idata_ovr_fifo_ctl_[j0]; }








  ErrIdataOvrCtlMutable &err_idata_ovr_ctl(int j0) { return err_idata_ovr_ctl_[j0]; }








  OErrorFifoCtlMutable &o_error_fifo_ctl(int j0) { return o_error_fifo_ctl_[j0]; }








  S2pStatsErrorCtlMutable &s2p_stats_error_ctl(int j0) { return s2p_stats_error_ctl_[j0]; }








  S2pMeterErrorCtlMutable &s2p_meter_error_ctl(int j0) { return s2p_meter_error_ctl_[j0]; }








  ExactMatchLogicalResultDelayMutable &exact_match_logical_result_delay() { return exact_match_logical_result_delay_; }






  ExactMatchLogicalResultEnMutable &exact_match_logical_result_en() { return exact_match_logical_result_en_; }









  NextTableMapEnMutable &next_table_map_en() { return next_table_map_en_; }












  NextTableTcamActionbitMapEnMutable &next_table_tcam_actionbit_map_en() { return next_table_tcam_actionbit_map_en_; }









  MauImmediateDataTcamActionbitMapEnMutable &mau_immediate_data_tcam_actionbit_map_en() { return mau_immediate_data_tcam_actionbit_map_en_; }












  MauActionInstructionAdrTcamActionbitMapEnMutable &mau_action_instruction_adr_tcam_actionbit_map_en() { return mau_action_instruction_adr_tcam_actionbit_map_en_; }









  MauActiondataAdrTcamActionbitMapEnMutable &mau_actiondata_adr_tcam_actionbit_map_en() { return mau_actiondata_adr_tcam_actionbit_map_en_; }









  MauStatsAdrTcamActionbitMapEnMutable &mau_stats_adr_tcam_actionbit_map_en() { return mau_stats_adr_tcam_actionbit_map_en_; }









  MauMeterAdrTcamActionbitMapEnMutable &mau_meter_adr_tcam_actionbit_map_en() { return mau_meter_adr_tcam_actionbit_map_en_; }








  MauMatchCentralMapramReadColorOfloCtlMutable &mau_match_central_mapram_read_color_oflo_ctl() { return mau_match_central_mapram_read_color_oflo_ctl_; }



























  MatchToLogicalTableIxbarOutputmapMutable &match_to_logical_table_ixbar_outputmap(int j1,int j0) { return match_to_logical_table_ixbar_outputmap_[j1][j0]; }



















  MauActionInstructionAdrMapDataMutable &mau_action_instruction_adr_map_data(int j2,int j1,int j0) { return mau_action_instruction_adr_map_data_[j2][j1][j0]; }













  GatewayPayloadDataMutable &gateway_payload_data(int j3,int j2,int j1,int j0) { return gateway_payload_data_[j3][j2][j1][j0]; }









  MauIdletimeAdrTcamActionbitMapEnMutable &mau_idletime_adr_tcam_actionbit_map_en() { return mau_idletime_adr_tcam_actionbit_map_en_; }






  MauSelectorHashSpsEnableMutable &mau_selector_hash_sps_enable() { return mau_selector_hash_sps_enable_; }






  MauHashGroupConfigMutable &mau_hash_group_config() { return mau_hash_group_config_; }










  MauHashGroupShiftcountMutable &mau_hash_group_shiftcount() { return mau_hash_group_shiftcount_; }








  MauLogicalToMeterAluMapMutable &mau_logical_to_meter_alu_map() { return mau_logical_to_meter_alu_map_; }












  MauMeterPrecolorHashSelMutable &mau_meter_precolor_hash_sel() { return mau_meter_precolor_hash_sel_; }






  GatewayEnMutable &gateway_en() { return gateway_en_; }





  MauSnapshotLogicalTableHitMutable &mau_snapshot_logical_table_hit() { return mau_snapshot_logical_table_hit_; }





  MauSnapshotGatewayTableInhibitLogicalMutable &mau_snapshot_gateway_table_inhibit_logical() { return mau_snapshot_gateway_table_inhibit_logical_; }






  MauSnapshotTableActiveMutable &mau_snapshot_table_active() { return mau_snapshot_table_active_; }







  MauTableCounterClearMutable &mau_table_counter_clear() { return mau_table_counter_clear_; }







  MauStatefulLogCounterClearMutable &mau_stateful_log_counter_clear() { return mau_stateful_log_counter_clear_; }






  MauStatefulLogVpnHoleEnMutable &mau_stateful_log_vpn_hole_en() { return mau_stateful_log_vpn_hole_en_; }











  MauStatefulLogInstructionWidthMutable &mau_stateful_log_instruction_width() { return mau_stateful_log_instruction_width_; }






  ActiondataErrorCtlMutable &actiondata_error_ctl() { return actiondata_error_ctl_; }






  ImemParityErrorCtlMutable &imem_parity_error_ctl() { return imem_parity_error_ctl_; }














  NextTableMapDataMutable &next_table_map_data(int j1,int j0) { return next_table_map_data_[j1][j0]; }


























  MauPayloadShifterEnableMutable &mau_payload_shifter_enable(int j1,int j0) { return mau_payload_shifter_enable_[j1][j0]; }











  MauImmediateDataMaskMutable &mau_immediate_data_mask(int j1,int j0) { return mau_immediate_data_mask_[j1][j0]; }











  MauImmediateDataDefaultMutable &mau_immediate_data_default(int j1,int j0) { return mau_immediate_data_default_[j1][j0]; }









  MauImmediateDataTcamActionbitMapDataMutable &mau_immediate_data_tcam_actionbit_map_data(int j1,int j0) { return mau_immediate_data_tcam_actionbit_map_data_[j1][j0]; }











  MauActionInstructionAdrMaskMutable &mau_action_instruction_adr_mask(int j1,int j0) { return mau_action_instruction_adr_mask_[j1][j0]; }











  MauActionInstructionAdrDefaultMutable &mau_action_instruction_adr_default(int j1,int j0) { return mau_action_instruction_adr_default_[j1][j0]; }





















  MauActionInstructionAdrPerEntryEnMuxCtlMutable &mau_action_instruction_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_action_instruction_adr_per_entry_en_mux_ctl_[j1][j0]; }












  MauActiondataAdrVpnShiftcountMutable &mau_actiondata_adr_vpn_shiftcount(int j1,int j0) { return mau_actiondata_adr_vpn_shiftcount_[j1][j0]; }











  MauActiondataAdrMaskMutable &mau_actiondata_adr_mask(int j1,int j0) { return mau_actiondata_adr_mask_[j1][j0]; }











  MauActiondataAdrDefaultMutable &mau_actiondata_adr_default(int j1,int j0) { return mau_actiondata_adr_default_[j1][j0]; }





















  MauActiondataAdrPerEntryEnMuxCtlMutable &mau_actiondata_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_actiondata_adr_per_entry_en_mux_ctl_[j1][j0]; }









  MauActiondataAdrTcamActionbitMapDataMutable &mau_actiondata_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_actiondata_adr_tcam_actionbit_map_data_[j1][j0]; }











  MauStatsAdrMaskMutable &mau_stats_adr_mask(int j1,int j0) { return mau_stats_adr_mask_[j1][j0]; }











  MauStatsAdrDefaultMutable &mau_stats_adr_default(int j1,int j0) { return mau_stats_adr_default_[j1][j0]; }





















  MauStatsAdrPerEntryEnMuxCtlMutable &mau_stats_adr_per_entry_en_mux_ctl(int j1,int j0) { return mau_stats_adr_per_entry_en_mux_ctl_[j1][j0]; }





























  MauStatsAdrHoleSwizzleModeMutable &mau_stats_adr_hole_swizzle_mode(int j1,int j0) { return mau_stats_adr_hole_swizzle_mode_[j1][j0]; }









  MauStatsAdrTcamActionbitMapDataMutable &mau_stats_adr_tcam_actionbit_map_data(int j1,int j0) { return mau_stats_adr_tcam_actionbit_map_data_[j1][j0]; }











  MauMeterAdrMaskMutable &mau_meter_adr_mask(int j1,int j0) { return mau_meter_adr_mask_[j1][j0]; }







  MauMatchMergeColAddrmapMutable &col(int j0) { return col_[j0]; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset < 0x80) {
      offset -= 0x0;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x80 && offset < 0x100) {
      offset -= 0x80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x100 && offset < 0x180) {
      offset -= 0x100;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selectorlength_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selectorlength_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selectorlength_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_type_position_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_match_adr_[ i2 ][ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x600 && offset < 0x640) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_match_adr_to_physical_oxbar_outputmap_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x640 && offset < 0x680) {
      offset -= 0x640;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tind_ram_data_size_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x680 && offset < 0x6c0) {
      offset -= 0x680;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      next_table_format_data_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x6c0 && offset < 0x700) {
      offset -= 0x6c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x700 && offset < 0x740) {
      offset -= 0x700;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x740 && offset < 0x780) {
      offset -= 0x740;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x780 && offset < 0x7c0) {
      offset -= 0x780;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x7c0 && offset < 0x800) {
      offset -= 0x7c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1000 && offset < 0x1040) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1040 && offset < 0x1080) {
      offset -= 0x1040;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1080 && offset < 0x10c0) {
      offset -= 0x1080;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x10c0 && offset < 0x1100) {
      offset -= 0x10c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1100 && offset < 0x1140) {
      offset -= 0x1100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1140 && offset < 0x1180) {
      offset -= 0x1140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_tcam_shiftcount_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1180 && offset < 0x11c0) {
      offset -= 0x1180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_miss_value_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x11c0 && offset < 0x11f0) {
      offset -= 0x11c0;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_hash_group_xbar_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1200 && offset < 0x1240) {
      offset -= 0x1200;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      stash_hitmap_output_map_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1240 && offset < 0x1280) {
      offset -= 0x1240;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      stash_next_table_lut_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1280 && offset < 0x12c0) {
      offset -= 0x1280;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      stash_row_nxtable_bus_drive_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x12c0 && offset < 0x1300) {
      offset -= 0x12c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_to_logicaltable_xbar_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1300 && offset < 0x1340) {
      offset -= 0x1300;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_inhibit_lut_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1340 && offset < 0x1380) {
      offset -= 0x1340;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_to_pbus_xbar_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1380 && offset < 0x13c0) {
      offset -= 0x1380;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tind_bus_prop_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x13c0 && offset < 0x1400) {
      offset -= 0x13c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_physical_tcam_hit_address_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2000 && offset < 0x2040) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_physical_exact_match_hit_address_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2040 && offset < 0x2080) {
      offset -= 0x2040;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_table_counter_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2080 && offset < 0x20a0) {
      offset -= 0x2080;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_hit_to_logical_table_ixbar_outputmap_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x20a0 && offset < 0x20b8) {
      offset -= 0x20a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_hash_group_mask_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x20c0 && offset < 0x20e0) {
      offset -= 0x20c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_tind_pbus_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x20e0 && offset < 0x2100) {
      offset -= 0x20e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_exact_pbus_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2100 && offset < 0x2120) {
      offset -= 0x2100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_table_prop_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2120 && offset < 0x212c) {
      offset -= 0x2120;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_delay_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2130 && offset < 0x213c) {
      offset -= 0x2130;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      logical_table_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2140 && offset < 0x2150) {
      offset -= 0x2140;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_physical_to_meter_alu_ixbar_map_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2150 && offset < 0x2160) {
      offset -= 0x2150;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_precolor_hash_map_to_logical_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2160 && offset < 0x2170) {
      offset -= 0x2160;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_selector_action_entry_size_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2170 && offset < 0x2180) {
      offset -= 0x2170;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2180 && offset < 0x2190) {
      offset -= 0x2180;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_ctl_ixbar_map_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2190 && offset < 0x2198) {
      offset -= 0x2190;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      meter_alu_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2198 && offset < 0x21a0) {
      offset -= 0x2198;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_phys_result_delay_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21a0 && offset < 0x21a8) {
      offset -= 0x21a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_phys_result_en_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21a8 && offset < 0x21b0) {
      offset -= 0x21a8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      exact_match_phys_result_thread_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21b0 && offset < 0x21b8) {
      offset -= 0x21b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_map_en_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21b8 && offset < 0x21c0) {
      offset -= 0x21b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_mapram_color_map_to_logical_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21c0 && offset < 0x21c8) {
      offset -= 0x21c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_hash_group_expand_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21c8 && offset < 0x21d0) {
      offset -= 0x21c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_alu_to_logical_map_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21d0 && offset < 0x21d8) {
      offset -= 0x21d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      predication_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21d8 && offset < 0x21e0) {
      offset -= 0x21d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_next_table_out_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21e0 && offset < 0x21e8) {
      offset -= 0x21e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_snapshot_capture_datapath_error_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21e8 && offset < 0x21f0) {
      offset -= 0x21e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_table_counter_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21f0 && offset < 0x21f8) {
      offset -= 0x21f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x21f8 && offset < 0x2200) {
      offset -= 0x21f8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_vpn_limit_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2400 && offset < 0x2600) {
      offset -= 0x2400;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2600 && offset < 0x2800) {
      offset -= 0x2600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2800 && offset < 0x2a00) {
      offset -= 0x2800;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2a00 && offset < 0x2c00) {
      offset -= 0x2a00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2c00 && offset < 0x2e00) {
      offset -= 0x2c00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x2e00 && offset < 0x3000) {
      offset -= 0x2e00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_idletime_adr_exact_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3000 && offset < 0x3200) {
      offset -= 0x3000;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_next_table_lut_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3200 && offset < 0x3208) {
      offset -= 0x3200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stateful_log_vpn_offset_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3208 && offset < 0x3210) {
      offset -= 0x3208;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tcam_match_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3210 && offset < 0x3218) {
      offset -= 0x3210;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tind_ecc_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3218 && offset < 0x3220) {
      offset -= 0x3218;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gfm_parity_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3220 && offset < 0x3228) {
      offset -= 0x3220;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      emm_ecc_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3228 && offset < 0x3230) {
      offset -= 0x3228;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      prev_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3230 && offset < 0x3238) {
      offset -= 0x3230;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      err_idata_ovr_fifo_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3238 && offset < 0x3240) {
      offset -= 0x3238;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      err_idata_ovr_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3240 && offset < 0x3248) {
      offset -= 0x3240;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      o_error_fifo_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3248 && offset < 0x3250) {
      offset -= 0x3248;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      s2p_stats_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3250 && offset < 0x3258) {
      offset -= 0x3250;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      s2p_meter_error_ctl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3258 && offset < 0x325c) {
      offset -= 0x3258;
      if (read_callback_) read_callback_();
      exact_match_logical_result_delay_.read( offset, data );
    }
    else if (offset >= 0x325c && offset < 0x3260) {
      offset -= 0x325c;
      if (read_callback_) read_callback_();
      exact_match_logical_result_en_.read( offset, data );
    }
    else if (offset >= 0x3260 && offset < 0x3264) {
      offset -= 0x3260;
      if (read_callback_) read_callback_();
      next_table_map_en_.read( offset, data );
    }
    else if (offset >= 0x3264 && offset < 0x3268) {
      offset -= 0x3264;
      if (read_callback_) read_callback_();
      next_table_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x3268 && offset < 0x326c) {
      offset -= 0x3268;
      if (read_callback_) read_callback_();
      mau_immediate_data_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x326c && offset < 0x3270) {
      offset -= 0x326c;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x3270 && offset < 0x3274) {
      offset -= 0x3270;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x3274 && offset < 0x3278) {
      offset -= 0x3274;
      if (read_callback_) read_callback_();
      mau_stats_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x3278 && offset < 0x327c) {
      offset -= 0x3278;
      if (read_callback_) read_callback_();
      mau_meter_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x327c && offset < 0x3280) {
      offset -= 0x327c;
      if (read_callback_) read_callback_();
      mau_match_central_mapram_read_color_oflo_ctl_.read( offset, data );
    }
    else if (offset >= 0x3300 && offset < 0x3400) {
      offset -= 0x3300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      match_to_logical_table_ixbar_outputmap_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3400 && offset < 0x3500) {
      offset -= 0x3400;
      int i2 = offset / 0x80;
      offset  -= i2 * 0x80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_map_data_[ i2 ][ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3500 && offset < 0x3600) {
      offset -= 0x3500;
      int i3 = offset / 0x20;
      offset  -= i3 * 0x20;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      gateway_payload_data_[ i3 ][ i2 ][ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3600 && offset < 0x3604) {
      offset -= 0x3600;
      if (read_callback_) read_callback_();
      mau_idletime_adr_tcam_actionbit_map_en_.read( offset, data );
    }
    else if (offset >= 0x3604 && offset < 0x3608) {
      offset -= 0x3604;
      if (read_callback_) read_callback_();
      mau_selector_hash_sps_enable_.read( offset, data );
    }
    else if (offset >= 0x3608 && offset < 0x360c) {
      offset -= 0x3608;
      if (read_callback_) read_callback_();
      mau_hash_group_config_.read( offset, data );
    }
    else if (offset >= 0x360c && offset < 0x3610) {
      offset -= 0x360c;
      if (read_callback_) read_callback_();
      mau_hash_group_shiftcount_.read( offset, data );
    }
    else if (offset >= 0x3610 && offset < 0x3614) {
      offset -= 0x3610;
      if (read_callback_) read_callback_();
      mau_logical_to_meter_alu_map_.read( offset, data );
    }
    else if (offset >= 0x3614 && offset < 0x3618) {
      offset -= 0x3614;
      if (read_callback_) read_callback_();
      mau_meter_precolor_hash_sel_.read( offset, data );
    }
    else if (offset >= 0x3618 && offset < 0x361c) {
      offset -= 0x3618;
      if (read_callback_) read_callback_();
      gateway_en_.read( offset, data );
    }
    else if (offset >= 0x361c && offset < 0x3620) {
      offset -= 0x361c;
      if (read_callback_) read_callback_();
      mau_snapshot_logical_table_hit_.read( offset, data );
    }
    else if (offset >= 0x3620 && offset < 0x3624) {
      offset -= 0x3620;
      if (read_callback_) read_callback_();
      mau_snapshot_gateway_table_inhibit_logical_.read( offset, data );
    }
    else if (offset >= 0x3624 && offset < 0x3628) {
      offset -= 0x3624;
      if (read_callback_) read_callback_();
      mau_snapshot_table_active_.read( offset, data );
    }
    else if (offset >= 0x3628 && offset < 0x362c) {
      offset -= 0x3628;
      if (read_callback_) read_callback_();
      mau_table_counter_clear_.read( offset, data );
    }
    else if (offset >= 0x362c && offset < 0x3630) {
      offset -= 0x362c;
      if (read_callback_) read_callback_();
      mau_stateful_log_counter_clear_.read( offset, data );
    }
    else if (offset >= 0x3630 && offset < 0x3634) {
      offset -= 0x3630;
      if (read_callback_) read_callback_();
      mau_stateful_log_vpn_hole_en_.read( offset, data );
    }
    else if (offset >= 0x3634 && offset < 0x3638) {
      offset -= 0x3634;
      if (read_callback_) read_callback_();
      mau_stateful_log_instruction_width_.read( offset, data );
    }
    else if (offset >= 0x3638 && offset < 0x363c) {
      offset -= 0x3638;
      if (read_callback_) read_callback_();
      actiondata_error_ctl_.read( offset, data );
    }
    else if (offset >= 0x363c && offset < 0x3640) {
      offset -= 0x363c;
      if (read_callback_) read_callback_();
      imem_parity_error_ctl_.read( offset, data );
    }
    else if (offset >= 0x3680 && offset < 0x3700) {
      offset -= 0x3680;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      next_table_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3700 && offset < 0x3780) {
      offset -= 0x3700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_payload_shifter_enable_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3780 && offset < 0x3800) {
      offset -= 0x3780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3800 && offset < 0x3880) {
      offset -= 0x3800;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3880 && offset < 0x3900) {
      offset -= 0x3880;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_immediate_data_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3900 && offset < 0x3980) {
      offset -= 0x3900;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3980 && offset < 0x3a00) {
      offset -= 0x3980;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3a00 && offset < 0x3a80) {
      offset -= 0x3a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_action_instruction_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3a80 && offset < 0x3b00) {
      offset -= 0x3a80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_vpn_shiftcount_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3b00 && offset < 0x3b80) {
      offset -= 0x3b00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3b80 && offset < 0x3c00) {
      offset -= 0x3b80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3c00 && offset < 0x3c80) {
      offset -= 0x3c00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3c80 && offset < 0x3d00) {
      offset -= 0x3c80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_actiondata_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3d00 && offset < 0x3d80) {
      offset -= 0x3d00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3d80 && offset < 0x3e00) {
      offset -= 0x3d80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_default_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3e00 && offset < 0x3e80) {
      offset -= 0x3e00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3e80 && offset < 0x3f00) {
      offset -= 0x3e80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_hole_swizzle_mode_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3f00 && offset < 0x3f80) {
      offset -= 0x3f00;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_stats_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x3f80 && offset < 0x4000) {
      offset -= 0x3f80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_meter_adr_mask_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x1800 && offset < 0x1e00) {
      offset -= 0x1800;
      int i0 = offset / 0x80;
      offset  -= i0 * 0x80;
      if (read_callback_) read_callback_();
      col_[ i0 ].read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset < 0x80) {
      offset -= 0x0;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0x100) {
      offset -= 0x80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100 && offset < 0x180) {
      offset -= 0x100;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selectorlength_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selectorlength_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selectorlength_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_type_position_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_match_adr_[ i2 ][ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x640) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_match_adr_to_physical_oxbar_outputmap_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x640 && offset < 0x680) {
      offset -= 0x640;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tind_ram_data_size_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x680 && offset < 0x6c0) {
      offset -= 0x680;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      next_table_format_data_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6c0 && offset < 0x700) {
      offset -= 0x6c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x700 && offset < 0x740) {
      offset -= 0x700;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x740 && offset < 0x780) {
      offset -= 0x740;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x780 && offset < 0x7c0) {
      offset -= 0x780;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7c0 && offset < 0x800) {
      offset -= 0x7c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1040) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1040 && offset < 0x1080) {
      offset -= 0x1040;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1080 && offset < 0x10c0) {
      offset -= 0x1080;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10c0 && offset < 0x1100) {
      offset -= 0x10c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1100 && offset < 0x1140) {
      offset -= 0x1100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1140 && offset < 0x1180) {
      offset -= 0x1140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_tcam_shiftcount_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1180 && offset < 0x11c0) {
      offset -= 0x1180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_miss_value_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x11c0 && offset < 0x11f0) {
      offset -= 0x11c0;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_hash_group_xbar_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1200 && offset < 0x1240) {
      offset -= 0x1200;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      stash_hitmap_output_map_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1240 && offset < 0x1280) {
      offset -= 0x1240;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      stash_next_table_lut_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1280 && offset < 0x12c0) {
      offset -= 0x1280;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      stash_row_nxtable_bus_drive_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x12c0 && offset < 0x1300) {
      offset -= 0x12c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_to_logicaltable_xbar_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1300 && offset < 0x1340) {
      offset -= 0x1300;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_inhibit_lut_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1340 && offset < 0x1380) {
      offset -= 0x1340;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_to_pbus_xbar_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1380 && offset < 0x13c0) {
      offset -= 0x1380;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tind_bus_prop_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x13c0 && offset < 0x1400) {
      offset -= 0x13c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_physical_tcam_hit_address_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2040) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_physical_exact_match_hit_address_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2040 && offset < 0x2080) {
      offset -= 0x2040;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_table_counter_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2080 && offset < 0x20a0) {
      offset -= 0x2080;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_hit_to_logical_table_ixbar_outputmap_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20a0 && offset < 0x20b8) {
      offset -= 0x20a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_hash_group_mask_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20c0 && offset < 0x20e0) {
      offset -= 0x20c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_tind_pbus_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20e0 && offset < 0x2100) {
      offset -= 0x20e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_exact_pbus_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2100 && offset < 0x2120) {
      offset -= 0x2100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_table_prop_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2120 && offset < 0x212c) {
      offset -= 0x2120;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_delay_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2130 && offset < 0x213c) {
      offset -= 0x2130;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      logical_table_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2140 && offset < 0x2150) {
      offset -= 0x2140;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_physical_to_meter_alu_ixbar_map_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2150 && offset < 0x2160) {
      offset -= 0x2150;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_precolor_hash_map_to_logical_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2160 && offset < 0x2170) {
      offset -= 0x2160;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_selector_action_entry_size_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2170 && offset < 0x2180) {
      offset -= 0x2170;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_counter_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2180 && offset < 0x2190) {
      offset -= 0x2180;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_ctl_ixbar_map_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2190 && offset < 0x2198) {
      offset -= 0x2190;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      meter_alu_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2198 && offset < 0x21a0) {
      offset -= 0x2198;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_phys_result_delay_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21a0 && offset < 0x21a8) {
      offset -= 0x21a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_phys_result_en_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21a8 && offset < 0x21b0) {
      offset -= 0x21a8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      exact_match_phys_result_thread_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21b0 && offset < 0x21b8) {
      offset -= 0x21b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_map_en_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21b8 && offset < 0x21c0) {
      offset -= 0x21b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_mapram_color_map_to_logical_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21c0 && offset < 0x21c8) {
      offset -= 0x21c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_hash_group_expand_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21c8 && offset < 0x21d0) {
      offset -= 0x21c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_alu_to_logical_map_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21d0 && offset < 0x21d8) {
      offset -= 0x21d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      predication_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21d8 && offset < 0x21e0) {
      offset -= 0x21d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_next_table_out_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21e0 && offset < 0x21e8) {
      offset -= 0x21e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_snapshot_capture_datapath_error_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21e8 && offset < 0x21f0) {
      offset -= 0x21e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_table_counter_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21f0 && offset < 0x21f8) {
      offset -= 0x21f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_counter_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x21f8 && offset < 0x2200) {
      offset -= 0x21f8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_vpn_limit_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2400 && offset < 0x2600) {
      offset -= 0x2400;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2600 && offset < 0x2800) {
      offset -= 0x2600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2800 && offset < 0x2a00) {
      offset -= 0x2800;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2a00 && offset < 0x2c00) {
      offset -= 0x2a00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c00 && offset < 0x2e00) {
      offset -= 0x2c00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2e00 && offset < 0x3000) {
      offset -= 0x2e00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_idletime_adr_exact_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3200) {
      offset -= 0x3000;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_next_table_lut_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3200 && offset < 0x3208) {
      offset -= 0x3200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stateful_log_vpn_offset_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3208 && offset < 0x3210) {
      offset -= 0x3208;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tcam_match_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3210 && offset < 0x3218) {
      offset -= 0x3210;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tind_ecc_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3218 && offset < 0x3220) {
      offset -= 0x3218;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gfm_parity_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3220 && offset < 0x3228) {
      offset -= 0x3220;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      emm_ecc_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3228 && offset < 0x3230) {
      offset -= 0x3228;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      prev_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3230 && offset < 0x3238) {
      offset -= 0x3230;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      err_idata_ovr_fifo_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3238 && offset < 0x3240) {
      offset -= 0x3238;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      err_idata_ovr_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3240 && offset < 0x3248) {
      offset -= 0x3240;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      o_error_fifo_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3248 && offset < 0x3250) {
      offset -= 0x3248;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      s2p_stats_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3250 && offset < 0x3258) {
      offset -= 0x3250;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      s2p_meter_error_ctl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3258 && offset < 0x325c) {
      offset -= 0x3258;
      exact_match_logical_result_delay_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x325c && offset < 0x3260) {
      offset -= 0x325c;
      exact_match_logical_result_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3260 && offset < 0x3264) {
      offset -= 0x3260;
      next_table_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3264 && offset < 0x3268) {
      offset -= 0x3264;
      next_table_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3268 && offset < 0x326c) {
      offset -= 0x3268;
      mau_immediate_data_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x326c && offset < 0x3270) {
      offset -= 0x326c;
      mau_action_instruction_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3270 && offset < 0x3274) {
      offset -= 0x3270;
      mau_actiondata_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3274 && offset < 0x3278) {
      offset -= 0x3274;
      mau_stats_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3278 && offset < 0x327c) {
      offset -= 0x3278;
      mau_meter_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x327c && offset < 0x3280) {
      offset -= 0x327c;
      mau_match_central_mapram_read_color_oflo_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3300 && offset < 0x3400) {
      offset -= 0x3300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      match_to_logical_table_ixbar_outputmap_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3400 && offset < 0x3500) {
      offset -= 0x3400;
      int i2 = offset / 0x80;
      offset  -= i2 * 0x80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_map_data_[ i2 ][ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3500 && offset < 0x3600) {
      offset -= 0x3500;
      int i3 = offset / 0x20;
      offset  -= i3 * 0x20;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      gateway_payload_data_[ i3 ][ i2 ][ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3600 && offset < 0x3604) {
      offset -= 0x3600;
      mau_idletime_adr_tcam_actionbit_map_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3604 && offset < 0x3608) {
      offset -= 0x3604;
      mau_selector_hash_sps_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3608 && offset < 0x360c) {
      offset -= 0x3608;
      mau_hash_group_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x360c && offset < 0x3610) {
      offset -= 0x360c;
      mau_hash_group_shiftcount_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3610 && offset < 0x3614) {
      offset -= 0x3610;
      mau_logical_to_meter_alu_map_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3614 && offset < 0x3618) {
      offset -= 0x3614;
      mau_meter_precolor_hash_sel_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3618 && offset < 0x361c) {
      offset -= 0x3618;
      gateway_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x361c && offset < 0x3620) {
      offset -= 0x361c;
      mau_snapshot_logical_table_hit_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3620 && offset < 0x3624) {
      offset -= 0x3620;
      mau_snapshot_gateway_table_inhibit_logical_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3624 && offset < 0x3628) {
      offset -= 0x3624;
      mau_snapshot_table_active_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3628 && offset < 0x362c) {
      offset -= 0x3628;
      mau_table_counter_clear_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x362c && offset < 0x3630) {
      offset -= 0x362c;
      mau_stateful_log_counter_clear_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3630 && offset < 0x3634) {
      offset -= 0x3630;
      mau_stateful_log_vpn_hole_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3634 && offset < 0x3638) {
      offset -= 0x3634;
      mau_stateful_log_instruction_width_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3638 && offset < 0x363c) {
      offset -= 0x3638;
      actiondata_error_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x363c && offset < 0x3640) {
      offset -= 0x363c;
      imem_parity_error_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3680 && offset < 0x3700) {
      offset -= 0x3680;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      next_table_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3700 && offset < 0x3780) {
      offset -= 0x3700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_payload_shifter_enable_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3780 && offset < 0x3800) {
      offset -= 0x3780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3800 && offset < 0x3880) {
      offset -= 0x3800;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3880 && offset < 0x3900) {
      offset -= 0x3880;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_immediate_data_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3900 && offset < 0x3980) {
      offset -= 0x3900;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3980 && offset < 0x3a00) {
      offset -= 0x3980;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3a00 && offset < 0x3a80) {
      offset -= 0x3a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_action_instruction_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3a80 && offset < 0x3b00) {
      offset -= 0x3a80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_vpn_shiftcount_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3b00 && offset < 0x3b80) {
      offset -= 0x3b00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3b80 && offset < 0x3c00) {
      offset -= 0x3b80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c00 && offset < 0x3c80) {
      offset -= 0x3c00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c80 && offset < 0x3d00) {
      offset -= 0x3c80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_actiondata_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3d00 && offset < 0x3d80) {
      offset -= 0x3d00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3d80 && offset < 0x3e00) {
      offset -= 0x3d80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_default_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3e00 && offset < 0x3e80) {
      offset -= 0x3e00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3e80 && offset < 0x3f00) {
      offset -= 0x3e80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_hole_swizzle_mode_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3f00 && offset < 0x3f80) {
      offset -= 0x3f00;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_stats_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3f80 && offset < 0x4000) {
      offset -= 0x3f80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_meter_adr_mask_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1e00) {
      offset -= 0x1800;
      int i0 = offset / 0x80;
      offset  -= i0 * 0x80;
      col_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : mau_meter_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_selectorlength_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_selectorlength_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_selectorlength_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_type_position_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : gateway_payload_match_adr_) {
      for (auto &f1 : f0) {
        for (auto &f2 : f1) {
          f2.reset();
        }
      }
    }
    for (auto &f0 : tcam_match_adr_to_physical_oxbar_outputmap_) {
      f0.reset();
    }
    for (auto &f0 : tind_ram_data_size_) {
      f0.reset();
    }
    for (auto &f0 : next_table_format_data_) {
      f0.reset();
    }
    for (auto &f0 : mau_immediate_data_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_immediate_data_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_action_instruction_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_action_instruction_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_actiondata_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_actiondata_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_stats_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_stats_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_meter_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_meter_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_idletime_adr_tcam_shiftcount_) {
      f0.reset();
    }
    for (auto &f0 : mau_idletime_adr_miss_value_) {
      f0.reset();
    }
    for (auto &f0 : mau_hash_group_xbar_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : stash_hitmap_output_map_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : stash_next_table_lut_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : stash_row_nxtable_bus_drive_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : gateway_to_logicaltable_xbar_ctl_) {
      f0.reset();
    }
    for (auto &f0 : gateway_inhibit_lut_) {
      f0.reset();
    }
    for (auto &f0 : gateway_to_pbus_xbar_ctl_) {
      f0.reset();
    }
    for (auto &f0 : tind_bus_prop_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_physical_tcam_hit_address_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_physical_exact_match_hit_address_) {
      f0.reset();
    }
    for (auto &f0 : mau_table_counter_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : tcam_hit_to_logical_table_ixbar_outputmap_) {
      f0.reset();
    }
    for (auto &f0 : mau_hash_group_mask_) {
      f0.reset();
    }
    for (auto &f0 : gateway_payload_tind_pbus_) {
      f0.reset();
    }
    for (auto &f0 : gateway_payload_exact_pbus_) {
      f0.reset();
    }
    for (auto &f0 : tcam_table_prop_) {
      f0.reset();
    }
    for (auto &f0 : exact_match_delay_thread_) {
      f0.reset();
    }
    for (auto &f0 : logical_table_thread_) {
      f0.reset();
    }
    for (auto &f0 : mau_physical_to_meter_alu_ixbar_map_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_precolor_hash_map_to_logical_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mau_selector_action_entry_size_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_counter_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stateful_log_ctl_ixbar_map_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : meter_alu_thread_) {
      f0.reset();
    }
    for (auto &f0 : exact_match_phys_result_delay_) {
      f0.reset();
    }
    for (auto &f0 : exact_match_phys_result_en_) {
      f0.reset();
    }
    for (auto &f0 : exact_match_phys_result_thread_) {
      f0.reset();
    }
    for (auto &f0 : mau_action_instruction_adr_map_en_) {
      f0.reset();
    }
    for (auto &f0 : mau_mapram_color_map_to_logical_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mau_hash_group_expand_) {
      f0.reset();
    }
    for (auto &f0 : mau_meter_alu_to_logical_map_) {
      f0.reset();
    }
    for (auto &f0 : predication_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_next_table_out_) {
      f0.reset();
    }
    for (auto &f0 : mau_snapshot_capture_datapath_error_) {
      f0.reset();
    }
    for (auto &f0 : mau_table_counter_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_counter_ctl_) {
      f0.reset();
    }
    for (auto &f0 : mau_stateful_log_vpn_limit_) {
      f0.reset();
    }
    for (auto &f0 : mau_immediate_data_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_idletime_adr_exact_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : gateway_next_table_lut_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stateful_log_vpn_offset_) {
      f0.reset();
    }
    for (auto &f0 : tcam_match_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : tind_ecc_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : gfm_parity_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : emm_ecc_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : prev_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : err_idata_ovr_fifo_ctl_) {
      f0.reset();
    }
    for (auto &f0 : err_idata_ovr_ctl_) {
      f0.reset();
    }
    for (auto &f0 : o_error_fifo_ctl_) {
      f0.reset();
    }
    for (auto &f0 : s2p_stats_error_ctl_) {
      f0.reset();
    }
    for (auto &f0 : s2p_meter_error_ctl_) {
      f0.reset();
    }
    exact_match_logical_result_delay_.reset();
    exact_match_logical_result_en_.reset();
    next_table_map_en_.reset();
    next_table_tcam_actionbit_map_en_.reset();
    mau_immediate_data_tcam_actionbit_map_en_.reset();
    mau_action_instruction_adr_tcam_actionbit_map_en_.reset();
    mau_actiondata_adr_tcam_actionbit_map_en_.reset();
    mau_stats_adr_tcam_actionbit_map_en_.reset();
    mau_meter_adr_tcam_actionbit_map_en_.reset();
    mau_match_central_mapram_read_color_oflo_ctl_.reset();
    for (auto &f0 : match_to_logical_table_ixbar_outputmap_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_map_data_) {
      for (auto &f1 : f0) {
        for (auto &f2 : f1) {
          f2.reset();
        }
      }
    }
    for (auto &f0 : gateway_payload_data_) {
      for (auto &f1 : f0) {
        for (auto &f2 : f1) {
          for (auto &f3 : f2) {
            f3.reset();
          }
        }
      }
    }
    mau_idletime_adr_tcam_actionbit_map_en_.reset();
    mau_selector_hash_sps_enable_.reset();
    mau_hash_group_config_.reset();
    mau_hash_group_shiftcount_.reset();
    mau_logical_to_meter_alu_map_.reset();
    mau_meter_precolor_hash_sel_.reset();
    gateway_en_.reset();
    mau_snapshot_logical_table_hit_.reset();
    mau_snapshot_gateway_table_inhibit_logical_.reset();
    mau_snapshot_table_active_.reset();
    mau_table_counter_clear_.reset();
    mau_stateful_log_counter_clear_.reset();
    mau_stateful_log_vpn_hole_en_.reset();
    mau_stateful_log_instruction_width_.reset();
    actiondata_error_ctl_.reset();
    imem_parity_error_ctl_.reset();
    for (auto &f0 : next_table_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_payload_shifter_enable_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_immediate_data_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_immediate_data_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_immediate_data_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_action_instruction_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_vpn_shiftcount_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_actiondata_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_default_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_per_entry_en_mux_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_hole_swizzle_mode_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_stats_adr_tcam_actionbit_map_data_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : mau_meter_adr_mask_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : col_) {
      f0.reset();
    }
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x80) {
      offset -= 0x0;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0x100) {
      offset -= 0x80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100 && offset < 0x180) {
      offset -= 0x100;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x180 && offset < 0x200) {
      offset -= 0x180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x280) {
      offset -= 0x200;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x280 && offset < 0x300) {
      offset -= 0x280;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x300 && offset < 0x380) {
      offset -= 0x300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x380 && offset < 0x400) {
      offset -= 0x380;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selectorlength_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x480) {
      offset -= 0x400;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selectorlength_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x480 && offset < 0x500) {
      offset -= 0x480;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selectorlength_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x500 && offset < 0x580) {
      offset -= 0x500;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_type_position_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x580 && offset < 0x600) {
      offset -= 0x580;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_match_adr_[ i2 ][ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x640) {
      offset -= 0x600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_match_adr_to_physical_oxbar_outputmap_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x640 && offset < 0x680) {
      offset -= 0x640;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tind_ram_data_size_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x680 && offset < 0x6c0) {
      offset -= 0x680;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += next_table_format_data_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6c0 && offset < 0x700) {
      offset -= 0x6c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x700 && offset < 0x740) {
      offset -= 0x700;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x740 && offset < 0x780) {
      offset -= 0x740;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x780 && offset < 0x7c0) {
      offset -= 0x780;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7c0 && offset < 0x800) {
      offset -= 0x7c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1040) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1040 && offset < 0x1080) {
      offset -= 0x1040;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1080 && offset < 0x10c0) {
      offset -= 0x1080;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10c0 && offset < 0x1100) {
      offset -= 0x10c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1100 && offset < 0x1140) {
      offset -= 0x1100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1140 && offset < 0x1180) {
      offset -= 0x1140;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_tcam_shiftcount_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1180 && offset < 0x11c0) {
      offset -= 0x1180;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_miss_value_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x11c0 && offset < 0x11f0) {
      offset -= 0x11c0;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_hash_group_xbar_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1200 && offset < 0x1240) {
      offset -= 0x1200;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += stash_hitmap_output_map_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1240 && offset < 0x1280) {
      offset -= 0x1240;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += stash_next_table_lut_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1280 && offset < 0x12c0) {
      offset -= 0x1280;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += stash_row_nxtable_bus_drive_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x12c0 && offset < 0x1300) {
      offset -= 0x12c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_to_logicaltable_xbar_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1300 && offset < 0x1340) {
      offset -= 0x1300;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_inhibit_lut_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1340 && offset < 0x1380) {
      offset -= 0x1340;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_to_pbus_xbar_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1380 && offset < 0x13c0) {
      offset -= 0x1380;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tind_bus_prop_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x13c0 && offset < 0x1400) {
      offset -= 0x13c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_physical_tcam_hit_address_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2040) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_physical_exact_match_hit_address_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2040 && offset < 0x2080) {
      offset -= 0x2040;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_table_counter_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2080 && offset < 0x20a0) {
      offset -= 0x2080;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_hit_to_logical_table_ixbar_outputmap_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20a0 && offset < 0x20b8) {
      offset -= 0x20a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_hash_group_mask_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20c0 && offset < 0x20e0) {
      offset -= 0x20c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_tind_pbus_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20e0 && offset < 0x2100) {
      offset -= 0x20e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_exact_pbus_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2100 && offset < 0x2120) {
      offset -= 0x2100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_table_prop_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2120 && offset < 0x212c) {
      offset -= 0x2120;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_delay_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2130 && offset < 0x213c) {
      offset -= 0x2130;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += logical_table_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2140 && offset < 0x2150) {
      offset -= 0x2140;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_physical_to_meter_alu_ixbar_map_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2150 && offset < 0x2160) {
      offset -= 0x2150;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_precolor_hash_map_to_logical_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2160 && offset < 0x2170) {
      offset -= 0x2160;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_selector_action_entry_size_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2170 && offset < 0x2180) {
      offset -= 0x2170;
      int i1 = offset / 0x4;
      offset  -= i1 * 0x4;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_counter_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2180 && offset < 0x2190) {
      offset -= 0x2180;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_ctl_ixbar_map_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2190 && offset < 0x2198) {
      offset -= 0x2190;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += meter_alu_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2198 && offset < 0x21a0) {
      offset -= 0x2198;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_phys_result_delay_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21a0 && offset < 0x21a8) {
      offset -= 0x21a0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_phys_result_en_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21a8 && offset < 0x21b0) {
      offset -= 0x21a8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += exact_match_phys_result_thread_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21b0 && offset < 0x21b8) {
      offset -= 0x21b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_map_en_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21b8 && offset < 0x21c0) {
      offset -= 0x21b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_mapram_color_map_to_logical_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21c0 && offset < 0x21c8) {
      offset -= 0x21c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_hash_group_expand_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21c8 && offset < 0x21d0) {
      offset -= 0x21c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_alu_to_logical_map_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21d0 && offset < 0x21d8) {
      offset -= 0x21d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += predication_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21d8 && offset < 0x21e0) {
      offset -= 0x21d8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_next_table_out_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21e0 && offset < 0x21e8) {
      offset -= 0x21e0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_snapshot_capture_datapath_error_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21e8 && offset < 0x21f0) {
      offset -= 0x21e8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_table_counter_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21f0 && offset < 0x21f8) {
      offset -= 0x21f0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_counter_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x21f8 && offset < 0x2200) {
      offset -= 0x21f8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_vpn_limit_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2400 && offset < 0x2600) {
      offset -= 0x2400;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2600 && offset < 0x2800) {
      offset -= 0x2600;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2800 && offset < 0x2a00) {
      offset -= 0x2800;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2a00 && offset < 0x2c00) {
      offset -= 0x2a00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c00 && offset < 0x2e00) {
      offset -= 0x2c00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2e00 && offset < 0x3000) {
      offset -= 0x2e00;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_idletime_adr_exact_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3200) {
      offset -= 0x3000;
      int i1 = offset / 0x20;
      offset  -= i1 * 0x20;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_next_table_lut_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3200 && offset < 0x3208) {
      offset -= 0x3200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stateful_log_vpn_offset_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3208 && offset < 0x3210) {
      offset -= 0x3208;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tcam_match_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3210 && offset < 0x3218) {
      offset -= 0x3210;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tind_ecc_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3218 && offset < 0x3220) {
      offset -= 0x3218;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gfm_parity_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3220 && offset < 0x3228) {
      offset -= 0x3220;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += emm_ecc_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3228 && offset < 0x3230) {
      offset -= 0x3228;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += prev_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3230 && offset < 0x3238) {
      offset -= 0x3230;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += err_idata_ovr_fifo_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3238 && offset < 0x3240) {
      offset -= 0x3238;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += err_idata_ovr_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3240 && offset < 0x3248) {
      offset -= 0x3240;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += o_error_fifo_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3248 && offset < 0x3250) {
      offset -= 0x3248;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += s2p_stats_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3250 && offset < 0x3258) {
      offset -= 0x3250;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += s2p_meter_error_ctl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3258 && offset < 0x325c) {
      offset -= 0x3258;
      r += exact_match_logical_result_delay_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x325c && offset < 0x3260) {
      offset -= 0x325c;
      r += exact_match_logical_result_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3260 && offset < 0x3264) {
      offset -= 0x3260;
      r += next_table_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3264 && offset < 0x3268) {
      offset -= 0x3264;
      r += next_table_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3268 && offset < 0x326c) {
      offset -= 0x3268;
      r += mau_immediate_data_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x326c && offset < 0x3270) {
      offset -= 0x326c;
      r += mau_action_instruction_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3270 && offset < 0x3274) {
      offset -= 0x3270;
      r += mau_actiondata_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3274 && offset < 0x3278) {
      offset -= 0x3274;
      r += mau_stats_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3278 && offset < 0x327c) {
      offset -= 0x3278;
      r += mau_meter_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x327c && offset < 0x3280) {
      offset -= 0x327c;
      r += mau_match_central_mapram_read_color_oflo_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3300 && offset < 0x3400) {
      offset -= 0x3300;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += match_to_logical_table_ixbar_outputmap_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3400 && offset < 0x3500) {
      offset -= 0x3400;
      int i2 = offset / 0x80;
      offset  -= i2 * 0x80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_map_data_[ i2 ][ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3500 && offset < 0x3600) {
      offset -= 0x3500;
      int i3 = offset / 0x20;
      offset  -= i3 * 0x20;
      int i2 = offset / 0x10;
      offset  -= i2 * 0x10;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += gateway_payload_data_[ i3 ][ i2 ][ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3600 && offset < 0x3604) {
      offset -= 0x3600;
      r += mau_idletime_adr_tcam_actionbit_map_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3604 && offset < 0x3608) {
      offset -= 0x3604;
      r += mau_selector_hash_sps_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3608 && offset < 0x360c) {
      offset -= 0x3608;
      r += mau_hash_group_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x360c && offset < 0x3610) {
      offset -= 0x360c;
      r += mau_hash_group_shiftcount_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3610 && offset < 0x3614) {
      offset -= 0x3610;
      r += mau_logical_to_meter_alu_map_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3614 && offset < 0x3618) {
      offset -= 0x3614;
      r += mau_meter_precolor_hash_sel_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3618 && offset < 0x361c) {
      offset -= 0x3618;
      r += gateway_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x361c && offset < 0x3620) {
      offset -= 0x361c;
      r += mau_snapshot_logical_table_hit_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3620 && offset < 0x3624) {
      offset -= 0x3620;
      r += mau_snapshot_gateway_table_inhibit_logical_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3624 && offset < 0x3628) {
      offset -= 0x3624;
      r += mau_snapshot_table_active_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3628 && offset < 0x362c) {
      offset -= 0x3628;
      r += mau_table_counter_clear_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x362c && offset < 0x3630) {
      offset -= 0x362c;
      r += mau_stateful_log_counter_clear_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3630 && offset < 0x3634) {
      offset -= 0x3630;
      r += mau_stateful_log_vpn_hole_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3634 && offset < 0x3638) {
      offset -= 0x3634;
      r += mau_stateful_log_instruction_width_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3638 && offset < 0x363c) {
      offset -= 0x3638;
      r += actiondata_error_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x363c && offset < 0x3640) {
      offset -= 0x363c;
      r += imem_parity_error_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3680 && offset < 0x3700) {
      offset -= 0x3680;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += next_table_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3700 && offset < 0x3780) {
      offset -= 0x3700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_payload_shifter_enable_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3780 && offset < 0x3800) {
      offset -= 0x3780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3800 && offset < 0x3880) {
      offset -= 0x3800;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3880 && offset < 0x3900) {
      offset -= 0x3880;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_immediate_data_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3900 && offset < 0x3980) {
      offset -= 0x3900;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3980 && offset < 0x3a00) {
      offset -= 0x3980;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3a00 && offset < 0x3a80) {
      offset -= 0x3a00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_action_instruction_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3a80 && offset < 0x3b00) {
      offset -= 0x3a80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_vpn_shiftcount_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3b00 && offset < 0x3b80) {
      offset -= 0x3b00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3b80 && offset < 0x3c00) {
      offset -= 0x3b80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c00 && offset < 0x3c80) {
      offset -= 0x3c00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c80 && offset < 0x3d00) {
      offset -= 0x3c80;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_actiondata_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3d00 && offset < 0x3d80) {
      offset -= 0x3d00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3d80 && offset < 0x3e00) {
      offset -= 0x3d80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_default_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3e00 && offset < 0x3e80) {
      offset -= 0x3e00;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_per_entry_en_mux_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3e80 && offset < 0x3f00) {
      offset -= 0x3e80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_hole_swizzle_mode_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3f00 && offset < 0x3f80) {
      offset -= 0x3f00;
      int i1 = offset / 0x8;
      offset  -= i1 * 0x8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_stats_adr_tcam_actionbit_map_data_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3f80 && offset < 0x4000) {
      offset -= 0x3f80;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_meter_adr_mask_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1e00) {
      offset -= 0x1800;
      int i0 = offset / 0x80;
      offset  -= i0 * 0x80;
      r += col_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_meter_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_idletime_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_idletime_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_idletime_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_idletime_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_selectorlength_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_selectorlength_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_selectorlength_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_type_position_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a2=0;a2<8;++a2) {
      for (uint32_t a1=0;a1<2;++a1) {
        for (uint32_t a0=0;a0<2;++a0) {
          r += gateway_payload_match_adr_[a2][a1][a0].to_string(print_zeros,indent_string) ;
        }
      }
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += tcam_match_adr_to_physical_oxbar_outputmap_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += tind_ram_data_size_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += next_table_format_data_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_immediate_data_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_immediate_data_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_action_instruction_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_action_instruction_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_actiondata_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_actiondata_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_stats_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_stats_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_meter_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_meter_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_idletime_adr_tcam_shiftcount_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_idletime_adr_miss_value_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<6;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_hash_group_xbar_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += stash_hitmap_output_map_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += stash_next_table_lut_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += stash_row_nxtable_bus_drive_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += gateway_to_logicaltable_xbar_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += gateway_inhibit_lut_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += gateway_to_pbus_xbar_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += tind_bus_prop_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_snapshot_physical_tcam_hit_address_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<16;++a0) {
      r += mau_snapshot_physical_exact_match_hit_address_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<1;++a0) {
        r += mau_table_counter_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += tcam_hit_to_logical_table_ixbar_outputmap_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<6;++a0) {
      r += mau_hash_group_mask_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += gateway_payload_tind_pbus_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += gateway_payload_exact_pbus_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<8;++a0) {
      r += tcam_table_prop_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += exact_match_delay_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<3;++a0) {
      r += logical_table_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_physical_to_meter_alu_ixbar_map_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_meter_precolor_hash_map_to_logical_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += mau_selector_action_entry_size_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<4;++a1) {
      for (uint32_t a0=0;a0<1;++a0) {
        r += mau_stateful_log_counter_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_stateful_log_ctl_ixbar_map_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += meter_alu_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += exact_match_phys_result_delay_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += exact_match_phys_result_en_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += exact_match_phys_result_thread_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_action_instruction_adr_map_en_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_mapram_color_map_to_logical_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_hash_group_expand_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_meter_alu_to_logical_map_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += predication_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_next_table_out_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_snapshot_capture_datapath_error_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_table_counter_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_stateful_log_counter_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_stateful_log_vpn_limit_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_immediate_data_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_action_instruction_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_actiondata_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_stats_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_meter_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += mau_idletime_adr_exact_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<8;++a0) {
        r += gateway_next_table_lut_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_stateful_log_vpn_offset_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += tcam_match_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += tind_ecc_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += gfm_parity_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += emm_ecc_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += prev_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += err_idata_ovr_fifo_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += err_idata_ovr_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += o_error_fifo_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += s2p_stats_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += s2p_meter_error_ctl_[a0].to_string(print_zeros,indent_string) ;
    }
    r += exact_match_logical_result_delay_.to_string(print_zeros,indent_string) ;
    r += exact_match_logical_result_en_.to_string(print_zeros,indent_string) ;
    r += next_table_map_en_.to_string(print_zeros,indent_string) ;
    r += next_table_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_immediate_data_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_action_instruction_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_actiondata_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_stats_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_meter_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_match_central_mapram_read_color_oflo_ctl_.to_string(print_zeros,indent_string) ;
    for (uint32_t a1=0;a1<4;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += match_to_logical_table_ixbar_outputmap_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a2=0;a2<2;++a2) {
      for (uint32_t a1=0;a1<16;++a1) {
        for (uint32_t a0=0;a0<2;++a0) {
          r += mau_action_instruction_adr_map_data_[a2][a1][a0].to_string(print_zeros,indent_string) ;
        }
      }
    }
    for (uint32_t a3=0;a3<8;++a3) {
      for (uint32_t a2=0;a2<2;++a2) {
        for (uint32_t a1=0;a1<2;++a1) {
          for (uint32_t a0=0;a0<2;++a0) {
            r += gateway_payload_data_[a3][a2][a1][a0].to_string(print_zeros,indent_string) ;
          }
        }
      }
    }
    r += mau_idletime_adr_tcam_actionbit_map_en_.to_string(print_zeros,indent_string) ;
    r += mau_selector_hash_sps_enable_.to_string(print_zeros,indent_string) ;
    r += mau_hash_group_config_.to_string(print_zeros,indent_string) ;
    r += mau_hash_group_shiftcount_.to_string(print_zeros,indent_string) ;
    r += mau_logical_to_meter_alu_map_.to_string(print_zeros,indent_string) ;
    r += mau_meter_precolor_hash_sel_.to_string(print_zeros,indent_string) ;
    r += gateway_en_.to_string(print_zeros,indent_string) ;
    r += mau_snapshot_logical_table_hit_.to_string(print_zeros,indent_string) ;
    r += mau_snapshot_gateway_table_inhibit_logical_.to_string(print_zeros,indent_string) ;
    r += mau_snapshot_table_active_.to_string(print_zeros,indent_string) ;
    r += mau_table_counter_clear_.to_string(print_zeros,indent_string) ;
    r += mau_stateful_log_counter_clear_.to_string(print_zeros,indent_string) ;
    r += mau_stateful_log_vpn_hole_en_.to_string(print_zeros,indent_string) ;
    r += mau_stateful_log_instruction_width_.to_string(print_zeros,indent_string) ;
    r += actiondata_error_ctl_.to_string(print_zeros,indent_string) ;
    r += imem_parity_error_ctl_.to_string(print_zeros,indent_string) ;
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += next_table_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_payload_shifter_enable_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_immediate_data_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_immediate_data_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_immediate_data_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_action_instruction_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_action_instruction_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_action_instruction_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_vpn_shiftcount_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_actiondata_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_actiondata_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_default_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_per_entry_en_mux_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_stats_adr_hole_swizzle_mode_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<16;++a1) {
      for (uint32_t a0=0;a0<2;++a0) {
        r += mau_stats_adr_tcam_actionbit_map_data_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += mau_meter_adr_mask_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a0=0;a0<12;++a0) {
      r += col_[a0].to_string(print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< std::array< MauMeterAdrDefaultMutable, 16 >, 2 > mau_meter_adr_default_;
  std::array< std::array< MauMeterAdrPerEntryEnMuxCtlMutable, 16 >, 2 > mau_meter_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauMeterAdrTcamActionbitMapDataMutable, 2 >, 16 > mau_meter_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauIdletimeAdrMaskMutable, 16 >, 2 > mau_idletime_adr_mask_;
  std::array< std::array< MauIdletimeAdrDefaultMutable, 16 >, 2 > mau_idletime_adr_default_;
  std::array< std::array< MauIdletimeAdrTcamActionbitMapDataMutable, 2 >, 16 > mau_idletime_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauIdletimeAdrPerEntryEnMuxCtlMutable, 16 >, 2 > mau_idletime_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauSelectorlengthShiftcountMutable, 16 >, 2 > mau_selectorlength_shiftcount_;
  std::array< std::array< MauSelectorlengthMaskMutable, 16 >, 2 > mau_selectorlength_mask_;
  std::array< std::array< MauSelectorlengthDefaultMutable, 16 >, 2 > mau_selectorlength_default_;
  std::array< std::array< MauMeterAdrTypePositionMutable, 16 >, 2 > mau_meter_adr_type_position_;
  std::array< std::array< std::array< GatewayPayloadMatchAdrMutable, 2 >, 2 >, 8 > gateway_payload_match_adr_;
  std::array< TcamMatchAdrToPhysicalOxbarOutputmapMutable, 16 > tcam_match_adr_to_physical_oxbar_outputmap_;
  std::array< TindRamDataSizeMutable, 16 > tind_ram_data_size_;
  std::array< NextTableFormatDataMutable, 16 > next_table_format_data_;
  std::array< MauImmediateDataTcamShiftcountMutable, 16 > mau_immediate_data_tcam_shiftcount_;
  std::array< MauImmediateDataMissValueMutable, 16 > mau_immediate_data_miss_value_;
  std::array< MauActionInstructionAdrTcamShiftcountMutable, 16 > mau_action_instruction_adr_tcam_shiftcount_;
  std::array< MauActionInstructionAdrMissValueMutable, 16 > mau_action_instruction_adr_miss_value_;
  std::array< MauActiondataAdrTcamShiftcountMutable, 16 > mau_actiondata_adr_tcam_shiftcount_;
  std::array< MauActiondataAdrMissValueMutable, 16 > mau_actiondata_adr_miss_value_;
  std::array< MauStatsAdrTcamShiftcountMutable, 16 > mau_stats_adr_tcam_shiftcount_;
  std::array< MauStatsAdrMissValueMutable, 16 > mau_stats_adr_miss_value_;
  std::array< MauMeterAdrTcamShiftcountMutable, 16 > mau_meter_adr_tcam_shiftcount_;
  std::array< MauMeterAdrMissValueMutable, 16 > mau_meter_adr_miss_value_;
  std::array< MauIdletimeAdrTcamShiftcountMutable, 16 > mau_idletime_adr_tcam_shiftcount_;
  std::array< MauIdletimeAdrMissValueMutable, 16 > mau_idletime_adr_miss_value_;
  std::array< std::array< MauHashGroupXbarCtlMutable, 2 >, 6 > mau_hash_group_xbar_ctl_;
  std::array< std::array< StashHitmapOutputMapMutable, 8 >, 2 > stash_hitmap_output_map_;
  std::array< std::array< StashNextTableLutMutable, 8 >, 2 > stash_next_table_lut_;
  std::array< std::array< StashRowNxtableBusDriveMutable, 8 >, 2 > stash_row_nxtable_bus_drive_;
  std::array< GatewayToLogicaltableXbarCtlMutable, 16 > gateway_to_logicaltable_xbar_ctl_;
  std::array< GatewayInhibitLutMutable, 16 > gateway_inhibit_lut_;
  std::array< GatewayToPbusXbarCtlMutable, 16 > gateway_to_pbus_xbar_ctl_;
  std::array< TindBusPropMutable, 16 > tind_bus_prop_;
  std::array< MauSnapshotPhysicalTcamHitAddressMutable, 16 > mau_snapshot_physical_tcam_hit_address_;
  std::array< MauSnapshotPhysicalExactMatchHitAddressMutable, 16 > mau_snapshot_physical_exact_match_hit_address_;
  std::array< std::array< MauTableCounterMutable, 1 >, 16 > mau_table_counter_;
  std::array< TcamHitToLogicalTableIxbarOutputmapMutable, 8 > tcam_hit_to_logical_table_ixbar_outputmap_;
  std::array< MauHashGroupMaskMutable, 6 > mau_hash_group_mask_;
  std::array< GatewayPayloadTindPbusMutable, 8 > gateway_payload_tind_pbus_;
  std::array< GatewayPayloadExactPbusMutable, 8 > gateway_payload_exact_pbus_;
  std::array< TcamTablePropMutable, 8 > tcam_table_prop_;
  std::array< ExactMatchDelayThreadMutable, 3 > exact_match_delay_thread_;
  std::array< LogicalTableThreadMutable, 3 > logical_table_thread_;
  std::array< std::array< MauPhysicalToMeterAluIxbarMapMutable, 2 >, 2 > mau_physical_to_meter_alu_ixbar_map_;
  std::array< MauMeterPrecolorHashMapToLogicalCtlMutable, 4 > mau_meter_precolor_hash_map_to_logical_ctl_;
  std::array< MauSelectorActionEntrySizeMutable, 4 > mau_selector_action_entry_size_;
  std::array< std::array< MauStatefulLogCounterMutable, 1 >, 4 > mau_stateful_log_counter_;
  std::array< std::array< MauStatefulLogCtlIxbarMapMutable, 2 >, 2 > mau_stateful_log_ctl_ixbar_map_;
  std::array< MeterAluThreadMutable, 2 > meter_alu_thread_;
  std::array< ExactMatchPhysResultDelayMutable, 2 > exact_match_phys_result_delay_;
  std::array< ExactMatchPhysResultEnMutable, 2 > exact_match_phys_result_en_;
  std::array< ExactMatchPhysResultThreadMutable, 2 > exact_match_phys_result_thread_;
  std::array< MauActionInstructionAdrMapEnMutable, 2 > mau_action_instruction_adr_map_en_;
  std::array< MauMapramColorMapToLogicalCtlMutable, 2 > mau_mapram_color_map_to_logical_ctl_;
  std::array< MauHashGroupExpandMutable, 2 > mau_hash_group_expand_;
  std::array< MauMeterAluToLogicalMapMutable, 2 > mau_meter_alu_to_logical_map_;
  std::array< PredicationCtlMutable, 2 > predication_ctl_;
  std::array< MauSnapshotNextTableOutMutable, 2 > mau_snapshot_next_table_out_;
  std::array< MauSnapshotCaptureDatapathErrorMutable, 2 > mau_snapshot_capture_datapath_error_;
  std::array< MauTableCounterCtlMutable, 2 > mau_table_counter_ctl_;
  std::array< MauStatefulLogCounterCtlMutable, 2 > mau_stateful_log_counter_ctl_;
  std::array< MauStatefulLogVpnLimitMutable, 2 > mau_stateful_log_vpn_limit_;
  std::array< std::array< MauImmediateDataExactShiftcountMutable, 5 >, 16 > mau_immediate_data_exact_shiftcount_;
  std::array< std::array< MauActionInstructionAdrExactShiftcountMutable, 5 >, 16 > mau_action_instruction_adr_exact_shiftcount_;
  std::array< std::array< MauActiondataAdrExactShiftcountMutable, 5 >, 16 > mau_actiondata_adr_exact_shiftcount_;
  std::array< std::array< MauStatsAdrExactShiftcountMutable, 5 >, 16 > mau_stats_adr_exact_shiftcount_;
  std::array< std::array< MauMeterAdrExactShiftcountMutable, 5 >, 16 > mau_meter_adr_exact_shiftcount_;
  std::array< std::array< MauIdletimeAdrExactShiftcountMutable, 5 >, 16 > mau_idletime_adr_exact_shiftcount_;
  std::array< std::array< GatewayNextTableLutMutable, 5 >, 16 > gateway_next_table_lut_;
  std::array< MauStatefulLogVpnOffsetMutable, 2 > mau_stateful_log_vpn_offset_;
  std::array< TcamMatchErrorCtlMutable, 2 > tcam_match_error_ctl_;
  std::array< TindEccErrorCtlMutable, 2 > tind_ecc_error_ctl_;
  std::array< GfmParityErrorCtlMutable, 2 > gfm_parity_error_ctl_;
  std::array< EmmEccErrorCtlMutable, 2 > emm_ecc_error_ctl_;
  std::array< PrevErrorCtlMutable, 2 > prev_error_ctl_;
  std::array< ErrIdataOvrFifoCtlMutable, 2 > err_idata_ovr_fifo_ctl_;
  std::array< ErrIdataOvrCtlMutable, 2 > err_idata_ovr_ctl_;
  std::array< OErrorFifoCtlMutable, 2 > o_error_fifo_ctl_;
  std::array< S2pStatsErrorCtlMutable, 2 > s2p_stats_error_ctl_;
  std::array< S2pMeterErrorCtlMutable, 2 > s2p_meter_error_ctl_;
  ExactMatchLogicalResultDelayMutable exact_match_logical_result_delay_;
  ExactMatchLogicalResultEnMutable exact_match_logical_result_en_;
  NextTableMapEnMutable next_table_map_en_;
  NextTableTcamActionbitMapEnMutable next_table_tcam_actionbit_map_en_;
  MauImmediateDataTcamActionbitMapEnMutable mau_immediate_data_tcam_actionbit_map_en_;
  MauActionInstructionAdrTcamActionbitMapEnMutable mau_action_instruction_adr_tcam_actionbit_map_en_;
  MauActiondataAdrTcamActionbitMapEnMutable mau_actiondata_adr_tcam_actionbit_map_en_;
  MauStatsAdrTcamActionbitMapEnMutable mau_stats_adr_tcam_actionbit_map_en_;
  MauMeterAdrTcamActionbitMapEnMutable mau_meter_adr_tcam_actionbit_map_en_;
  MauMatchCentralMapramReadColorOfloCtlMutable mau_match_central_mapram_read_color_oflo_ctl_;
  std::array< std::array< MatchToLogicalTableIxbarOutputmapMutable, 16 >, 4 > match_to_logical_table_ixbar_outputmap_;
  std::array< std::array< std::array< MauActionInstructionAdrMapDataMutable, 2 >, 16 >, 2 > mau_action_instruction_adr_map_data_;
  std::array< std::array< std::array< std::array< GatewayPayloadDataMutable, 2 >, 2 >, 2 >, 8 > gateway_payload_data_;
  MauIdletimeAdrTcamActionbitMapEnMutable mau_idletime_adr_tcam_actionbit_map_en_;
  MauSelectorHashSpsEnableMutable mau_selector_hash_sps_enable_;
  MauHashGroupConfigMutable mau_hash_group_config_;
  MauHashGroupShiftcountMutable mau_hash_group_shiftcount_;
  MauLogicalToMeterAluMapMutable mau_logical_to_meter_alu_map_;
  MauMeterPrecolorHashSelMutable mau_meter_precolor_hash_sel_;
  GatewayEnMutable gateway_en_;
  MauSnapshotLogicalTableHitMutable mau_snapshot_logical_table_hit_;
  MauSnapshotGatewayTableInhibitLogicalMutable mau_snapshot_gateway_table_inhibit_logical_;
  MauSnapshotTableActiveMutable mau_snapshot_table_active_;
  MauTableCounterClearMutable mau_table_counter_clear_;
  MauStatefulLogCounterClearMutable mau_stateful_log_counter_clear_;
  MauStatefulLogVpnHoleEnMutable mau_stateful_log_vpn_hole_en_;
  MauStatefulLogInstructionWidthMutable mau_stateful_log_instruction_width_;
  ActiondataErrorCtlMutable actiondata_error_ctl_;
  ImemParityErrorCtlMutable imem_parity_error_ctl_;
  std::array< std::array< NextTableMapDataMutable, 2 >, 16 > next_table_map_data_;
  std::array< std::array< MauPayloadShifterEnableMutable, 16 >, 2 > mau_payload_shifter_enable_;
  std::array< std::array< MauImmediateDataMaskMutable, 16 >, 2 > mau_immediate_data_mask_;
  std::array< std::array< MauImmediateDataDefaultMutable, 16 >, 2 > mau_immediate_data_default_;
  std::array< std::array< MauImmediateDataTcamActionbitMapDataMutable, 2 >, 16 > mau_immediate_data_tcam_actionbit_map_data_;
  std::array< std::array< MauActionInstructionAdrMaskMutable, 16 >, 2 > mau_action_instruction_adr_mask_;
  std::array< std::array< MauActionInstructionAdrDefaultMutable, 16 >, 2 > mau_action_instruction_adr_default_;
  std::array< std::array< MauActionInstructionAdrPerEntryEnMuxCtlMutable, 16 >, 2 > mau_action_instruction_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauActiondataAdrVpnShiftcountMutable, 16 >, 2 > mau_actiondata_adr_vpn_shiftcount_;
  std::array< std::array< MauActiondataAdrMaskMutable, 16 >, 2 > mau_actiondata_adr_mask_;
  std::array< std::array< MauActiondataAdrDefaultMutable, 16 >, 2 > mau_actiondata_adr_default_;
  std::array< std::array< MauActiondataAdrPerEntryEnMuxCtlMutable, 16 >, 2 > mau_actiondata_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauActiondataAdrTcamActionbitMapDataMutable, 2 >, 16 > mau_actiondata_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauStatsAdrMaskMutable, 16 >, 2 > mau_stats_adr_mask_;
  std::array< std::array< MauStatsAdrDefaultMutable, 16 >, 2 > mau_stats_adr_default_;
  std::array< std::array< MauStatsAdrPerEntryEnMuxCtlMutable, 16 >, 2 > mau_stats_adr_per_entry_en_mux_ctl_;
  std::array< std::array< MauStatsAdrHoleSwizzleModeMutable, 16 >, 2 > mau_stats_adr_hole_swizzle_mode_;
  std::array< std::array< MauStatsAdrTcamActionbitMapDataMutable, 2 >, 16 > mau_stats_adr_tcam_actionbit_map_data_;
  std::array< std::array< MauMeterAdrMaskMutable, 16 >, 2 > mau_meter_adr_mask_;
  std::array< MauMatchMergeColAddrmapMutable, 12 > col_;
private:
  static int StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    int offset=0;
    offset += 0x2000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x800000; // pipe_addrmap[]
    assert(index_mau_addrmap < 12);
    offset += index_mau_addrmap * 0x80000; // mau_addrmap[]
    offset += 0x18000; // to get to match
    offset += 0x4000; // to get to merge
    return offset;
  }

};











  }; // namespace register_classes
}; // namespace tofino

#endif // __REGISTER_INCLUDES_MAU_MATCH_MERGE_ADDRMAP_MUTABLE_H__
