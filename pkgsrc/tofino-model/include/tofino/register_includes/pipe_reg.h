/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_PIPE_REG_H__
#define __REGISTER_INCLUDES_PIPE_REG_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "pipe_reg_ctr_drop_no_dst.h"
#include "pipe_reg_ctr_drop_sop_by_sop.h"
#include "pipe_reg_ctr_vld_sop.h"
#include "pipe_reg_debug_bus_ctrl.h"
#include "pipe_reg_intr.h"
#include "pipe_reg_intr_enable0.h"
#include "pipe_reg_intr_enable1.h"
#include "pipe_reg_intr_freeze_enable.h"
#include "pipe_reg_intr_inject.h"
#include "pipe_reg_intr_status.h"
#include "pipe_reg_ppg_drop_cnt_table_mbe_errlog.h"
#include "pipe_reg_ppg_drop_cnt_table_sbe_errlog.h"
#include "pipe_reg_ppg_mapping_table_mbe_errlog.h"
#include "pipe_reg_ppg_mapping_table_sbe_errlog.h"
#include "pipe_reg_wac_drop_buf_full.h"
#include "pipe_reg_wac_ecc.h"
#include "wac_bypass.h"
#include "wac_debug_register.h"
#include "wac_drop_count_port.h"
#include "wac_drop_count_ppg.h"
#include "wac_offset.h"
#include "wac_pfc_state.h"
#include "wac_port_drop_state.h"
#include "wac_port_pause_en.h"
#include "wac_port_pfc_en.h"
#include "wac_ppg_drop_state.h"
#include "wac_pre_fifo_mapping.h"

namespace tofino {
  namespace register_classes {

class PipeReg : public model_core::RegisterBlock<RegisterCallback> {
public:
  PipeReg(
      int chipNumber, int index_tm_wac_pipe_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_tm_wac_pipe_rspec), 6532, false, write_callback, read_callback, std::string("PipeReg")+":"+boost::lexical_cast<std::string>(index_tm_wac_pipe_rspec))
    {
    }
  PipeReg(
      
  )
    : RegisterBlock(0, 0, 0, false, 0, 0, "PipeReg")
    {
    }
public:





  WacBypass &wac_reg_wac_bypass_config() { return wac_reg_wac_bypass_config_; }





  PipeRegCtrDropNoDst &wac_reg_ctr_drop_no_dst() { return wac_reg_ctr_drop_no_dst_; }





  PipeRegCtrDropSopBySop &wac_reg_ctr_drop_sop_by_sop() { return wac_reg_ctr_drop_sop_by_sop_; }





  PipeRegCtrVldSop &wac_reg_ctr_vld_sop() { return wac_reg_ctr_vld_sop_; }





  PipeRegWacDropBufFull &wac_reg_wac_drop_buf_full() { return wac_reg_wac_drop_buf_full_; }





  WacDebugRegister &wac_reg_wac_debug_register() { return wac_reg_wac_debug_register_; }







  WacOffset &wac_reg_offset_profile(int j0) { return wac_reg_offset_profile_[j0]; }







  WacPortPfcEn &wac_reg_port_pfc_en(int j0) { return wac_reg_port_pfc_en_[j0]; }







  WacPortPauseEn &wac_reg_port_pause_en(int j0) { return wac_reg_port_pause_en_[j0]; }








  PipeRegWacEcc &wac_reg_wac_ecc() { return wac_reg_wac_ecc_; }





  PipeRegPpgMappingTableSbeErrlog &wac_reg_ppg_mapping_table_sbe_errlog() { return wac_reg_ppg_mapping_table_sbe_errlog_; }





  PipeRegPpgMappingTableMbeErrlog &wac_reg_ppg_mapping_table_mbe_errlog() { return wac_reg_ppg_mapping_table_mbe_errlog_; }





  PipeRegPpgDropCntTableSbeErrlog &wac_reg_ppg_drop_cnt_table_sbe_errlog() { return wac_reg_ppg_drop_cnt_table_sbe_errlog_; }





  PipeRegPpgDropCntTableMbeErrlog &wac_reg_ppg_drop_cnt_table_mbe_errlog() { return wac_reg_ppg_drop_cnt_table_mbe_errlog_; }








  WacDropCountPort &wac_reg_wac_drop_count_port(int j0) { return wac_reg_wac_drop_count_port_[j0]; }










  WacDropCountPpg &wac_reg_wac_drop_count_ppg(int j0) { return wac_reg_wac_drop_count_ppg_[j0]; }








  WacPfcState &wac_reg_wac_pfc_state(int j0) { return wac_reg_wac_pfc_state_[j0]; }






  WacPpgDropState &wac_reg_wac_ppg_drop_state0() { return wac_reg_wac_ppg_drop_state0_; }






  WacPpgDropState &wac_reg_wac_ppg_drop_state1() { return wac_reg_wac_ppg_drop_state1_; }






  WacPortDropState &wac_reg_wac_port_drop_state() { return wac_reg_wac_port_drop_state_; }







  WacPreFifoMapping &wac_reg_wac_pre_fifo_mapping(int j0) { return wac_reg_wac_pre_fifo_mapping_[j0]; }





  PipeRegDebugBusCtrl &wac_reg_debug_bus_ctrl() { return wac_reg_debug_bus_ctrl_; }
  PipeRegIntr &wac_reg_intr() { return wac_reg_intr_; }






  PipeRegIntrStatus &wac_reg_intr_status() { return wac_reg_intr_status_; }







  PipeRegIntrEnable0 &wac_reg_intr_enable0() { return wac_reg_intr_enable0_; }







  PipeRegIntrEnable1 &wac_reg_intr_enable1() { return wac_reg_intr_enable1_; }








  PipeRegIntrInject &wac_reg_intr_inject() { return wac_reg_intr_inject_; }





  PipeRegIntrFreezeEnable &wac_reg_intr_freeze_enable() { return wac_reg_intr_freeze_enable_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset < 0x4) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      wac_reg_wac_bypass_config_.read( offset, data );
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      if (read_callback_) read_callback_();
      wac_reg_ctr_drop_no_dst_.read( offset, data );
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      if (read_callback_) read_callback_();
      wac_reg_ctr_drop_sop_by_sop_.read( offset, data );
    }
    else if (offset >= 0x10 && offset < 0x18) {
      offset -= 0x10;
      if (read_callback_) read_callback_();
      wac_reg_ctr_vld_sop_.read( offset, data );
    }
    else if (offset >= 0x18 && offset < 0x20) {
      offset -= 0x18;
      if (read_callback_) read_callback_();
      wac_reg_wac_drop_buf_full_.read( offset, data );
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      wac_reg_wac_debug_register_.read( offset, data );
    }
    else if (offset >= 0x80 && offset < 0x100) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      wac_reg_offset_profile_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      wac_reg_port_pfc_en_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      wac_reg_port_pause_en_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x520 && offset < 0x524) {
      offset -= 0x520;
      if (read_callback_) read_callback_();
      wac_reg_wac_ecc_.read( offset, data );
    }
    else if (offset >= 0x554 && offset < 0x558) {
      offset -= 0x554;
      if (read_callback_) read_callback_();
      wac_reg_ppg_mapping_table_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x558 && offset < 0x55c) {
      offset -= 0x558;
      if (read_callback_) read_callback_();
      wac_reg_ppg_mapping_table_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x55c && offset < 0x560) {
      offset -= 0x55c;
      if (read_callback_) read_callback_();
      wac_reg_ppg_drop_cnt_table_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x560 && offset < 0x564) {
      offset -= 0x560;
      if (read_callback_) read_callback_();
      wac_reg_ppg_drop_cnt_table_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x800 && offset < 0xa48) {
      offset -= 0x800;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      if (read_callback_) read_callback_();
      wac_reg_wac_drop_count_port_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1000 && offset < 0x1648) {
      offset -= 0x1000;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      if (read_callback_) read_callback_();
      wac_reg_wac_drop_count_ppg_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1800 && offset < 0x1924) {
      offset -= 0x1800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      wac_reg_wac_pfc_state_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1930 && offset < 0x1940) {
      offset -= 0x1930;
      if (read_callback_) read_callback_();
      wac_reg_wac_ppg_drop_state0_.read( offset, data );
    }
    else if (offset >= 0x1940 && offset < 0x1950) {
      offset -= 0x1940;
      if (read_callback_) read_callback_();
      wac_reg_wac_ppg_drop_state1_.read( offset, data );
    }
    else if (offset >= 0x1950 && offset < 0x195c) {
      offset -= 0x1950;
      if (read_callback_) read_callback_();
      wac_reg_wac_port_drop_state_.read( offset, data );
    }
    else if (offset >= 0x1960 && offset < 0x1980) {
      offset -= 0x1960;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      wac_reg_wac_pre_fifo_mapping_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1980 && offset < 0x1984) {
      offset -= 0x1980;
      if (read_callback_) read_callback_();
      wac_reg_debug_bus_ctrl_.read( offset, data );
    }
    else if (offset >= 0x540 && offset < 0x554) {
      offset -= 0x540;
      if (read_callback_) read_callback_();
      wac_reg_intr_.read( offset, data );
    }
    else if (offset >= 0x540 && offset < 0x544) {
      offset -= 0x540;
      if (read_callback_) read_callback_();
      wac_reg_intr_status_.read( offset, data );
    }
    else if (offset >= 0x544 && offset < 0x548) {
      offset -= 0x544;
      if (read_callback_) read_callback_();
      wac_reg_intr_enable0_.read( offset, data );
    }
    else if (offset >= 0x548 && offset < 0x54c) {
      offset -= 0x548;
      if (read_callback_) read_callback_();
      wac_reg_intr_enable1_.read( offset, data );
    }
    else if (offset >= 0x54c && offset < 0x550) {
      offset -= 0x54c;
      if (read_callback_) read_callback_();
      wac_reg_intr_inject_.read( offset, data );
    }
    else if (offset >= 0x550 && offset < 0x554) {
      offset -= 0x550;
      if (read_callback_) read_callback_();
      wac_reg_intr_freeze_enable_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset < 0x4) {
      offset -= 0x0;
      wac_reg_wac_bypass_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      wac_reg_ctr_drop_no_dst_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      wac_reg_ctr_drop_sop_by_sop_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10 && offset < 0x18) {
      offset -= 0x10;
      wac_reg_ctr_vld_sop_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18 && offset < 0x20) {
      offset -= 0x18;
      wac_reg_wac_drop_buf_full_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      wac_reg_wac_debug_register_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0x100) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      wac_reg_offset_profile_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      wac_reg_port_pfc_en_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      wac_reg_port_pause_en_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x520 && offset < 0x524) {
      offset -= 0x520;
      wac_reg_wac_ecc_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x554 && offset < 0x558) {
      offset -= 0x554;
      wac_reg_ppg_mapping_table_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x558 && offset < 0x55c) {
      offset -= 0x558;
      wac_reg_ppg_mapping_table_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x55c && offset < 0x560) {
      offset -= 0x55c;
      wac_reg_ppg_drop_cnt_table_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x560 && offset < 0x564) {
      offset -= 0x560;
      wac_reg_ppg_drop_cnt_table_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0xa48) {
      offset -= 0x800;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      wac_reg_wac_drop_count_port_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1648) {
      offset -= 0x1000;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      wac_reg_wac_drop_count_ppg_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1924) {
      offset -= 0x1800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      wac_reg_wac_pfc_state_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1930 && offset < 0x1940) {
      offset -= 0x1930;
      wac_reg_wac_ppg_drop_state0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1940 && offset < 0x1950) {
      offset -= 0x1940;
      wac_reg_wac_ppg_drop_state1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1950 && offset < 0x195c) {
      offset -= 0x1950;
      wac_reg_wac_port_drop_state_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1960 && offset < 0x1980) {
      offset -= 0x1960;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      wac_reg_wac_pre_fifo_mapping_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1980 && offset < 0x1984) {
      offset -= 0x1980;
      wac_reg_debug_bus_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x540 && offset < 0x554) {
      offset -= 0x540;
      wac_reg_intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x540 && offset < 0x544) {
      offset -= 0x540;
      wac_reg_intr_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x544 && offset < 0x548) {
      offset -= 0x544;
      wac_reg_intr_enable0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x548 && offset < 0x54c) {
      offset -= 0x548;
      wac_reg_intr_enable1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x54c && offset < 0x550) {
      offset -= 0x54c;
      wac_reg_intr_inject_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x550 && offset < 0x554) {
      offset -= 0x550;
      wac_reg_intr_freeze_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    wac_reg_wac_bypass_config_.reset();
    wac_reg_ctr_drop_no_dst_.reset();
    wac_reg_ctr_drop_sop_by_sop_.reset();
    wac_reg_ctr_vld_sop_.reset();
    wac_reg_wac_drop_buf_full_.reset();
    wac_reg_wac_debug_register_.reset();
    for (auto &f0 : wac_reg_offset_profile_) {
      f0.reset();
    }
    for (auto &f0 : wac_reg_port_pfc_en_) {
      f0.reset();
    }
    for (auto &f0 : wac_reg_port_pause_en_) {
      f0.reset();
    }
    wac_reg_wac_ecc_.reset();
    wac_reg_ppg_mapping_table_sbe_errlog_.reset();
    wac_reg_ppg_mapping_table_mbe_errlog_.reset();
    wac_reg_ppg_drop_cnt_table_sbe_errlog_.reset();
    wac_reg_ppg_drop_cnt_table_mbe_errlog_.reset();
    for (auto &f0 : wac_reg_wac_drop_count_port_) {
      f0.reset();
    }
    for (auto &f0 : wac_reg_wac_drop_count_ppg_) {
      f0.reset();
    }
    for (auto &f0 : wac_reg_wac_pfc_state_) {
      f0.reset();
    }
    wac_reg_wac_ppg_drop_state0_.reset();
    wac_reg_wac_ppg_drop_state1_.reset();
    wac_reg_wac_port_drop_state_.reset();
    for (auto &f0 : wac_reg_wac_pre_fifo_mapping_) {
      f0.reset();
    }
    wac_reg_debug_bus_ctrl_.reset();
    wac_reg_intr_.reset();
    wac_reg_intr_status_.reset();
    wac_reg_intr_enable0_.reset();
    wac_reg_intr_enable1_.reset();
    wac_reg_intr_inject_.reset();
    wac_reg_intr_freeze_enable_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x4) {
      offset -= 0x0;
      r += wac_reg_wac_bypass_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      r += wac_reg_ctr_drop_no_dst_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      r += wac_reg_ctr_drop_sop_by_sop_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10 && offset < 0x18) {
      offset -= 0x10;
      r += wac_reg_ctr_vld_sop_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18 && offset < 0x20) {
      offset -= 0x18;
      r += wac_reg_wac_drop_buf_full_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      r += wac_reg_wac_debug_register_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0x100) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += wac_reg_offset_profile_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x320) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += wac_reg_port_pfc_en_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x400 && offset < 0x520) {
      offset -= 0x400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += wac_reg_port_pause_en_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x520 && offset < 0x524) {
      offset -= 0x520;
      r += wac_reg_wac_ecc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x554 && offset < 0x558) {
      offset -= 0x554;
      r += wac_reg_ppg_mapping_table_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x558 && offset < 0x55c) {
      offset -= 0x558;
      r += wac_reg_ppg_mapping_table_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x55c && offset < 0x560) {
      offset -= 0x55c;
      r += wac_reg_ppg_drop_cnt_table_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x560 && offset < 0x564) {
      offset -= 0x560;
      r += wac_reg_ppg_drop_cnt_table_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0xa48) {
      offset -= 0x800;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      r += wac_reg_wac_drop_count_port_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1648) {
      offset -= 0x1000;
      int i0 = offset / 0x8;
      offset  -= i0 * 0x8;
      r += wac_reg_wac_drop_count_ppg_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1924) {
      offset -= 0x1800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += wac_reg_wac_pfc_state_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1930 && offset < 0x1940) {
      offset -= 0x1930;
      r += wac_reg_wac_ppg_drop_state0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1940 && offset < 0x1950) {
      offset -= 0x1940;
      r += wac_reg_wac_ppg_drop_state1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1950 && offset < 0x195c) {
      offset -= 0x1950;
      r += wac_reg_wac_port_drop_state_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1960 && offset < 0x1980) {
      offset -= 0x1960;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += wac_reg_wac_pre_fifo_mapping_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1980 && offset < 0x1984) {
      offset -= 0x1980;
      r += wac_reg_debug_bus_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x540 && offset < 0x554) {
      offset -= 0x540;
      r += wac_reg_intr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x540 && offset < 0x544) {
      offset -= 0x540;
      r += wac_reg_intr_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x544 && offset < 0x548) {
      offset -= 0x544;
      r += wac_reg_intr_enable0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x548 && offset < 0x54c) {
      offset -= 0x548;
      r += wac_reg_intr_enable1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x54c && offset < 0x550) {
      offset -= 0x54c;
      r += wac_reg_intr_inject_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x550 && offset < 0x554) {
      offset -= 0x550;
      r += wac_reg_intr_freeze_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += wac_reg_wac_bypass_config_.to_string(print_zeros,indent_string) ;
    r += wac_reg_ctr_drop_no_dst_.to_string(print_zeros,indent_string) ;
    r += wac_reg_ctr_drop_sop_by_sop_.to_string(print_zeros,indent_string) ;
    r += wac_reg_ctr_vld_sop_.to_string(print_zeros,indent_string) ;
    r += wac_reg_wac_drop_buf_full_.to_string(print_zeros,indent_string) ;
    r += wac_reg_wac_debug_register_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<32;++a0) {
      r += wac_reg_offset_profile_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += wac_reg_port_pfc_en_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += wac_reg_port_pause_en_[a0].to_string(print_zeros,indent_string) ;
    }
    r += wac_reg_wac_ecc_.to_string(print_zeros,indent_string) ;
    r += wac_reg_ppg_mapping_table_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += wac_reg_ppg_mapping_table_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += wac_reg_ppg_drop_cnt_table_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += wac_reg_ppg_drop_cnt_table_mbe_errlog_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<73;++a0) {
      r += wac_reg_wac_drop_count_port_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<201;++a0) {
      r += wac_reg_wac_drop_count_ppg_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<73;++a0) {
      r += wac_reg_wac_pfc_state_[a0].to_string(print_zeros,indent_string) ;
    }
    r += wac_reg_wac_ppg_drop_state0_.to_string(print_zeros,indent_string) ;
    r += wac_reg_wac_ppg_drop_state1_.to_string(print_zeros,indent_string) ;
    r += wac_reg_wac_port_drop_state_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<8;++a0) {
      r += wac_reg_wac_pre_fifo_mapping_[a0].to_string(print_zeros,indent_string) ;
    }
    r += wac_reg_debug_bus_ctrl_.to_string(print_zeros,indent_string) ;
    r += wac_reg_intr_.to_string(print_zeros,indent_string) ;
    r += wac_reg_intr_status_.to_string(print_zeros,indent_string) ;
    r += wac_reg_intr_enable0_.to_string(print_zeros,indent_string) ;
    r += wac_reg_intr_enable1_.to_string(print_zeros,indent_string) ;
    r += wac_reg_intr_inject_.to_string(print_zeros,indent_string) ;
    r += wac_reg_intr_freeze_enable_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  WacBypass wac_reg_wac_bypass_config_;
  PipeRegCtrDropNoDst wac_reg_ctr_drop_no_dst_;
  PipeRegCtrDropSopBySop wac_reg_ctr_drop_sop_by_sop_;
  PipeRegCtrVldSop wac_reg_ctr_vld_sop_;
  PipeRegWacDropBufFull wac_reg_wac_drop_buf_full_;
  WacDebugRegister wac_reg_wac_debug_register_;
  std::array< WacOffset, 32 > wac_reg_offset_profile_;
  std::array< WacPortPfcEn, 72 > wac_reg_port_pfc_en_;
  std::array< WacPortPauseEn, 72 > wac_reg_port_pause_en_;
  PipeRegWacEcc wac_reg_wac_ecc_;
  PipeRegPpgMappingTableSbeErrlog wac_reg_ppg_mapping_table_sbe_errlog_;
  PipeRegPpgMappingTableMbeErrlog wac_reg_ppg_mapping_table_mbe_errlog_;
  PipeRegPpgDropCntTableSbeErrlog wac_reg_ppg_drop_cnt_table_sbe_errlog_;
  PipeRegPpgDropCntTableMbeErrlog wac_reg_ppg_drop_cnt_table_mbe_errlog_;
  std::array< WacDropCountPort, 73 > wac_reg_wac_drop_count_port_;
  std::array< WacDropCountPpg, 201 > wac_reg_wac_drop_count_ppg_;
  std::array< WacPfcState, 73 > wac_reg_wac_pfc_state_;
  WacPpgDropState wac_reg_wac_ppg_drop_state0_;
  WacPpgDropState wac_reg_wac_ppg_drop_state1_;
  WacPortDropState wac_reg_wac_port_drop_state_;
  std::array< WacPreFifoMapping, 8 > wac_reg_wac_pre_fifo_mapping_;
  PipeRegDebugBusCtrl wac_reg_debug_bus_ctrl_;
  PipeRegIntr wac_reg_intr_;
  PipeRegIntrStatus wac_reg_intr_status_;
  PipeRegIntrEnable0 wac_reg_intr_enable0_;
  PipeRegIntrEnable1 wac_reg_intr_enable1_;
  PipeRegIntrInject wac_reg_intr_inject_;
  PipeRegIntrFreezeEnable wac_reg_intr_freeze_enable_;
private:
  static int StartOffset(
      int index_tm_wac_pipe_rspec
      ) {
    int offset=0;
    offset += 0x400000; // to get to tm_top
    assert(index_tm_wac_pipe_rspec < 4);
    offset += index_tm_wac_pipe_rspec * 0x8000; // tm_wac_pipe_rspec[]
    return offset;
  }

};





  }; // namespace register_classes
}; // namespace tofino

#endif // __REGISTER_INCLUDES_PIPE_REG_H__
