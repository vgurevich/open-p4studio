/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_DPRSR_OE_REGS_MUTABLE_H__
#define __REGISTER_INCLUDES_DPRSR_OE_REGS_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "dpr_o_dbg_ctrl_r_mutable.h"
#include "dpr_o_dbg_r_mutable.h"
#include "dprsr_byte_adj_fifo_thresh_r_mutable.h"
#include "dprsr_c_r_c640_cfg_r_mutable.h"
#include "dprsr_c_r_c_cfg_r_mutable.h"
#include "dprsr_c_r_c_chk_dis_r_mutable.h"
#include "dprsr_c_t_m_ch_empty_r_mutable.h"
#include "dprsr_cnt_oe_pkts_mutable.h"
#include "dprsr_ctm_sop_thresh_r_mutable.h"
#include "dprsr_edf_cfg_r_mutable.h"
#include "dprsr_edf_max_ctr_r_mutable.h"
#include "dprsr_edf_thresh_hi_r_mutable.h"
#include "dprsr_edf_thresh_r_mutable.h"
#include "dprsr_edf_watermark_r_mutable.h"
#include "dprsr_hdr_sop_thresh_r_mutable.h"
#include "dprsr_load_interval_r_mutable.h"
#include "dprsr_o_ctm_delay_cfg_r_mutable.h"
#include "dprsr_oe_ebuf_ctrl_r_mutable.h"
#include "dprsr_oe_regs_ctm_crc_err_mutable.h"
#include "dprsr_oe_regs_diagbus_cfg_mutable.h"
#include "dprsr_oe_regs_e_ctm_pkt_err_mutable.h"
#include "dprsr_oe_regs_e_disc_pkts_mutable.h"
#include "dprsr_oe_regs_e_egr_pkt_err_mutable.h"
#include "dprsr_oe_regs_e_fwd_pkts_mutable.h"
#include "dprsr_oe_regs_e_mirr_hdr_mbe_errlog_mutable.h"
#include "dprsr_oe_regs_e_mirr_hdr_mbe_mutable.h"
#include "dprsr_oe_regs_e_mirr_hdr_mutable.h"
#include "dprsr_oe_regs_e_mirr_hdr_sbe_errlog_mutable.h"
#include "dprsr_oe_regs_e_mirr_hdr_sbe_mutable.h"
#include "dprsr_oe_regs_e_mirr_pkts_mutable.h"
#include "dprsr_oe_regs_intr_mutable.h"
#include "dprsr_oe_regs_mirr_hdr_e_mbe_err_mutable.h"
#include "dprsr_oe_regs_mirr_hdr_e_sbe_err_mutable.h"
#include "dprsr_oe_regs_offset_beyond_pkt_err_mutable.h"
#include "dprsr_out_arbiter_ctrl_r_mutable.h"

namespace tofinoB0 {
  namespace register_classes {

class DprsrOeRegsMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  DprsrOeRegsMutable(
      int chipNumber, int index_pipe_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap), 4096, true, write_callback, read_callback, std::string("DprsrOeRegsMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap))
    {
    }
  DprsrOeRegsMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "DprsrOeRegsMutable")
    {
    }
public:





  DprsrOutArbiterCtrlRMutable &arb_ctrl() { return arb_ctrl_; }





  DprsrCntOePktsMutable &cnt_pkts() { return cnt_pkts_; }





  DprsrOeEbufCtrlRMutable &ebuf_ctrl() { return ebuf_ctrl_; }





  DprsrCRCCfgRMutable &crc_zero() { return crc_zero_; }





  DprsrCRCChkDisRMutable &crc_chk() { return crc_chk_; }





  DprsrCRC640CfgRMutable &crc_gen_cfg() { return crc_gen_cfg_; }





  DprsrCTMChEmptyRMutable &ctm_ch_fifo() { return ctm_ch_fifo_; }






  DprsrByteAdjFifoThreshRMutable &byte_adj() { return byte_adj_; }





  DprODbgCtrlRMutable &arb_dbg_ctrl() { return arb_dbg_ctrl_; }






  DprODbgRMutable &arb_dbg() { return arb_dbg_; }






  DprsrOeRegsEMirrHdrMutable &e_mirr_hdr() { return e_mirr_hdr_; }





  DprsrOeRegsEMirrHdrSbeMutable &e_mirr_hdr_sbe() { return e_mirr_hdr_sbe_; }





  DprsrOeRegsEMirrHdrMbeMutable &e_mirr_hdr_mbe() { return e_mirr_hdr_mbe_; }





  DprsrOeRegsEMirrHdrMbeErrlogMutable &e_mirr_hdr_mbe_errlog() { return e_mirr_hdr_mbe_errlog_; }





  DprsrOeRegsEMirrHdrSbeErrlogMutable &e_mirr_hdr_sbe_errlog() { return e_mirr_hdr_sbe_errlog_; }





  DprsrOeRegsMirrHdrESbeErrMutable &mirr_hdr_e_sbe_err() { return mirr_hdr_e_sbe_err_; }





  DprsrOeRegsMirrHdrEMbeErrMutable &mirr_hdr_e_mbe_err() { return mirr_hdr_e_mbe_err_; }







  DprsrOeRegsCtmCrcErrMutable &ctm_crc_err(int j0) { return ctm_crc_err_[j0]; }





  DprsrOeRegsEEgrPktErrMutable &e_egr_pkt_err() { return e_egr_pkt_err_; }





  DprsrOeRegsECtmPktErrMutable &e_ctm_pkt_err() { return e_ctm_pkt_err_; }





  DprsrOeRegsEFwdPktsMutable &e_fwd_pkts() { return e_fwd_pkts_; }





  DprsrOeRegsEDiscPktsMutable &e_disc_pkts() { return e_disc_pkts_; }





  DprsrOeRegsEMirrPktsMutable &e_mirr_pkts() { return e_mirr_pkts_; }





  DprsrOeRegsDiagbusCfgMutable &diagbus_cfg() { return diagbus_cfg_; }





  DprsrOCtmDelayCfgRMutable &ctm_fcu_cfg() { return ctm_fcu_cfg_; }





  DprsrOeRegsOffsetBeyondPktErrMutable &offset_beyond_pkt_err() { return offset_beyond_pkt_err_; }









  DprsrEdfThreshRMutable &edf_min_thresh() { return edf_min_thresh_; }









  DprsrEdfThreshHiRMutable &edf_hi_thresh() { return edf_hi_thresh_; }





  DprsrLoadIntervalRMutable &load_interval() { return load_interval_; }









  DprsrCtmSopThreshRMutable &ctm_sop_thresh() { return ctm_sop_thresh_; }









  DprsrHdrSopThreshRMutable &hdr_sop_thresh() { return hdr_sop_thresh_; }





  DprsrEdfCfgRMutable &edf_cfg() { return edf_cfg_; }





  DprsrEdfMaxCtrRMutable &edf_ctr_limit() { return edf_ctr_limit_; }





  DprsrEdfWatermarkRMutable &edf_water() { return edf_water_; }
  DprsrOeRegsIntrMutable &intr() { return intr_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      if (read_callback_) read_callback_();
      arb_ctrl_.read( offset, data );
    }
    else if (offset >= 0x8 && offset < 0x10) {
      offset -= 0x8;
      if (read_callback_) read_callback_();
      cnt_pkts_.read( offset, data );
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      if (read_callback_) read_callback_();
      ebuf_ctrl_.read( offset, data );
    }
    else if (offset >= 0x20 && offset < 0x2c) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      crc_zero_.read( offset, data );
    }
    else if (offset >= 0x30 && offset < 0x3c) {
      offset -= 0x30;
      if (read_callback_) read_callback_();
      crc_chk_.read( offset, data );
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      if (read_callback_) read_callback_();
      crc_gen_cfg_.read( offset, data );
    }
    else if (offset >= 0x40 && offset < 0x4c) {
      offset -= 0x40;
      if (read_callback_) read_callback_();
      ctm_ch_fifo_.read( offset, data );
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      if (read_callback_) read_callback_();
      byte_adj_.read( offset, data );
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      if (read_callback_) read_callback_();
      arb_dbg_ctrl_.read( offset, data );
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      if (read_callback_) read_callback_();
      arb_dbg_.read( offset, data );
    }
    else if (offset >= 0x600 && offset < 0x604) {
      offset -= 0x600;
      if (read_callback_) read_callback_();
      e_mirr_hdr_.read( offset, data );
    }
    else if (offset >= 0x604 && offset < 0x608) {
      offset -= 0x604;
      if (read_callback_) read_callback_();
      e_mirr_hdr_sbe_.read( offset, data );
    }
    else if (offset >= 0x608 && offset < 0x60c) {
      offset -= 0x608;
      if (read_callback_) read_callback_();
      e_mirr_hdr_mbe_.read( offset, data );
    }
    else if (offset >= 0x634 && offset < 0x638) {
      offset -= 0x634;
      if (read_callback_) read_callback_();
      e_mirr_hdr_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x638 && offset < 0x63c) {
      offset -= 0x638;
      if (read_callback_) read_callback_();
      e_mirr_hdr_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x63c && offset < 0x640) {
      offset -= 0x63c;
      if (read_callback_) read_callback_();
      mirr_hdr_e_sbe_err_.read( offset, data );
    }
    else if (offset >= 0x640 && offset < 0x644) {
      offset -= 0x640;
      if (read_callback_) read_callback_();
      mirr_hdr_e_mbe_err_.read( offset, data );
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      ctm_crc_err_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x920 && offset < 0x924) {
      offset -= 0x920;
      if (read_callback_) read_callback_();
      e_egr_pkt_err_.read( offset, data );
    }
    else if (offset >= 0x924 && offset < 0x928) {
      offset -= 0x924;
      if (read_callback_) read_callback_();
      e_ctm_pkt_err_.read( offset, data );
    }
    else if (offset >= 0x928 && offset < 0x930) {
      offset -= 0x928;
      if (read_callback_) read_callback_();
      e_fwd_pkts_.read( offset, data );
    }
    else if (offset >= 0x930 && offset < 0x938) {
      offset -= 0x930;
      if (read_callback_) read_callback_();
      e_disc_pkts_.read( offset, data );
    }
    else if (offset >= 0x938 && offset < 0x940) {
      offset -= 0x938;
      if (read_callback_) read_callback_();
      e_mirr_pkts_.read( offset, data );
    }
    else if (offset >= 0x940 && offset < 0x944) {
      offset -= 0x940;
      if (read_callback_) read_callback_();
      diagbus_cfg_.read( offset, data );
    }
    else if (offset >= 0x944 && offset < 0x948) {
      offset -= 0x944;
      if (read_callback_) read_callback_();
      ctm_fcu_cfg_.read( offset, data );
    }
    else if (offset >= 0x948 && offset < 0x94c) {
      offset -= 0x948;
      if (read_callback_) read_callback_();
      offset_beyond_pkt_err_.read( offset, data );
    }
    else if (offset >= 0x94c && offset < 0x950) {
      offset -= 0x94c;
      if (read_callback_) read_callback_();
      edf_min_thresh_.read( offset, data );
    }
    else if (offset >= 0x950 && offset < 0x954) {
      offset -= 0x950;
      if (read_callback_) read_callback_();
      edf_hi_thresh_.read( offset, data );
    }
    else if (offset >= 0x954 && offset < 0x958) {
      offset -= 0x954;
      if (read_callback_) read_callback_();
      load_interval_.read( offset, data );
    }
    else if (offset >= 0x958 && offset < 0x95c) {
      offset -= 0x958;
      if (read_callback_) read_callback_();
      ctm_sop_thresh_.read( offset, data );
    }
    else if (offset >= 0x95c && offset < 0x960) {
      offset -= 0x95c;
      if (read_callback_) read_callback_();
      hdr_sop_thresh_.read( offset, data );
    }
    else if (offset >= 0x960 && offset < 0x964) {
      offset -= 0x960;
      if (read_callback_) read_callback_();
      edf_cfg_.read( offset, data );
    }
    else if (offset >= 0x964 && offset < 0x968) {
      offset -= 0x964;
      if (read_callback_) read_callback_();
      edf_ctr_limit_.read( offset, data );
    }
    else if (offset >= 0x968 && offset < 0x96c) {
      offset -= 0x968;
      if (read_callback_) read_callback_();
      edf_water_.read( offset, data );
    }
    else if (offset >= 0x620 && offset < 0x634) {
      offset -= 0x620;
      if (read_callback_) read_callback_();
      intr_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      arb_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8 && offset < 0x10) {
      offset -= 0x8;
      cnt_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      ebuf_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20 && offset < 0x2c) {
      offset -= 0x20;
      crc_zero_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x30 && offset < 0x3c) {
      offset -= 0x30;
      crc_chk_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      crc_gen_cfg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40 && offset < 0x4c) {
      offset -= 0x40;
      ctm_ch_fifo_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      byte_adj_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      arb_dbg_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      arb_dbg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x600 && offset < 0x604) {
      offset -= 0x600;
      e_mirr_hdr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x604 && offset < 0x608) {
      offset -= 0x604;
      e_mirr_hdr_sbe_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x608 && offset < 0x60c) {
      offset -= 0x608;
      e_mirr_hdr_mbe_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x634 && offset < 0x638) {
      offset -= 0x634;
      e_mirr_hdr_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x638 && offset < 0x63c) {
      offset -= 0x638;
      e_mirr_hdr_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x63c && offset < 0x640) {
      offset -= 0x63c;
      mirr_hdr_e_sbe_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x640 && offset < 0x644) {
      offset -= 0x640;
      mirr_hdr_e_mbe_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      ctm_crc_err_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x920 && offset < 0x924) {
      offset -= 0x920;
      e_egr_pkt_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x924 && offset < 0x928) {
      offset -= 0x924;
      e_ctm_pkt_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x928 && offset < 0x930) {
      offset -= 0x928;
      e_fwd_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x930 && offset < 0x938) {
      offset -= 0x930;
      e_disc_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x938 && offset < 0x940) {
      offset -= 0x938;
      e_mirr_pkts_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x940 && offset < 0x944) {
      offset -= 0x940;
      diagbus_cfg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x944 && offset < 0x948) {
      offset -= 0x944;
      ctm_fcu_cfg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x948 && offset < 0x94c) {
      offset -= 0x948;
      offset_beyond_pkt_err_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x94c && offset < 0x950) {
      offset -= 0x94c;
      edf_min_thresh_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x950 && offset < 0x954) {
      offset -= 0x950;
      edf_hi_thresh_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x954 && offset < 0x958) {
      offset -= 0x954;
      load_interval_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x958 && offset < 0x95c) {
      offset -= 0x958;
      ctm_sop_thresh_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x95c && offset < 0x960) {
      offset -= 0x95c;
      hdr_sop_thresh_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x960 && offset < 0x964) {
      offset -= 0x960;
      edf_cfg_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x964 && offset < 0x968) {
      offset -= 0x964;
      edf_ctr_limit_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x968 && offset < 0x96c) {
      offset -= 0x968;
      edf_water_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x620 && offset < 0x634) {
      offset -= 0x620;
      intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    arb_ctrl_.reset();
    cnt_pkts_.reset();
    ebuf_ctrl_.reset();
    crc_zero_.reset();
    crc_chk_.reset();
    crc_gen_cfg_.reset();
    ctm_ch_fifo_.reset();
    byte_adj_.reset();
    arb_dbg_ctrl_.reset();
    arb_dbg_.reset();
    e_mirr_hdr_.reset();
    e_mirr_hdr_sbe_.reset();
    e_mirr_hdr_mbe_.reset();
    e_mirr_hdr_mbe_errlog_.reset();
    e_mirr_hdr_sbe_errlog_.reset();
    mirr_hdr_e_sbe_err_.reset();
    mirr_hdr_e_mbe_err_.reset();
    for (auto &f0 : ctm_crc_err_) {
      f0.reset();
    }
    e_egr_pkt_err_.reset();
    e_ctm_pkt_err_.reset();
    e_fwd_pkts_.reset();
    e_disc_pkts_.reset();
    e_mirr_pkts_.reset();
    diagbus_cfg_.reset();
    ctm_fcu_cfg_.reset();
    offset_beyond_pkt_err_.reset();
    edf_min_thresh_.reset();
    edf_hi_thresh_.reset();
    load_interval_.reset();
    ctm_sop_thresh_.reset();
    hdr_sop_thresh_.reset();
    edf_cfg_.reset();
    edf_ctr_limit_.reset();
    edf_water_.reset();
    intr_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      r += arb_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8 && offset < 0x10) {
      offset -= 0x8;
      r += cnt_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      r += ebuf_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20 && offset < 0x2c) {
      offset -= 0x20;
      r += crc_zero_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x30 && offset < 0x3c) {
      offset -= 0x30;
      r += crc_chk_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      r += crc_gen_cfg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40 && offset < 0x4c) {
      offset -= 0x40;
      r += ctm_ch_fifo_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      r += byte_adj_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      r += arb_dbg_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      r += arb_dbg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x600 && offset < 0x604) {
      offset -= 0x600;
      r += e_mirr_hdr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x604 && offset < 0x608) {
      offset -= 0x604;
      r += e_mirr_hdr_sbe_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x608 && offset < 0x60c) {
      offset -= 0x608;
      r += e_mirr_hdr_mbe_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x634 && offset < 0x638) {
      offset -= 0x634;
      r += e_mirr_hdr_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x638 && offset < 0x63c) {
      offset -= 0x638;
      r += e_mirr_hdr_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x63c && offset < 0x640) {
      offset -= 0x63c;
      r += mirr_hdr_e_sbe_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x640 && offset < 0x644) {
      offset -= 0x640;
      r += mirr_hdr_e_mbe_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x800 && offset < 0x920) {
      offset -= 0x800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += ctm_crc_err_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x920 && offset < 0x924) {
      offset -= 0x920;
      r += e_egr_pkt_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x924 && offset < 0x928) {
      offset -= 0x924;
      r += e_ctm_pkt_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x928 && offset < 0x930) {
      offset -= 0x928;
      r += e_fwd_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x930 && offset < 0x938) {
      offset -= 0x930;
      r += e_disc_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x938 && offset < 0x940) {
      offset -= 0x938;
      r += e_mirr_pkts_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x940 && offset < 0x944) {
      offset -= 0x940;
      r += diagbus_cfg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x944 && offset < 0x948) {
      offset -= 0x944;
      r += ctm_fcu_cfg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x948 && offset < 0x94c) {
      offset -= 0x948;
      r += offset_beyond_pkt_err_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x94c && offset < 0x950) {
      offset -= 0x94c;
      r += edf_min_thresh_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x950 && offset < 0x954) {
      offset -= 0x950;
      r += edf_hi_thresh_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x954 && offset < 0x958) {
      offset -= 0x954;
      r += load_interval_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x958 && offset < 0x95c) {
      offset -= 0x958;
      r += ctm_sop_thresh_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x95c && offset < 0x960) {
      offset -= 0x95c;
      r += hdr_sop_thresh_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x960 && offset < 0x964) {
      offset -= 0x960;
      r += edf_cfg_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x964 && offset < 0x968) {
      offset -= 0x964;
      r += edf_ctr_limit_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x968 && offset < 0x96c) {
      offset -= 0x968;
      r += edf_water_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x620 && offset < 0x634) {
      offset -= 0x620;
      r += intr_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += arb_ctrl_.to_string(print_zeros,indent_string) ;
    r += cnt_pkts_.to_string(print_zeros,indent_string) ;
    r += ebuf_ctrl_.to_string(print_zeros,indent_string) ;
    r += crc_zero_.to_string(print_zeros,indent_string) ;
    r += crc_chk_.to_string(print_zeros,indent_string) ;
    r += crc_gen_cfg_.to_string(print_zeros,indent_string) ;
    r += ctm_ch_fifo_.to_string(print_zeros,indent_string) ;
    r += byte_adj_.to_string(print_zeros,indent_string) ;
    r += arb_dbg_ctrl_.to_string(print_zeros,indent_string) ;
    r += arb_dbg_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_sbe_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_mbe_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += e_mirr_hdr_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += mirr_hdr_e_sbe_err_.to_string(print_zeros,indent_string) ;
    r += mirr_hdr_e_mbe_err_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<72;++a0) {
      r += ctm_crc_err_[a0].to_string(print_zeros,indent_string) ;
    }
    r += e_egr_pkt_err_.to_string(print_zeros,indent_string) ;
    r += e_ctm_pkt_err_.to_string(print_zeros,indent_string) ;
    r += e_fwd_pkts_.to_string(print_zeros,indent_string) ;
    r += e_disc_pkts_.to_string(print_zeros,indent_string) ;
    r += e_mirr_pkts_.to_string(print_zeros,indent_string) ;
    r += diagbus_cfg_.to_string(print_zeros,indent_string) ;
    r += ctm_fcu_cfg_.to_string(print_zeros,indent_string) ;
    r += offset_beyond_pkt_err_.to_string(print_zeros,indent_string) ;
    r += edf_min_thresh_.to_string(print_zeros,indent_string) ;
    r += edf_hi_thresh_.to_string(print_zeros,indent_string) ;
    r += load_interval_.to_string(print_zeros,indent_string) ;
    r += ctm_sop_thresh_.to_string(print_zeros,indent_string) ;
    r += hdr_sop_thresh_.to_string(print_zeros,indent_string) ;
    r += edf_cfg_.to_string(print_zeros,indent_string) ;
    r += edf_ctr_limit_.to_string(print_zeros,indent_string) ;
    r += edf_water_.to_string(print_zeros,indent_string) ;
    r += intr_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  DprsrOutArbiterCtrlRMutable arb_ctrl_;
  DprsrCntOePktsMutable cnt_pkts_;
  DprsrOeEbufCtrlRMutable ebuf_ctrl_;
  DprsrCRCCfgRMutable crc_zero_;
  DprsrCRCChkDisRMutable crc_chk_;
  DprsrCRC640CfgRMutable crc_gen_cfg_;
  DprsrCTMChEmptyRMutable ctm_ch_fifo_;
  DprsrByteAdjFifoThreshRMutable byte_adj_;
  DprODbgCtrlRMutable arb_dbg_ctrl_;
  DprODbgRMutable arb_dbg_;
  DprsrOeRegsEMirrHdrMutable e_mirr_hdr_;
  DprsrOeRegsEMirrHdrSbeMutable e_mirr_hdr_sbe_;
  DprsrOeRegsEMirrHdrMbeMutable e_mirr_hdr_mbe_;
  DprsrOeRegsEMirrHdrMbeErrlogMutable e_mirr_hdr_mbe_errlog_;
  DprsrOeRegsEMirrHdrSbeErrlogMutable e_mirr_hdr_sbe_errlog_;
  DprsrOeRegsMirrHdrESbeErrMutable mirr_hdr_e_sbe_err_;
  DprsrOeRegsMirrHdrEMbeErrMutable mirr_hdr_e_mbe_err_;
  std::array< DprsrOeRegsCtmCrcErrMutable, 72 > ctm_crc_err_;
  DprsrOeRegsEEgrPktErrMutable e_egr_pkt_err_;
  DprsrOeRegsECtmPktErrMutable e_ctm_pkt_err_;
  DprsrOeRegsEFwdPktsMutable e_fwd_pkts_;
  DprsrOeRegsEDiscPktsMutable e_disc_pkts_;
  DprsrOeRegsEMirrPktsMutable e_mirr_pkts_;
  DprsrOeRegsDiagbusCfgMutable diagbus_cfg_;
  DprsrOCtmDelayCfgRMutable ctm_fcu_cfg_;
  DprsrOeRegsOffsetBeyondPktErrMutable offset_beyond_pkt_err_;
  DprsrEdfThreshRMutable edf_min_thresh_;
  DprsrEdfThreshHiRMutable edf_hi_thresh_;
  DprsrLoadIntervalRMutable load_interval_;
  DprsrCtmSopThreshRMutable ctm_sop_thresh_;
  DprsrHdrSopThreshRMutable hdr_sop_thresh_;
  DprsrEdfCfgRMutable edf_cfg_;
  DprsrEdfMaxCtrRMutable edf_ctr_limit_;
  DprsrEdfWatermarkRMutable edf_water_;
  DprsrOeRegsIntrMutable intr_;
private:
  static int StartOffset(
      int index_pipe_addrmap
      ) {
    int offset=0;
    offset += 0x2000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x800000; // pipe_addrmap[]
    offset += 0x780000; // to get to deparser
    offset += 0x18000; // to get to out_egr
    return offset;
  }

};











  }; // namespace register_classes
}; // namespace tofinoB0

#endif // __REGISTER_INCLUDES_DPRSR_OE_REGS_MUTABLE_H__
