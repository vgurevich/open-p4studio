/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_DRU_RSPEC_MUTABLE_H__
#define __REGISTER_INCLUDES_DRU_RSPEC_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "dr_base_addr_high_mutable.h"
#include "dr_base_addr_low_mutable.h"
#include "dr_ctrl_mutable.h"
#include "dr_data_timeout_mutable.h"
#include "dr_head_ptr_mutable.h"
#include "dr_limit_addr_high_mutable.h"
#include "dr_limit_addr_low_mutable.h"
#include "dr_ring_timeout_mutable.h"
#include "dr_size_mutable.h"
#include "dr_status_mutable.h"
#include "dr_tail_ptr_mutable.h"

namespace tofinoB0 {
  namespace register_classes {

class DruRspecMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  enum CbcRspecEnum {
    kCbcLqFmDr,
    kCbcLqRxDr,
    kCbcWlCplDr,
    kCbcWlTxDr
  };
  enum MbcRspecEnum {
    kMbcMacCplDr,
    kMbcMacTxDr
  };
  enum PbcRspecEnum {
    kPbcDiagFmDr,
    kPbcDiagRxDr,
    kPbcIdleFmDr,
    kPbcIdleRxDr,
    kPbcIlCplDr,
    kPbcIlTxDr,
    kPbcRbCplDr,
    kPbcRbTxDr,
    kPbcStatFmDr,
    kPbcStatRxDr,
    kPbcWbCplDr,
    kPbcWbTxDr
  };
  enum TbcRspecEnum {
    kTbcCplDr,
    kTbcFmDr,
    kTbcRxDr,
    kTbcTxDr
  };
public:
  DruRspecMutable(
      int chipNumber, CbcRspecEnum selector_cbc_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_cbc_rspec), 44, true, write_callback, read_callback, std::string("DruRspecMutable")+":"+boost::lexical_cast<std::string>(selector_cbc_rspec))
    {
    }
  DruRspecMutable(
      int chipNumber, MbcRspecEnum selector_mbc_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_mbc_rspec), 44, true, write_callback, read_callback, std::string("DruRspecMutable")+":"+boost::lexical_cast<std::string>(selector_mbc_rspec))
    {
    }
  DruRspecMutable(
      int chipNumber, PbcRspecEnum selector_pbc_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_pbc_rspec), 44, true, write_callback, read_callback, std::string("DruRspecMutable")+":"+boost::lexical_cast<std::string>(selector_pbc_rspec))
    {
    }
  DruRspecMutable(
      int chipNumber, PbcRspecEnum selector_pbc_rspec, int index_dru_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_pbc_rspec, index_dru_rspec), 44, true, write_callback, read_callback, std::string("DruRspecMutable")+":"+boost::lexical_cast<std::string>(selector_pbc_rspec) + "," + boost::lexical_cast<std::string>(index_dru_rspec))
    {
    }
  DruRspecMutable(
      int chipNumber, TbcRspecEnum selector_tbc_rspec, int index_dru_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(selector_tbc_rspec, index_dru_rspec), 44, true, write_callback, read_callback, std::string("DruRspecMutable")+":"+boost::lexical_cast<std::string>(selector_tbc_rspec) + "," + boost::lexical_cast<std::string>(index_dru_rspec))
    {
    }
  DruRspecMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "DruRspecMutable")
    {
    }
public:





  DrCtrlMutable &ctrl() { return ctrl_; }





  DrBaseAddrLowMutable &base_addr_low() { return base_addr_low_; }





  DrBaseAddrHighMutable &base_addr_high() { return base_addr_high_; }





  DrLimitAddrLowMutable &limit_addr_low() { return limit_addr_low_; }





  DrLimitAddrHighMutable &limit_addr_high() { return limit_addr_high_; }





  DrSizeMutable &size() { return size_; }





  DrHeadPtrMutable &head_ptr() { return head_ptr_; }





  DrTailPtrMutable &tail_ptr() { return tail_ptr_; }





  DrRingTimeoutMutable &ring_timeout() { return ring_timeout_; }





  DrDataTimeoutMutable &data_timeout() { return data_timeout_; }





  DrStatusMutable &status() { return status_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset < 0x4) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      ctrl_.read( offset, data );
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      if (read_callback_) read_callback_();
      base_addr_low_.read( offset, data );
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      if (read_callback_) read_callback_();
      base_addr_high_.read( offset, data );
    }
    else if (offset >= 0xc && offset < 0x10) {
      offset -= 0xc;
      if (read_callback_) read_callback_();
      limit_addr_low_.read( offset, data );
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      if (read_callback_) read_callback_();
      limit_addr_high_.read( offset, data );
    }
    else if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      if (read_callback_) read_callback_();
      size_.read( offset, data );
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      if (read_callback_) read_callback_();
      head_ptr_.read( offset, data );
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      if (read_callback_) read_callback_();
      tail_ptr_.read( offset, data );
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      ring_timeout_.read( offset, data );
    }
    else if (offset >= 0x24 && offset < 0x28) {
      offset -= 0x24;
      if (read_callback_) read_callback_();
      data_timeout_.read( offset, data );
    }
    else if (offset >= 0x28 && offset < 0x2c) {
      offset -= 0x28;
      if (read_callback_) read_callback_();
      status_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset < 0x4) {
      offset -= 0x0;
      ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      base_addr_low_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      base_addr_high_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc && offset < 0x10) {
      offset -= 0xc;
      limit_addr_low_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      limit_addr_high_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      size_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      head_ptr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      tail_ptr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      ring_timeout_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x24 && offset < 0x28) {
      offset -= 0x24;
      data_timeout_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28 && offset < 0x2c) {
      offset -= 0x28;
      status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    ctrl_.reset();
    base_addr_low_.reset();
    base_addr_high_.reset();
    limit_addr_low_.reset();
    limit_addr_high_.reset();
    size_.reset();
    head_ptr_.reset();
    tail_ptr_.reset();
    ring_timeout_.reset();
    data_timeout_.reset();
    status_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x4) {
      offset -= 0x0;
      r += ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      r += base_addr_low_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      r += base_addr_high_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc && offset < 0x10) {
      offset -= 0xc;
      r += limit_addr_low_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      r += limit_addr_high_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      r += size_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      r += head_ptr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      r += tail_ptr_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      r += ring_timeout_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x24 && offset < 0x28) {
      offset -= 0x24;
      r += data_timeout_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28 && offset < 0x2c) {
      offset -= 0x28;
      r += status_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += ctrl_.to_string(print_zeros,indent_string) ;
    r += base_addr_low_.to_string(print_zeros,indent_string) ;
    r += base_addr_high_.to_string(print_zeros,indent_string) ;
    r += limit_addr_low_.to_string(print_zeros,indent_string) ;
    r += limit_addr_high_.to_string(print_zeros,indent_string) ;
    r += size_.to_string(print_zeros,indent_string) ;
    r += head_ptr_.to_string(print_zeros,indent_string) ;
    r += tail_ptr_.to_string(print_zeros,indent_string) ;
    r += ring_timeout_.to_string(print_zeros,indent_string) ;
    r += data_timeout_.to_string(print_zeros,indent_string) ;
    r += status_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  DrCtrlMutable ctrl_;
  DrBaseAddrLowMutable base_addr_low_;
  DrBaseAddrHighMutable base_addr_high_;
  DrLimitAddrLowMutable limit_addr_low_;
  DrLimitAddrHighMutable limit_addr_high_;
  DrSizeMutable size_;
  DrHeadPtrMutable head_ptr_;
  DrTailPtrMutable tail_ptr_;
  DrRingTimeoutMutable ring_timeout_;
  DrDataTimeoutMutable data_timeout_;
  DrStatusMutable status_;
private:
  static int StartOffset(
      CbcRspecEnum selector_cbc_rspec
      ) {
    int offset=0;
    offset += 0x140000; // to get to cbc
    switch (selector_cbc_rspec) {
      case kCbcLqFmDr:
        offset += 0x180; // to get to cbc_lq_fm_dr
        break;
      case kCbcLqRxDr:
        offset += 0x1c0; // to get to cbc_lq_rx_dr
        break;
      case kCbcWlCplDr:
        offset += 0x140; // to get to cbc_wl_cpl_dr
        break;
      case kCbcWlTxDr:
        offset += 0x100; // to get to cbc_wl_tx_dr
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      MbcRspecEnum selector_mbc_rspec
      ) {
    int offset=0;
    offset += 0xc0000; // to get to mbc
    switch (selector_mbc_rspec) {
      case kMbcMacCplDr:
        offset += 0x140; // to get to mbc_mac_cpl_dr
        break;
      case kMbcMacTxDr:
        offset += 0x100; // to get to mbc_mac_tx_dr
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      PbcRspecEnum selector_pbc_rspec
      ) {
    int offset=0;
    offset += 0x100000; // to get to pbc
    switch (selector_pbc_rspec) {
      case kPbcDiagFmDr:
        offset += 0xa00; // to get to pbc_diag_fm_dr
        break;
      case kPbcDiagRxDr:
        offset += 0xa40; // to get to pbc_diag_rx_dr
        break;
      case kPbcIdleFmDr:
        offset += 0x980; // to get to pbc_idle_fm_dr
        break;
      case kPbcIdleRxDr:
        offset += 0x9c0; // to get to pbc_idle_rx_dr
        break;
      case kPbcRbCplDr:
        offset += 0x8c0; // to get to pbc_rb_cpl_dr
        break;
      case kPbcRbTxDr:
        offset += 0x880; // to get to pbc_rb_tx_dr
        break;
      case kPbcStatFmDr:
        offset += 0x900; // to get to pbc_stat_fm_dr
        break;
      case kPbcStatRxDr:
        offset += 0x940; // to get to pbc_stat_rx_dr
        break;
      case kPbcWbCplDr:
        offset += 0x840; // to get to pbc_wb_cpl_dr
        break;
      case kPbcWbTxDr:
        offset += 0x800; // to get to pbc_wb_tx_dr
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      PbcRspecEnum selector_pbc_rspec, int index_dru_rspec
      ) {
    int offset=0;
    offset += 0x100000; // to get to pbc
    switch (selector_pbc_rspec) {
      case kPbcIlCplDr:
        offset += 0x600; // to get to pbc_il_cpl_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kPbcIlTxDr:
        offset += 0x400; // to get to pbc_il_tx_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

  static int StartOffset(
      TbcRspecEnum selector_tbc_rspec, int index_dru_rspec
      ) {
    int offset=0;
    offset += 0x180000; // to get to tbc
    switch (selector_tbc_rspec) {
      case kTbcCplDr:
        offset += 0x200; // to get to tbc_cpl_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kTbcFmDr:
        offset += 0x400; // to get to tbc_fm_dr
        assert(index_dru_rspec < 8);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kTbcRxDr:
        offset += 0x600; // to get to tbc_rx_dr
        assert(index_dru_rspec < 8);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      case kTbcTxDr:
        offset += 0x100; // to get to tbc_tx_dr
        assert(index_dru_rspec < 4);
        offset += index_dru_rspec * 0x2c; // dru_rspec[]
        break;
      default:
        assert(0);
        break;
    }
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace tofinoB0

#endif // __REGISTER_INCLUDES_DRU_RSPEC_MUTABLE_H__
