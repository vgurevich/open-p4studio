/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_MAU_DATAPATH_ADDRMAP_MUTABLE_H__
#define __REGISTER_INCLUDES_MAU_DATAPATH_ADDRMAP_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "action_output_delay_mutable.h"
#include "actionmux_din_power_ctl_mutable.h"
#include "cur_stage_dependency_on_prev_mutable.h"
#include "hashout_ctl_mutable.h"
#include "imem_parity_ctl_mutable.h"
#include "imem_sbe_errlog_mutable.h"
#include "imem_table_addr_egress_mutable.h"
#include "intr_enable0_mau_gfm_hash_mutable.h"
#include "intr_enable0_mau_imem_mutable.h"
#include "intr_enable0_mau_snapshot_mutable.h"
#include "intr_enable1_mau_gfm_hash_mutable.h"
#include "intr_enable1_mau_imem_mutable.h"
#include "intr_enable1_mau_snapshot_mutable.h"
#include "intr_freeze_enable_mau_gfm_hash_mutable.h"
#include "intr_freeze_enable_mau_imem_mutable.h"
#include "intr_freeze_enable_mau_snapshot_mutable.h"
#include "intr_inject_mau_gfm_hash_mutable.h"
#include "intr_inject_mau_imem_mutable.h"
#include "intr_inject_mau_snapshot_mutable.h"
#include "intr_status_mau_gfm_hash_mutable.h"
#include "intr_status_mau_imem_mutable.h"
#include "intr_status_mau_snapshot_mutable.h"
#include "match_ie_input_mux_sel_mutable.h"
#include "match_input_xbar_din_power_ctl_mutable.h"
#include "mau_diag_adb_ctl_mutable.h"
#include "mau_imem_addrmap_mutable.h"
#include "mau_match_input_xbar_exact_match_enable_mutable.h"
#include "mau_match_input_xbar_hash_addrmap_mutable.h"
#include "mau_scratch_mutable.h"
#include "mau_snapshot_control_addrmap_mutable.h"
#include "mau_snapshot_datapath_addrmap_mutable.h"
#include "next_stage_dependency_on_cur_mutable.h"
#include "phv_egress_thread_alu_mutable.h"
#include "phv_egress_thread_imem_mutable.h"
#include "phv_egress_thread_mutable.h"
#include "phv_fifo_enable_mutable.h"
#include "phv_ingress_thread_alu_mutable.h"
#include "phv_ingress_thread_imem_mutable.h"
#include "phv_ingress_thread_mutable.h"
#include "pipelength_added_stages_mutable.h"
#include "stage_concurrent_with_prev_mutable.h"

namespace tofinoB0 {
  namespace register_classes {

class MauDatapathAddrmapMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  MauDatapathAddrmapMutable(
      int chipNumber, int index_pipe_addrmap, int index_mau_addrmap, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_pipe_addrmap, index_mau_addrmap), 131072, true, write_callback, read_callback, std::string("MauDatapathAddrmapMutable")+":"+boost::lexical_cast<std::string>(index_pipe_addrmap) + "," + boost::lexical_cast<std::string>(index_mau_addrmap))
    {
    }
  MauDatapathAddrmapMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "MauDatapathAddrmapMutable")
    {
    }
public:











  PhvIngressThreadImemMutable &phv_ingress_thread_imem(int j1,int j0) { return phv_ingress_thread_imem_[j1][j0]; }











  PhvEgressThreadImemMutable &phv_egress_thread_imem(int j1,int j0) { return phv_egress_thread_imem_[j1][j0]; }



















  ActionmuxDinPowerCtlMutable &actionmux_din_power_ctl(int j1,int j0) { return actionmux_din_power_ctl_[j1][j0]; }




















  MatchInputXbarDinPowerCtlMutable &match_input_xbar_din_power_ctl(int j1,int j0) { return match_input_xbar_din_power_ctl_[j1][j0]; }





  IntrFreezeEnableMauImemMutable &intr_freeze_enable_mau_imem() { return intr_freeze_enable_mau_imem_; }






  IntrStatusMauSnapshotMutable &intr_status_mau_snapshot() { return intr_status_mau_snapshot_; }






  IntrEnable0MauSnapshotMutable &intr_enable0_mau_snapshot() { return intr_enable0_mau_snapshot_; }






  IntrEnable1MauSnapshotMutable &intr_enable1_mau_snapshot() { return intr_enable1_mau_snapshot_; }







  IntrInjectMauSnapshotMutable &intr_inject_mau_snapshot() { return intr_inject_mau_snapshot_; }





  IntrFreezeEnableMauSnapshotMutable &intr_freeze_enable_mau_snapshot() { return intr_freeze_enable_mau_snapshot_; }





  MauScratchMutable &mau_scratch() { return mau_scratch_; }






  ImemSbeErrlogMutable &imem_sbe_errlog() { return imem_sbe_errlog_; }



















  HashoutCtlMutable &hashout_ctl() { return hashout_ctl_; }






  IntrStatusMauGfmHashMutable &intr_status_mau_gfm_hash() { return intr_status_mau_gfm_hash_; }






  IntrEnable0MauGfmHashMutable &intr_enable0_mau_gfm_hash() { return intr_enable0_mau_gfm_hash_; }






  IntrEnable1MauGfmHashMutable &intr_enable1_mau_gfm_hash() { return intr_enable1_mau_gfm_hash_; }







  IntrInjectMauGfmHashMutable &intr_inject_mau_gfm_hash() { return intr_inject_mau_gfm_hash_; }





  IntrFreezeEnableMauGfmHashMutable &intr_freeze_enable_mau_gfm_hash() { return intr_freeze_enable_mau_gfm_hash_; }















  ActionOutputDelayMutable &action_output_delay(int j0) { return action_output_delay_[j0]; }













  CurStageDependencyOnPrevMutable &cur_stage_dependency_on_prev(int j0) { return cur_stage_dependency_on_prev_[j0]; }













  NextStageDependencyOnCurMutable &next_stage_dependency_on_cur(int j0) { return next_stage_dependency_on_cur_[j0]; }










  PipelengthAddedStagesMutable &pipelength_added_stages(int j0) { return pipelength_added_stages_[j0]; }










  MauMatchInputXbarExactMatchEnableMutable &mau_match_input_xbar_exact_match_enable(int j0) { return mau_match_input_xbar_exact_match_enable_[j0]; }














  MatchIeInputMuxSelMutable &match_ie_input_mux_sel() { return match_ie_input_mux_sel_; }








  ImemParityCtlMutable &imem_parity_ctl() { return imem_parity_ctl_; }












  PhvFifoEnableMutable &phv_fifo_enable() { return phv_fifo_enable_; }






  StageConcurrentWithPrevMutable &stage_concurrent_with_prev() { return stage_concurrent_with_prev_; }








  ImemTableAddrEgressMutable &imem_table_addr_egress() { return imem_table_addr_egress_; }





  MauDiagAdbCtlMutable &mau_diag_adb_ctl() { return mau_diag_adb_ctl_; }






  IntrStatusMauImemMutable &intr_status_mau_imem() { return intr_status_mau_imem_; }






  IntrEnable0MauImemMutable &intr_enable0_mau_imem() { return intr_enable0_mau_imem_; }






  IntrEnable1MauImemMutable &intr_enable1_mau_imem() { return intr_enable1_mau_imem_; }







  IntrInjectMauImemMutable &intr_inject_mau_imem() { return intr_inject_mau_imem_; }

















  PhvIngressThreadMutable &phv_ingress_thread(int j1,int j0) { return phv_ingress_thread_[j1][j0]; }









  PhvEgressThreadMutable &phv_egress_thread(int j1,int j0) { return phv_egress_thread_[j1][j0]; }











  PhvIngressThreadAluMutable &phv_ingress_thread_alu(int j1,int j0) { return phv_ingress_thread_alu_[j1][j0]; }











  PhvEgressThreadAluMutable &phv_egress_thread_alu(int j1,int j0) { return phv_egress_thread_alu_[j1][j0]; }





  MauMatchInputXbarHashAddrmapMutable &xbar_hash() { return xbar_hash_; }





  MauSnapshotControlAddrmapMutable &snapshot_ctl() { return snapshot_ctl_; }





  MauSnapshotDatapathAddrmapMutable &snapshot_dp() { return snapshot_dp_; }





  MauImemAddrmapMutable &imem() { return imem_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x10000 && offset < 0x10080) {
      offset -= 0x10000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_ingress_thread_imem_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10080 && offset < 0x10100) {
      offset -= 0x10080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_egress_thread_imem_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10100 && offset < 0x10180) {
      offset -= 0x10100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      actionmux_din_power_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10180 && offset < 0x10200) {
      offset -= 0x10180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      match_input_xbar_din_power_ctl_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10400 && offset < 0x10404) {
      offset -= 0x10400;
      if (read_callback_) read_callback_();
      intr_freeze_enable_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x10404 && offset < 0x10408) {
      offset -= 0x10404;
      if (read_callback_) read_callback_();
      intr_status_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x10408 && offset < 0x1040c) {
      offset -= 0x10408;
      if (read_callback_) read_callback_();
      intr_enable0_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x1040c && offset < 0x10410) {
      offset -= 0x1040c;
      if (read_callback_) read_callback_();
      intr_enable1_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x10410 && offset < 0x10414) {
      offset -= 0x10410;
      if (read_callback_) read_callback_();
      intr_inject_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x10414 && offset < 0x10418) {
      offset -= 0x10414;
      if (read_callback_) read_callback_();
      intr_freeze_enable_mau_snapshot_.read( offset, data );
    }
    else if (offset >= 0x10418 && offset < 0x1041c) {
      offset -= 0x10418;
      if (read_callback_) read_callback_();
      mau_scratch_.read( offset, data );
    }
    else if (offset >= 0x1041c && offset < 0x10420) {
      offset -= 0x1041c;
      if (read_callback_) read_callback_();
      imem_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x10480 && offset < 0x10484) {
      offset -= 0x10480;
      if (read_callback_) read_callback_();
      hashout_ctl_.read( offset, data );
    }
    else if (offset >= 0x10484 && offset < 0x10488) {
      offset -= 0x10484;
      if (read_callback_) read_callback_();
      intr_status_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x10488 && offset < 0x1048c) {
      offset -= 0x10488;
      if (read_callback_) read_callback_();
      intr_enable0_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x1048c && offset < 0x10490) {
      offset -= 0x1048c;
      if (read_callback_) read_callback_();
      intr_enable1_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x104a0 && offset < 0x104a4) {
      offset -= 0x104a0;
      if (read_callback_) read_callback_();
      intr_inject_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x104a4 && offset < 0x104a8) {
      offset -= 0x104a4;
      if (read_callback_) read_callback_();
      intr_freeze_enable_mau_gfm_hash_.read( offset, data );
    }
    else if (offset >= 0x104b0 && offset < 0x104b8) {
      offset -= 0x104b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      action_output_delay_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x104b8 && offset < 0x104c0) {
      offset -= 0x104b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      cur_stage_dependency_on_prev_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x104c0 && offset < 0x104c8) {
      offset -= 0x104c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      next_stage_dependency_on_cur_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x104c8 && offset < 0x104d0) {
      offset -= 0x104c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pipelength_added_stages_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x104d0 && offset < 0x104d8) {
      offset -= 0x104d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      mau_match_input_xbar_exact_match_enable_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x104d8 && offset < 0x104dc) {
      offset -= 0x104d8;
      if (read_callback_) read_callback_();
      match_ie_input_mux_sel_.read( offset, data );
    }
    else if (offset >= 0x104dc && offset < 0x104e0) {
      offset -= 0x104dc;
      if (read_callback_) read_callback_();
      imem_parity_ctl_.read( offset, data );
    }
    else if (offset >= 0x104e0 && offset < 0x104e4) {
      offset -= 0x104e0;
      if (read_callback_) read_callback_();
      phv_fifo_enable_.read( offset, data );
    }
    else if (offset >= 0x104e4 && offset < 0x104e8) {
      offset -= 0x104e4;
      if (read_callback_) read_callback_();
      stage_concurrent_with_prev_.read( offset, data );
    }
    else if (offset >= 0x104e8 && offset < 0x104ec) {
      offset -= 0x104e8;
      if (read_callback_) read_callback_();
      imem_table_addr_egress_.read( offset, data );
    }
    else if (offset >= 0x104ec && offset < 0x104f0) {
      offset -= 0x104ec;
      if (read_callback_) read_callback_();
      mau_diag_adb_ctl_.read( offset, data );
    }
    else if (offset >= 0x104f0 && offset < 0x104f4) {
      offset -= 0x104f0;
      if (read_callback_) read_callback_();
      intr_status_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x104f4 && offset < 0x104f8) {
      offset -= 0x104f4;
      if (read_callback_) read_callback_();
      intr_enable0_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x104f8 && offset < 0x104fc) {
      offset -= 0x104f8;
      if (read_callback_) read_callback_();
      intr_enable1_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x104fc && offset < 0x10500) {
      offset -= 0x104fc;
      if (read_callback_) read_callback_();
      intr_inject_mau_imem_.read( offset, data );
    }
    else if (offset >= 0x10600 && offset < 0x10680) {
      offset -= 0x10600;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_ingress_thread_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10680 && offset < 0x10700) {
      offset -= 0x10680;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_egress_thread_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10700 && offset < 0x10780) {
      offset -= 0x10700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_ingress_thread_alu_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset >= 0x10780 && offset < 0x10800) {
      offset -= 0x10780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      phv_egress_thread_alu_[ i1 ][ i0 ].read( offset, data );
    }
    else if (offset < 0x10000) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      xbar_hash_.read( offset, data );
    }
    else if (offset >= 0x10440 && offset < 0x10480) {
      offset -= 0x10440;
      if (read_callback_) read_callback_();
      snapshot_ctl_.read( offset, data );
    }
    else if (offset >= 0x12000 && offset < 0x14000) {
      offset -= 0x12000;
      if (read_callback_) read_callback_();
      snapshot_dp_.read( offset, data );
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      if (read_callback_) read_callback_();
      imem_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x10000 && offset < 0x10080) {
      offset -= 0x10000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_ingress_thread_imem_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10080 && offset < 0x10100) {
      offset -= 0x10080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_egress_thread_imem_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10100 && offset < 0x10180) {
      offset -= 0x10100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      actionmux_din_power_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10180 && offset < 0x10200) {
      offset -= 0x10180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      match_input_xbar_din_power_ctl_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10400 && offset < 0x10404) {
      offset -= 0x10400;
      intr_freeze_enable_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10404 && offset < 0x10408) {
      offset -= 0x10404;
      intr_status_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10408 && offset < 0x1040c) {
      offset -= 0x10408;
      intr_enable0_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1040c && offset < 0x10410) {
      offset -= 0x1040c;
      intr_enable1_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10410 && offset < 0x10414) {
      offset -= 0x10410;
      intr_inject_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10414 && offset < 0x10418) {
      offset -= 0x10414;
      intr_freeze_enable_mau_snapshot_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10418 && offset < 0x1041c) {
      offset -= 0x10418;
      mau_scratch_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1041c && offset < 0x10420) {
      offset -= 0x1041c;
      imem_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10480 && offset < 0x10484) {
      offset -= 0x10480;
      hashout_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10484 && offset < 0x10488) {
      offset -= 0x10484;
      intr_status_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10488 && offset < 0x1048c) {
      offset -= 0x10488;
      intr_enable0_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1048c && offset < 0x10490) {
      offset -= 0x1048c;
      intr_enable1_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104a0 && offset < 0x104a4) {
      offset -= 0x104a0;
      intr_inject_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104a4 && offset < 0x104a8) {
      offset -= 0x104a4;
      intr_freeze_enable_mau_gfm_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104b0 && offset < 0x104b8) {
      offset -= 0x104b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      action_output_delay_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104b8 && offset < 0x104c0) {
      offset -= 0x104b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      cur_stage_dependency_on_prev_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104c0 && offset < 0x104c8) {
      offset -= 0x104c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      next_stage_dependency_on_cur_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104c8 && offset < 0x104d0) {
      offset -= 0x104c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pipelength_added_stages_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104d0 && offset < 0x104d8) {
      offset -= 0x104d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      mau_match_input_xbar_exact_match_enable_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104d8 && offset < 0x104dc) {
      offset -= 0x104d8;
      match_ie_input_mux_sel_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104dc && offset < 0x104e0) {
      offset -= 0x104dc;
      imem_parity_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104e0 && offset < 0x104e4) {
      offset -= 0x104e0;
      phv_fifo_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104e4 && offset < 0x104e8) {
      offset -= 0x104e4;
      stage_concurrent_with_prev_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104e8 && offset < 0x104ec) {
      offset -= 0x104e8;
      imem_table_addr_egress_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104ec && offset < 0x104f0) {
      offset -= 0x104ec;
      mau_diag_adb_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104f0 && offset < 0x104f4) {
      offset -= 0x104f0;
      intr_status_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104f4 && offset < 0x104f8) {
      offset -= 0x104f4;
      intr_enable0_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104f8 && offset < 0x104fc) {
      offset -= 0x104f8;
      intr_enable1_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104fc && offset < 0x10500) {
      offset -= 0x104fc;
      intr_inject_mau_imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10600 && offset < 0x10680) {
      offset -= 0x10600;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_ingress_thread_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10680 && offset < 0x10700) {
      offset -= 0x10680;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_egress_thread_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10700 && offset < 0x10780) {
      offset -= 0x10700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_ingress_thread_alu_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10780 && offset < 0x10800) {
      offset -= 0x10780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      phv_egress_thread_alu_[ i1 ][ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset < 0x10000) {
      offset -= 0x0;
      xbar_hash_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10440 && offset < 0x10480) {
      offset -= 0x10440;
      snapshot_ctl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x12000 && offset < 0x14000) {
      offset -= 0x12000;
      snapshot_dp_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      imem_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    for (auto &f0 : phv_ingress_thread_imem_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : phv_egress_thread_imem_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : actionmux_din_power_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : match_input_xbar_din_power_ctl_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    intr_freeze_enable_mau_imem_.reset();
    intr_status_mau_snapshot_.reset();
    intr_enable0_mau_snapshot_.reset();
    intr_enable1_mau_snapshot_.reset();
    intr_inject_mau_snapshot_.reset();
    intr_freeze_enable_mau_snapshot_.reset();
    mau_scratch_.reset();
    imem_sbe_errlog_.reset();
    hashout_ctl_.reset();
    intr_status_mau_gfm_hash_.reset();
    intr_enable0_mau_gfm_hash_.reset();
    intr_enable1_mau_gfm_hash_.reset();
    intr_inject_mau_gfm_hash_.reset();
    intr_freeze_enable_mau_gfm_hash_.reset();
    for (auto &f0 : action_output_delay_) {
      f0.reset();
    }
    for (auto &f0 : cur_stage_dependency_on_prev_) {
      f0.reset();
    }
    for (auto &f0 : next_stage_dependency_on_cur_) {
      f0.reset();
    }
    for (auto &f0 : pipelength_added_stages_) {
      f0.reset();
    }
    for (auto &f0 : mau_match_input_xbar_exact_match_enable_) {
      f0.reset();
    }
    match_ie_input_mux_sel_.reset();
    imem_parity_ctl_.reset();
    phv_fifo_enable_.reset();
    stage_concurrent_with_prev_.reset();
    imem_table_addr_egress_.reset();
    mau_diag_adb_ctl_.reset();
    intr_status_mau_imem_.reset();
    intr_enable0_mau_imem_.reset();
    intr_enable1_mau_imem_.reset();
    intr_inject_mau_imem_.reset();
    for (auto &f0 : phv_ingress_thread_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : phv_egress_thread_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : phv_ingress_thread_alu_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    for (auto &f0 : phv_egress_thread_alu_) {
      for (auto &f1 : f0) {
        f1.reset();
      }
    }
    xbar_hash_.reset();
    snapshot_ctl_.reset();
    snapshot_dp_.reset();
    imem_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x10000 && offset < 0x10080) {
      offset -= 0x10000;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_ingress_thread_imem_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10080 && offset < 0x10100) {
      offset -= 0x10080;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_egress_thread_imem_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10100 && offset < 0x10180) {
      offset -= 0x10100;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += actionmux_din_power_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10180 && offset < 0x10200) {
      offset -= 0x10180;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += match_input_xbar_din_power_ctl_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10400 && offset < 0x10404) {
      offset -= 0x10400;
      r += intr_freeze_enable_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10404 && offset < 0x10408) {
      offset -= 0x10404;
      r += intr_status_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10408 && offset < 0x1040c) {
      offset -= 0x10408;
      r += intr_enable0_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1040c && offset < 0x10410) {
      offset -= 0x1040c;
      r += intr_enable1_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10410 && offset < 0x10414) {
      offset -= 0x10410;
      r += intr_inject_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10414 && offset < 0x10418) {
      offset -= 0x10414;
      r += intr_freeze_enable_mau_snapshot_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10418 && offset < 0x1041c) {
      offset -= 0x10418;
      r += mau_scratch_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1041c && offset < 0x10420) {
      offset -= 0x1041c;
      r += imem_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10480 && offset < 0x10484) {
      offset -= 0x10480;
      r += hashout_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10484 && offset < 0x10488) {
      offset -= 0x10484;
      r += intr_status_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10488 && offset < 0x1048c) {
      offset -= 0x10488;
      r += intr_enable0_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1048c && offset < 0x10490) {
      offset -= 0x1048c;
      r += intr_enable1_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104a0 && offset < 0x104a4) {
      offset -= 0x104a0;
      r += intr_inject_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104a4 && offset < 0x104a8) {
      offset -= 0x104a4;
      r += intr_freeze_enable_mau_gfm_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104b0 && offset < 0x104b8) {
      offset -= 0x104b0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += action_output_delay_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104b8 && offset < 0x104c0) {
      offset -= 0x104b8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += cur_stage_dependency_on_prev_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104c0 && offset < 0x104c8) {
      offset -= 0x104c0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += next_stage_dependency_on_cur_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104c8 && offset < 0x104d0) {
      offset -= 0x104c8;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pipelength_added_stages_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104d0 && offset < 0x104d8) {
      offset -= 0x104d0;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += mau_match_input_xbar_exact_match_enable_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104d8 && offset < 0x104dc) {
      offset -= 0x104d8;
      r += match_ie_input_mux_sel_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104dc && offset < 0x104e0) {
      offset -= 0x104dc;
      r += imem_parity_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104e0 && offset < 0x104e4) {
      offset -= 0x104e0;
      r += phv_fifo_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104e4 && offset < 0x104e8) {
      offset -= 0x104e4;
      r += stage_concurrent_with_prev_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104e8 && offset < 0x104ec) {
      offset -= 0x104e8;
      r += imem_table_addr_egress_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104ec && offset < 0x104f0) {
      offset -= 0x104ec;
      r += mau_diag_adb_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104f0 && offset < 0x104f4) {
      offset -= 0x104f0;
      r += intr_status_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104f4 && offset < 0x104f8) {
      offset -= 0x104f4;
      r += intr_enable0_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104f8 && offset < 0x104fc) {
      offset -= 0x104f8;
      r += intr_enable1_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104fc && offset < 0x10500) {
      offset -= 0x104fc;
      r += intr_inject_mau_imem_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10600 && offset < 0x10680) {
      offset -= 0x10600;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_ingress_thread_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10680 && offset < 0x10700) {
      offset -= 0x10680;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_egress_thread_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10700 && offset < 0x10780) {
      offset -= 0x10700;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_ingress_thread_alu_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10780 && offset < 0x10800) {
      offset -= 0x10780;
      int i1 = offset / 0x40;
      offset  -= i1 * 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += phv_egress_thread_alu_[ i1 ][ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset < 0x10000) {
      offset -= 0x0;
      r += xbar_hash_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10440 && offset < 0x10480) {
      offset -= 0x10440;
      r += snapshot_ctl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x12000 && offset < 0x14000) {
      offset -= 0x12000;
      r += snapshot_dp_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18000 && offset < 0x20000) {
      offset -= 0x18000;
      r += imem_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_ingress_thread_imem_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_egress_thread_imem_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += actionmux_din_power_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += match_input_xbar_din_power_ctl_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    r += intr_freeze_enable_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_status_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_enable0_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_enable1_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_inject_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += intr_freeze_enable_mau_snapshot_.to_string(print_zeros,indent_string) ;
    r += mau_scratch_.to_string(print_zeros,indent_string) ;
    r += imem_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += hashout_ctl_.to_string(print_zeros,indent_string) ;
    r += intr_status_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += intr_enable0_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += intr_enable1_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += intr_inject_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    r += intr_freeze_enable_mau_gfm_hash_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<2;++a0) {
      r += action_output_delay_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += cur_stage_dependency_on_prev_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += next_stage_dependency_on_cur_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += pipelength_added_stages_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<2;++a0) {
      r += mau_match_input_xbar_exact_match_enable_[a0].to_string(print_zeros,indent_string) ;
    }
    r += match_ie_input_mux_sel_.to_string(print_zeros,indent_string) ;
    r += imem_parity_ctl_.to_string(print_zeros,indent_string) ;
    r += phv_fifo_enable_.to_string(print_zeros,indent_string) ;
    r += stage_concurrent_with_prev_.to_string(print_zeros,indent_string) ;
    r += imem_table_addr_egress_.to_string(print_zeros,indent_string) ;
    r += mau_diag_adb_ctl_.to_string(print_zeros,indent_string) ;
    r += intr_status_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_enable0_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_enable1_mau_imem_.to_string(print_zeros,indent_string) ;
    r += intr_inject_mau_imem_.to_string(print_zeros,indent_string) ;
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_ingress_thread_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_egress_thread_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_ingress_thread_alu_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    for (uint32_t a1=0;a1<2;++a1) {
      for (uint32_t a0=0;a0<16;++a0) {
        r += phv_egress_thread_alu_[a1][a0].to_string(print_zeros,indent_string) ;
      }
    }
    r += xbar_hash_.to_string(print_zeros,indent_string) ;
    r += snapshot_ctl_.to_string(print_zeros,indent_string) ;
    r += snapshot_dp_.to_string(print_zeros,indent_string) ;
    r += imem_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  std::array< std::array< PhvIngressThreadImemMutable, 14 >, 2 > phv_ingress_thread_imem_;
  std::array< std::array< PhvEgressThreadImemMutable, 14 >, 2 > phv_egress_thread_imem_;
  std::array< std::array< ActionmuxDinPowerCtlMutable, 14 >, 2 > actionmux_din_power_ctl_;
  std::array< std::array< MatchInputXbarDinPowerCtlMutable, 14 >, 2 > match_input_xbar_din_power_ctl_;
  IntrFreezeEnableMauImemMutable intr_freeze_enable_mau_imem_;
  IntrStatusMauSnapshotMutable intr_status_mau_snapshot_;
  IntrEnable0MauSnapshotMutable intr_enable0_mau_snapshot_;
  IntrEnable1MauSnapshotMutable intr_enable1_mau_snapshot_;
  IntrInjectMauSnapshotMutable intr_inject_mau_snapshot_;
  IntrFreezeEnableMauSnapshotMutable intr_freeze_enable_mau_snapshot_;
  MauScratchMutable mau_scratch_;
  ImemSbeErrlogMutable imem_sbe_errlog_;
  HashoutCtlMutable hashout_ctl_;
  IntrStatusMauGfmHashMutable intr_status_mau_gfm_hash_;
  IntrEnable0MauGfmHashMutable intr_enable0_mau_gfm_hash_;
  IntrEnable1MauGfmHashMutable intr_enable1_mau_gfm_hash_;
  IntrInjectMauGfmHashMutable intr_inject_mau_gfm_hash_;
  IntrFreezeEnableMauGfmHashMutable intr_freeze_enable_mau_gfm_hash_;
  std::array< ActionOutputDelayMutable, 2 > action_output_delay_;
  std::array< CurStageDependencyOnPrevMutable, 2 > cur_stage_dependency_on_prev_;
  std::array< NextStageDependencyOnCurMutable, 2 > next_stage_dependency_on_cur_;
  std::array< PipelengthAddedStagesMutable, 2 > pipelength_added_stages_;
  std::array< MauMatchInputXbarExactMatchEnableMutable, 2 > mau_match_input_xbar_exact_match_enable_;
  MatchIeInputMuxSelMutable match_ie_input_mux_sel_;
  ImemParityCtlMutable imem_parity_ctl_;
  PhvFifoEnableMutable phv_fifo_enable_;
  StageConcurrentWithPrevMutable stage_concurrent_with_prev_;
  ImemTableAddrEgressMutable imem_table_addr_egress_;
  MauDiagAdbCtlMutable mau_diag_adb_ctl_;
  IntrStatusMauImemMutable intr_status_mau_imem_;
  IntrEnable0MauImemMutable intr_enable0_mau_imem_;
  IntrEnable1MauImemMutable intr_enable1_mau_imem_;
  IntrInjectMauImemMutable intr_inject_mau_imem_;
  std::array< std::array< PhvIngressThreadMutable, 14 >, 2 > phv_ingress_thread_;
  std::array< std::array< PhvEgressThreadMutable, 14 >, 2 > phv_egress_thread_;
  std::array< std::array< PhvIngressThreadAluMutable, 14 >, 2 > phv_ingress_thread_alu_;
  std::array< std::array< PhvEgressThreadAluMutable, 14 >, 2 > phv_egress_thread_alu_;
  MauMatchInputXbarHashAddrmapMutable xbar_hash_;
  MauSnapshotControlAddrmapMutable snapshot_ctl_;
  MauSnapshotDatapathAddrmapMutable snapshot_dp_;
  MauImemAddrmapMutable imem_;
private:
  static int StartOffset(
      int index_pipe_addrmap, int index_mau_addrmap
      ) {
    int offset=0;
    offset += 0x2000000; // to get to pipes
    assert(index_pipe_addrmap < 4);
    offset += index_pipe_addrmap * 0x800000; // pipe_addrmap[]
    assert(index_mau_addrmap < 12);
    offset += index_mau_addrmap * 0x80000; // mau_addrmap[]
    offset += 0x60000; // to get to dp
    return offset;
  }

};



















  }; // namespace register_classes
}; // namespace tofinoB0

#endif // __REGISTER_INCLUDES_MAU_DATAPATH_ADDRMAP_MUTABLE_H__
