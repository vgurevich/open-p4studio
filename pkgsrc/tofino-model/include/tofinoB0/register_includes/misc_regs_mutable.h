/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_MISC_REGS_MUTABLE_H__
#define __REGISTER_INCLUDES_MISC_REGS_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "misc_regs_baresync_ctrl_mutable.h"
#include "misc_regs_core_pll_ctrl0_mutable.h"
#include "misc_regs_core_pll_ctrl1_mutable.h"
#include "misc_regs_dbg_rst_mutable.h"
#include "misc_regs_func_fuse_mutable.h"
#include "misc_regs_fuse_ctrl_mutable.h"
#include "misc_regs_fuse_status_mutable.h"
#include "misc_regs_gpio_ctrl_mutable.h"
#include "misc_regs_int_en_mutable.h"
#include "misc_regs_int_inj_mutable.h"
#include "misc_regs_int_pri_mutable.h"
#include "misc_regs_int_stat_mutable.h"
#include "misc_regs_linkdown_ctrl_mutable.h"
#include "misc_regs_mac_pll_ctrl0_mutable.h"
#include "misc_regs_mac_pll_ctrl1_mutable.h"
#include "misc_regs_pcie_int_gen1_ctrl_mutable.h"
#include "misc_regs_pcie_int_gen1_enable_mutable.h"
#include "misc_regs_pcie_int_gen2_ctrl_mutable.h"
#include "misc_regs_pcie_int_gen2_enable_mutable.h"
#include "misc_regs_pcie_int_gen3_ctrl_mutable.h"
#include "misc_regs_pcie_int_gen3_enable_mutable.h"
#include "misc_regs_pcie_int_pwrup_ctrl_mutable.h"
#include "misc_regs_pcie_int_pwrup_enable_mutable.h"
#include "misc_regs_pcie_pll_ctrl0_mutable.h"
#include "misc_regs_pcie_pll_ctrl1_mutable.h"
#include "misc_regs_pcie_reset_trig_mutable.h"
#include "misc_regs_pcie_rxeq_ctrl_mutable.h"
#include "misc_regs_pciectl_gen3_default_mutable.h"
#include "misc_regs_pciephy_side_cntl_mutable.h"
#include "misc_regs_pciephy_status0_mutable.h"
#include "misc_regs_pciephy_status1_mutable.h"
#include "misc_regs_refclk_pad_ctrl_mutable.h"
#include "misc_regs_sbm_ind_ctrl_mutable.h"
#include "misc_regs_sbm_ind_rdata_mutable.h"
#include "misc_regs_sbm_ind_rslt_mutable.h"
#include "misc_regs_sbm_ind_wdata_mutable.h"
#include "misc_regs_sbm_timeout_ena_mutable.h"
#include "misc_regs_soft_reset_mutable.h"
#include "misc_regs_spi_command_mutable.h"
#include "misc_regs_spi_idcode_mutable.h"
#include "misc_regs_spi_indata_mutable.h"
#include "misc_regs_spi_outdata0_mutable.h"
#include "misc_regs_spi_outdata1_mutable.h"
#include "misc_regs_tcu_control0_mutable.h"
#include "misc_regs_tcu_control1_mutable.h"
#include "misc_regs_tcu_control_wrack_mutable.h"
#include "misc_regs_tcu_status_mutable.h"

namespace tofinoB0 {
  namespace register_classes {

class MiscRegsMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  MiscRegsMutable(
      int chipNumber, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(), 316, true, write_callback, read_callback, std::string("MiscRegsMutable"))
    {
    }
  MiscRegsMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "MiscRegsMutable")
    {
    }
public:







  MiscRegsSoftResetMutable &soft_reset() { return soft_reset_; }





  MiscRegsRefclkPadCtrlMutable &refclk_pad_ctrl() { return refclk_pad_ctrl_; }





  MiscRegsPciePllCtrl0Mutable &pcie_pll_ctrl0() { return pcie_pll_ctrl0_; }





  MiscRegsPciePllCtrl1Mutable &pcie_pll_ctrl1() { return pcie_pll_ctrl1_; }





  MiscRegsCorePllCtrl0Mutable &core_pll_ctrl0() { return core_pll_ctrl0_; }





  MiscRegsCorePllCtrl1Mutable &core_pll_ctrl1() { return core_pll_ctrl1_; }





  MiscRegsMacPllCtrl0Mutable &mac_pll_ctrl0() { return mac_pll_ctrl0_; }





  MiscRegsMacPllCtrl1Mutable &mac_pll_ctrl1() { return mac_pll_ctrl1_; }






  MiscRegsPcieIntPwrupEnableMutable &pcie_int_pwrup_enable() { return pcie_int_pwrup_enable_; }






  MiscRegsPcieIntGen1EnableMutable &pcie_int_gen1_enable() { return pcie_int_gen1_enable_; }






  MiscRegsPcieIntGen2EnableMutable &pcie_int_gen2_enable() { return pcie_int_gen2_enable_; }






  MiscRegsPcieIntGen3EnableMutable &pcie_int_gen3_enable() { return pcie_int_gen3_enable_; }








  MiscRegsPcieIntPwrupCtrlMutable &pcie_int_pwrup_ctrl(int j0) { return pcie_int_pwrup_ctrl_[j0]; }








  MiscRegsPcieIntGen1CtrlMutable &pcie_int_gen1_ctrl(int j0) { return pcie_int_gen1_ctrl_[j0]; }








  MiscRegsPcieIntGen2CtrlMutable &pcie_int_gen2_ctrl(int j0) { return pcie_int_gen2_ctrl_[j0]; }








  MiscRegsPcieIntGen3CtrlMutable &pcie_int_gen3_ctrl(int j0) { return pcie_int_gen3_ctrl_[j0]; }







  MiscRegsPciephySideCntlMutable &pciephy_side_cntl(int j0) { return pciephy_side_cntl_[j0]; }







  MiscRegsPciephyStatus0Mutable &pciephy_status0(int j0) { return pciephy_status0_[j0]; }







  MiscRegsPciephyStatus1Mutable &pciephy_status1(int j0) { return pciephy_status1_[j0]; }





  MiscRegsIntStatMutable &int_stat() { return int_stat_; }





  MiscRegsIntEnMutable &int_en() { return int_en_; }





  MiscRegsIntPriMutable &int_pri() { return int_pri_; }






  MiscRegsIntInjMutable &int_inj() { return int_inj_; }





  MiscRegsGpioCtrlMutable &gpio_ctrl() { return gpio_ctrl_; }





  MiscRegsSbmIndWdataMutable &sbm_ind_wdata() { return sbm_ind_wdata_; }






  MiscRegsSbmIndCtrlMutable &sbm_ind_ctrl() { return sbm_ind_ctrl_; }





  MiscRegsSbmIndRdataMutable &sbm_ind_rdata() { return sbm_ind_rdata_; }





  MiscRegsSbmIndRsltMutable &sbm_ind_rslt() { return sbm_ind_rslt_; }





  MiscRegsSbmTimeoutEnaMutable &sbm_timeout_ena() { return sbm_timeout_ena_; }





  MiscRegsSpiOutdata0Mutable &spi_outdata0() { return spi_outdata0_; }





  MiscRegsSpiOutdata1Mutable &spi_outdata1() { return spi_outdata1_; }






  MiscRegsSpiCommandMutable &spi_command() { return spi_command_; }





  MiscRegsSpiIndataMutable &spi_indata() { return spi_indata_; }





  MiscRegsSpiIdcodeMutable &spi_idcode() { return spi_idcode_; }





  MiscRegsPciectlGen3DefaultMutable &pciectl_gen3_default() { return pciectl_gen3_default_; }





  MiscRegsPcieRxeqCtrlMutable &pcie_rxeq_ctrl() { return pcie_rxeq_ctrl_; }





  MiscRegsFuseCtrlMutable &fuse_ctrl() { return fuse_ctrl_; }





  MiscRegsBaresyncCtrlMutable &baresync_ctrl() { return baresync_ctrl_; }





  MiscRegsLinkdownCtrlMutable &linkdown_ctrl() { return linkdown_ctrl_; }





  MiscRegsPcieResetTrigMutable &pcie_reset_trig() { return pcie_reset_trig_; }







  MiscRegsFuncFuseMutable &func_fuse(int j0) { return func_fuse_[j0]; }





  MiscRegsFuseStatusMutable &fuse_status() { return fuse_status_; }





  MiscRegsDbgRstMutable &dbg_rst0() { return dbg_rst0_; }





  MiscRegsDbgRstMutable &dbg_rst1() { return dbg_rst1_; }





  MiscRegsTcuControl0Mutable &tcu_control0() { return tcu_control0_; }





  MiscRegsTcuControl1Mutable &tcu_control1() { return tcu_control1_; }





  MiscRegsTcuControlWrackMutable &tcu_wrack() { return tcu_wrack_; }





  MiscRegsTcuStatusMutable &tcu_status() { return tcu_status_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset < 0x4) {
      offset -= 0x0;
      if (read_callback_) read_callback_();
      soft_reset_.read( offset, data );
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      if (read_callback_) read_callback_();
      refclk_pad_ctrl_.read( offset, data );
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      if (read_callback_) read_callback_();
      pcie_pll_ctrl0_.read( offset, data );
    }
    else if (offset >= 0xc && offset < 0x10) {
      offset -= 0xc;
      if (read_callback_) read_callback_();
      pcie_pll_ctrl1_.read( offset, data );
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      if (read_callback_) read_callback_();
      core_pll_ctrl0_.read( offset, data );
    }
    else if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      if (read_callback_) read_callback_();
      core_pll_ctrl1_.read( offset, data );
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      if (read_callback_) read_callback_();
      mac_pll_ctrl0_.read( offset, data );
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      if (read_callback_) read_callback_();
      mac_pll_ctrl1_.read( offset, data );
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      pcie_int_pwrup_enable_.read( offset, data );
    }
    else if (offset >= 0x24 && offset < 0x28) {
      offset -= 0x24;
      if (read_callback_) read_callback_();
      pcie_int_gen1_enable_.read( offset, data );
    }
    else if (offset >= 0x28 && offset < 0x2c) {
      offset -= 0x28;
      if (read_callback_) read_callback_();
      pcie_int_gen2_enable_.read( offset, data );
    }
    else if (offset >= 0x2c && offset < 0x30) {
      offset -= 0x2c;
      if (read_callback_) read_callback_();
      pcie_int_gen3_enable_.read( offset, data );
    }
    else if (offset >= 0x30 && offset < 0x40) {
      offset -= 0x30;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pcie_int_pwrup_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x40 && offset < 0x50) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pcie_int_gen1_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x50 && offset < 0x60) {
      offset -= 0x50;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pcie_int_gen2_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x60 && offset < 0x70) {
      offset -= 0x60;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pcie_int_gen3_ctrl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x70 && offset < 0x80) {
      offset -= 0x70;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pciephy_side_cntl_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x80 && offset < 0x90) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pciephy_status0_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x90 && offset < 0xa0) {
      offset -= 0x90;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      pciephy_status1_[ i0 ].read( offset, data );
    }
    else if (offset >= 0xa0 && offset < 0xa4) {
      offset -= 0xa0;
      if (read_callback_) read_callback_();
      int_stat_.read( offset, data );
    }
    else if (offset >= 0xa4 && offset < 0xa8) {
      offset -= 0xa4;
      if (read_callback_) read_callback_();
      int_en_.read( offset, data );
    }
    else if (offset >= 0xa8 && offset < 0xac) {
      offset -= 0xa8;
      if (read_callback_) read_callback_();
      int_pri_.read( offset, data );
    }
    else if (offset >= 0xac && offset < 0xb0) {
      offset -= 0xac;
      if (read_callback_) read_callback_();
      int_inj_.read( offset, data );
    }
    else if (offset >= 0xb0 && offset < 0xb4) {
      offset -= 0xb0;
      if (read_callback_) read_callback_();
      gpio_ctrl_.read( offset, data );
    }
    else if (offset >= 0xb4 && offset < 0xb8) {
      offset -= 0xb4;
      if (read_callback_) read_callback_();
      sbm_ind_wdata_.read( offset, data );
    }
    else if (offset >= 0xb8 && offset < 0xbc) {
      offset -= 0xb8;
      if (read_callback_) read_callback_();
      sbm_ind_ctrl_.read( offset, data );
    }
    else if (offset >= 0xbc && offset < 0xc0) {
      offset -= 0xbc;
      if (read_callback_) read_callback_();
      sbm_ind_rdata_.read( offset, data );
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      if (read_callback_) read_callback_();
      sbm_ind_rslt_.read( offset, data );
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      if (read_callback_) read_callback_();
      sbm_timeout_ena_.read( offset, data );
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      if (read_callback_) read_callback_();
      spi_outdata0_.read( offset, data );
    }
    else if (offset >= 0xcc && offset < 0xd0) {
      offset -= 0xcc;
      if (read_callback_) read_callback_();
      spi_outdata1_.read( offset, data );
    }
    else if (offset >= 0xd0 && offset < 0xd4) {
      offset -= 0xd0;
      if (read_callback_) read_callback_();
      spi_command_.read( offset, data );
    }
    else if (offset >= 0xd4 && offset < 0xd8) {
      offset -= 0xd4;
      if (read_callback_) read_callback_();
      spi_indata_.read( offset, data );
    }
    else if (offset >= 0xd8 && offset < 0xdc) {
      offset -= 0xd8;
      if (read_callback_) read_callback_();
      spi_idcode_.read( offset, data );
    }
    else if (offset >= 0xdc && offset < 0xe0) {
      offset -= 0xdc;
      if (read_callback_) read_callback_();
      pciectl_gen3_default_.read( offset, data );
    }
    else if (offset >= 0xe0 && offset < 0xe4) {
      offset -= 0xe0;
      if (read_callback_) read_callback_();
      pcie_rxeq_ctrl_.read( offset, data );
    }
    else if (offset >= 0xe4 && offset < 0xe8) {
      offset -= 0xe4;
      if (read_callback_) read_callback_();
      fuse_ctrl_.read( offset, data );
    }
    else if (offset >= 0xe8 && offset < 0xec) {
      offset -= 0xe8;
      if (read_callback_) read_callback_();
      baresync_ctrl_.read( offset, data );
    }
    else if (offset >= 0xec && offset < 0xf0) {
      offset -= 0xec;
      if (read_callback_) read_callback_();
      linkdown_ctrl_.read( offset, data );
    }
    else if (offset >= 0xf0 && offset < 0xf4) {
      offset -= 0xf0;
      if (read_callback_) read_callback_();
      pcie_reset_trig_.read( offset, data );
    }
    else if (offset >= 0x100 && offset < 0x120) {
      offset -= 0x100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      func_fuse_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x120 && offset < 0x124) {
      offset -= 0x120;
      if (read_callback_) read_callback_();
      fuse_status_.read( offset, data );
    }
    else if (offset >= 0x124 && offset < 0x128) {
      offset -= 0x124;
      if (read_callback_) read_callback_();
      dbg_rst0_.read( offset, data );
    }
    else if (offset >= 0x128 && offset < 0x12c) {
      offset -= 0x128;
      if (read_callback_) read_callback_();
      dbg_rst1_.read( offset, data );
    }
    else if (offset >= 0x12c && offset < 0x130) {
      offset -= 0x12c;
      if (read_callback_) read_callback_();
      tcu_control0_.read( offset, data );
    }
    else if (offset >= 0x130 && offset < 0x134) {
      offset -= 0x130;
      if (read_callback_) read_callback_();
      tcu_control1_.read( offset, data );
    }
    else if (offset >= 0x134 && offset < 0x138) {
      offset -= 0x134;
      if (read_callback_) read_callback_();
      tcu_wrack_.read( offset, data );
    }
    else if (offset >= 0x138 && offset < 0x13c) {
      offset -= 0x138;
      if (read_callback_) read_callback_();
      tcu_status_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset < 0x4) {
      offset -= 0x0;
      soft_reset_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      refclk_pad_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      pcie_pll_ctrl0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc && offset < 0x10) {
      offset -= 0xc;
      pcie_pll_ctrl1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      core_pll_ctrl0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      core_pll_ctrl1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      mac_pll_ctrl0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      mac_pll_ctrl1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      pcie_int_pwrup_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x24 && offset < 0x28) {
      offset -= 0x24;
      pcie_int_gen1_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x28 && offset < 0x2c) {
      offset -= 0x28;
      pcie_int_gen2_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2c && offset < 0x30) {
      offset -= 0x2c;
      pcie_int_gen3_enable_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x30 && offset < 0x40) {
      offset -= 0x30;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pcie_int_pwrup_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40 && offset < 0x50) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pcie_int_gen1_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x50 && offset < 0x60) {
      offset -= 0x50;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pcie_int_gen2_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x60 && offset < 0x70) {
      offset -= 0x60;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pcie_int_gen3_ctrl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x70 && offset < 0x80) {
      offset -= 0x70;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pciephy_side_cntl_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x80 && offset < 0x90) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pciephy_status0_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x90 && offset < 0xa0) {
      offset -= 0x90;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      pciephy_status1_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa0 && offset < 0xa4) {
      offset -= 0xa0;
      int_stat_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa4 && offset < 0xa8) {
      offset -= 0xa4;
      int_en_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xa8 && offset < 0xac) {
      offset -= 0xa8;
      int_pri_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xac && offset < 0xb0) {
      offset -= 0xac;
      int_inj_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb0 && offset < 0xb4) {
      offset -= 0xb0;
      gpio_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb4 && offset < 0xb8) {
      offset -= 0xb4;
      sbm_ind_wdata_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xb8 && offset < 0xbc) {
      offset -= 0xb8;
      sbm_ind_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xbc && offset < 0xc0) {
      offset -= 0xbc;
      sbm_ind_rdata_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      sbm_ind_rslt_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      sbm_timeout_ena_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      spi_outdata0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xcc && offset < 0xd0) {
      offset -= 0xcc;
      spi_outdata1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd0 && offset < 0xd4) {
      offset -= 0xd0;
      spi_command_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd4 && offset < 0xd8) {
      offset -= 0xd4;
      spi_indata_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xd8 && offset < 0xdc) {
      offset -= 0xd8;
      spi_idcode_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xdc && offset < 0xe0) {
      offset -= 0xdc;
      pciectl_gen3_default_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe0 && offset < 0xe4) {
      offset -= 0xe0;
      pcie_rxeq_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe4 && offset < 0xe8) {
      offset -= 0xe4;
      fuse_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xe8 && offset < 0xec) {
      offset -= 0xe8;
      baresync_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xec && offset < 0xf0) {
      offset -= 0xec;
      linkdown_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0xf0 && offset < 0xf4) {
      offset -= 0xf0;
      pcie_reset_trig_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100 && offset < 0x120) {
      offset -= 0x100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      func_fuse_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x120 && offset < 0x124) {
      offset -= 0x120;
      fuse_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x124 && offset < 0x128) {
      offset -= 0x124;
      dbg_rst0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x128 && offset < 0x12c) {
      offset -= 0x128;
      dbg_rst1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x12c && offset < 0x130) {
      offset -= 0x12c;
      tcu_control0_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x130 && offset < 0x134) {
      offset -= 0x130;
      tcu_control1_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x134 && offset < 0x138) {
      offset -= 0x134;
      tcu_wrack_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x138 && offset < 0x13c) {
      offset -= 0x138;
      tcu_status_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    soft_reset_.reset();
    refclk_pad_ctrl_.reset();
    pcie_pll_ctrl0_.reset();
    pcie_pll_ctrl1_.reset();
    core_pll_ctrl0_.reset();
    core_pll_ctrl1_.reset();
    mac_pll_ctrl0_.reset();
    mac_pll_ctrl1_.reset();
    pcie_int_pwrup_enable_.reset();
    pcie_int_gen1_enable_.reset();
    pcie_int_gen2_enable_.reset();
    pcie_int_gen3_enable_.reset();
    for (auto &f0 : pcie_int_pwrup_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : pcie_int_gen1_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : pcie_int_gen2_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : pcie_int_gen3_ctrl_) {
      f0.reset();
    }
    for (auto &f0 : pciephy_side_cntl_) {
      f0.reset();
    }
    for (auto &f0 : pciephy_status0_) {
      f0.reset();
    }
    for (auto &f0 : pciephy_status1_) {
      f0.reset();
    }
    int_stat_.reset();
    int_en_.reset();
    int_pri_.reset();
    int_inj_.reset();
    gpio_ctrl_.reset();
    sbm_ind_wdata_.reset();
    sbm_ind_ctrl_.reset();
    sbm_ind_rdata_.reset();
    sbm_ind_rslt_.reset();
    sbm_timeout_ena_.reset();
    spi_outdata0_.reset();
    spi_outdata1_.reset();
    spi_command_.reset();
    spi_indata_.reset();
    spi_idcode_.reset();
    pciectl_gen3_default_.reset();
    pcie_rxeq_ctrl_.reset();
    fuse_ctrl_.reset();
    baresync_ctrl_.reset();
    linkdown_ctrl_.reset();
    pcie_reset_trig_.reset();
    for (auto &f0 : func_fuse_) {
      f0.reset();
    }
    fuse_status_.reset();
    dbg_rst0_.reset();
    dbg_rst1_.reset();
    tcu_control0_.reset();
    tcu_control1_.reset();
    tcu_wrack_.reset();
    tcu_status_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset < 0x4) {
      offset -= 0x0;
      r += soft_reset_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4 && offset < 0x8) {
      offset -= 0x4;
      r += refclk_pad_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8 && offset < 0xc) {
      offset -= 0x8;
      r += pcie_pll_ctrl0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc && offset < 0x10) {
      offset -= 0xc;
      r += pcie_pll_ctrl1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10 && offset < 0x14) {
      offset -= 0x10;
      r += core_pll_ctrl0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x14 && offset < 0x18) {
      offset -= 0x14;
      r += core_pll_ctrl1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x18 && offset < 0x1c) {
      offset -= 0x18;
      r += mac_pll_ctrl0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1c && offset < 0x20) {
      offset -= 0x1c;
      r += mac_pll_ctrl1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20 && offset < 0x24) {
      offset -= 0x20;
      r += pcie_int_pwrup_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x24 && offset < 0x28) {
      offset -= 0x24;
      r += pcie_int_gen1_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x28 && offset < 0x2c) {
      offset -= 0x28;
      r += pcie_int_gen2_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2c && offset < 0x30) {
      offset -= 0x2c;
      r += pcie_int_gen3_enable_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x30 && offset < 0x40) {
      offset -= 0x30;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pcie_int_pwrup_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40 && offset < 0x50) {
      offset -= 0x40;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pcie_int_gen1_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x50 && offset < 0x60) {
      offset -= 0x50;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pcie_int_gen2_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x60 && offset < 0x70) {
      offset -= 0x60;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pcie_int_gen3_ctrl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x70 && offset < 0x80) {
      offset -= 0x70;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pciephy_side_cntl_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x80 && offset < 0x90) {
      offset -= 0x80;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pciephy_status0_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x90 && offset < 0xa0) {
      offset -= 0x90;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += pciephy_status1_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa0 && offset < 0xa4) {
      offset -= 0xa0;
      r += int_stat_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa4 && offset < 0xa8) {
      offset -= 0xa4;
      r += int_en_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xa8 && offset < 0xac) {
      offset -= 0xa8;
      r += int_pri_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xac && offset < 0xb0) {
      offset -= 0xac;
      r += int_inj_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb0 && offset < 0xb4) {
      offset -= 0xb0;
      r += gpio_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb4 && offset < 0xb8) {
      offset -= 0xb4;
      r += sbm_ind_wdata_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xb8 && offset < 0xbc) {
      offset -= 0xb8;
      r += sbm_ind_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xbc && offset < 0xc0) {
      offset -= 0xbc;
      r += sbm_ind_rdata_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc0 && offset < 0xc4) {
      offset -= 0xc0;
      r += sbm_ind_rslt_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc4 && offset < 0xc8) {
      offset -= 0xc4;
      r += sbm_timeout_ena_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xc8 && offset < 0xcc) {
      offset -= 0xc8;
      r += spi_outdata0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xcc && offset < 0xd0) {
      offset -= 0xcc;
      r += spi_outdata1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd0 && offset < 0xd4) {
      offset -= 0xd0;
      r += spi_command_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd4 && offset < 0xd8) {
      offset -= 0xd4;
      r += spi_indata_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xd8 && offset < 0xdc) {
      offset -= 0xd8;
      r += spi_idcode_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xdc && offset < 0xe0) {
      offset -= 0xdc;
      r += pciectl_gen3_default_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe0 && offset < 0xe4) {
      offset -= 0xe0;
      r += pcie_rxeq_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe4 && offset < 0xe8) {
      offset -= 0xe4;
      r += fuse_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xe8 && offset < 0xec) {
      offset -= 0xe8;
      r += baresync_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xec && offset < 0xf0) {
      offset -= 0xec;
      r += linkdown_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0xf0 && offset < 0xf4) {
      offset -= 0xf0;
      r += pcie_reset_trig_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100 && offset < 0x120) {
      offset -= 0x100;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += func_fuse_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x120 && offset < 0x124) {
      offset -= 0x120;
      r += fuse_status_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x124 && offset < 0x128) {
      offset -= 0x124;
      r += dbg_rst0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x128 && offset < 0x12c) {
      offset -= 0x128;
      r += dbg_rst1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x12c && offset < 0x130) {
      offset -= 0x12c;
      r += tcu_control0_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x130 && offset < 0x134) {
      offset -= 0x130;
      r += tcu_control1_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x134 && offset < 0x138) {
      offset -= 0x134;
      r += tcu_wrack_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x138 && offset < 0x13c) {
      offset -= 0x138;
      r += tcu_status_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += soft_reset_.to_string(print_zeros,indent_string) ;
    r += refclk_pad_ctrl_.to_string(print_zeros,indent_string) ;
    r += pcie_pll_ctrl0_.to_string(print_zeros,indent_string) ;
    r += pcie_pll_ctrl1_.to_string(print_zeros,indent_string) ;
    r += core_pll_ctrl0_.to_string(print_zeros,indent_string) ;
    r += core_pll_ctrl1_.to_string(print_zeros,indent_string) ;
    r += mac_pll_ctrl0_.to_string(print_zeros,indent_string) ;
    r += mac_pll_ctrl1_.to_string(print_zeros,indent_string) ;
    r += pcie_int_pwrup_enable_.to_string(print_zeros,indent_string) ;
    r += pcie_int_gen1_enable_.to_string(print_zeros,indent_string) ;
    r += pcie_int_gen2_enable_.to_string(print_zeros,indent_string) ;
    r += pcie_int_gen3_enable_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<4;++a0) {
      r += pcie_int_pwrup_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += pcie_int_gen1_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += pcie_int_gen2_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += pcie_int_gen3_ctrl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += pciephy_side_cntl_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += pciephy_status0_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<4;++a0) {
      r += pciephy_status1_[a0].to_string(print_zeros,indent_string) ;
    }
    r += int_stat_.to_string(print_zeros,indent_string) ;
    r += int_en_.to_string(print_zeros,indent_string) ;
    r += int_pri_.to_string(print_zeros,indent_string) ;
    r += int_inj_.to_string(print_zeros,indent_string) ;
    r += gpio_ctrl_.to_string(print_zeros,indent_string) ;
    r += sbm_ind_wdata_.to_string(print_zeros,indent_string) ;
    r += sbm_ind_ctrl_.to_string(print_zeros,indent_string) ;
    r += sbm_ind_rdata_.to_string(print_zeros,indent_string) ;
    r += sbm_ind_rslt_.to_string(print_zeros,indent_string) ;
    r += sbm_timeout_ena_.to_string(print_zeros,indent_string) ;
    r += spi_outdata0_.to_string(print_zeros,indent_string) ;
    r += spi_outdata1_.to_string(print_zeros,indent_string) ;
    r += spi_command_.to_string(print_zeros,indent_string) ;
    r += spi_indata_.to_string(print_zeros,indent_string) ;
    r += spi_idcode_.to_string(print_zeros,indent_string) ;
    r += pciectl_gen3_default_.to_string(print_zeros,indent_string) ;
    r += pcie_rxeq_ctrl_.to_string(print_zeros,indent_string) ;
    r += fuse_ctrl_.to_string(print_zeros,indent_string) ;
    r += baresync_ctrl_.to_string(print_zeros,indent_string) ;
    r += linkdown_ctrl_.to_string(print_zeros,indent_string) ;
    r += pcie_reset_trig_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<8;++a0) {
      r += func_fuse_[a0].to_string(print_zeros,indent_string) ;
    }
    r += fuse_status_.to_string(print_zeros,indent_string) ;
    r += dbg_rst0_.to_string(print_zeros,indent_string) ;
    r += dbg_rst1_.to_string(print_zeros,indent_string) ;
    r += tcu_control0_.to_string(print_zeros,indent_string) ;
    r += tcu_control1_.to_string(print_zeros,indent_string) ;
    r += tcu_wrack_.to_string(print_zeros,indent_string) ;
    r += tcu_status_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  MiscRegsSoftResetMutable soft_reset_;
  MiscRegsRefclkPadCtrlMutable refclk_pad_ctrl_;
  MiscRegsPciePllCtrl0Mutable pcie_pll_ctrl0_;
  MiscRegsPciePllCtrl1Mutable pcie_pll_ctrl1_;
  MiscRegsCorePllCtrl0Mutable core_pll_ctrl0_;
  MiscRegsCorePllCtrl1Mutable core_pll_ctrl1_;
  MiscRegsMacPllCtrl0Mutable mac_pll_ctrl0_;
  MiscRegsMacPllCtrl1Mutable mac_pll_ctrl1_;
  MiscRegsPcieIntPwrupEnableMutable pcie_int_pwrup_enable_;
  MiscRegsPcieIntGen1EnableMutable pcie_int_gen1_enable_;
  MiscRegsPcieIntGen2EnableMutable pcie_int_gen2_enable_;
  MiscRegsPcieIntGen3EnableMutable pcie_int_gen3_enable_;
  std::array< MiscRegsPcieIntPwrupCtrlMutable, 4 > pcie_int_pwrup_ctrl_;
  std::array< MiscRegsPcieIntGen1CtrlMutable, 4 > pcie_int_gen1_ctrl_;
  std::array< MiscRegsPcieIntGen2CtrlMutable, 4 > pcie_int_gen2_ctrl_;
  std::array< MiscRegsPcieIntGen3CtrlMutable, 4 > pcie_int_gen3_ctrl_;
  std::array< MiscRegsPciephySideCntlMutable, 4 > pciephy_side_cntl_;
  std::array< MiscRegsPciephyStatus0Mutable, 4 > pciephy_status0_;
  std::array< MiscRegsPciephyStatus1Mutable, 4 > pciephy_status1_;
  MiscRegsIntStatMutable int_stat_;
  MiscRegsIntEnMutable int_en_;
  MiscRegsIntPriMutable int_pri_;
  MiscRegsIntInjMutable int_inj_;
  MiscRegsGpioCtrlMutable gpio_ctrl_;
  MiscRegsSbmIndWdataMutable sbm_ind_wdata_;
  MiscRegsSbmIndCtrlMutable sbm_ind_ctrl_;
  MiscRegsSbmIndRdataMutable sbm_ind_rdata_;
  MiscRegsSbmIndRsltMutable sbm_ind_rslt_;
  MiscRegsSbmTimeoutEnaMutable sbm_timeout_ena_;
  MiscRegsSpiOutdata0Mutable spi_outdata0_;
  MiscRegsSpiOutdata1Mutable spi_outdata1_;
  MiscRegsSpiCommandMutable spi_command_;
  MiscRegsSpiIndataMutable spi_indata_;
  MiscRegsSpiIdcodeMutable spi_idcode_;
  MiscRegsPciectlGen3DefaultMutable pciectl_gen3_default_;
  MiscRegsPcieRxeqCtrlMutable pcie_rxeq_ctrl_;
  MiscRegsFuseCtrlMutable fuse_ctrl_;
  MiscRegsBaresyncCtrlMutable baresync_ctrl_;
  MiscRegsLinkdownCtrlMutable linkdown_ctrl_;
  MiscRegsPcieResetTrigMutable pcie_reset_trig_;
  std::array< MiscRegsFuncFuseMutable, 8 > func_fuse_;
  MiscRegsFuseStatusMutable fuse_status_;
  MiscRegsDbgRstMutable dbg_rst0_;
  MiscRegsDbgRstMutable dbg_rst1_;
  MiscRegsTcuControl0Mutable tcu_control0_;
  MiscRegsTcuControl1Mutable tcu_control1_;
  MiscRegsTcuControlWrackMutable tcu_wrack_;
  MiscRegsTcuStatusMutable tcu_status_;
private:
  static int StartOffset(
      
      ) {
    int offset=0;
    offset += 0x40000; // to get to misc_regs
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace tofinoB0

#endif // __REGISTER_INCLUDES_MISC_REGS_MUTABLE_H__
