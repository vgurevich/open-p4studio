/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

// generated by split_classes.pl
#ifndef __REGISTER_INCLUDES_TM_SCH_PIPE_RSPEC_MUTABLE_H__
#define __REGISTER_INCLUDES_TM_SCH_PIPE_RSPEC_MUTABLE_H__


#include <cstdint>
#include <cassert>
#include <array>
#include <vector>
#include <string>
#include <boost/lexical_cast.hpp>
#include <boost/format.hpp>
#include <model_core/register_block.h>
#include <shared/bitvector.h>











#include "sch_byte_count_adjust_r_mutable.h"
#include "sch_ctrl_r_mutable.h"
#include "sch_excessbucket_dynamic_r_mutable.h"
#include "sch_excessbucket_static_r_mutable.h"
#include "sch_leakybucket_dynamic_r_mutable.h"
#include "sch_leakybucket_static_r_mutable.h"
#include "sch_port_config_r_mutable.h"
#include "sch_port_pex_status_r_mutable.h"
#include "sch_port_pfc_status_r_mutable.h"
#include "sch_queue_config_r_mutable.h"
#include "sch_queue_pfc_status_r_mutable.h"
#include "sch_ready_r_mutable.h"
#include "sch_tdm_config_r_mutable.h"
#include "sch_tdm_table_entry_r_mutable.h"
#include "tm_sch_pipe_rspec_debug_bus_ctrl_mutable.h"
#include "tm_sch_pipe_rspec_ecc_mutable.h"
#include "tm_sch_pipe_rspec_intr_mutable.h"
#include "tm_sch_pipe_rspec_p_maxrate_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_p_maxrate_sbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_pex_credit_errlog_mutable.h"
#include "tm_sch_pipe_rspec_q_excrate_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_q_excrate_sbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_q_maxrate_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_q_maxrate_sbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_q_minrate_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_q_minrate_sbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_tdm_table_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_tdm_table_sbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_upd_edprsr_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_upd_edprsr_sbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex0_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex0_sbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex1_mbe_errlog_mutable.h"
#include "tm_sch_pipe_rspec_upd_pex1_sbe_errlog_mutable.h"

namespace tofinoB0 {
  namespace register_classes {

class TmSchPipeRspecMutable : public model_core::RegisterBlock<RegisterCallback> {
public:
  TmSchPipeRspecMutable(
      int chipNumber, int index_tm_sch_pipe_rspec, RegisterCallback& write_callback = 0, RegisterCallback& read_callback = 0
  )
    : RegisterBlock(chipNumber, StartOffset(index_tm_sch_pipe_rspec), 65536, true, write_callback, read_callback, std::string("TmSchPipeRspecMutable")+":"+boost::lexical_cast<std::string>(index_tm_sch_pipe_rspec))
    {
    }
  TmSchPipeRspecMutable(
      
  )
    : RegisterBlock(0, 0, 0, true, 0, 0, "TmSchPipeRspecMutable")
    {
    }
public:








  TmSchPipeRspecEccMutable &ecc() { return ecc_; }





  TmSchPipeRspecTdmTableSbeErrlogMutable &tdm_table_sbe_errlog() { return tdm_table_sbe_errlog_; }





  TmSchPipeRspecTdmTableMbeErrlogMutable &tdm_table_mbe_errlog() { return tdm_table_mbe_errlog_; }





  TmSchPipeRspecQMinrateSbeErrlogMutable &q_minrate_sbe_errlog() { return q_minrate_sbe_errlog_; }





  TmSchPipeRspecQMinrateMbeErrlogMutable &q_minrate_mbe_errlog() { return q_minrate_mbe_errlog_; }





  TmSchPipeRspecQExcrateSbeErrlogMutable &q_excrate_sbe_errlog() { return q_excrate_sbe_errlog_; }





  TmSchPipeRspecQExcrateMbeErrlogMutable &q_excrate_mbe_errlog() { return q_excrate_mbe_errlog_; }





  TmSchPipeRspecQMaxrateSbeErrlogMutable &q_maxrate_sbe_errlog() { return q_maxrate_sbe_errlog_; }





  TmSchPipeRspecQMaxrateMbeErrlogMutable &q_maxrate_mbe_errlog() { return q_maxrate_mbe_errlog_; }





  TmSchPipeRspecPMaxrateSbeErrlogMutable &p_maxrate_sbe_errlog() { return p_maxrate_sbe_errlog_; }





  TmSchPipeRspecPMaxrateMbeErrlogMutable &p_maxrate_mbe_errlog() { return p_maxrate_mbe_errlog_; }










  TmSchPipeRspecUpdPex0SbeErrlogMutable &upd_pex0_sbe_errlog() { return upd_pex0_sbe_errlog_; }










  TmSchPipeRspecUpdPex0MbeErrlogMutable &upd_pex0_mbe_errlog() { return upd_pex0_mbe_errlog_; }










  TmSchPipeRspecUpdPex1SbeErrlogMutable &upd_pex1_sbe_errlog() { return upd_pex1_sbe_errlog_; }










  TmSchPipeRspecUpdPex1MbeErrlogMutable &upd_pex1_mbe_errlog() { return upd_pex1_mbe_errlog_; }










  TmSchPipeRspecUpdEdprsrSbeErrlogMutable &upd_edprsr_sbe_errlog() { return upd_edprsr_sbe_errlog_; }










  TmSchPipeRspecUpdEdprsrMbeErrlogMutable &upd_edprsr_mbe_errlog() { return upd_edprsr_mbe_errlog_; }





  TmSchPipeRspecPexCreditErrlogMutable &pex_credit_errlog() { return pex_credit_errlog_; }






  SchCtrlRMutable &ctrl() { return ctrl_; }






  SchReadyRMutable &ready() { return ready_; }






  SchByteCountAdjustRMutable &global_bytecnt_adj() { return global_bytecnt_adj_; }





  SchTdmConfigRMutable &tdm_config() { return tdm_config_; }












  SchTdmTableEntryRMutable &tdm_table(int j0) { return tdm_table_[j0]; }








  SchPortConfigRMutable &port_config(int j0) { return port_config_[j0]; }








  SchLeakybucketStaticRMutable &port_max_lb_static_mem(int j0) { return port_max_lb_static_mem_[j0]; }










  SchLeakybucketDynamicRMutable &port_max_lb_dynamic_mem(int j0) { return port_max_lb_dynamic_mem_[j0]; }






  SchPortPfcStatusRMutable &port_pfc_status_mem(int j0) { return port_pfc_status_mem_[j0]; }






  SchPortPexStatusRMutable &port_pex_status_mem(int j0) { return port_pex_status_mem_[j0]; }









  SchQueueConfigRMutable &queue_config(int j0) { return queue_config_[j0]; }








  SchLeakybucketStaticRMutable &q_min_lb_static_mem(int j0) { return q_min_lb_static_mem_[j0]; }










  SchLeakybucketDynamicRMutable &q_min_lb_dynamic_mem(int j0) { return q_min_lb_dynamic_mem_[j0]; }








  SchLeakybucketStaticRMutable &q_max_lb_static_mem(int j0) { return q_max_lb_static_mem_[j0]; }










  SchLeakybucketDynamicRMutable &q_max_lb_dynamic_mem(int j0) { return q_max_lb_dynamic_mem_[j0]; }










  SchExcessbucketStaticRMutable &q_exc_static_mem(int j0) { return q_exc_static_mem_[j0]; }










  SchExcessbucketDynamicRMutable &q_exc_dynamic_mem(int j0) { return q_exc_dynamic_mem_[j0]; }






  SchQueuePfcStatusRMutable &q_pfc_status_mem(int j0) { return q_pfc_status_mem_[j0]; }





  TmSchPipeRspecDebugBusCtrlMutable &debug_bus_ctrl() { return debug_bus_ctrl_; }
  TmSchPipeRspecIntrMutable &intr() { return intr_; }

  bool read(
      uint32_t offset, uint32_t* data
      ) const {
    if (offset >= 0x10 && offset < 0x1c) {
      offset -= 0x10;
      if (read_callback_) read_callback_();
      ecc_.read( offset, data );
    }
    else if (offset >= 0x34 && offset < 0x38) {
      offset -= 0x34;
      if (read_callback_) read_callback_();
      tdm_table_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x38 && offset < 0x3c) {
      offset -= 0x38;
      if (read_callback_) read_callback_();
      tdm_table_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      if (read_callback_) read_callback_();
      q_minrate_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x40 && offset < 0x44) {
      offset -= 0x40;
      if (read_callback_) read_callback_();
      q_minrate_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x44 && offset < 0x48) {
      offset -= 0x44;
      if (read_callback_) read_callback_();
      q_excrate_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x48 && offset < 0x4c) {
      offset -= 0x48;
      if (read_callback_) read_callback_();
      q_excrate_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      if (read_callback_) read_callback_();
      q_maxrate_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      if (read_callback_) read_callback_();
      q_maxrate_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      if (read_callback_) read_callback_();
      p_maxrate_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x58 && offset < 0x5c) {
      offset -= 0x58;
      if (read_callback_) read_callback_();
      p_maxrate_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x5c && offset < 0x60) {
      offset -= 0x5c;
      if (read_callback_) read_callback_();
      upd_pex0_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x60 && offset < 0x64) {
      offset -= 0x60;
      if (read_callback_) read_callback_();
      upd_pex0_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      if (read_callback_) read_callback_();
      upd_pex1_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      if (read_callback_) read_callback_();
      upd_pex1_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      if (read_callback_) read_callback_();
      upd_edprsr_sbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x70 && offset < 0x74) {
      offset -= 0x70;
      if (read_callback_) read_callback_();
      upd_edprsr_mbe_errlog_.read( offset, data );
    }
    else if (offset >= 0x74 && offset < 0x78) {
      offset -= 0x74;
      if (read_callback_) read_callback_();
      pex_credit_errlog_.read( offset, data );
    }
    else if (offset >= 0x100 && offset < 0x104) {
      offset -= 0x100;
      if (read_callback_) read_callback_();
      ctrl_.read( offset, data );
    }
    else if (offset >= 0x104 && offset < 0x108) {
      offset -= 0x104;
      if (read_callback_) read_callback_();
      ready_.read( offset, data );
    }
    else if (offset >= 0x108 && offset < 0x10c) {
      offset -= 0x108;
      if (read_callback_) read_callback_();
      global_bytecnt_adj_.read( offset, data );
    }
    else if (offset >= 0x10c && offset < 0x110) {
      offset -= 0x10c;
      if (read_callback_) read_callback_();
      tdm_config_.read( offset, data );
    }
    else if (offset >= 0x200 && offset < 0x400) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      tdm_table_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1000 && offset < 0x1120) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_config_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1200 && offset < 0x1320) {
      offset -= 0x1200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_max_lb_static_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1400 && offset < 0x1520) {
      offset -= 0x1400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_max_lb_dynamic_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1600 && offset < 0x1720) {
      offset -= 0x1600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_pfc_status_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x1800 && offset < 0x1920) {
      offset -= 0x1800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      port_pex_status_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x2000 && offset < 0x2900) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      queue_config_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x3000 && offset < 0x3900) {
      offset -= 0x3000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      q_min_lb_static_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x4000 && offset < 0x4900) {
      offset -= 0x4000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      q_min_lb_dynamic_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x5000 && offset < 0x5900) {
      offset -= 0x5000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      q_max_lb_static_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x6000 && offset < 0x6900) {
      offset -= 0x6000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      q_max_lb_dynamic_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x7000 && offset < 0x7900) {
      offset -= 0x7000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      q_exc_static_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x8000 && offset < 0x8900) {
      offset -= 0x8000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      q_exc_dynamic_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x9000 && offset < 0x9900) {
      offset -= 0x9000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      if (read_callback_) read_callback_();
      q_pfc_status_mem_[ i0 ].read( offset, data );
    }
    else if (offset >= 0x9900 && offset < 0x9904) {
      offset -= 0x9900;
      if (read_callback_) read_callback_();
      debug_bus_ctrl_.read( offset, data );
    }
    else if (offset >= 0x20 && offset < 0x34) {
      offset -= 0x20;
      if (read_callback_) read_callback_();
      intr_.read( offset, data );
    }
    return true;
  }


  bool write(
      uint32_t offset, uint32_t data
      ) {
    if (offset >= 0x10 && offset < 0x1c) {
      offset -= 0x10;
      ecc_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x34 && offset < 0x38) {
      offset -= 0x34;
      tdm_table_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x38 && offset < 0x3c) {
      offset -= 0x38;
      tdm_table_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      q_minrate_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x40 && offset < 0x44) {
      offset -= 0x40;
      q_minrate_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x44 && offset < 0x48) {
      offset -= 0x44;
      q_excrate_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x48 && offset < 0x4c) {
      offset -= 0x48;
      q_excrate_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      q_maxrate_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      q_maxrate_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      p_maxrate_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x58 && offset < 0x5c) {
      offset -= 0x58;
      p_maxrate_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5c && offset < 0x60) {
      offset -= 0x5c;
      upd_pex0_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x60 && offset < 0x64) {
      offset -= 0x60;
      upd_pex0_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      upd_pex1_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      upd_pex1_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      upd_edprsr_sbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x70 && offset < 0x74) {
      offset -= 0x70;
      upd_edprsr_mbe_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x74 && offset < 0x78) {
      offset -= 0x74;
      pex_credit_errlog_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x100 && offset < 0x104) {
      offset -= 0x100;
      ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x104 && offset < 0x108) {
      offset -= 0x104;
      ready_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x108 && offset < 0x10c) {
      offset -= 0x108;
      global_bytecnt_adj_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x10c && offset < 0x110) {
      offset -= 0x10c;
      tdm_config_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x200 && offset < 0x400) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      tdm_table_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1000 && offset < 0x1120) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_config_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1200 && offset < 0x1320) {
      offset -= 0x1200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_max_lb_static_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1400 && offset < 0x1520) {
      offset -= 0x1400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_max_lb_dynamic_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1600 && offset < 0x1720) {
      offset -= 0x1600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_pfc_status_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x1800 && offset < 0x1920) {
      offset -= 0x1800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      port_pex_status_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x2000 && offset < 0x2900) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      queue_config_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x3000 && offset < 0x3900) {
      offset -= 0x3000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      q_min_lb_static_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x4000 && offset < 0x4900) {
      offset -= 0x4000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      q_min_lb_dynamic_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x5000 && offset < 0x5900) {
      offset -= 0x5000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      q_max_lb_static_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x6000 && offset < 0x6900) {
      offset -= 0x6000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      q_max_lb_dynamic_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x7000 && offset < 0x7900) {
      offset -= 0x7000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      q_exc_static_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x8000 && offset < 0x8900) {
      offset -= 0x8000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      q_exc_dynamic_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x9000 && offset < 0x9900) {
      offset -= 0x9000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      q_pfc_status_mem_[ i0 ].write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x9900 && offset < 0x9904) {
      offset -= 0x9900;
      debug_bus_ctrl_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    else if (offset >= 0x20 && offset < 0x34) {
      offset -= 0x20;
      intr_.write( offset, data );
      if (write_callback_) write_callback_();
    }
    return true;
  }

  void reset(
      
      ) {
    ecc_.reset();
    tdm_table_sbe_errlog_.reset();
    tdm_table_mbe_errlog_.reset();
    q_minrate_sbe_errlog_.reset();
    q_minrate_mbe_errlog_.reset();
    q_excrate_sbe_errlog_.reset();
    q_excrate_mbe_errlog_.reset();
    q_maxrate_sbe_errlog_.reset();
    q_maxrate_mbe_errlog_.reset();
    p_maxrate_sbe_errlog_.reset();
    p_maxrate_mbe_errlog_.reset();
    upd_pex0_sbe_errlog_.reset();
    upd_pex0_mbe_errlog_.reset();
    upd_pex1_sbe_errlog_.reset();
    upd_pex1_mbe_errlog_.reset();
    upd_edprsr_sbe_errlog_.reset();
    upd_edprsr_mbe_errlog_.reset();
    pex_credit_errlog_.reset();
    ctrl_.reset();
    ready_.reset();
    global_bytecnt_adj_.reset();
    tdm_config_.reset();
    for (auto &f0 : tdm_table_) {
      f0.reset();
    }
    for (auto &f0 : port_config_) {
      f0.reset();
    }
    for (auto &f0 : port_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : port_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : port_pfc_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : port_pex_status_mem_) {
      f0.reset();
    }
    for (auto &f0 : queue_config_) {
      f0.reset();
    }
    for (auto &f0 : q_min_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_min_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_max_lb_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_max_lb_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_exc_static_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_exc_dynamic_mem_) {
      f0.reset();
    }
    for (auto &f0 : q_pfc_status_mem_) {
      f0.reset();
    }
    debug_bus_ctrl_.reset();
    intr_.reset();
    if (write_callback_) write_callback_();
  }

  std::string to_string(
      uint32_t offset, bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    if (offset >= 0x10 && offset < 0x1c) {
      offset -= 0x10;
      r += ecc_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x34 && offset < 0x38) {
      offset -= 0x34;
      r += tdm_table_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x38 && offset < 0x3c) {
      offset -= 0x38;
      r += tdm_table_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3c && offset < 0x40) {
      offset -= 0x3c;
      r += q_minrate_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x40 && offset < 0x44) {
      offset -= 0x40;
      r += q_minrate_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x44 && offset < 0x48) {
      offset -= 0x44;
      r += q_excrate_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x48 && offset < 0x4c) {
      offset -= 0x48;
      r += q_excrate_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4c && offset < 0x50) {
      offset -= 0x4c;
      r += q_maxrate_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x50 && offset < 0x54) {
      offset -= 0x50;
      r += q_maxrate_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x54 && offset < 0x58) {
      offset -= 0x54;
      r += p_maxrate_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x58 && offset < 0x5c) {
      offset -= 0x58;
      r += p_maxrate_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5c && offset < 0x60) {
      offset -= 0x5c;
      r += upd_pex0_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x60 && offset < 0x64) {
      offset -= 0x60;
      r += upd_pex0_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x64 && offset < 0x68) {
      offset -= 0x64;
      r += upd_pex1_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x68 && offset < 0x6c) {
      offset -= 0x68;
      r += upd_pex1_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6c && offset < 0x70) {
      offset -= 0x6c;
      r += upd_edprsr_sbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x70 && offset < 0x74) {
      offset -= 0x70;
      r += upd_edprsr_mbe_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x74 && offset < 0x78) {
      offset -= 0x74;
      r += pex_credit_errlog_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x100 && offset < 0x104) {
      offset -= 0x100;
      r += ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x104 && offset < 0x108) {
      offset -= 0x104;
      r += ready_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x108 && offset < 0x10c) {
      offset -= 0x108;
      r += global_bytecnt_adj_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x10c && offset < 0x110) {
      offset -= 0x10c;
      r += tdm_config_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x200 && offset < 0x400) {
      offset -= 0x200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += tdm_table_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1000 && offset < 0x1120) {
      offset -= 0x1000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1200 && offset < 0x1320) {
      offset -= 0x1200;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1400 && offset < 0x1520) {
      offset -= 0x1400;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1600 && offset < 0x1720) {
      offset -= 0x1600;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_pfc_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x1800 && offset < 0x1920) {
      offset -= 0x1800;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += port_pex_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x2000 && offset < 0x2900) {
      offset -= 0x2000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += queue_config_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x3000 && offset < 0x3900) {
      offset -= 0x3000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += q_min_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x4000 && offset < 0x4900) {
      offset -= 0x4000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += q_min_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x5000 && offset < 0x5900) {
      offset -= 0x5000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += q_max_lb_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x6000 && offset < 0x6900) {
      offset -= 0x6000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += q_max_lb_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x7000 && offset < 0x7900) {
      offset -= 0x7000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += q_exc_static_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x8000 && offset < 0x8900) {
      offset -= 0x8000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += q_exc_dynamic_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x9000 && offset < 0x9900) {
      offset -= 0x9000;
      int i0 = offset / 0x4;
      offset  -= i0 * 0x4;
      r += q_pfc_status_mem_[ i0 ].to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x9900 && offset < 0x9904) {
      offset -= 0x9900;
      r += debug_bus_ctrl_.to_string(offset,print_zeros,indent_string) ;
    }
    else if (offset >= 0x20 && offset < 0x34) {
      offset -= 0x20;
      r += intr_.to_string(offset,print_zeros,indent_string) ;
    }
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

  std::string to_string(
      bool print_zeros = false, std::string indent_string = ""
      ) const {
    std::string r("");
    bool all_zeros=true;
    all_zeros=false;
    r += ecc_.to_string(print_zeros,indent_string) ;
    r += tdm_table_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += tdm_table_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += q_minrate_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += q_minrate_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += q_excrate_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += q_excrate_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += q_maxrate_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += q_maxrate_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += p_maxrate_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += p_maxrate_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += upd_pex0_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += upd_pex0_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += upd_pex1_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += upd_pex1_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += upd_edprsr_sbe_errlog_.to_string(print_zeros,indent_string) ;
    r += upd_edprsr_mbe_errlog_.to_string(print_zeros,indent_string) ;
    r += pex_credit_errlog_.to_string(print_zeros,indent_string) ;
    r += ctrl_.to_string(print_zeros,indent_string) ;
    r += ready_.to_string(print_zeros,indent_string) ;
    r += global_bytecnt_adj_.to_string(print_zeros,indent_string) ;
    r += tdm_config_.to_string(print_zeros,indent_string) ;
    for (uint32_t a0=0;a0<128;++a0) {
      r += tdm_table_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_pfc_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<72;++a0) {
      r += port_pex_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += queue_config_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += q_min_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += q_min_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += q_max_lb_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += q_max_lb_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += q_exc_static_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += q_exc_dynamic_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    for (uint32_t a0=0;a0<576;++a0) {
      r += q_pfc_status_mem_[a0].to_string(print_zeros,indent_string) ;
    }
    r += debug_bus_ctrl_.to_string(print_zeros,indent_string) ;
    r += intr_.to_string(print_zeros,indent_string) ;
    if (all_zeros && !print_zeros) {
      return("");
    }
    else {
      return r;
    }
  }

private:
  TmSchPipeRspecEccMutable ecc_;
  TmSchPipeRspecTdmTableSbeErrlogMutable tdm_table_sbe_errlog_;
  TmSchPipeRspecTdmTableMbeErrlogMutable tdm_table_mbe_errlog_;
  TmSchPipeRspecQMinrateSbeErrlogMutable q_minrate_sbe_errlog_;
  TmSchPipeRspecQMinrateMbeErrlogMutable q_minrate_mbe_errlog_;
  TmSchPipeRspecQExcrateSbeErrlogMutable q_excrate_sbe_errlog_;
  TmSchPipeRspecQExcrateMbeErrlogMutable q_excrate_mbe_errlog_;
  TmSchPipeRspecQMaxrateSbeErrlogMutable q_maxrate_sbe_errlog_;
  TmSchPipeRspecQMaxrateMbeErrlogMutable q_maxrate_mbe_errlog_;
  TmSchPipeRspecPMaxrateSbeErrlogMutable p_maxrate_sbe_errlog_;
  TmSchPipeRspecPMaxrateMbeErrlogMutable p_maxrate_mbe_errlog_;
  TmSchPipeRspecUpdPex0SbeErrlogMutable upd_pex0_sbe_errlog_;
  TmSchPipeRspecUpdPex0MbeErrlogMutable upd_pex0_mbe_errlog_;
  TmSchPipeRspecUpdPex1SbeErrlogMutable upd_pex1_sbe_errlog_;
  TmSchPipeRspecUpdPex1MbeErrlogMutable upd_pex1_mbe_errlog_;
  TmSchPipeRspecUpdEdprsrSbeErrlogMutable upd_edprsr_sbe_errlog_;
  TmSchPipeRspecUpdEdprsrMbeErrlogMutable upd_edprsr_mbe_errlog_;
  TmSchPipeRspecPexCreditErrlogMutable pex_credit_errlog_;
  SchCtrlRMutable ctrl_;
  SchReadyRMutable ready_;
  SchByteCountAdjustRMutable global_bytecnt_adj_;
  SchTdmConfigRMutable tdm_config_;
  std::array< SchTdmTableEntryRMutable, 128 > tdm_table_;
  std::array< SchPortConfigRMutable, 72 > port_config_;
  std::array< SchLeakybucketStaticRMutable, 72 > port_max_lb_static_mem_;
  std::array< SchLeakybucketDynamicRMutable, 72 > port_max_lb_dynamic_mem_;
  std::array< SchPortPfcStatusRMutable, 72 > port_pfc_status_mem_;
  std::array< SchPortPexStatusRMutable, 72 > port_pex_status_mem_;
  std::array< SchQueueConfigRMutable, 576 > queue_config_;
  std::array< SchLeakybucketStaticRMutable, 576 > q_min_lb_static_mem_;
  std::array< SchLeakybucketDynamicRMutable, 576 > q_min_lb_dynamic_mem_;
  std::array< SchLeakybucketStaticRMutable, 576 > q_max_lb_static_mem_;
  std::array< SchLeakybucketDynamicRMutable, 576 > q_max_lb_dynamic_mem_;
  std::array< SchExcessbucketStaticRMutable, 576 > q_exc_static_mem_;
  std::array< SchExcessbucketDynamicRMutable, 576 > q_exc_dynamic_mem_;
  std::array< SchQueuePfcStatusRMutable, 576 > q_pfc_status_mem_;
  TmSchPipeRspecDebugBusCtrlMutable debug_bus_ctrl_;
  TmSchPipeRspecIntrMutable intr_;
private:
  static int StartOffset(
      int index_tm_sch_pipe_rspec
      ) {
    int offset=0;
    offset += 0x400000; // to get to tm_top
    offset += 0xc0000; // to get to tm_sch_top
    assert(index_tm_sch_pipe_rspec < 4);
    offset += index_tm_sch_pipe_rspec * 0x10000; // tm_sch_pipe_rspec[]
    return offset;
  }

};









  }; // namespace register_classes
}; // namespace tofinoB0

#endif // __REGISTER_INCLUDES_TM_SCH_PIPE_RSPEC_MUTABLE_H__
